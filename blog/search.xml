<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[[OpenShift] 如何計算在 Jenkins pipeline 中工作所花費的時間]]></title>
      <url>/blog/2017/11/29/OpenShift/OpenShift-Howto-Calculate-Time-Duration-in-Jenkins/</url>
      <content type="html"><![CDATA[<p>最近的工作都是使用 OpenShift + Jenkins 在進行 CI/CD 的相關工作，在時間的顯示上遇到了兩個問題：</p>
<ol>
<li><p>Jenkins 系統上使用的是 UTC 時間，希望改成 Taiwan 時間(+8:00)</p>
</li>
<li><p>想要知道整個 pipeline 的工作完成後一共花了多少時間</p>
</li>
</ol>
<p>上網找了很多資料，拼拼湊湊寫出了以下的 groovy script 來完成這件事情：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat</span><br><span class="line"><span class="keyword">import</span> java.util.Calendar</span><br><span class="line"><span class="keyword">import</span> groovy.time.*</span><br><span class="line"></span><br><span class="line"><span class="comment">// human-readable format</span></span><br><span class="line"><span class="keyword">def</span> dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// convert time from UTC to Taiwan Time(+8:00)</span></span><br><span class="line"><span class="keyword">def</span> startTime = <span class="keyword">new</span> Date((Calendar.getInstance()).getTimeInMillis() + (<span class="number">480</span> * <span class="number">60000</span>))</span><br><span class="line"><span class="keyword">def</span> strStartTime = dateFormat.format(startTime)</span><br><span class="line"></span><br><span class="line">sleep <span class="number">5</span></span><br><span class="line"></span><br><span class="line">openshift.withCluster() &#123;</span><br><span class="line">    stage(<span class="string">'Calculate Time Duration'</span>) &#123;</span><br><span class="line">        node &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">def</span> endTime = <span class="keyword">new</span> Date((Calendar.getInstance()).getTimeInMillis() + (<span class="number">480</span> * <span class="number">60000</span>))</span><br><span class="line">            strEndTime = dateFormat.format(endTime)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// calculate time duration</span></span><br><span class="line">            TimeDuration duration = TimeCategory.minus(endTime, startTime)</span><br><span class="line">            <span class="keyword">def</span> strDuration = String.format(<span class="string">"%02d"</span>, duration.getHours()) + <span class="string">":"</span> + String.format(<span class="string">"%02d"</span>, duration.getMinutes()) + <span class="string">":"</span> + String.format(<span class="string">"%02d"</span>, duration.getSeconds())</span><br><span class="line">            <span class="comment">// it's necessary to set it to null for avoiding "not serializable exception"</span></span><br><span class="line">            duration = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">            echo <span class="string">"Start Time = $&#123;strStartTime&#125;"</span></span><br><span class="line">            echo <span class="string">"End Time = $&#123;strEndTime&#125;"</span></span><br><span class="line">            echo <span class="string">"Time Duration = $&#123;strDuration&#125;"</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="comment">// ---------- End of stage('Configure IAAS')</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>透過以下步驟，可以直接使用我放在 GitHub 上面的範例，直接建立一個 build job 來測試：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/godleon/openshift-jenkins-customization.git</span><br><span class="line"></span><br><span class="line">$ oc create -f openshift-objects/</span><br><span class="line"></span><br><span class="line">$ oc start-build calculate-time-duration</span><br></pre></td></tr></table></figure>
<p>接著到 Jenkins 系統內部就可以看到執行結果囉!</p>
<hr>
<h1 id="關於-Script-Approval-的處理"><a href="#關於-Script-Approval-的處理" class="headerlink" title="關於 Script Approval 的處理"></a>關於 Script Approval 的處理</h1><p>預設 Jenkins pipeline 會在 sandbox 的環境中執行，因此很多 grovvy or java method 都會無法使用，因此在 OpenShift 中需要對 Jenkins 進行客製化，預先設定 script whitelist，讓某些 method 可以在 pipeline 中使用，如何客製化 Jenkins 詳情可以參考之前寫過的文章。</p>
]]></content>
      
        <categories>
            
            <category> OpenShift </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OpenShift </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[OpenShift] 如何客製化 Jenkins Image]]></title>
      <url>/blog/2017/11/07/OpenShift/OpenShift-Howto-Customize-builtin-Jenkins-Image/</url>
      <content type="html"><![CDATA[<p>本文章的主題在於如何將客製化 OpenShift 原生提供的 Jenkins image</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Openshift 在 DevOps 的方面的確是下了不少功夫，使用 OpenShift 的確可以讓 DevOps engineer 省下不少工，但相對的也有蠻多新東西要學的! XD</p>
<p>在 OpenShift 建立第一個 BuildConfig(pipeline) 時，它會自動幫使用者佈署一個用來驅動 build pipeline 的 Jenkins server(此 container 會由 OpenShift 本身納管，因此掛了會自己再起一個新的)，佈署的行為如下：</p>
<ol>
<li><p>使用 <code>openshift</code> namespace 中的 template <code>jenkins-ephemeral</code> 為範本產生 Jenkins server</p>
</li>
<li><p>此 tempate 使用的 image stream 為 <code>jenkins:latest</code></p>
</li>
<li><p>Image Stream <code>jenkins:latest</code> 則是指到 Red Hat 官方所提供的 Jenkins image(<strong>registry.access.redhat.com/openshift3/jenkins-2-rhel7</strong>)</p>
</li>
</ol>
<p>當 Jenkins server 佈署好之後，就會自動的與 OpenShift 本身的認証機制進行整合，完全不用使用者進行額外的設定，相關的 credential 也都會設定在 Jenkins server 內部，使用者需要做的就是開始設計 pipeline 就對了!</p>
<hr>
<h1 id="Jenkins-image-for-OpenShift"><a href="#Jenkins-image-for-OpenShift" class="headerlink" title="Jenkins image for OpenShift"></a>Jenkins image for OpenShift</h1><p>由於 Jenkins 並不是一個很容易入門上手的系統，因此為了提供使用者能更方便的使用 Jenkins，OpenShift 將 Jenkins 系統打包成 docker image，並加入了許多常用的 plugin 以及與 OpenShift 整合所需要的 plugin，還很貼心的做好相關整合的設定，讓使用者在建立 pipeline 時就會同時產生相對應的 Jenkins server 來使用，省略許多繁複且容易造成錯誤的設定過程。</p>
<p>目前使用者可能比較容易用到的 Jenkins image for OpenShift 可能會有以下兩種：</p>
<ul>
<li>Red Hat 版本：<code>registry.access.redhat.com/openshift3/jenkins-2-rhel7</code><br>本文章的主題在於如何將客製化 OpenShift 原生提供的 Jenkins image</li>
</ul>
<h1 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h1><p>Openshift 在 DevOps 的方面的確是下了不少功夫，使用 OpenShift 的確可以讓 DevOps engineer 省下不少工，但相對的也有蠻多新東西要學的! XD</p>
<p>在 OpenShift 建立第一個 BuildConfig(pipeline) 時，它會自動幫使用者佈署一個用來驅動 build pipeline 的 Jenkins server(此 container 會由 OpenShift 本身納管，因此掛了會自己再起一個新的)，佈署的行為如下：</p>
<ol>
<li><p>使用 <code>openshift</code> namespace 中的 template <code>jenkins-ephemeral</code> 為範本產生 Jenkins server</p>
</li>
<li><p>此 tempate 使用的 image stream 為 <code>jenkins:latest</code></p>
</li>
<li><p>Image Stream <code>jenkins:latest</code> 則是指到 Red Hat 官方所提供的 Jenkins image(<strong>registry.access.redhat.com/openshift3/jenkins-2-rhel7</strong>)</p>
</li>
</ol>
<p>當 Jenkins server 佈署好之後，就會自動的與 OpenShift 本身的認証機制進行整合，完全不用使用者進行額外的設定，相關的 credential 也都會設定在 Jenkins server 內部，使用者需要做的就是開始設計 pipeline 就對了!</p>
<hr>
<h1 id="Jenkins-image-for-OpenShift-1"><a href="#Jenkins-image-for-OpenShift-1" class="headerlink" title="Jenkins image for OpenShift"></a>Jenkins image for OpenShift</h1><p>由於 Jenkins 並不是一個很容易入門上手的系統，因此為了提供使用者能更方便的使用 Jenkins，OpenShift 將 Jenkins 系統打包成 docker image，並加入了許多常用的 plugin 以及與 OpenShift 整合所需要的 plugin，還很貼心的做好相關整合的設定，讓使用者在建立 pipeline 時就會同時產生相對應的 Jenkins server 來使用，省略許多繁複且容易造成錯誤的設定過程。</p>
<p>目前使用者可能比較容易用到的 Jenkins image for OpenShift 可能會有以下兩種：</p>
<ul>
<li><p>Red Hat 版本：<code>registry.access.redhat.com/openshift3/jenkins-2-rhel7</code></p>
</li>
<li><p>CentOS 版本：<code>openshift/jenkins-2-centos7</code> (位於 DockerHub 上)</p>
</li>
</ul>
<p>由於新版的 OpenShift pipeline plugin for Jenkins 目前僅在 CentOS 版本的 Jenkins image 支援，因此後面的範例將會以 CentOS 版本為主，並提供將原有的 Jenkins image 從 Red Hat 版本改成 CentOS 版本的方法。</p>
<hr>
<h1 id="安裝額外的-Jenkins-plugin"><a href="#安裝額外的-Jenkins-plugin" class="headerlink" title="安裝額外的 Jenkins plugin"></a>安裝額外的 Jenkins plugin</h1><p>由於 OpenShift 提供的 Jenkins image 本身就是一個具有 s2i 功能的 docker image，因此我們可以透過 s2i 的流程，將所需要安裝的 plugin 以 source code injection 的方式指定進來並安裝。</p>
<p>以下的範例將會進行以下的客製化：</p>
<ol>
<li><p>安裝 <strong>redmine</strong>, <strong>gitlab-plugin</strong>, <strong>testlink</strong> 三個 plugin (詳細版本可參考<a href="https://github.com/godleon/learning_openshift/blob/master/jenkins_customization/plugins.txt" target="_blank" rel="noopener">原始碼</a>)</p>
</li>
<li><p>預先加入 <strong>scriptApproval.xml</strong> 檔案，讓某些 method 可在 sandbox 的環境中執行 (詳細清單可參考<a href="https://github.com/godleon/learning_openshift/blob/master/jenkins_customization/configuration/scriptApproval.xml" target="_blank" rel="noopener">原始碼</a>)</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取得原始碼</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/godleon/openshift-jenkins-customization.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 ImageStream(custom-jenkins-2-centos7) BuildConfig(custom-jenkins-build)</span></span><br><span class="line">$ oc create -f openshift-jenkins-customization/openshift-objects/</span><br><span class="line"></span><br><span class="line">$ oc -n openshift start-build custom-jenkins-build</span><br><span class="line"></span><br><span class="line">$ oc -n openshift get pods</span><br><span class="line">NAME                           READY     STATUS      RESTARTS   AGE</span><br><span class="line">custom-jenkins-build-1-build   0/1       Completed   0          22m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視 build log</span></span><br><span class="line">$ oc -n openshift logs -f custom-jenkins-build-1-build</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用者必須先安裝 <a href="https://github.com/openshift/origin/releases" target="_blank" rel="noopener">OpenShift CLI tool</a> 才可以執行上述的 oc 指令</p>
</blockquote>
<p>在最後一行指令中檢視 build log 時，就可以看見 OpenShift 透過 s2i 流程將我們在程式碼中所指定的 plugin 都已經安裝完成，此時我們就可以透過 ImageStream <code>custom-jenkins-2-centos7</code>(定義於 <strong>Jenkins_Customization/bc_custom-jenkins-build.yml</strong> 中) 來作為啟動 Jenkins server 的 default image。</p>
<hr>
<h1 id="更換原有的-Jenkins-Image"><a href="#更換原有的-Jenkins-Image" class="headerlink" title="更換原有的 Jenkins Image"></a>更換原有的 Jenkins Image</h1><p>今天在測試設計較為複雜的 Jenkins pipeline 時，發現 <a href="https://github.com/openshift/origin/tree/master/examples/jenkins/pipeline" target="_blank" rel="noopener">OpenShift 在 GitHub 提供的範例</a> 無法正常的使用，會出現 openshift class 不存在的錯誤，後來仔細的查了一下，發現原來裡面的範例需要搭配 <a href="https://github.com/openshift/jenkins-client-plugin" target="_blank" rel="noopener">OpenShift Jenkins Pipeline (DSL) Plugin</a> 一起使用。</p>
<p><strong>問題是，Red Hat 版本的 Jenkins image 並沒有內建這一個 plugin，此 plugin 目前僅有內建在 Centos 版本的 Jenkins image 中。</strong></p>
<p>而在上一個步驟中，我們使用了 CentOS 版本的 Jenkins image，並安裝了額外的 plugin 作為後續使用，因此以下便使用已經客製化完成的 Jenkins image 來作為啟動 Jenkins server 的 image。</p>
<p>為了更改自動佈署的 Jenkins server 所使用的 docker image，需要調整 <code>jenkins-ephemeral</code> 的內容，將 image 從 Red Hat 版本改到在上一個步驟完成的客製化 CentOS 版本，執行以下指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ oc edit template/jenkins-ephemeral -n openshift</span><br></pre></td></tr></table></figure>
<p>找到 <code>parameters</code> –&gt; <code>JENKINS_IMAGE_STREAM_TAG</code>，將 <strong>value</strong> 從 <code>jenkins:latest</code> 改為 <code>custom-jenkins-2-centos7:latest</code>，存檔即可。</p>
<p>經過了以上的設定，後面自動佈署出來的 Jenkins server 都會是 CentOS7 的版本，也會同時預載好 <a href="https://github.com/openshift/jenkins-client-plugin" target="_blank" rel="noopener">OpenShift Jenkins Pipeline (DSL) Plugin</a> 以及在上一個步驟額外安裝好的 plugin。</p>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><p><a href="https://github.com/jenkinsci/openshift-pipeline-plugin" target="_blank" rel="noopener">OpenShift V3 Plugin for Jenkins (based on Kubernetes plugin)</a></p>
</li>
<li><p><a href="https://github.com/openshift/jenkins-client-plugin" target="_blank" rel="noopener">OpenShift Jenkins Pipeline (DSL) Plugin (newly design)</a></p>
</li>
<li><p><a href="https://github.com/openshift/origin/tree/master/examples/jenkins/pipeline" target="_blank" rel="noopener">Using Jenkins Pipelines with OpenShift @GitbHub</a></p>
</li>
<li><p><a href="https://docs.openshift.com/container-platform/3.6/using_images/other_images/jenkins.html" target="_blank" rel="noopener">Jenkins - Other Images | Using Images | OpenShift Container Platform 3.6</a></p>
</li>
<li><p><a href="https://github.com/openshift/jenkins-sync-plugin/issues/57" target="_blank" rel="noopener">Script approvals needed for changes to build config Jenkinsfile · Issue #57 · openshift/jenkins-sync-plugin</a></p>
</li>
<li><p><a href="https://github.com/fabric8io/jenkins-docker" target="_blank" rel="noopener">fabric8io/jenkins-docker: docker file for a jenkins docker image</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> OpenShift </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OpenShift </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[OpenShift] Concept - Image Stream]]></title>
      <url>/blog/2017/11/06/OpenShift/OpenShift-Concept-ImageStream/</url>
      <content type="html"><![CDATA[<h1 id="What-is-Image-Stream"><a href="#What-is-Image-Stream" class="headerlink" title="What is Image Stream?"></a>What is Image Stream?</h1><p>每一個 image stream 代表著一個 Docker-formatted container image；它其實只是一個在 OpenShift 中內部對於 docker image 的命名方式，讓系統可以使用指定的名稱找到正確的 docker image 來使用。(類似 Docker 中對每個 image 使用 tag 來命名)</p>
<p>也因為有自己內部的命名方式，因此 Image Stream 就可以包含以下來源的 image：</p>
<ul>
<li><p>OpenShift 內部的 container registry</p>
</li>
<li><p>其他的 image stream</p>
</li>
<li><p>外部的 image repository (例如：DockerHub, CoreOS Quay)</p>
</li>
</ul>
<p>在 OpenShift 中，image stream 可與 Build &amp; Deployment 搭配完成特定的自動化功能；由於 Build &amp; Deployment 都可以監控特定 image stream，當 image stream 指向的 image 有新版產生時，可自動的進行特定的 build or deploy 的工作。</p>
<hr>
<h1 id="建立第一個-Image-Stream"><a href="#建立第一個-Image-Stream" class="headerlink" title="建立第一個 Image Stream"></a>建立第一個 Image Stream</h1><p>以下是一個 ImageStream 的定義範例：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ImageStream</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">"myubuntu:xenial"</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  tags:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">'16.04'</span></span><br><span class="line"><span class="attr">    from:</span></span><br><span class="line"><span class="attr">      kind:</span> <span class="string">DockerImage</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">ubuntu</span></span><br></pre></td></tr></table></figure>
<p>透過以上的 image stream 定義，在 OpenShift Build or Deployment 中，就可以使用 <code>myubuntu:xenial</code> 指定外部 DockerHub 中的 <code>ubuntu:16.04</code> image。</p>
<p>當以上 ImageStream 被建立後，我們可以查詢到以下資訊：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ oc get is</span><br><span class="line">NAME       DOCKER REPO                                           TAGS      UPDATED</span><br><span class="line">myubuntu   docker-registry.default.svc:5000/leon-test/myubuntu   16.04     2 seconds ago</span><br></pre></td></tr></table></figure>
<p>若使用 <code>oc get is/myubuntu -o=yaml</code> 指令檢視 YAML 輸出，得到以下內容：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ImageStream</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">openshift.io/image.dockerRepositoryCheck:</span> <span class="number">2017</span><span class="bullet">-11</span><span class="bullet">-06</span><span class="attr">T04:12:59Z</span></span><br><span class="line"><span class="attr">  creationTimestamp:</span> <span class="number">2017</span><span class="bullet">-11</span><span class="bullet">-06</span><span class="attr">T04:12:58Z</span></span><br><span class="line"><span class="attr">  generation:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">myubuntu</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">leon-test</span></span><br><span class="line"><span class="attr">  resourceVersion:</span> <span class="string">"9145705"</span></span><br><span class="line"><span class="attr">  selfLink:</span> <span class="string">/oapi/v1/namespaces/leon-test/imagestreams/myubuntu</span></span><br><span class="line"><span class="attr">  uid:</span> <span class="string">c59725ce-c2a8-11e7-a13b-faf564e56811</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  lookupPolicy:</span></span><br><span class="line"><span class="attr">    local:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  tags:</span></span><br><span class="line"><span class="attr">  - annotations:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">    from:</span></span><br><span class="line"><span class="attr">      kind:</span> <span class="string">DockerImage</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">ubuntu</span></span><br><span class="line"><span class="attr">    generation:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">    importPolicy:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">"16.04"</span></span><br><span class="line"><span class="attr">    referencePolicy:</span></span><br><span class="line"><span class="attr">      type:</span> <span class="string">Source</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line"><span class="attr">  dockerImageRepository:</span> <span class="string">docker-registry.default.svc:5000/leon-test/myubuntu</span></span><br><span class="line"><span class="attr">  tags:</span></span><br><span class="line"><span class="attr">  - items:</span></span><br><span class="line"><span class="attr">    - created:</span> <span class="number">2017</span><span class="bullet">-11</span><span class="bullet">-06</span><span class="attr">T04:12:59Z</span></span><br><span class="line"><span class="attr">      dockerImageReference:</span> <span class="string">ubuntu@sha256:152b4ccc429f6f28533aff625d8345baf1ba3808e9a99446e86b2bf3efa18571</span></span><br><span class="line"><span class="attr">      generation:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">sha256:152b4ccc429f6f28533aff625d8345baf1ba3808e9a99446e86b2bf3efa18571</span></span><br><span class="line"><span class="attr">    tag:</span> <span class="string">"16.04"</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Image-Stream-Image"><a href="#Image-Stream-Image" class="headerlink" title="Image Stream Image"></a>Image Stream Image</h1><p>image stream image(簡稱 <strong>isimage</strong>) 是一種 virtual resource，讓使用者可以透過 isimage 從特定的 image stream 取得 image，isimage 以 <code>&lt;image stream name&gt;@&lt;image name&gt;</code> 的方式呈現，因此以上面的範例來看，image steam image 就會是：</p>
<blockquote>
<p>myubuntu@sha256:152b4ccc429f6f28533aff625d8345baf1ba3808e9a99446e86b2bf3efa18571</p>
</blockquote>
<hr>
<h1 id="Image-Stream-Tag"><a href="#Image-Stream-Tag" class="headerlink" title="Image Stream Tag"></a>Image Stream Tag</h1><p>image stream tag(簡稱 <strong>istag</strong>) 是一個指到上面 image stream image 的 name pointer，可指向 local or 外部的 image，此外 isiage 還包含了 image 內容變動的歷史紀錄，這樣的設計讓使用者可以在有需要的時候方便的進行 rollback。</p>
<p>istag 以 <code>&lt;image stream name&gt;:&lt;tag&gt;</code> 的方式呈現，因此以上面的範例來看， istag 就會是：</p>
<blockquote>
<p>　myubuntu:16.04</p>
</blockquote>
<hr>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>有了 Image Stream(is), Image Stream Image (isimage), 以及 Image Stream Tag(istag) 的觀念之後，下一個階段將會介紹如何在 OpenShift 中管理 Image。</p>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><p><a href="https://docs.openshift.com/container-platform/3.6/architecture/core_concepts/builds_and_image_streams.html" target="_blank" rel="noopener">Builds and Image Streams - Core Concepts | Architecture | OpenShift Container Platform 3.6</a></p>
</li>
<li><p><a href="https://docs.openshift.com/enterprise/3.0/architecture/core_concepts/builds_and_image_streams.html" target="_blank" rel="noopener">Builds and Image Streams - Core Concepts | Architecture | OpenShift Enterprise 3.0</a></p>
</li>
<li><p><a href="https://github.com/openshift/origin/tree/master/examples/image-streams" target="_blank" rel="noopener">OpenShift ImageStream Examples @GitHub</a></p>
</li>
<li><p><a href="https://docs.openshift.com/container-platform/3.6/dev_guide/managing_images.html" target="_blank" rel="noopener">Managing Images | Developer Guide | OpenShift Container Platform 3.6</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> OpenShift </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OpenShift </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Kubernetes 學習筆記]]></title>
      <url>/blog/2017/06/29/Kubernetes/Learning-Kubernetes/</url>
      <content type="html"><![CDATA[<p>此篇文章為研究 Kubernetes 時所留下的學習筆記索引</p>
<h1 id="Concepts"><a href="#Concepts" class="headerlink" title="Concepts"></a>Concepts</h1><h2 id="kubeconfig"><a href="#kubeconfig" class="headerlink" title="kubeconfig"></a>kubeconfig</h2><ul>
<li><a href="https://github.com/godleon/learning_kubernetes/blob/master/concept/howto_configure_kubeconfig.md" target="_blank" rel="noopener">如何設定 kubeconfig 與 Kubernetes cluster 互動</a></li>
</ul>
<h2 id="Overview-amp-Components"><a href="#Overview-amp-Components" class="headerlink" title="Overview &amp; Components"></a>Overview &amp; Components</h2><ul>
<li><p><a href="https://github.com/godleon/learning_kubernetes/blob/master/concept/component_overview.md" target="_blank" rel="noopener">組成元件概觀</a></p>
</li>
<li><p><a href="https://github.com/godleon/learning_kubernetes/blob/master/concept/overview.md" target="_blank" rel="noopener">Kubernetes Overview</a></p>
</li>
</ul>
<h2 id="Networking"><a href="#Networking" class="headerlink" title="Networking"></a>Networking</h2><ul>
<li><p><a href="https://github.com/godleon/learning_kubernetes/blob/master/concept/network/service.md" target="_blank" rel="noopener">Service</a></p>
</li>
<li><p><a href="https://github.com/godleon/learning_kubernetes/blob/master/concept/network/ingress.md" target="_blank" rel="noopener">Ingress</a></p>
</li>
</ul>
<h2 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h2><ul>
<li><a href="https://github.com/godleon/learning_kubernetes/blob/master/concept/storage/volume.md" target="_blank" rel="noopener">Volume, PersistentVolume &amp; PersistentVolumeClaim</a></li>
</ul>
<hr>
<h1 id="Operating"><a href="#Operating" class="headerlink" title="Operating"></a>Operating</h1><ul>
<li><a href="https://github.com/godleon/learning_kubernetes/blob/master/operation/basic.md" target="_blank" rel="noopener">Kubernetes 基本操作</a></li>
</ul>
<h2 id="Persistent-Volume"><a href="#Persistent-Volume" class="headerlink" title="Persistent Volume"></a>Persistent Volume</h2><ul>
<li><a href="https://github.com/godleon/learning_kubernetes/blob/master/operation/use_PersistentVolume_NFS.md" target="_blank" rel="noopener">使用 Persistent Volume - 以 NFS 為例</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Kubernetes </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Ceph 簡單指令操作]]></title>
      <url>/blog/2017/05/25/Ceph/Ceph-Cheatsheet/</url>
      <content type="html"><![CDATA[<h1 id="Monitoring-and-Health"><a href="#Monitoring-and-Health" class="headerlink" title="Monitoring and Health"></a>Monitoring and Health</h1><p>剛安裝完，首先先檢查 ceph cluster 的狀態：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 檢視 ceph cluster status</span></span><br><span class="line">$ ceph -s</span><br><span class="line">    cluster cd6fcb41-c373-48fb-aab3-f8d330a26ccb</span><br><span class="line">     health HEALTH_WARN</span><br><span class="line">            too few PGs per OSD (16 &lt; min 30)</span><br><span class="line">     monmap e1: 3 mons at &#123;ceph01=10.102.41.101:6789/0,ceph02=10.102.41.102:6789/0,ceph03=10.102.41.103:6789/0&#125;</span><br><span class="line">            election epoch 8, quorum 0,1,2 ceph01,ceph02,ceph03</span><br><span class="line">     osdmap e36: 12 osds: 12 up, 12 <span class="keyword">in</span></span><br><span class="line">            flags sortbitwise,require_jewel_osds</span><br><span class="line">      pgmap v84: 64 pgs, 1 pools, 0 bytes data, 0 objects</span><br><span class="line">            405 MB used, 2174 GB / 2174 GB avail</span><br><span class="line">                  64 active+clean</span><br></pre></td></tr></table></figure>
<blockquote>
<p>也可以用 <code>ceph -w</code> 檢視即時的狀態</p>
</blockquote>
<p>檢查健康狀態：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ceph health detail</span><br><span class="line">HEALTH_WARN too few PGs per OSD (16 &lt; min 30)</span><br><span class="line">too few PGs per OSD (16 &lt; min 30)</span><br></pre></td></tr></table></figure>
<p>接著檢視目前 ceph cluster 提供了多少容量可用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 檢視目前可用的容量、每個 pool 的使用狀況 &amp; quota 等資訊</span></span><br><span class="line">$ ceph df</span><br><span class="line">GLOBAL:</span><br><span class="line">    SIZE      AVAIL     RAW USED     %RAW USED </span><br><span class="line">    2174G     2174G         405M          0.02 </span><br><span class="line">POOLS:</span><br><span class="line">    NAME     ID     USED     %USED     MAX AVAIL     OBJECTS </span><br><span class="line">    rbd      0         0         0          724G           0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 連到 CRUSH tree, 顯示 weight, variance, capacity ... etc</span></span><br><span class="line">$ ceph osd df tree</span><br><span class="line">ID WEIGHT  REWEIGHT SIZE  USE    AVAIL %USE VAR  PGS TYPE NAME       </span><br><span class="line">-1 2.12384        - 2174G   405M 2174G 0.02 1.00   0 root default    </span><br><span class="line">-2 0.70795        -  724G   135M  724G 0.02 1.00   0     host ceph01 </span><br><span class="line"> 0 0.17699  1.00000  181G 35200k  181G 0.02 1.02  11         osd.0   </span><br><span class="line"> 3 0.17699  1.00000  181G 34708k  181G 0.02 1.00  19         osd.3   </span><br><span class="line"> 6 0.17699  1.00000  181G 34420k  181G 0.02 0.99  14         osd.6   </span><br><span class="line"> 8 0.17699  1.00000  181G 34336k  181G 0.02 0.99  20         osd.8   </span><br><span class="line">-3 0.70795        -  724G   135M  724G 0.02 1.00   0     host ceph03 </span><br><span class="line"> 1 0.17699  1.00000  181G 35568k  181G 0.02 1.03  17         osd.1   </span><br><span class="line"> 5 0.17699  1.00000  181G 34432k  181G 0.02 0.99  12         osd.5   </span><br><span class="line"> 9 0.17699  1.00000  181G 34272k  181G 0.02 0.99  18         osd.9   </span><br><span class="line">11 0.17699  1.00000  181G 34200k  181G 0.02 0.99  17         osd.11  </span><br><span class="line">-4 0.70795        -  724G   135M  724G 0.02 1.00   0     host ceph02 </span><br><span class="line"> 2 0.17699  1.00000  181G 35076k  181G 0.02 1.01  19         osd.2   </span><br><span class="line"> 4 0.17699  1.00000  181G 34652k  181G 0.02 1.00  18         osd.4   </span><br><span class="line"> 7 0.17699  1.00000  181G 34456k  181G 0.02 0.99  11         osd.7   </span><br><span class="line">10 0.17699  1.00000  181G 34280k  181G 0.02 0.99  16         osd.10  </span><br><span class="line">              TOTAL 2174G   405M 2174G 0.02</span><br></pre></td></tr></table></figure>
<h1 id="Working-with-Pools-and-OSDs"><a href="#Working-with-Pools-and-OSDs" class="headerlink" title="Working with Pools and OSDs"></a>Working with Pools and OSDs</h1><p>若要尋找單顆 OSD 的相關資訊：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 尋找 OSD physical location</span></span><br><span class="line">$ ceph osd find 1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"osd"</span>: 1,</span><br><span class="line">    <span class="string">"ip"</span>: <span class="string">"10.102.41.103:6800\/63011"</span>,</span><br><span class="line">    <span class="string">"crush_location"</span>: &#123;</span><br><span class="line">        <span class="string">"host"</span>: <span class="string">"ceph03"</span>,</span><br><span class="line">        <span class="string">"root"</span>: <span class="string">"default"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示指定 OSD metadata</span></span><br><span class="line">$ ceph osd metadata 1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"id"</span>: 1,</span><br><span class="line">    <span class="string">"arch"</span>: <span class="string">"x86_64"</span>,</span><br><span class="line">    <span class="string">"back_addr"</span>: <span class="string">"10.102.41.103:6801\/63011"</span>,</span><br><span class="line">    <span class="string">"backend_filestore_dev_node"</span>: <span class="string">"unknown"</span>,</span><br><span class="line">    <span class="string">"backend_filestore_partition_path"</span>: <span class="string">"unknown"</span>,</span><br><span class="line">    <span class="string">"ceph_version"</span>: <span class="string">"ceph version 10.2.5-37.el7cp (033f137cde8573cfc5a4662b4ed6a63b8a8d1464)"</span>,</span><br><span class="line">    ......</span><br><span class="line">    <span class="string">"osd_data"</span>: <span class="string">"\/var\/lib\/ceph\/osd\/ceph-1"</span>,</span><br><span class="line">    <span class="string">"osd_journal"</span>: <span class="string">"\/var\/lib\/ceph\/osd\/ceph-1\/journal"</span>,</span><br><span class="line">    <span class="string">"osd_objectstore"</span>: <span class="string">"filestore"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建立/移除 pool: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立 pool, 名稱為 pve_image, pg 數量為 1024</span></span><br><span class="line">$ ceph osd pool create pve_images 1024</span><br><span class="line">pool <span class="string">'pve_images'</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示目前 pool 詳細狀態</span></span><br><span class="line">$ ceph osd pool ls detail</span><br><span class="line">pool 0 <span class="string">'rbd'</span> replicated size 3 min_size 2 crush_ruleset 0 object_hash rjenkins pg_num 64 pgp_num 64 last_change 1 flags hashpspool stripe_width 0</span><br><span class="line">pool 1 <span class="string">'pve_images'</span> replicated size 3 min_size 2 crush_ruleset 0 object_hash rjenkins pg_num 1024 pgp_num 1024 last_change 37 flags hashpspool stripe_width 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示指定 pool 的詳細資料</span></span><br><span class="line">$ ceph osd pool get pve_images all</span><br><span class="line">size: 3</span><br><span class="line">min_size: 2</span><br><span class="line">crash_replay_interval: 0</span><br><span class="line">pg_num: 1024</span><br><span class="line">pgp_num: 1024</span><br><span class="line">crush_ruleset: 0</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除 pool (要重複 pool name 兩次還要加上那有趣的參數)</span></span><br><span class="line">$ ceph osd pool delete pve_images pve_images --yes-i-really-really-mean-it</span><br><span class="line">pool <span class="string">'pve_images'</span> removed</span><br></pre></td></tr></table></figure>
<p>調整現有 pool 的狀態：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 設定 placement groups 的數量</span></span><br><span class="line">$ ceph osd pool <span class="built_in">set</span> rbd pg_num 384</span><br><span class="line"><span class="built_in">set</span> pool 0 pg_num to 384</span><br><span class="line"></span><br><span class="line"><span class="comment"># pgp =&gt; The effective number of placement groups to use when calculating data placement.</span></span><br><span class="line">$ ceph osd pool <span class="built_in">set</span> rbd pgp_num 384</span><br><span class="line"><span class="built_in">set</span> pool 0 pgp_num to 384</span><br><span class="line"></span><br><span class="line"><span class="comment"># 調整完就會從原本的 warning 狀態變成 health_ok 了!</span></span><br><span class="line">$ ceph -s</span><br><span class="line">    cluster cd6fcb41-c373-48fb-aab3-f8d330a26ccb</span><br><span class="line">     health HEALTH_OK</span><br><span class="line">     monmap e1: 3 mons at &#123;ceph01=10.102.41.101:6789/0,ceph02=10.102.41.102:6789/0,ceph03=10.102.41.103:6789/0&#125;</span><br><span class="line">            election epoch 8, quorum 0,1,2 ceph01,ceph02,ceph03</span><br><span class="line">     osdmap e47: 12 osds: 12 up, 12 <span class="keyword">in</span></span><br><span class="line">            flags sortbitwise,require_jewel_osds</span><br><span class="line">      pgmap v177: 384 pgs, 1 pools, 0 bytes data, 0 objects</span><br><span class="line">            461 MB used, 2174 GB / 2174 GB avail</span><br><span class="line">                 384 active+clean</span><br></pre></td></tr></table></figure>
<h1 id="RBD-Block-Storage"><a href="#RBD-Block-Storage" class="headerlink" title="RBD Block Storage"></a>RBD Block Storage</h1><p>這個部份是用在把 Ceph 作為 block-based storage 時所需要了解的指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 顯示目前的 RBD volume</span></span><br><span class="line">$ rbd ls</span><br><span class="line">vm-101-disk-1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示指定 RBD volume 的狀態</span></span><br><span class="line">$ rbd status vm-101-disk-1</span><br><span class="line">Watchers:</span><br><span class="line">	watcher=10.102.70.124:0/3361738208 client.143192 cookie=140498849842176</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示指定 RBD volume 的相關資訊</span></span><br><span class="line">$ rbd info vm-101-disk-1</span><br><span class="line">rbd image <span class="string">'vm-101-disk-1'</span>:</span><br><span class="line">	size 32768 MB <span class="keyword">in</span> 8192 objects</span><br><span class="line">	order 22 (4096 kB objects)</span><br><span class="line">	block_name_prefix: rbd_data.22f52238e1f29</span><br><span class="line">	format: 2</span><br><span class="line">	features: layering, exclusive-lock, object-map, fast-diff, deep-flatten</span><br><span class="line">	flags: </span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除指定的 RBD volume</span></span><br><span class="line">$ rbd rm vm-101-disk-1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立名稱為 Jenkins_Data，大小為 40GB 的 RBD volume</span></span><br><span class="line">$ rbd create --pool rbd --image Jenkins_Data --size 40960</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視 RBD volume 資訊</span></span><br><span class="line">$ rbd --image Jenkins_Data info</span><br><span class="line">rbd image <span class="string">'Jenkins_Data'</span>:</span><br><span class="line">	size 40960 MB <span class="keyword">in</span> 10240 objects</span><br><span class="line">	order 22 (4096 kB objects)</span><br><span class="line">	block_name_prefix: rbd_data.a71d6238e1f29</span><br><span class="line">	format: 2</span><br><span class="line">	features: layering, exclusive-lock, object-map, fast-diff, deep-flatten</span><br><span class="line">	flags: </span><br><span class="line"></span><br><span class="line"><span class="comment"># 變更 RBD volume 大小，縮小要加上 "--allow-shrink" 以確保安全</span></span><br><span class="line">$ rbd --image Jenkins_Data resize --size 10240 --allow-shrink</span><br><span class="line">Resizing image: 100% complete...done.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 確認 RBD volume 容量正確變更</span></span><br><span class="line">$ rbd --image Jenkins_Data info</span><br><span class="line">rbd image <span class="string">'Jenkins_Data'</span>:</span><br><span class="line">	size 10240 MB <span class="keyword">in</span> 2560 objects</span><br><span class="line">	order 22 (4096 kB objects)</span><br><span class="line">	block_name_prefix: rbd_data.a71d6238e1f29</span><br><span class="line">	format: 2</span><br><span class="line">	features: layering, exclusive-lock, object-map, fast-diff, deep-flatten</span><br><span class="line">	flags: </span><br><span class="line"></span><br><span class="line"><span class="comment"># 放大 RBD Volume</span></span><br><span class="line">$ rbd --image Jenkins_Data resize --size 20480</span><br><span class="line">Resizing image: 100% complete...done.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 確認 RBD volume 容量正確變更</span></span><br><span class="line">$ rbd --image Jenkins_Data info</span><br><span class="line">rbd image <span class="string">'Jenkins_Data'</span>:</span><br><span class="line">	size 20480 MB <span class="keyword">in</span> 5120 objects</span><br><span class="line">	order 22 (4096 kB objects)</span><br><span class="line">	block_name_prefix: rbd_data.a71d6238e1f29</span><br><span class="line">	format: 2</span><br><span class="line">	features: layering, exclusive-lock, object-map, fast-diff, deep-flatten</span><br><span class="line">	flags:</span><br></pre></td></tr></table></figure>
<h1 id="Authentication-and-Authorization"><a href="#Authentication-and-Authorization" class="headerlink" title="Authentication and Authorization"></a>Authentication and Authorization</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 檢視目前可使用 ceph cluster 的 user list</span></span><br><span class="line">$ ceph auth list</span><br><span class="line">installed auth entries:</span><br><span class="line"></span><br><span class="line">osd.0</span><br><span class="line">	key: ABxxxxxxx</span><br><span class="line">	caps: [mon] allow profile osd</span><br><span class="line">	caps: [osd] allow *</span><br><span class="line">......</span><br><span class="line">client.admin</span><br><span class="line">	key: ABxxxxxxx</span><br><span class="line">	caps: [mds] allow *</span><br><span class="line">	caps: [mon] allow *</span><br><span class="line">	caps: [osd] allow *</span><br><span class="line">client.bootstrap-mds</span><br><span class="line">	key: ABxxxxxxx</span><br><span class="line">	caps: [mon] allow profile bootstrap-mds</span><br><span class="line">client.bootstrap-osd</span><br><span class="line">	key: ABxxxxxxx</span><br><span class="line">	caps: [mon] allow profile bootstrap-osd</span><br><span class="line">client.bootstrap-rgw</span><br><span class="line">	key: ABxxxxxxx</span><br><span class="line">	caps: [mon] allow profile bootstrap-rgw</span><br></pre></td></tr></table></figure>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><p><a href="https://www.gitbook.com/book/tobegit3hub1/ceph_from_scratch/details" target="_blank" rel="noopener">Ceph From Scratch · GitBook</a></p>
</li>
<li><p><a href="https://sabaini.at/pages/ceph-cheatsheet.html" target="_blank" rel="noopener">Ceph Cheatsheet - sabaini.at</a></p>
</li>
<li><p><a href="http://michaelkang.blog.51cto.com/1553154/1698287" target="_blank" rel="noopener">最新ceph集群常用命令梳理 - 康建华 - 51CTO技术博客</a></p>
</li>
<li><p><a href="http://docs.ceph.com/docs/jewel/rados/operations/pools/" target="_blank" rel="noopener">Pools — Ceph Documentation</a></p>
</li>
<li><p><a href="http://docs.ceph.com/docs/master/rados/operations/placement-groups/" target="_blank" rel="noopener">Placement Groups — Ceph Documentation</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Ceph </tag>
            
            <tag> SDS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[AWS 學習筆記 - S3(Simple Storage Service)]]></title>
      <url>/blog/2017/05/14/AWS/AWS-Learning-Notes-S3/</url>
      <content type="html"><![CDATA[<h1 id="What-is-S3"><a href="#What-is-S3" class="headerlink" title="What is S3?"></a>What is S3?</h1><p>Amazon Simple Storage Service (Amazon S3) is object storage with a simple web service interface to store and retrieve any amount of data from anywhere on the web. It is designed to deliver 99.999999999% durability, and scale past trillions of objects worldwide.</p>
<p>Customers use S3 as primary storage for cloud-native applications; as a bulk repository, or “<a href="https://aws.amazon.com/big-data/data-lake-on-aws/download/" target="_blank" rel="noopener">data lake</a>,” for analytics; as a target for <a href="https://aws.amazon.com/backup-recovery/getting-started/" target="_blank" rel="noopener">backup &amp; recovery</a> and disaster recovery; and with <a href="https://aws.amazon.com/lambda/details/" target="_blank" rel="noopener">serverless computing</a>.</p>
<p>It’s simple to move large volumes of data into or out of Amazon S3 with Amazon’s <a href="https://aws.amazon.com/cloud-data-migration/" target="_blank" rel="noopener">cloud data migration</a> options. Once data is stored in S3, it can be automatically tiered into lower cost, longer-term cloud storage classes like S3 Standard - Infrequent Access and <a href="https://aws.amazon.com/glacier/details/" target="_blank" rel="noopener">Amazon Glacier</a> for archiving.</p>
<h1 id="S3-The-Basics"><a href="#S3-The-Basics" class="headerlink" title="S3 - The Basics"></a>S3 - The Basics</h1><ul>
<li><p>單一檔案大小的限制為 <code>0 bytes</code> ~ <code>5 TB</code></p>
</li>
<li><p>檔案一律存在 bucket 中 (Bucket 裏面無法再放一個 bucket，但可以放 folder)</p>
</li>
<li><p>單一帳號預設最大上限可存放 100 個 buckets，但可以通知 AWS 協助放大上限</p>
</li>
<li><p>S3 裡面的每個 bucket 都會有一個全球獨一無二的 DNS 名稱(ex: <a href="https://s3-eu-west-1.amazonaws.com/YOUR_UNIQUE_BUCKET_NAME" target="_blank" rel="noopener">https://s3-eu-west-1.amazonaws.com/YOUR_UNIQUE_BUCKET_NAME</a>)</p>
<blockquote>
<p>因此可以做為 static website hosting 之用</p>
</blockquote>
</li>
<li><p>成功上傳檔案到 S3 後，會收到 HTTP 200 的回應</p>
</li>
<li><p>Built for 99.99% availability for S3 platform</p>
</li>
<li><p>Amazon 實際保證 99.9% availability</p>
</li>
<li><p>Amazon 保證 11 個 9 的 durability for S3 information (資料遺失的可能性)</p>
<blockquote>
<p>為避免人為不小心刪除的狀況發生，最好的方法還是建議把 versioning, cross-regsion replication, MFA 刪除等機制啟用</p>
</blockquote>
</li>
<li><p>Tiered Storage available</p>
</li>
<li><p>Lifecycle Management</p>
<blockquote>
<p>可以設定前 30 天在正常的 <strong>standard</strong> tier, 接著 30 天移到另外一個 IA(Infrequently Accessed) tier, 90 天後進行 archive</p>
</blockquote>
</li>
<li><p>Versioning</p>
</li>
<li><p>Encryption</p>
</li>
<li><p>可透過 Access Control Lists &amp; Bucket Policies 來提升安全性</p>
<blockquote>
<p>剛建立好的 bucket or 上傳的 object 所預設的權限僅限於自己可以存取(private &amp; inaccessible)，完全沒有預設對外開放的規則</p>
</blockquote>
</li>
</ul>
<h1 id="Data-Consistency-Model-for-S3"><a href="#Data-Consistency-Model-for-S3" class="headerlink" title="Data Consistency Model for S3"></a>Data Consistency Model for S3</h1><ul>
<li><p>Read after consistency for PUTS of new Object (新增檔案後馬上就可以讀取)</p>
</li>
<li><p>Eventually Consistency for overwrite PUTS and DELETES(can take some time to propagate)</p>
<blockquote>
<p>若是針對已經存在的檔案進行修改 or 刪除，這樣的變更需要花點時間才會完全套用到所有的硬體設施中</p>
</blockquote>
</li>
</ul>
<h1 id="S3-is-a-simple-key-value-store"><a href="#S3-is-a-simple-key-value-store" class="headerlink" title="S3 is a simple key, value store"></a>S3 is a simple key, value store</h1><p>S3 is object based. 每個 object 都包含以下資訊：</p>
<ul>
<li><p><strong>Key</strong>: object name (檔案會依照字母順序排序，新增時要考量這個問題，建議在每個檔案名稱前 random 一個字串作為開始)</p>
</li>
<li><p><strong>Value</strong>: 基本上就是此檔案的資料本身</p>
</li>
<li><p><strong>Version ID</strong>: 作為版本控管之用</p>
</li>
<li><p><strong>Metadata</strong>: 額外用來記錄 object 相關資訊的資料(ex: 上傳檔案的時間、最後變更的時間…etc)</p>
<blockquote>
<p>使用者也可以自訂客製化的 metadata，藉此來為 object 標註不同的屬性值</p>
</blockquote>
</li>
<li><p><strong>Subresources</strong></p>
<ul>
<li>Access Control Lists (用來做細部的存取控管)</li>
<li>Torrent (S3 支援 bittorrent protocol)</li>
</ul>
</li>
</ul>
<h1 id="S3-vs-Glacier"><a href="#S3-vs-Glacier" class="headerlink" title="S3 vs Glacier"></a>S3 vs Glacier</h1><table>
<thead>
<tr>
<th></th>
<th style="text-align:center">Standard</th>
<th style="text-align:center">Standard - IA</th>
<th style="text-align:center">Glacier</th>
</tr>
</thead>
<tbody>
<tr>
<td>Designed for Durability</td>
<td style="text-align:center">11 x 9’s</td>
<td style="text-align:center">11 x 9’s</td>
<td style="text-align:center">11 x 9’s</td>
</tr>
<tr>
<td>Designed for Availability</td>
<td style="text-align:center">99.99%</td>
<td style="text-align:center">99.99%</td>
<td style="text-align:center">N/A</td>
</tr>
<tr>
<td>Availability SLA</td>
<td style="text-align:center">99.9%</td>
<td style="text-align:center">99%</td>
<td style="text-align:center">N/A</td>
</tr>
<tr>
<td>Minumum Object Size</td>
<td style="text-align:center">N/A</td>
<td style="text-align:center">128KB</td>
<td style="text-align:center">N/A</td>
</tr>
<tr>
<td>Minumum Storage Duration</td>
<td style="text-align:center">N/A</td>
<td style="text-align:center">30 days</td>
<td style="text-align:center">90 days</td>
</tr>
<tr>
<td>Retrieval Fee</td>
<td style="text-align:center">N/A</td>
<td style="text-align:center">per GB retrieved</td>
<td style="text-align:center">per GB retrieved</td>
</tr>
<tr>
<td>First Byte Latency</td>
<td style="text-align:center">ms</td>
<td style="text-align:center">ms</td>
<td style="text-align:center">select minutes or hours</td>
</tr>
<tr>
<td>Storage Class</td>
<td style="text-align:center">object level</td>
<td style="text-align:center">object level</td>
<td style="text-align:center">object level</td>
</tr>
<tr>
<td>Lifecycle Transitions</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">S3</th>
<th style="text-align:center">Glacier</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">up to 5TB object</td>
<td style="text-align:center">up to 40TB archive</td>
</tr>
<tr>
<td style="text-align:center">user-definable key</td>
<td style="text-align:center">system-generated archive ID</td>
</tr>
<tr>
<td style="text-align:center">encrypt is optional</td>
<td style="text-align:center">automatically encrypted</td>
</tr>
</tbody>
</table>
<h1 id="S3-收費標準"><a href="#S3-收費標準" class="headerlink" title="S3 收費標準"></a>S3 收費標準</h1><ul>
<li><p>Storage Pricing</p>
</li>
<li><p>Request Pricing</p>
</li>
<li><p>Storage Management Pricing</p>
<blockquote>
<p>例如：analysis, tagging, inventory check</p>
</blockquote>
</li>
<li><p>Data Transfer Pricing</p>
<blockquote>
<p>資料存入 S3 免費，往其他地方傳則要付費，即使是 region 之間互傳</p>
</blockquote>
</li>
<li><p>Transfer Acceleration</p>
<blockquote>
<p>Amazon S3 Transfer Acceleration enables fast, easy, and secure transfers of files over long distances between your client and an S3 bucket. Transfer Acceleration takes advantage of Amazon CloudFront’s globally distributed edge locations. As the data arrives at an edge location, data is routed to Amazon S3 over an optimized network path.</p>
</blockquote>
</li>
</ul>
<h1 id="Advanced-Features"><a href="#Advanced-Features" class="headerlink" title="Advanced Features"></a>Advanced Features</h1><h2 id="Prefix-amp-Delimiter"><a href="#Prefix-amp-Delimiter" class="headerlink" title="Prefix &amp; Delimiter"></a>Prefix &amp; Delimiter</h2><p>以下面的 object 名稱為例：</p>
<blockquote>
<p>logs/2016/January/server42.log<br>logs/2016/February/server42.log<br>logs/2016/March/server42.log</p>
</blockquote>
<ul>
<li><p>S3 可透過 prefix &amp; delimiter 作到類似檔案階層的功能(hierachy &amp; folder)，但事實那些都只是透過 object 的檔名虛構出來的，並沒有實際階層功能</p>
</li>
<li><p>REST API, SDK, CLI, Management Console 都支援使用 prefix &amp; delimiter</p>
</li>
<li><p>與 IAM or S3 Bucket Plicies 搭配，可以在單一個 bucket 中達成像是 department subdirectories, user home directories … 等效果</p>
</li>
</ul>
<h2 id="Storage-Tiers-Classes"><a href="#Storage-Tiers-Classes" class="headerlink" title="Storage Tiers/Classes"></a>Storage Tiers/Classes</h2><table>
<thead>
<tr>
<th></th>
<th style="text-align:center">Standard</th>
<th style="text-align:center">Standard (Infrequent Access)</th>
<th style="text-align:center">Reduced Redundancy Storage</th>
</tr>
</thead>
<tbody>
<tr>
<td>Durability</td>
<td style="text-align:center">99.999999999%</td>
<td style="text-align:center">99.999999999%</td>
<td style="text-align:center">99.99%</td>
</tr>
<tr>
<td>Availability</td>
<td style="text-align:center">99.99%</td>
<td style="text-align:center">99.99%</td>
<td style="text-align:center">99.99%</td>
</tr>
<tr>
<td>Concurrect facility fault tolerance</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>SSL support</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">Yes</td>
</tr>
<tr>
<td>First byte latency</td>
<td style="text-align:center">Miliseconds</td>
<td style="text-align:center">Miliseconds</td>
<td style="text-align:center">Miliseconds</td>
</tr>
<tr>
<td>Lifecycle Management Policies</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">Yes</td>
</tr>
<tr>
<td>附註</td>
<td style="text-align:center"></td>
<td style="text-align:center">object 大小限制為最小 128KB, 最少要存放 30 天, 存取資料要額外收費</td>
</tr>
</tbody>
</table>
<h3 id="1-Standard"><a href="#1-Standard" class="headerlink" title="1. Standard"></a>1. Standard</h3><p>99.99 availability, 99.999999999% durability, stored redundantly across multiple devices in multiple facilities and is designed to sustain the loss of 2 facilities concurrently.</p>
<h3 id="2-IA-Infrequently-Accessed"><a href="#2-IA-Infrequently-Accessed" class="headerlink" title="2. IA(Infrequently Accessed)"></a>2. IA(Infrequently Accessed)</h3><p>適合不常存取的資料，比 standard 便宜，要存取時可以馬上取得，但存取需要額外付費</p>
<h3 id="3-Reduced-Redundancy-Storage-RRS"><a href="#3-Reduced-Redundancy-Storage-RRS" class="headerlink" title="3. Reduced Redundancy Storage (RRS)"></a>3. Reduced Redundancy Storage (RRS)</h3><p>Design to provide 99.99% durability and 99.99 availability of objects over a given year.</p>
<blockquote>
<p>durability 從 <strong>11 x 9’s</strong> 變成 <strong>4 x 9’s</strong>，適合存像是圖片的 thumb nails 之類的資料</p>
</blockquote>
<h3 id="4-Glacier"><a href="#4-Glacier" class="headerlink" title="4. Glacier"></a>4. Glacier</h3><ul>
<li><p>very cheap, but used for archival only. </p>
</li>
<li><p>存取前需先執行 restore 命令，並需要等待 3~5 個小時的資料準備時間</p>
</li>
<li><p>Glacier 上的資料不會因為 restore 命令而刪除，除非明確執行刪除指令</p>
</li>
<li><p>資料還原時會放到 S3 <strong>RRS(Reduced Redundancy Storage)</strong> class</p>
</li>
<li><p>AWS 提供每個月免費取得 5% Glacier 資料的額度 (每日為單位計算)</p>
<blockquote>
<p>可透過設定 <strong>retrieval policy</strong> or <strong>設定 max GB-per-hour limit</strong> 來確保存取資料會在免費的額度下進行，來降低甚至避免還原費用的發生</p>
</blockquote>
</li>
<li><p>雖然是 S3 Storage Class 的一個選項，但其實 Glacier 是個獨立服務且有獨立的 API，並提供一些 S3 沒有的功能</p>
</li>
<li><p>可用來作為取代傳統磁帶作為長期備份的選項 (在某些行業必須有保留資料 N 年的規定)</p>
</li>
<li><p>非常可靠，也是有 11 個 9 的 durability</p>
</li>
</ul>
<h4 id="Archive"><a href="#Archive" class="headerlink" title="Archive"></a>Archive</h4><ul>
<li><p>在 Glacier 上儲存的備份單位稱為 <strong>archive</strong>（等同 S3 上 object 的概念)</p>
</li>
<li><p>每個 archive 最大可以到 <strong>40TB</strong></p>
</li>
<li><p>使用者可以擁有無限數量的 archive</p>
</li>
<li><p>每個 archive 都會有一個 unique archive ID (無法自己取名字)</p>
</li>
<li><p>所有的 archive 都會被自動加密 &amp; 無法被修改</p>
</li>
</ul>
<h4 id="Vault"><a href="#Vault" class="headerlink" title="Vault"></a>Vault</h4><ul>
<li><p>在 Glacier 中存放 archive 的容器稱為 <strong>vault</strong> (等同 S3 上 bucket 的概念)</p>
</li>
<li><p>可透過設定 IAM policy or vault access policy 來限制存取</p>
</li>
</ul>
<h4 id="Vaults-Locks"><a href="#Vaults-Locks" class="headerlink" title="Vaults    Locks"></a>Vaults    Locks</h4><ul>
<li><p>使用者可透過 Vaults    Locks 針對 Glacier 設定強制管理</p>
</li>
<li><p>可藉由設定 Write Once Read Many(WORM) 在 vault lock policy 中來套用到未來所有存放到 valut 的 archive</p>
</li>
<li><p>一旦設定了 vault lock policy，就無法再度變更規則</p>
</li>
</ul>
<h2 id="Lifecycle-Management"><a href="#Lifecycle-Management" class="headerlink" title="Lifecycle Management"></a>Lifecycle Management</h2><ul>
<li><p>等同於傳統 IT storage infra 中的 <strong>automated storage tiering</strong> 功能，是一種 data 從 <code>hot</code>(frequently    accessed) -&gt; <code>warm</code>(less    frequently    accessed) -&gt; <code>cold</code>(long-term    backup    or    archive) 的概念</p>
</li>
<li><p>Can be used in conjuction with versioning.</p>
</li>
<li><p>Can be applied to current versions and previous versions</p>
</li>
<li><p>Following actions can now be done:</p>
<ul>
<li>Transition to the <strong>Standard - Infrequent Access</strong> storage class (128Kb and 30 days after the creation date)</li>
<li>Archive to the <strong>Glacier</strong> storage class (30 days after IA, if relevent)</li>
<li>Permanently Delete (若有移到 Glacier 要把刪除的日期設為 90 天以上，因為 Glacier 費用低消是 90 days)</li>
</ul>
</li>
</ul>
<h2 id="Encryption"><a href="#Encryption" class="headerlink" title="Encryption"></a>Encryption</h2><h3 id="1-In-Transit"><a href="#1-In-Transit" class="headerlink" title="1. In Transit"></a>1. In Transit</h3><p>透過 AWS SSL API endpoints 存取 S3 (<strong>HTTPS</strong>)，存取的流量都會被加密</p>
<h3 id="2-At-Rest"><a href="#2-At-Rest" class="headerlink" title="2. At Rest"></a>2. At Rest</h3><h4 id="1-Server-Side-Encryption"><a href="#1-Server-Side-Encryption" class="headerlink" title="(1) Server Side Encryption"></a>(1) Server Side Encryption</h4><ul>
<li><p>S3 Managed Keys (<code>SSE-S3</code>)</p>
<blockquote>
<p>AWS 會將資料用 master key(AES-256) 進行加密，且 key 會定期更換，全由 AWS 託管</p>
</blockquote>
</li>
<li><p>AWS Key Management Service, Managed Keys (<code>SSE-KMS</code>)</p>
<blockquote>
<p>透過 KMS 指定 master key 來進行加密，<strong>需要額外支付 KMS 的費用</strong><br>但可以控管 S3 的存取，也可以確認存取 S3 的人是擁有 key 的使用者(可以搭配 AWS 的追蹤功能之道誰在何時存取了 S3 並解密，甚至可以檢視哪個沒有權限的使用者嘗試解密資料時發生的錯誤)</p>
</blockquote>
</li>
<li><p>Server Side Encryption with Customer Provided Keys (<code>SSE-C</code>)</p>
</li>
</ul>
<h4 id="2-Client-Side-Encryption-將資料加密後傳到-S3"><a href="#2-Client-Side-Encryption-將資料加密後傳到-S3" class="headerlink" title="(2) Client Side Encryption (將資料加密後傳到 S3)"></a>(2) Client Side Encryption (將資料加密後傳到 S3)</h4><p>AWS 可從兩個管道取得 data encryption key:</p>
<ul>
<li><p>AWS KMS-managed customer master key</p>
</li>
<li><p>client-side master key</p>
</li>
</ul>
<h2 id="Versioning"><a href="#Versioning" class="headerlink" title="Versioning"></a>Versioning</h2><ul>
<li><p>object 的所有版本資訊都會被保留下來，<strong>包含所有的寫入資訊甚至是刪除的資訊</strong>都會被完整保留 (<strong>同樣也要支付多倍的費用來儲存不同的版本</strong>)</p>
</li>
<li><p>Great backup tool</p>
</li>
<li><p>Once enabled, Versioning cannot be disabled, only suspended.</p>
</li>
<li><p>Integrates with Lifecycle rules</p>
</li>
<li><p>Versioning’s MFA Delete capability, which uses multi-factor authentication, can be used to provide an additional layer of security. (<strong>只能由 root 帳號啟用此功能</strong>)</p>
<blockquote>
<p>刪除 object 前必須提供 token or security code 來完成</p>
</blockquote>
</li>
<li><p>Cross Region Replication, requires versioning enabled on the source bucket</p>
</li>
</ul>
<h2 id="Pre-Signed-URLs"><a href="#Pre-Signed-URLs" class="headerlink" title="Pre-Signed URLs"></a>Pre-Signed URLs</h2><p>object owner 可以透過 <strong>pre-signed URL</strong> 的機制，提供給其他人<strong>暫時</strong>存取 object 的權限，而有效期限則是由 owner 自行指定；也可以透過來保護公開的網頁資料，避免未授權的惡意行為發生。</p>
<h2 id="Multipart-Upload"><a href="#Multipart-Upload" class="headerlink" title="Multipart Upload"></a>Multipart Upload</h2><p>當使用者有大檔案要上傳時，可開啟 multipart upload 的功能，檔案會被切成多個部份同時上傳，到 S3 上後會自動重組而成原本的檔案。</p>
<blockquote>
<p>建議超過 100MB 的檔案使用 multipart upload；此外，超過 5GB 的檔案一定要用 multipart upload 才可以上傳</p>
<p>可以針對未完成上傳的檔案設定 lifecycle policy，如此可以減少費用的支出，讓超過期限未完成上傳的檔案自動失效</p>
</blockquote>
<h2 id="Range-GETs"><a href="#Range-GETs" class="headerlink" title="Range    GETs"></a>Range    GETs</h2><p>可下載指定 object 的部份內容，透過指定 byte 的範圍來取得 object 的部份資料；而這功能必須透過 SDK 搭配 Range HTTP header 才能實現。</p>
<blockquote>
<p>若是網路品質很差，或是想要從很大的 Glacier 備份中取得部份資料時可能會用到</p>
</blockquote>
<h2 id="Cross-Region-Replication"><a href="#Cross-Region-Replication" class="headerlink" title="Cross-Region Replication"></a>Cross-Region Replication</h2><p>cross-region replication 允許使用者將指定 bucket 的 object 非同步的複製到其他的 region。</p>
<ul>
<li><p>啟用 cross-region replication 的功能前，必須先啟動 bucket 的 versioning 功能</p>
</li>
<li><p>任何與 object 相關的 metadata or ACL 設定更動時，都會觸發 replication 的發生</p>
</li>
<li><p>必須設定正確的 IAM policy 讓 S3 本身可以進行 replication 的工作</p>
</li>
<li><p>若是已經存在的 bucket 開啟 cross-region replication 的功能，原有的資料不會被複製，必須自行複製 or 透過額外的命令來進行資料搬移</p>
</li>
</ul>
<blockquote>
<p>此功能常被用來將 object 放在靠使用者較近的地方來減少延遲；或是滿足不同地理區域備份的需求</p>
</blockquote>
<h2 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h2><ul>
<li><p>針對 bucket 存取的 logging 功能預設關閉，可透過 S3 server access logs 功能開啟</p>
</li>
<li><p>log 可儲存在同一個 bucket 內，也可以存在另外一個 bucket 中；但重點是設定 prefix(例如：<code>logs/</code> or <code>bucket_name/logs/</code>) 讓後續尋找 log 方便是很重要的</p>
</li>
<li><p>log 資訊包含：</p>
<ul>
<li>requestor account &amp; IP</li>
<li>request time</li>
<li>bucket name</li>
<li>action (GET, PUT, LIST … etc)</li>
<li>response status &amp; error code</li>
</ul>
</li>
</ul>
<h2 id="Event-Notification"><a href="#Event-Notification" class="headerlink" title="Event Notification"></a>Event Notification</h2><p>event notification 可以用來在 bucket 狀態有變更(例如：上傳 object)時驅動某些事件的發生，使用者可以透過此特性來加入到 workflow 的設計，發送警告，或是執行特定工作…等等。</p>
<ul>
<li><p>設定於 bucket level</p>
</li>
<li><p>可在 object 被建立(PUT, POST, COPY or multipart upload), 被刪除(DELETE)，或是偵測到有 RRS(Reduced Redundancy Storage) object 遺失的時候發送通知</p>
</li>
<li><p>可透過 Amazon SNS(Simple Notification Service) or SQS(Simple Queue Service) 發送通知，也可以直接呼叫 AWS Lambda function</p>
</li>
</ul>
<h1 id="S3-Management-Console"><a href="#S3-Management-Console" class="headerlink" title="S3 Management Console"></a>S3 Management Console</h1><h2 id="Permissions"><a href="#Permissions" class="headerlink" title="Permissions"></a>Permissions</h2><p>在權限管理的部分，有分成 <code>Objects</code> &amp; <code>Object permissions</code> 兩種：</p>
<ol>
<li><p><strong>Objects</strong>: 對於 object 本身內容的存取權限</p>
<blockquote>
<p>Grant permissions to the user to list, create, overwrite, or delete objects in the bucket.</p>
</blockquote>
</li>
<li><p><strong>Object permissions</strong>: 對於 object 的 ACL 的存取權限，並非 object 本身</p>
<blockquote>
<p>Grant permissions to the user to read or write to an access control list (ACL) for the bucket</p>
</blockquote>
</li>
</ol>
<p>即使 bucket 的權限被設定為 public readable，也不代表後續上傳到此 bucket 的 object 也是 public readable，權限是分開管理的</p>
<h2 id="Versioning-1"><a href="#Versioning-1" class="headerlink" title="Versioning"></a>Versioning</h2><ul>
<li><p>當此功能開啟後，之後無法移除，只能關閉</p>
</li>
<li><p>上傳相同名稱的檔案多次，S3 會在介面上看到一個檔案搭配多個 version 可選 (透過檢視 metadata 可以發現其實根本就是不同的 object)</p>
<blockquote>
<p>而使用容量的計算當然就是所有版本 object 的 size 總和 (<strong>計算成本的時候要特別注意這件事情</strong>)</p>
</blockquote>
</li>
<li><p>若移除 object 的 version，永遠就會消失無法還原</p>
</li>
<li><p>刪除 object 之後，會在系統上留下一個 <code>Delete Marker</code>(需要在 Versions 的地方選 <strong>Show</strong> 藉以顯示所有歷程記錄)，刪除 Delete Marker 之後就可以回復原本被刪除的檔案 </p>
<blockquote>
<p>目前還原功能是在舊版的版面上找到的，新版的目前沒有看到類似的功能頁面</p>
</blockquote>
</li>
</ul>
<h1 id="S3-Transfer-Acceleration"><a href="#S3-Transfer-Acceleration" class="headerlink" title="S3 Transfer Acceleration"></a>S3 Transfer Acceleration</h1><h2 id="What-is-S3-Transfer-Acceleration"><a href="#What-is-S3-Transfer-Acceleration" class="headerlink" title="What is S3 Transfer Acceleration?"></a>What is S3 Transfer Acceleration?</h2><p>S3 Transfer Acceleration utilise the CloudFront Edge Network to accelerate your uploads to S3. Instead of uploading directly to your S3 bucket, you can use a distinct URL to upload directly to an edge location which will then transfer that file to S3. You will get a distinct URL to upload to:</p>
<blockquote>
<p>your-bucket-name.s3-accelerate.amazonaws.com</p>
</blockquote>
<p>若要上傳大量的資料到距離本地端很遠的 region，使用 S3 Transfer Acceleration 會很有幫助</p>
<h1 id="Create-a-Static-Website-using-S3"><a href="#Create-a-Static-Website-using-S3" class="headerlink" title="Create a Static Website using S3"></a>Create a Static Website using S3</h1><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol>
<li><p>建立 bucket</p>
</li>
<li><p>啟用 <strong>Static website hosting</strong></p>
</li>
</ol>
<blockquote>
<p>這裡會取得一個 <strong><a href="http://your-bucket-name.s3-website.region-alias.amazonaws.com" target="_blank" rel="noopener">http://your-bucket-name.s3-website.region-alias.amazonaws.com</a></strong> 的 domain name</p>
</blockquote>
<ol>
<li><p>可以額外設定 index/error pages.</p>
</li>
<li><p>依然要提供 object read permission 才可以</p>
</li>
</ol>
<h1 id="Exam-Tips"><a href="#Exam-Tips" class="headerlink" title="Exam Tips"></a>Exam Tips</h1><h2 id="S3-101"><a href="#S3-101" class="headerlink" title="S3 101"></a>S3 101</h2><ul>
<li><p>S3 is Object based.</p>
</li>
<li><p>Files can be from 0 Bytes ~ 5 TB.</p>
</li>
<li><p>There is unlimited storage.</p>
</li>
<li><p>Files are stored in Buckets.</p>
</li>
<li><p>S3 is a universal namespace, that is, names must be unique globally.</p>
<blockquote>
<p>網址的格式為: <a href="https://[RegionName].amazonaws.com/[YourBucketName" target="_blank" rel="noopener">https://[RegionName].amazonaws.com/[YourBucketName</a>]</p>
</blockquote>
</li>
<li><p>Read after Write consistency for PUTS of new Object</p>
</li>
<li><p>Eventual Consistency for overwrite PUTS and DELETES (can take some time to propagate)</p>
</li>
<li><p>S3 Storage Classes/Tiers</p>
<ul>
<li>S3 (durable, immediately available, frequently accessed)</li>
<li>S3 - IA (durable, immediately available, infrequently accessed)</li>
<li>S3 - Reduced Redundancy Storage (data that is easily reproducible, such as thumb nails etc)</li>
<li>Glacier - Archived data, where you can wait 3~5 hours before accessing</li>
</ul>
</li>
<li><p>Remember the core fundamentals of an S3 object</p>
<ul>
<li>Key (name)<blockquote>
<p>這是一個 1024 bytes 的 UTF-8 字元所組成，在同一個 bucket 內不會重複(但不同的 bucket 可能會有同樣的 key)</p>
</blockquote>
</li>
<li>Value (data)</li>
<li>version ID</li>
<li>metadata</li>
<li>subresource (ACL, torrent)</li>
</ul>
</li>
<li><p>Object based storage only (for files).</p>
</li>
<li><p><strong>Not suitable to install an operating system</strong>.</p>
</li>
<li><p>Successfuly upload will generate a HTTP 200 status code.</p>
</li>
</ul>
<h2 id="Versioning-2"><a href="#Versioning-2" class="headerlink" title="Versioning"></a>Versioning</h2><ul>
<li><p>object 的所有版本資訊都會被保留下來，<strong>包含所有的寫入資訊甚至是刪除的資訊</strong>都會被完整保留 (<strong>同樣也要支付多倍的費用來儲存不同的版本</strong>)</p>
</li>
<li><p>Great backup tool</p>
</li>
<li><p>Once enabled, Versioning cannot be disabled, only suspended.</p>
</li>
<li><p>Integrates with Lifecycle rules</p>
</li>
<li><p>Versioning’s MFA Delete capability, which uses multi-factor authentication, can be used to provide an additional layer of security. (<strong>只能由 root 帳號啟用此功能</strong>)</p>
<blockquote>
<p>刪除 object 前必須提供 token or security code 來完成</p>
</blockquote>
</li>
<li><p>Cross Region Replication, requires versioning enabled on the source bucket</p>
</li>
</ul>
<h2 id="Cross-Region-Replication-1"><a href="#Cross-Region-Replication-1" class="headerlink" title="Cross Region Replication"></a>Cross Region Replication</h2><ul>
<li><p>要啟用 cross region replication 的功能，source &amp; destination bucket 都必須要啟用 versioning 才可以</p>
</li>
<li><p>設定 replication 前已經存在的 object 不會自動被同步，只有後續上傳的 object 會被同步</p>
<blockquote>
<p>如果上傳新版的 object，原來所有版本的記錄都會一併被同步</p>
</blockquote>
</li>
<li><p>任何與 object 相關的 metadata or ACL 被變更時，都會觸發 replication 的工作執行</p>
</li>
<li><p>必須設定 IAM policy，用以提供 S3 合適的權限進行 replication 工作</p>
</li>
<li><p>單一 bucket 無法同步到多個 region，但可透過 <code>region1_bucket -&gt; region2_bucket -&gt; region3_bucket</code> 的方式達成相同效果 (daisy chain 似乎也不行)</p>
</li>
<li><p>刪除 object 後，原本同步 region 上的 object 也會被刪除</p>
<ul>
<li>所從舊版的 console 刪除 delete maker 後可以恢復檔案，但刪除 delete marker 這動作不會被同步，因此同步的 destination bucket 上的檔案不會回復</li>
<li>若使用 <code>region1_bucket -&gt; region2_bucket -&gt; region3_bucket</code> 同步到多個 region，delete marker 只會被同步到 region2，region3 只會得到檔案被刪除的結果，看不到 delete marker</li>
</ul>
</li>
<li><p>Deleting individual versions or delete markers will not be replicated</p>
<blockquote>
<p>在 source bucket 中刪除 delete marker or 特定版本(在舊版的 console)的結果，不會被同步到 destination bucket</p>
</blockquote>
</li>
</ul>
<h2 id="Lifecycle-Management-1"><a href="#Lifecycle-Management-1" class="headerlink" title="Lifecycle Management"></a>Lifecycle Management</h2><ul>
<li><p>等同於傳統 IT storage infra 中的 <strong>automated storage tiering</strong> 功能，是一種 data 從 <code>hot</code>(frequently    accessed) -&gt; <code>warm</code>(less    frequently    accessed) -&gt; <code>cold</code>(long-term    backup    or    archive) 的概念</p>
</li>
<li><p>Can be used in conjuction with versioning.</p>
</li>
<li><p>Can be applied to current versions and previous versions</p>
</li>
<li><p>Following actions can now be done:</p>
<ul>
<li>Transition to the <strong>Standard - Infrequent Access</strong> storage class (128Kb and 30 days after the creation date)</li>
<li>Archive to the <strong>Glacier</strong> storage class (30 days after IA, if relevent)</li>
<li>Permanently Delete (若有移到 Glacier 要把刪除的日期設為 90 天以上，因為 Glacier 費用低消是 90 days)</li>
</ul>
</li>
</ul>
<h2 id="CloudFront"><a href="#CloudFront" class="headerlink" title="CloudFront"></a>CloudFront</h2><ul>
<li><p>Edge Location: This is the location where content will be cached. This is separate to an AWS Region/AZ.</p>
</li>
<li><p>Origin: This is the origin of all the files that the CDN will distribute. This can be either an S3 bucket, an EC2 instance, an Elastic Load Balancer or Route53.</p>
</li>
<li><p>Distribution: This is the name given the CDN which consists of a collection of Edge Locations.</p>
<ul>
<li><strong>Web Distribution</strong>: Typically used for websites.</li>
<li><strong>RTMP</strong>: Used for media streaming. (ex: Adobe Flash)</li>
</ul>
</li>
<li><p>Edge Locations are <strong>not just READ only</strong>, you can write to them too. (ie. put an object on to them).</p>
</li>
<li><p>Objects are cached for the life of the TTL (Time to Live)</p>
</li>
<li><p>You can clear cached objects, but you will be charged. (不需要等到 TTL 結束)</p>
</li>
</ul>
<h2 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h2><ul>
<li><p>By default, all newly created buckets are <strong>PRIVATE</strong></p>
</li>
<li><p>You can setup access control to your buckets using:</p>
<ul>
<li>Bucket Policies</li>
<li>Access Control Lists (可調整個別 object 的權限)</li>
</ul>
</li>
<li><p>S3 buckets can be configured to create access logs which log all requests made to the S3 buckets. This can be done to another bucket. (也可以將 log 放到另一個 AWS 帳號 S3 bucket 中，需要進行跨帳號連結的設定) </p>
</li>
</ul>
<h2 id="Encryption-1"><a href="#Encryption-1" class="headerlink" title="Encryption"></a>Encryption</h2><h3 id="1-In-Transit-SSL-TLS"><a href="#1-In-Transit-SSL-TLS" class="headerlink" title="1. In Transit (SSL/TLS)"></a>1. In Transit (SSL/TLS)</h3><h3 id="2-At-Rest-1"><a href="#2-At-Rest-1" class="headerlink" title="2. At Rest"></a>2. At Rest</h3><ul>
<li><p>Server Side Encryption</p>
<ul>
<li>S3 Managed Keys (<code>SSE-S3</code>)</li>
<li>AWS Key Management Service, Managed Keys (<code>SSE-KMS</code>)</li>
<li>Server Side Encryption with Customer Provided Keys (<code>SSE-C</code>)</li>
</ul>
</li>
<li><p>Client Side Encryption</p>
</li>
</ul>
<h2 id="Storage-Gateway"><a href="#Storage-Gateway" class="headerlink" title="Storage Gateway"></a>Storage Gateway</h2><ul>
<li><p><strong>File Gateway</strong>: For flat files, stored directly on S3</p>
</li>
<li><p><strong>Volume Gateway</strong></p>
<ul>
<li><strong>Stored Volumes</strong> - Entire Dataset is stored on site and is asynchronously backed up to S3.</li>
<li><strong>Cached Volumes</strong> - Entire Dataset is stored on S3 and the most frequently accessed data is cached on site.</li>
</ul>
</li>
<li><p><strong>Gateway Virtual Tape Library (VTL)</strong>: Used for backup and uses popular backup applications like NetBackup, Backup Exec, Veam etc</p>
</li>
</ul>
<h2 id="Snowball"><a href="#Snowball" class="headerlink" title="Snowball"></a>Snowball</h2><ul>
<li><p>Snowball</p>
</li>
<li><p>Snowball Edge</p>
</li>
<li><p>Snowmobile</p>
</li>
<li><p>Understand what Snowball is</p>
</li>
<li><p>Understand what Import Export is</p>
</li>
<li><p>Snowball can</p>
<ul>
<li>Import to S3</li>
<li>Export from S3</li>
</ul>
</li>
</ul>
<h2 id="S3-Transfer-Acceleration-1"><a href="#S3-Transfer-Acceleration-1" class="headerlink" title="S3 Transfer Acceleration"></a>S3 Transfer Acceleration</h2><p>You can speed up transfers to S3 using S3 transfer acceleration. This cost extra, and has the greatest impact on people who are in far away location.</p>
<h2 id="S3-Static-Websites"><a href="#S3-Static-Websites" class="headerlink" title="S3 Static Websites"></a>S3 Static Websites</h2><ul>
<li><p>You can use S3 to hsot static websites</p>
</li>
<li><p>Serverless</p>
</li>
<li><p>Very cheap, scales automatically</p>
</li>
<li><p><strong>STATIC</strong> only, canonot host dynamic sites</p>
</li>
</ul>
<h2 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h2><ul>
<li><p>Write to S3 - HTTP 200 code for a successful write.</p>
</li>
<li><p>You can load files to S3 much faster by enabling multipart upload</p>
</li>
<li><p>Read the S3 FAQ before taking the exam. It comes up A LOT!</p>
</li>
</ul>
<p>##　Best Practices, Patterns,    and    Performance</p>
<ul>
<li><p>S3 &amp; Glacier 非常適合在 hybrid cloud 的環境下作為異地備份的工具</p>
</li>
<li><p>另一個常見的應用是將 S3 作為大量 blob 檔案的儲存位置，而把這些 blob 的 index 存於其他的服務(例如：Amazon DynamoDB or Amazon RDS)，透過此方式可以針對 key name 提高搜尋的速度並支援複雜的查詢</p>
</li>
<li><p>S3 會自動 scale 來支援 high request rate，也會自動的根據需求針對 bucket 進行 repartition 的動作</p>
</li>
<li><p>若有每秒超過 100 個 reuqest 的需求，可參考 developer guide 中的資訊，讓 object key 可以隨機的分佈 (可透過像是使用 hash 值作為 key name prefix 的方式來達成)</p>
</li>
</ul>
<h1 id="應考前建議"><a href="#應考前建議" class="headerlink" title="應考前建議"></a>應考前建議</h1><p>詳細閱讀下列資料：</p>
<ul>
<li><a href="https://aws.amazon.com/s3/faqs/" target="_blank" rel="noopener">Amazon Simple Storage Service (S3) FAQs</a> <a href="https://aws.amazon.com/tw/s3/faqs/" target="_blank" rel="noopener">(中文)</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> AWS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AWS </tag>
            
            <tag> S3 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[AWS 學習筆記 - IAM(Identity and Access Management)]]></title>
      <url>/blog/2017/05/02/AWS/AWS-Learning-Notes-IAM/</url>
      <content type="html"><![CDATA[<h1 id="What-is-IAM"><a href="#What-is-IAM" class="headerlink" title="What is IAM?"></a>What is IAM?</h1><p>AWS Identity and Access Management (IAM) enables you to securely control access to AWS services and resources for your users. Using IAM, you can create and manage AWS users and groups, and use permissions to allow and deny their access to AWS resources. </p>
<p>IAM is a feature of your AWS account offered at no additional charge. You will be charged only for use of other AWS services by your users.</p>
<h1 id="What-does-IAM-give-you"><a href="#What-does-IAM-give-you" class="headerlink" title="What does IAM give you?"></a>What does IAM give you?</h1><ul>
<li><p>Centralized control of your AWS account</p>
</li>
<li><p>Shared Access to your AWS account</p>
<blockquote>
<p>可以分享權限到其他帳號去</p>
</blockquote>
</li>
<li><p>Granular Permissions</p>
<blockquote>
<p>可以針對每個帳號可存取的資源權限進行很細部的控制，例如<strong>限制某人只能對 DynamoDB 進行唯讀的存取</strong></p>
</blockquote>
</li>
<li><p>Identity Federation(including Active Directory, Facebook, Linkedin etc)</p>
<blockquote>
<p>可以透過其他服務(AD, Facebook, Linkedin etc)的帳號透過 SSO 登入 AWS</p>
</blockquote>
</li>
<li><p>Multifactor Authentication</p>
<blockquote>
<p>AWS 建議為每個帳號都設定 multifactor authentication</p>
</blockquote>
</li>
<li><p>Provide temporary access for users/devices and services where necessary</p>
</li>
<li><p>Allows you to set up your own password rotation policy</p>
</li>
<li><p>Integrates with many different AWS services</p>
</li>
<li><p>Supports PCI DSS(Payment Card Industry Data Security Standards) Compliance</p>
<blockquote>
<p>PCI DSS(支付卡產業資料安全標準)是在整合外部付費服務之用，為了提升線上支付的安全性</p>
</blockquote>
</li>
</ul>
<h1 id="Critical-Terms"><a href="#Critical-Terms" class="headerlink" title="Critical Terms"></a>Critical Terms</h1><ul>
<li><p><strong>Users</strong> - End Users(think people)</p>
</li>
<li><p><strong>Group</strong> - A collection of userss under one set of permissions.</p>
<blockquote>
<p>A way to group our users and apply policies to them collectively</p>
</blockquote>
</li>
<li><p><strong>Roles</strong> - You create roles and can then assign them to AWS resources</p>
</li>
<li><p><strong>Policies</strong> - A document that defined one(or more permission)</p>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"Version"</span>: <span class="string">"2012-10-17"</span>,</span><br><span class="line">  <span class="attr">"Statement"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"Effect"</span>: <span class="string">"Allow"</span>,</span><br><span class="line">      <span class="attr">"Action"</span>: <span class="string">"s3:*"</span>,</span><br><span class="line">      <span class="attr">"Resource"</span>: <span class="string">"*"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="學習筆記"><a href="#學習筆記" class="headerlink" title="學習筆記"></a>學習筆記</h1><h2 id="IAM-is-global-universal"><a href="#IAM-is-global-universal" class="headerlink" title="IAM is global(universal)"></a>IAM is global(universal)</h2><p>從 management console 進入 IAM 的功能頁面後，Region 的部份會變成 <code>global</code>，表示 IAM 只需要設定一次，這個設定就可以用來套用到使用者在全球所有 region 中的 resource</p>
<h3 id="IAM-users-sign-in-link"><a href="#IAM-users-sign-in-link" class="headerlink" title="IAM users sign-in link"></a>IAM users sign-in link</h3><p><img src="http://etutorialsworld.com/wp-content/uploads/2016/05/72.22BAWS2BIAM2BDashboard-1.png" alt="IAM users sign-in link"></p>
<ol>
<li><p>這是用來提供給其他使用者存取 AWS resource 之用，並非 root account，需要注意一下!</p>
</li>
<li><p>網址是動態產生的，可以透過 <strong>Customize</strong> 的 link 設定別名以方便記憶</p>
</li>
</ol>
<h2 id="Security-Status"><a href="#Security-Status" class="headerlink" title="Security Status"></a>Security Status</h2><h3 id="1-Delete-your-root-access-keys"><a href="#1-Delete-your-root-access-keys" class="headerlink" title="(1) Delete your root access keys"></a>(1) Delete your root access keys</h3><p>AWS 建議儘量不要用 root account 進行資源的存取；正確的作法應該新增使用者，並為使用者設定所需要的資源存取權限。</p>
<p>例如：一開始我在 root account 加了一把 access key，在這個部份就無法 pass 檢查了</p>
<h3 id="2-Activate-MFA-on-your-root-account"><a href="#2-Activate-MFA-on-your-root-account" class="headerlink" title="(2) Activate MFA on your root account"></a>(2) Activate MFA on your root account</h3><p>選擇 <code>A virtual MFA device</code> 作為 MFA device type(Hardware 是要花錢買的)，接著可以選用 <code>Google Authenticator</code> 作為接收驗證碼之用。</p>
<p>在 Google Authenticator 中可以設定很多個要用來作 MFA 的帳號，當然也就可以把 AWS IAM 設定進來。</p>
<p>透過掃描 barcode 的方式，手機上會一直出現 random 的啟用碼(要等一下)，輸入兩個就可以用來啟用 AWS IAM MFA 了。</p>
<h3 id="3-Create-individual-IAM-users"><a href="#3-Create-individual-IAM-users" class="headerlink" title="(3) Create individual IAM users"></a>(3) Create individual IAM users</h3><p>在建立 user 時，有幾點需要注意一下：</p>
<ul>
<li><p><strong>Access type</strong>：勾選 <code>Programmatic access</code> 才可以用這個帳號搭配 AWS API, CLI, SDK …. 等其他開發工具來存取 AWS 的資源；勾選 <code>AWS Management Console access</code> 才可以透過密碼登入的方式進入 AWS Management console</p>
</li>
<li><p>可在此時順便建立 or 指定特定的 group，也可以順便指定 policy 來設定權限</p>
<blockquote>
<p>policy 並非 group 專屬，也可以 attach 到單一 user</p>
</blockquote>
</li>
<li><p>建立完成的 user(若有勾選 <strong>Programmatic access</strong>) 會得到 <code>Access key ID</code> &amp; <code>Secret access key</code>，這是開發用來存取 AWS 資源的程式需要的資訊</p>
</li>
</ul>
<h3 id="4-Use-groups-to-assign-permissions"><a href="#4-Use-groups-to-assign-permissions" class="headerlink" title="(4) Use groups to assign permissions"></a>(4) Use groups to assign permissions</h3><p>目前 AWS 已經提供了很多內建的權限清單可以用，例如：S3 唯讀, Glacier 唯讀….等等，但目前還不確定能不能自訂權限的選項。。</p>
<h3 id="5-Apply-an-IAM-password-policy"><a href="#5-Apply-an-IAM-password-policy" class="headerlink" title="(5) Apply an IAM password policy"></a>(5) Apply an IAM password policy</h3><p>這沒什麼特別，就是設定密碼的規則….(長度, rotation period…等等)</p>
<h2 id="Add-Role"><a href="#Add-Role" class="headerlink" title="Add Role"></a>Add Role</h2><h3 id="1-Role-Type"><a href="#1-Role-Type" class="headerlink" title="(1) Role Type"></a>(1) Role Type</h3><ul>
<li><p><strong>AWS Service Role</strong>: 用來指定 AWS 上面的特定 service</p>
<blockquote>
<p>這可以設定的非常細，例如：只讓 EC2 對 S3 完全存取，無其他 service 的存取權限</p>
</blockquote>
</li>
<li><p><strong>Role for Cross-Account Access</strong>: 可以用來讓特定帳號去存取其他帳號的 management console</p>
</li>
<li><p><strong>Role for Identity Provider Access</strong>: 作 SSO, 整合 FB, Linkedin 帳號時才會用到的部份</p>
</li>
</ul>
<h3 id="2-Attach-Policy"><a href="#2-Attach-Policy" class="headerlink" title="(2) Attach Policy"></a>(2) Attach Policy</h3><h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><ul>
<li><p>IAM is universal. It does not apply to regions at this time.</p>
</li>
<li><p>The <strong>root account</strong> is simplely the account created when first setup your AWS account. It has complete Admin access.</p>
</li>
<li><p>New Users have <strong>NO</strong> permissions when first created.</p>
</li>
<li><p>New Users are assigned <strong>Access Key ID</strong> &amp; <strong>Secrect Access Keys</strong> when first created.</p>
</li>
<li><p>These are not the same as a password, and you cannot use the Access Key ID &amp; Secret Access Key to Login in to the console. You can use this to access AWS via the APIs, SDK and Command Line however.</p>
</li>
<li><p>You only get to view these once. If you lose them, you have to regenerate them. So save them in a secure location.</p>
</li>
<li><p>Always setup Multifactor Authentication on your root account.</p>
</li>
<li><p>You can create and customize your own password rotation policies.</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> AWS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AWS </tag>
            
            <tag> IAM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Linux KVM] Template & Snapshot 的運用]]></title>
      <url>/blog/2017/01/01/KVM/KVM-Template-And-Snapshot/</url>
      <content type="html"><![CDATA[<p>此篇文章介紹如何使用 KVM 中的 template &amp; snapshot 功能</p>
<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>虛擬化技術有些非常吸引人使用的特性，例如：</p>
<ul>
<li><p>Fast Provisioning</p>
</li>
<li><p>Snapshots</p>
</li>
<li><p>不複雜的 backup &amp; recovery 方式</p>
</li>
</ul>
<p>以上這些特性都不是在實體環境上容易實現的，但透過 KVM 中的 template，可以實現 fast provisioning，而透過 snapshot 則可簡單實現 backup &amp; recovery。</p>
<hr>
<h1 id="VM-Templates"><a href="#VM-Templates" class="headerlink" title="VM Templates"></a>VM Templates</h1><p>template 有別於一般的 VM clone，clone 只是從其他 VM 複製成另外一個完整的 VM；而 template 則是可以作為其他 VM 的 master copy，並用來產生很多個 clone</p>
<h2 id="建立-template"><a href="#建立-template" class="headerlink" title="建立 template"></a>建立 template</h2><p>template 是由以存在的 VM 所轉換過來的，因此在建立 template 之前，我們必須先完成以下步驟：</p>
<ol>
<li><p>安裝 &amp; 設定 VM，確認上面已經安裝所需要的所有軟體套件</p>
</li>
<li><p>移除所有系統特定的設定，確保只與此 VM 相關的設定(例如：固定 IP)不會被複製到其他 VM 上</p>
</li>
<li><p>修改 VM 名稱讓其容易辨識，例如以 <strong>template</strong> 作為開頭</p>
</li>
</ol>
<h3 id="1-建立-Centos-Template"><a href="#1-建立-Centos-Template" class="headerlink" title="(1) 建立 Centos Template"></a>(1) 建立 Centos Template</h3><p>要建立 Linux template，必須透過 <code>virt-sysprep</code> 工具的協助。</p>
<p>這工具由 <code>libguestfs-tools-s</code> 套件所提供，可以移除 VM 中系統特定的資訊，以便於轉換成 template 之用；此外也可以客製化 VM，例如加上 SSH Key、加入使用者、設定 Logo …. 等等。</p>
<p>輸入 <code>virt-prep --help</code> 可以知道 virt-sysprep 支援哪些調整選項：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@ocp-kvm-host ~]<span class="comment"># virt-sysprep -help</span></span><br><span class="line">virt-sysprep: reset or unconfigure a virtual machine so clones can be made</span><br><span class="line"></span><br><span class="line"> virt-sysprep [--options] -d domname</span><br><span class="line"></span><br><span class="line"> virt-sysprep [--options] -a disk.img [-a disk.img ...]</span><br><span class="line"></span><br><span class="line">A short summary of the options is given below.  For detailed <span class="built_in">help</span> please</span><br><span class="line"><span class="built_in">read</span> the man page virt-sysprep(1).</span><br><span class="line"></span><br><span class="line">  -a file                             Add disk image file</span><br><span class="line">  --add file                          Add disk image file</span><br><span class="line">  -c uri                              Set libvirt URI</span><br><span class="line">  --chmod PERMISSIONS:FILE            Change the permissions of a file</span><br><span class="line">  --connect uri                       Set libvirt URI</span><br><span class="line">  -d domain                           Set libvirt guest name</span><br><span class="line">  --debug-gc                          Debug GC and memory allocations (internal)</span><br><span class="line">  --delete PATH                       Delete a file or directory</span><br><span class="line">  --domain domain                     Set libvirt guest name</span><br><span class="line">  --dry-run                           Perform a dry run</span><br><span class="line">  --dryrun                            Perform a dry run</span><br><span class="line">  --dump-pod                          Dump POD (internal)</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>
<p>從 help 中的說明可以看出，virt-sysprep 有兩個參數分別是 <code>-d</code> &amp; <code>-a</code>，其中 <code>-d</code> 所處理的對象是 VM，而 <code>-a</code> 所處理的對象則是獨立的 virtual disk。</p>
<p>以下使用對 VM 為範例來操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@ocp-kvm-host ~]<span class="comment"># virsh list --all</span></span><br><span class="line"> Id    Name                           State</span><br><span class="line">----------------------------------------------------</span><br><span class="line"> -     centos7                        shut off</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">[root@ocp-kvm-host ~]<span class="comment"># virt-sysprep -d centos7</span></span><br><span class="line">[   0.0] Examining the guest ...</span><br><span class="line">[  43.0] Performing <span class="string">"abrt-data"</span> ...</span><br><span class="line">[  43.0] Performing <span class="string">"bash-history"</span> ...</span><br><span class="line">........</span><br><span class="line">[  43.0] Performing <span class="string">"udev-persistent-net"</span> ...</span><br><span class="line">[  43.0] Performing <span class="string">"utmp"</span> ...</span><br><span class="line">[  43.0] Performing <span class="string">"yum-uuid"</span> ...</span><br><span class="line">[  43.0] Performing <span class="string">"customize"</span> ...</span><br><span class="line">[  43.0] Setting a random seed</span><br><span class="line">[  43.0] Performing <span class="string">"lvm-uuids"</span> ...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>到此步驟時，VM template 已經準備完成；還有一點更重要的是，<strong>不要再啟動 template VM</strong>，否則將會失去之前 virt-sysprep 所完成的結果，甚至有可能會在使用 thin method(參考下方) 產生 VM 時發生問題 </p>
</blockquote>
<h3 id="2-建立-Windows-Template"><a href="#2-建立-Windows-Template" class="headerlink" title="(2) 建立 Windows Template"></a>(2) 建立 Windows Template</h3><p>要製作 template，可以透過 <code>virt-clone</code> + <code>virt-sysprep</code> 的方式</p>
<p>要透過 template 建立新的 VM，有以下兩種方式可以進行：</p>
<h2 id="透過-template-佈署-VM"><a href="#透過-template-佈署-VM" class="headerlink" title="透過 template 佈署 VM"></a>透過 template 佈署 VM</h2><ol>
<li><p><strong>thin method</strong></p>
<blockquote>
<p>此方式會以 template image 為 base image以 read-only(template VM image) 搭配 copy-on-write(新的 VM) 來處理，所需要的磁碟空間比較小，但需要確保 base image 可以被存取</p>
</blockquote>
</li>
<li><p><strong>clone method</strong></p>
<blockquote>
<p>此方式會完整複製一份 template image 作為 新 VM 的 image，會消耗較多的磁碟空間，但可以完全獨立不依賴原本的 base image</p>
</blockquote>
</li>
</ol>
<hr>
<h1 id="Snapshots"><a href="#Snapshots" class="headerlink" title="Snapshots"></a>Snapshots</h1><p>snapshot 是以檔案為基礎，用來表示 VM 在某個特定時間點的狀態，包含了相關設定檔 &amp; disk 資料；而透過 snapshot，管理者可以隨時將 VM 還原到當時建立 snapshot 時的狀態，而這功能在進行對於 VM 要進行重大變更前時特別好用。</p>
<p>此外，libvirt 還提供了 live snapshot 的功能，可以針對執行中的 VM 進行 snapshot，但這功能不建議使用在 I/O 工作頻繁的 VM 上，建議這類的 VM 還是 shutdown or suspend 之後再來做 snapshot 會較好。</p>
<p>libvirt 支援兩種 snapshop，分別如下：</p>
<h3 id="internal-snapshot"><a href="#internal-snapshot" class="headerlink" title="internal snapshot"></a>internal snapshot</h3><p>internal snapshot 的 snapshot 資訊會存在於同一個 qcow2 檔案中(before/after snapshot bit)，有以下的限制需要注意：</p>
<ul>
<li><p>僅支援 qcow2 format</p>
</li>
<li><p>當建立 snapshot 時，VM 會進入暫停狀態</p>
</li>
<li><p>無法使用在 LVM storage pool 上</p>
</li>
</ul>
<h3 id="external-snapshot"><a href="#external-snapshot" class="headerlink" title="external snapshot"></a>external snapshot</h3><p>external snapshot 是以 copy-on-write 的概念進行的，當 VM 進行 snapshot 後，system disk 就會進入 read-only 的模式，後續 VM guest 新增的資料就會放在 overlay disk image 上，以下有個圖示來說明：</p>
<p><img src="https://github.com/godleon/godleon.github.io/blob/master/_posts/images/2017/KVM-Template-And-Snapshot/copy-on-write_overlay-disk0-image.png?raw=true" alt="copy-on-write overlay disk image"></p>
<p>external snapshot 也有以下特點：</p>
<ol>
<li><p>overlay disk image 的起始大小為 0，最大可以到 original disk 的大小</p>
</li>
<li><p>base disk 可以是任何的格式(例如：raw, qcow2, 或是其他 libvirt 支援的格式)</p>
</li>
<li><p>overlay disk image 一定是 qcow2 格式</p>
</li>
</ol>
<h2 id="VM-Disk-Image-Format"><a href="#VM-Disk-Image-Format" class="headerlink" title="VM Disk Image Format"></a>VM Disk Image Format</h2><p>libvirt 支援很多種不同的 disk foramt，包含 iso, dmg, qcow2, raw, vmdk, vpc … 等等，但與 libvirt 搭配起來運作的最好的是 <strong>raw</strong> &amp; <strong>qcow2</strong> 兩種：</p>
<h3 id="1-raw"><a href="#1-raw" class="headerlink" title="(1) raw"></a>(1) <strong>raw</strong></h3><ul>
<li><p>效能最佳，performace overhead 最低，適合給有高度 I/O 需求的 VM 使用</p>
</li>
<li><p>完全佔據 disk 所指定的空間</p>
</li>
<li><p>沒有 snapshot &amp; compression 的功能</p>
</li>
</ul>
<h3 id="2-qcow2"><a href="#2-qcow2" class="headerlink" title="(2) qcow2"></a>(2) <strong>qcow2</strong></h3><ul>
<li><p>完全以 cloud 架構出發所設計的格式</p>
</li>
<li><p>支援 read-only backing、snapshot、compression、encryption、pre-allocation … 等功能</p>
</li>
</ul>
<h2 id="轉換-Disk-Image-Format"><a href="#轉換-Disk-Image-Format" class="headerlink" title="轉換 Disk Image Format"></a>轉換 Disk Image Format</h2><p>以下介紹如何透過 <code>qemu-img</code> 指令在 <strong>raw</strong> &amp; <strong>qcow2</strong> 之間進行轉換：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># raw -&gt; qcow2</span></span><br><span class="line">$ qemu-img convert -f raw -O qcow2 vm_disk.img vm_disk.qcow2</span><br><span class="line"></span><br><span class="line"><span class="comment"># qcow2 -&gt; raw</span></span><br><span class="line">$ qemu-img convert -f qcow2 -O ram vm_disk.qcow2 vm_disk.img</span><br></pre></td></tr></table></figure>
<h2 id="操作-Internal-Snapshot"><a href="#操作-Internal-Snapshot" class="headerlink" title="操作 Internal Snapshot"></a>操作 Internal Snapshot</h2><h3 id="1-建立-amp-檢視-snapshot"><a href="#1-建立-amp-檢視-snapshot" class="headerlink" title="(1) 建立 &amp; 檢視 snapshot"></a>(1) 建立 &amp; 檢視 snapshot</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">$ virsh snapshot-list rhel7.3</span><br><span class="line"> Name                 Creation Time             State</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 internal snapshot</span></span><br><span class="line">$ virsh snapshot-create rhel7.3</span><br><span class="line">Domain snapshot 1481514143 created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 internal snapshot (使用 snapshot-create-as 搭配 --name, --description 等參數)</span></span><br><span class="line"><span class="comment"># --atomic 可以確保 snapshot 是可以用的 (若是 snapshot 無法使用，建立時就會 fail)</span></span><br><span class="line">$ virsh snapshot-create-as rhel7.3 --name <span class="string">"rhel7.3_snapshot_1"</span> --description <span class="string">"First named snapshot"</span> --atomic</span><br><span class="line">Domain snapshot rhel7.3_snapshot_1 created</span><br><span class="line"></span><br><span class="line">$ virsh snapshot-list rhel7.3</span><br><span class="line"> Name                 Creation Time             State</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"> 1481514143           2016-12-12 11:42:23 +0800 shutoff</span><br><span class="line"> rhel7.3_snapshot_1   2016-12-14 08:32:23 +0800 shutoff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示 snapshot 資訊</span></span><br><span class="line">$ virsh snapshot-info rhel7.3 --snapshotname 1481514143</span><br><span class="line">Name:           1481514143</span><br><span class="line">Domain:         rhel7.3</span><br><span class="line">Current:        no</span><br><span class="line">State:          shutoff</span><br><span class="line">Location:       internal</span><br><span class="line">Parent:         -</span><br><span class="line">Children:       1</span><br><span class="line">Descendants:    1</span><br><span class="line">Metadata:       yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視指定 VM 的 current snapshot 資訊</span></span><br><span class="line">$ virsh snapshot-current rhel7.3</span><br><span class="line">&lt;domainsnapshot&gt;</span><br><span class="line">  &lt;name&gt;rhel7.3_snapshot_1&lt;/name&gt;</span><br><span class="line">  &lt;description&gt;First named snapshot&lt;/description&gt;</span><br><span class="line">  &lt;state&gt;shutoff&lt;/state&gt;</span><br><span class="line">  &lt;parent&gt;</span><br><span class="line">    &lt;name&gt;1481514143&lt;/name&gt;</span><br><span class="line">  &lt;/parent&gt;</span><br><span class="line">  &lt;creationTime&gt;1481675543&lt;/creationTime&gt;</span><br><span class="line">  &lt;memory snapshot=<span class="string">'no'</span>/&gt;</span><br><span class="line">  &lt;disks&gt;</span><br><span class="line">    &lt;disk name=<span class="string">'vda'</span> snapshot=<span class="string">'internal'</span>/&gt;</span><br><span class="line">  &lt;/disks&gt;</span><br><span class="line">  &lt;domain <span class="built_in">type</span>=<span class="string">'kvm'</span>&gt;</span><br><span class="line">    ....</span><br><span class="line">  &lt;/domain&gt;</span><br><span class="line">&lt;/domainsnapshot&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示 snapshot XML 資訊</span></span><br><span class="line">$ virsh snapshot-dumpxml rhel7.3 --snapshotname 1481514143</span><br><span class="line">&lt;domainsnapshot&gt;</span><br><span class="line">  .... 與上面類似</span><br><span class="line">&lt;/domainsnapshot&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示 snapshot 的 parent snapshot (第一個 snapshot 沒有 parent snapshot)</span></span><br><span class="line">$ virsh snapshot-parent rhel7.3 --snapshotname 1481514143</span><br><span class="line">error: snapshot <span class="string">'1481514143'</span> has no parent</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二個 snapshot 就有 parent snapshot 了</span></span><br><span class="line">$ virsh snapshot-parent rhel7.3 --snapshotname rhel7.3_snapshot_1</span><br><span class="line">1481514143</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示每個 snapshot 的 parent</span></span><br><span class="line">$ virsh snapshot-list rhel7.3 --parent</span><br><span class="line"> Name                 Creation Time             State           Parent</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"> 1481514143           2016-12-12 11:42:23 +0800 shutoff         (null)</span><br><span class="line"> rhel7.3_snapshot_1   2016-12-14 08:32:23 +0800 shutoff         1481514143</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以樹狀結構顯示每個 snapshot 的關係</span></span><br><span class="line">$ virsh snapshot-list rhel7.3 --tree</span><br><span class="line">1481514143</span><br><span class="line">  |</span><br><span class="line">  +- rhel7.3_snapshot_1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>若是在 VM 正在 running 的狀態下建立 snapshot，會需要多花一點時間，因為 VM 必須先進入到 <strong>pause</strong> 的狀態，當 snapshot 完成後才會回到 running 的狀態；而這一段時間的長短取決於 VM 當時耗用了多少記憶體，以及當時對記憶體存取的頻繁程度。</p>
</blockquote>
<p>另外還可以透過 <code>qemu-image</code> 工具來查詢 VM image 的狀態：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查詢 image 的狀態</span></span><br><span class="line">$ qemu-img info /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.qcow2 </span><br><span class="line">image: /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.qcow2</span><br><span class="line">file format: qcow2</span><br><span class="line">virtual size: 40G (42949672960 bytes)</span><br><span class="line">disk size: 572M</span><br><span class="line">cluster_size: 65536</span><br><span class="line">Snapshot list:</span><br><span class="line">ID        TAG                 VM SIZE                DATE       VM CLOCK</span><br><span class="line">1         1481514143                0 2016-12-12 11:42:23   00:00:00.000</span><br><span class="line">2         rhel7.3_snapshot_1        0 2016-12-14 08:32:23   00:00:00.000</span><br><span class="line">Format specific information:</span><br><span class="line">    compat: 0.10</span><br><span class="line">    refcount bits: 16</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢查 image 是否有錯誤</span></span><br><span class="line"><span class="comment"># 適合用在 running 過程中建立 snapshot 後，檢查有無錯誤發生</span></span><br><span class="line">$ qemu-img check /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.qcow2 </span><br><span class="line">No errors were found on the image.</span><br><span class="line">19467/655360 = 2.97% allocated, 93.71% fragmented, 90.63% compressed clusters</span><br><span class="line">Image end offset: 599916544</span><br></pre></td></tr></table></figure>
<h3 id="2-透過-snapshot-還原-VM"><a href="#2-透過-snapshot-還原-VM" class="headerlink" title="(2) 透過 snapshot 還原 VM"></a>(2) 透過 snapshot 還原 VM</h3><p>接著介紹如何透過 internal snapshot 還原 VM：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 從指定的 snapshot 還原 VM</span></span><br><span class="line">$ virsh snapshot-revert rhel7.3 --snapshotname rhel7.3_snapshot_1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 從指定的 snapshot 還原 &amp; 自動啟動 VM</span></span><br><span class="line">$ virsh snapshot-revert rhel7.3 --snapshotname rhel7.3_snapshot_1 --running</span><br></pre></td></tr></table></figure>
<h3 id="3-刪除-snapshot"><a href="#3-刪除-snapshot" class="headerlink" title="(3) 刪除 snapshot"></a>(3) 刪除 snapshot</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 刪除指定的 snapshot</span></span><br><span class="line">$ virsh snapshot-delete rhel7.3 1481514143</span><br><span class="line">Domain snapshot 1481514143 deleted</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示目前 snapshot 的狀態</span></span><br><span class="line">[root@ocp-kvm-host ~]<span class="comment"># virsh snapshot-list rhel7.3 --parent</span></span><br><span class="line"> Name                 Creation Time             State           Parent</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"> rhel7.3_snapshot_1   2016-12-14 08:32:23 +0800 shutoff         (null)</span><br></pre></td></tr></table></figure>
<h2 id="操作-External-Snapshot"><a href="#操作-External-Snapshot" class="headerlink" title="操作 External Snapshot"></a>操作 External Snapshot</h2><p>external snapshot 的原理是由 <code>overlay_image</code> &amp; <code>backing_file</code> 兩個所組成；其中 backing file 會變成 read-only，後續使用者針對 VM 的變更都會寫到 overlay_image 中。</p>
<p>而 external snapshot 比較有優勢的地方，在於支援各種不同的 disk image type(raw, qcow, vmdk … etc)，不僅有 qcow2 而已。</p>
<p>但由於目前 virsh 還不完全支援 external snapshot 的操作，這邊就先保留，等到 virsh 可以完整支援 external snapshot 之後再來補。</p>
<h3 id="1-建立-external-snapshot"><a href="#1-建立-external-snapshot" class="headerlink" title="(1) 建立 external snapshot"></a>(1) 建立 external snapshot</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ virsh list</span><br><span class="line"> Id    Name                           State</span><br><span class="line">----------------------------------------------------</span><br><span class="line"> 32    rhel7.3                        running</span><br><span class="line"></span><br><span class="line">$ virsh domblklist rhel7.3 --details</span><br><span class="line">Type       Device     Target     Source</span><br><span class="line">------------------------------------------------</span><br><span class="line">file       disk       vda        /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.qcow2</span><br><span class="line"></span><br><span class="line">$ virsh snapshot-create-as rhel7.3 ext_snapshot1 <span class="string">"first external snapshot"</span> --disk-only --atomic</span><br><span class="line">Domain snapshot ext_snapshot1 created</span><br><span class="line"></span><br><span class="line">$ virsh snapshot-list rhel7.3</span><br><span class="line">Name                 Creation Time             State</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">ext_snapshot1        2016-12-31 21:00:23 +0800 disk-snapshot</span><br><span class="line"></span><br><span class="line">$ virsh snapshot-info rhel7.3 ext_snapshot1</span><br><span class="line">Name:           ext_snapshot1</span><br><span class="line">Domain:         rhel7.3</span><br><span class="line">Current:        yes</span><br><span class="line">State:          disk-snapshot</span><br><span class="line">Location:       external</span><br><span class="line">Parent:         -</span><br><span class="line">Children:       0</span><br><span class="line">Descendants:    0</span><br><span class="line">Metadata:       yes</span><br></pre></td></tr></table></figure>
<p>利用上面的命令就可以建立 VM external snapshot；此外，還有幾點需要注意：</p>
<ol>
<li><p>external snapshot 可以在 VM running 的狀態下建立(若是 disk I/O 頻繁的 VM，建議還是 shutdown 之後再作)</p>
</li>
<li><p><code>--disk-only</code> 表示只針對 disk 作 snapshot</p>
</li>
<li><p><code>--atomic</code> 會確保 snapshot 建立的工作執行成功後會得到一個可用的 snapshot；若是中途發生任何問題，就不會有 snapshot 的產生，也不會對原有的 VM 產生任何異動，藉此確保建立 snapshot 不會損壞原有的 VM</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 檢視目前 VM disk 資訊</span></span><br><span class="line"><span class="comment"># 已經被 external disk 取代了!</span></span><br><span class="line">$ virsh domblklist rhel7.3 --details</span><br><span class="line">Type       Device     Target     Source</span><br><span class="line">------------------------------------------------</span><br><span class="line">file       disk       vda        /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot1</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 可看出原本的 disk 已經變成了 backing file</span></span><br><span class="line">$ qemu-img info /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot1</span><br><span class="line">image: /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot1</span><br><span class="line">file format: qcow2</span><br><span class="line">virtual size: 40G (42949672960 bytes)</span><br><span class="line">disk size: 2.0M</span><br><span class="line">cluster_size: 65536</span><br><span class="line">backing file: /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.qcow2</span><br><span class="line">backing file format: qcow2</span><br><span class="line">Format specific information:</span><br><span class="line">    compat: 1.1</span><br><span class="line">    lazy refcounts: <span class="literal">false</span></span><br><span class="line">    refcount bits: 16</span><br><span class="line">    corrupt: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>從上面可看出，從此刻開始對 VM 的變更將會直接寫入 external snapshot，而原本的 disk image 變成了 backing file。</p>
<p>接著再建立兩個 external snapshot 試試看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ virsh snapshot-create-as rhel7.3 ext_snapshot2 <span class="string">"second external snapshot"</span> --disk-only --atomic</span><br><span class="line">Domain snapshot ext_snapshot2 created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過 "--quiesce" 參數，確保連同記憶體內的資訊都一併進入到 snapshot 中</span></span><br><span class="line">$ virsh snapshot-create-as rhel7.3 ext_snapshot3 <span class="string">"third external snapshot"</span> --disk-only --quiesce</span><br><span class="line">Domain snapshot ext_snapshot3 created</span><br><span class="line"></span><br><span class="line">$ virsh snapshot-list rhel7.3</span><br><span class="line"> Name                 Creation Time             State</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"> ext_snapshot1        2016-12-31 21:00:23 +0800 disk-snapshot</span><br><span class="line"> ext_snapshot2        2016-12-31 22:16:42 +0800 disk-snapshot</span><br><span class="line"> ext_snapshot3        2016-12-31 22:17:53 +0800 disk-snapshot</span><br></pre></td></tr></table></figure>
<p>在第三個 snapshot 中使用了 <code>--quiesce</code> 參數，目的就是要讓尚未寫入 disk(記憶體中的資料) 一併進入到 snapshot 中，這樣就可以確保 snapshot 是最完整的狀態，但要使用這參數必須預先在 VM 上安裝 <code>qemu-guest agent</code> 才可以。</p>
<p>最後，每個 snapshot 的相依性可以使用下列命令觀察：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ qemu-img info --backing-chain /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot3 | grep backing</span><br><span class="line">backing file: /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot2</span><br><span class="line">backing file format: qcow2</span><br><span class="line">backing file: /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot1</span><br><span class="line">backing file format: qcow2</span><br><span class="line">backing file: /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.qcow2</span><br><span class="line">backing file format: qcow2</span><br></pre></td></tr></table></figure>
<h3 id="2-從-external-snapshot-還原"><a href="#2-從-external-snapshot-還原" class="headerlink" title="(2) 從 external snapshot 還原"></a>(2) 從 external snapshot 還原</h3><p>external snapshot 看似不錯，但其實無法透過 virsh 指令直接還原 VM：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ virsh snapshot-revert rhel7.3 --snapshotname <span class="string">"ext_snapshot3"</span></span><br><span class="line">error: unsupported configuration: revert to external snapshot not supported yet</span><br></pre></td></tr></table></figure>
<p>但這並不代表沒辦法從 external snapshot 還原，只是要透過以下步驟來完成：(假設要還原到 <code>ext_snapshot2</code>)</p>
<ol>
<li><p>關閉 VM (<strong>這是必須的!</strong>)</p>
</li>
<li><p>檢查要還原的 external snapshot overlay image 有無損毀</p>
</li>
<li><p>若 snapshot 完整無誤，編輯 VM XML 定義檔，將 boot disk 指向 <code>ext_snapshot2</code></p>
</li>
<li><p>確認 external snapshot image 格式</p>
</li>
<li><p>從 VM XML 定義中移除原本的 disk，改成指定要還原的 <code>ext_snapshot2</code></p>
</li>
<li><p>透過 <code>domblklist</code> 參數確認 VM 使用的 disk 已經指向 ext_snapshot2</p>
</li>
<li><p>重新啟動 VM</p>
</li>
</ol>
<p>以下是實際操作步驟：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 關閉 VM</span></span><br><span class="line">$ virsh shutdown rhel7.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取得 ext_snapshot2 的詳細路徑</span></span><br><span class="line">$ virsh snapshot-dumpxml rhel7.3 --snapshotname ext_snapshot2 | grep ext_snapshot2</span><br><span class="line">  &lt;name&gt;ext_snapshot2&lt;/name&gt;</span><br><span class="line">      &lt;<span class="built_in">source</span> file=<span class="string">'/var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot2'</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先使用 qemu-img 工具檢查 overlay image 有無損毀</span></span><br><span class="line">$ qemu-img check /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot2</span><br><span class="line">No errors were found on the image.</span><br><span class="line">11/655360 = 0.00% allocated, 36.36% fragmented, 0.00% compressed clusters</span><br><span class="line"></span><br><span class="line"><span class="comment"># 確認 overlay image 格式</span></span><br><span class="line">$ qemu-img info /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot2 | grep backing</span><br><span class="line">backing file: /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot1</span><br><span class="line">backing file format: qcow2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除原本的 disk</span></span><br><span class="line">$ virt-xml rhel7.3 --remove-device --disk target=vda</span><br><span class="line">Domain <span class="string">'rhel7.3'</span> defined successfully.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 換上要還原的 ext_snapshot2</span></span><br><span class="line">$ virt-xml rhel7.3 --add-device --disk /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot2,format=qcow2,bus=virtio</span><br><span class="line">Domain <span class="string">'rhel7.3'</span> defined successfully.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 確認目前 VM 所使用的 disk</span></span><br><span class="line">$ virsh domblklist rhel7.3</span><br><span class="line">Target     Source</span><br><span class="line">------------------------------------------------</span><br><span class="line">vda        /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新啟動 VM</span></span><br><span class="line">$ virsh start rhel7.3</span><br><span class="line">Domain rhel7.3 started</span><br></pre></td></tr></table></figure>
<h3 id="3-刪除-external-snapshot"><a href="#3-刪除-external-snapshot" class="headerlink" title="(3) 刪除 external snapshot"></a>(3) 刪除 external snapshot</h3><p>由於 virsh 不支援 external snapshot 的刪除，所以刪除 snapshot 就必須自己來了!</p>
<p>假設要移除所有的 snapshot，但又想要保留在 snapshot 上完整的變更，此時必須把 snapshot merge 到 base image 上，以下是操作步驟：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 目前 disk 所使用的 snapshot</span></span><br><span class="line">$ virsh domblklist rhel7.3</span><br><span class="line">Target     Source</span><br><span class="line">------------------------------------------------</span><br><span class="line">vda        /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢 snapshot overlay image 的相依關係</span></span><br><span class="line">$ qemu-img info --backing-chain /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot2 | grep backing</span><br><span class="line">backing file: /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot1</span><br><span class="line">backing file format: qcow2</span><br><span class="line">backing file: /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.qcow2</span><br><span class="line">backing file format: qcow2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將 base image &amp; snapshot overlay image 合併!</span></span><br><span class="line">$ virsh blockcommit rhel7.3 vda --verbose --pivot --active</span><br><span class="line">Block commit: [100 %]</span><br><span class="line">Successfully pivoted</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可看出 VM disk 已經變成 base image</span></span><br><span class="line">$ virsh domblklist rhel7.3</span><br><span class="line">Target     Source</span><br><span class="line">------------------------------------------------</span><br><span class="line">vda        /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.qcow2</span><br><span class="line"></span><br><span class="line">$ virsh snapshot-list rhel7.3</span><br><span class="line"> Name                 Creation Time             State</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"> ext_snapshot1        2016-12-31 21:00:23 +0800 disk-snapshot</span><br><span class="line"> ext_snapshot2        2016-12-31 22:16:42 +0800 disk-snapshot</span><br><span class="line"> ext_snapshot3        2016-12-31 22:17:53 +0800 disk-snapshot</span><br></pre></td></tr></table></figure>
<p>確認好 VM disk 已經不是指向 external snapshot 了，就可以開始進行刪除 snapshot 的動作，而刪除 external snapshot 必須從 metadata 下手，以下為操作範例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定刪除從 ext_snapshot1 開始的所有 children snapshot 的 metadata &amp; image</span></span><br><span class="line">$ virsh snapshot-delete rhel7.3 ext_snapshot1 --children --metadata</span><br><span class="line">Domain snapshot ext_snapshot1 deleted</span><br><span class="line"></span><br><span class="line"><span class="comment"># 確認所有 external snapshot 都已經被刪除</span></span><br><span class="line">$ virsh snapshot-list rhel7.3</span><br><span class="line"> Name                 Creation Time             State</span><br><span class="line">------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<h2 id="使用-snapshot-時所需的正確觀念"><a href="#使用-snapshot-時所需的正確觀念" class="headerlink" title="使用 snapshot 時所需的正確觀念"></a>使用 snapshot 時所需的正確觀念</h2><ol>
<li><p>不建議在 production 的環境中讓 VM 去 attach 之前做好的 snapshot 來使用</p>
</li>
<li><p>不要把 snapshot 當作是備份的方式，只是用來留下當時 VM 的狀態做後續使用而已</p>
</li>
<li><p>snapshot 不要保留太久，若確定不需要的就把 snapshot commit(for external snapshot) or 刪除</p>
</li>
<li><p>external snapshot 出現故障的機率比 internal snapshot 還低，因此建議優先使用 external snapshot</p>
</li>
<li><p>snapshot 數量要控制，太多的 snapshot 可能會倒置系統效能低落</p>
</li>
<li><p>建立 snapshot 前要先安裝 guest agent</p>
</li>
<li><p>建立 snapshot 確認都有帶上 <code>--quiesce</code> &amp;&amp; <code>--atomic</code> 兩個參數</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> KVM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> KVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Linux KVM] VM Life Cycle 管理]]></title>
      <url>/blog/2016/11/30/KVM/KVM-Lifecycle-Management/</url>
      <content type="html"><![CDATA[<p>此篇文章將會介紹 VM 生命周期管理、Qemu Guest Agent、Virtual Video Card、Graphic Server … 等主題。</p>
<h1 id="VM-Lifecycle"><a href="#VM-Lifecycle" class="headerlink" title="VM Lifecycle"></a>VM Lifecycle</h1><p>在 KVM 中的 virtual machine 共會有以下幾種狀態：</p>
<ul>
<li><p><strong>Undefined</strong>：未定義</p>
</li>
<li><p><strong>Defined / Shutoff</strong>：已定義，libvirtd 已經知道有此 VM 存在，但狀態為關機中(Stopped or Shutdown)</p>
</li>
<li><p><strong>Running</strong>：執行中</p>
</li>
<li><p><strong>Shutdown</strong>：關機中</p>
</li>
<li><p><strong>Paused</strong>：暫停中，VM 記憶體中的資料暫時被保留，並且可以在 guest OS 無法知悉的狀況下回復</p>
</li>
<li><p><strong>Saved</strong>：VM 處於完全暫停的狀態，記憶體中的資料被存到一般檔案中，並存在於 persistent storage (可回復到進行 save 時的狀態)</p>
</li>
<li><p><strong>Idle</strong>：等待 I/O，或是因為沒有工作需要進行而休眠中</p>
</li>
<li><p><strong>Crashed</strong>：可能因為 QEMU process 被強制移除 or core dump 所造成的 VM 損毀</p>
</li>
<li><p><strong>Dying</strong>：在 shutdown 的過程中失敗所產生的況狀</p>
</li>
<li><p><strong>Pmsuspended</strong>：透過 guest OS 中的電源管理功能進行 suspend 後進入的狀態</p>
</li>
</ul>
<p>有了上面概念後，可以透過 virsh 來檢視目前 domain(virtual machine) 的狀態：</p>
<hr>
<h1 id="檢視-VM"><a href="#檢視-VM" class="headerlink" title="檢視 VM"></a>檢視 VM</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 顯示所有 VM (包含關機中的)</span></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.3/system list --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示特定狀態的 VM</span></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.3/system list --state-[running|paused|shutoff|]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示(未)包含 snapshot 的 VM</span></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.3/system list --[with|without]-snapshot</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示(未)包含 managed save 狀態的 VM</span></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.3/system list --[with|without]-managed-save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 僅顯示 uuid or name</span></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.3/system list --[uuid|name]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>還有許多其他參數可用，使用者可透過 <code>virsh help</code> or <code>virsh help list</code> 來查詢更多使用方式</p>
</blockquote>
<hr>
<h1 id="操作-VM"><a href="#操作-VM" class="headerlink" title="操作 VM"></a>操作 VM</h1><p>了解 VM 有這麼多狀態之後，自然就會有相對應的操作了，virsh 提供以下幾項對 VM 的操作：</p>
<ul>
<li><p><strong>start</strong>：啟動 VM</p>
</li>
<li><p><strong>shutdown</strong>：關閉 VM (正常關機程序)</p>
</li>
<li><p><strong>reboot</strong>：重新啟動 VM</p>
</li>
<li><p><strong>reset</strong>：與 power cycle 相同效果</p>
</li>
<li><p><strong>save</strong>：將 VM 狀態儲存到檔案中，並關閉 VM</p>
</li>
<li><p><strong>restore</strong>：從指定的檔案將 VM 狀態回復為執行中</p>
</li>
<li><p><strong>suspend</strong>：暫停 VM 運作</p>
</li>
<li><p><strong>resume</strong>：回復 VM 運作</p>
</li>
<li><p><strong>destroy</strong>：直接刪除 QEMU process (類似直接拔掉電腦電源線的效果)</p>
</li>
<li><p><strong>create</strong>：使用指定的 XML 建立 VM，並啟動 VM</p>
</li>
<li><p><strong>define</strong>：使用指定的 XML 建立 VM，但不啟動 VM</p>
</li>
<li><p><strong>undefine</strong>：將 VM 從 libvird 的控制中移除</p>
</li>
</ul>
<hr>
<h1 id="QEMU-guest-agent"><a href="#QEMU-guest-agent" class="headerlink" title="QEMU guest agent"></a>QEMU guest agent</h1><p>在安裝 virtualbox or VMware 的 VM 時，安裝結束之後都會詢問要不要額外安裝 agent 在 guest VM 中，透過這個 agent，hypervisor 可以更有效率的管理每一個 VM；同樣的在 KVM 中，也是有相同的作法，稱為 <strong>QEMU guest agent</strong>。</p>
<p><strong>QEMU guest agent</strong> 是一個裝在 guest VM 中的套件，會以 service 的形式存在於背景，接著 service 就變成了 hypervisor &amp; guest OS 之間溝通的橋樑(channel)，hypervisor 會透過這個 channle 取得 VM 的資訊，以及對 VM 進行後續更多的操作；而兩者相互通訊的協定稱為 <strong>Qemu Machine Protocol(QMP)</strong>。</p>
<p>其中 Hypervisor 與 guest agent 是透過一個名稱為 <code>org.qemu.guest_agent.0</code> 的 virtio-serial channel 或是 isa-serial channel 來處理；而在 Hypervisor 這一端，相對應處理這些資訊交換的 socket file 則是存在於 <code>/var/lib/libvirt/qemu/channel/target</code> 目錄中，且同一個 socket file 可以同時被多個 VM 所共享，因此不會產生太多檔案。</p>
<p>若 guest VM 為 Linux，可安裝名稱為 <code>qemu-guest-agent</code> 的套件，若是 windows，則可以參考以下連結：</p>
<ul>
<li><p><a href="http://www.linux-kvm.org/page/WindowsGuestDrivers/Download_Drivers" target="_blank" rel="noopener">WindowsGuestDrivers/Download Drivers - KVM</a></p>
</li>
<li><p><a href="https://fedoraproject.org/wiki/Windows_Virtio_Drivers" target="_blank" rel="noopener">Windows Virtio Drivers - FedoraProject</a></p>
</li>
</ul>
<p>除了安裝 <code>qemu-guest-agent</code> 套件之外，還要確認 <code>qemu-guest-agent</code> service 是否有正確啟動：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl status qemu-guest-agent</span><br><span class="line">● qemu-guest-agent.service - QEMU Guest Agent</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/qemu-guest-agent.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Thu 2016-11-24 22:25:07 EST; 35min ago</span><br><span class="line">   ......</span><br></pre></td></tr></table></figure>
<p>確認服務沒有問題，我們就可以使用類似以下的命令在 KVM host 端取得 guest VM 的相關資訊：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ virsh qemu-agent-command &lt;GUEST_VM_NAME&gt; <span class="string">'&#123;"execute": "guest-info"&#125;'</span> --pretty</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"return"</span>: &#123;</span><br><span class="line">        <span class="string">"version"</span>: <span class="string">"2.3.0"</span>,</span><br><span class="line">        <span class="string">"supported_commands"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"enabled"</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">"name"</span>: <span class="string">"guest-get-memory-block-info"</span>,</span><br><span class="line">                <span class="string">"success-response"</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">.......</span><br></pre></td></tr></table></figure>
<blockquote>
<p>QMP 資料通訊使用 JSON format</p>
</blockquote>
<hr>
<h1 id="Virtual-Video-cards-amp-graphics"><a href="#Virtual-Video-cards-amp-graphics" class="headerlink" title="Virtual Video cards &amp; graphics"></a>Virtual Video cards &amp; graphics</h1><p>為了可以”看見” VM 的運作狀態，QEMU 需要提供兩個元素來達成這件任務：</p>
<ol>
<li><p><strong>virtual video card</strong>：讓每個 VM 都擁有一張虛擬的顯示卡</p>
</li>
<li><p>從遠端存取 VM 虛擬顯示卡的方式 or 協定</p>
</li>
</ol>
<h2 id="Virtual-Video-Card"><a href="#Virtual-Video-Card" class="headerlink" title="Virtual Video Card"></a>Virtual Video Card</h2><p>顯示卡的用途在於顯示圖形資料到顯示設備上，而虛擬顯示卡同樣也是為了這個目的而存在的。</p>
<p>然而在虛擬環境中當然沒有實體顯示卡，因此 QEMU 支援模擬以下幾種顯示卡：</p>
<ul>
<li><p><strong>Cirrus</strong>：libvirt 預設的顯示卡，可模擬 <strong>Cirrus Logic GD5446</strong> 顯示卡，Windows 95 之後的作業系統都支援這張顯示卡</p>
</li>
<li><p><strong>VGA</strong>：搭配 Bochs VBE extensions 的標準顯示卡，Windows XP 以後的作業系統可以支援(可設定 &gt;= 1280x1024x16 解析度 &amp; 大小的畫質)</p>
</li>
<li><p><strong>VMVGA</strong>：在 VGA 再更高階的虛擬顯示卡</p>
</li>
<li><p><strong>QXL</strong>：半虛擬化顯示卡，搭配在 VM 內安裝 QXL guest driver，可得到很不錯的顯示效果，而且是搭配 <strong>spice</strong> protocol 的最佳選擇</p>
</li>
</ul>
<p>在安裝 VM 時，libvirt 就會根據安裝的 OS，協助選擇一個最合適的顯示卡，通常安裝最近發佈的 OS，都會直接選配 QXL；若是 Windows 或是比較舊版的 Linux，可能就會使用 Cirrus。</p>
<h2 id="Graphics"><a href="#Graphics" class="headerlink" title="Graphics"></a>Graphics</h2><p>當 VM 有了顯示卡之後，接著需要一個可以存取圖形訊號的方法，在 KVM 中是透過 <strong>graphic server</strong> 的方式，目前提供了 <strong>VNC</strong> &amp; <em>*SPICE</em> 兩種 graphic server。</p>
<p>當 VM 確定好顯示卡之後，QEMU 就會啟動相對應的 Spice or VNC server，並與 VM 的顯示卡進行連接，以便讓外部的 client 可以使用圖形化的方式存取 VM。</p>
<h3 id="1-VNC"><a href="#1-VNC" class="headerlink" title="(1) VNC"></a>(1) VNC</h3><p>要為 VM 設定一個 VNC graphic server，可在 XML 定義檔中的 <code>&lt;device&gt;</code> section 內部加入類似以下的定義：(IP &amp; port 都可以自己定義)</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">graphics</span> <span class="attr">type</span>=<span class="string">'vnc'</span> <span class="attr">port</span>=<span class="string">'-1'</span> <span class="attr">autoport</span>=<span class="string">'yes'</span> <span class="attr">listen</span>=<span class="string">'192.168.122.1'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listen</span> <span class="attr">type</span>=<span class="string">'address'</span> <span class="attr">address</span>=<span class="string">'192.168.122.1'</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">graphics</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-SPICE"><a href="#2-SPICE" class="headerlink" title="(2) SPICE"></a>(2) SPICE</h3><p>SPICE(Simple Protocol for Independent Computing Environment) 僅有在 Linux 上支援，有以下特色：</p>
<ol>
<li><p>可以提供雙向的 audio</p>
</li>
<li><p>高效率的 2D 圖像繪製能力</p>
</li>
<li><p>可利用到 client 端的顯示卡的能力</p>
</li>
<li><p>支援加密、資料壓縮</p>
</li>
<li><p>支援透過網路的 USB passthrough</p>
</li>
</ol>
<p>因此若要規劃把 KVM 用在 VDI 的應用上，使用 <code>QXL</code> + <code>SPICE</code> 目前是最好的組合。</p>
<p>要為 VM 設定一個 SPICE graphic server，可在 XML 定義檔中的 <code>&lt;device&gt;</code> section 內部加入類似以下的定義：(IP &amp; port 都可以自己定義)</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">graphics</span> <span class="attr">type</span>=<span class="string">'spice'</span> <span class="attr">autoport</span>=<span class="string">'yes'</span> <span class="attr">listen</span>=<span class="string">'0.0.0.0'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listen</span> <span class="attr">type</span>=<span class="string">'address'</span> <span class="attr">address</span>=<span class="string">'0.0.0.0'</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">graphics</span>&gt;</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><p><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Virtualization_Administration_Guide/sect-QEMU_Guest_Agent-Running_the_QEMU_guest_agent_on_a_Windows_guest.html" target="_blank" rel="noopener">Virtualization Administration Guide &gt; Running the QEMU Guest Agent on a Windows Guest</a></p>
</li>
<li><p><a href="http://www.linux-kvm.org/page/WindowsGuestDrivers/Download_Drivers" target="_blank" rel="noopener">WindowsGuestDrivers/Download Drivers - KVM</a></p>
</li>
<li><p><a href="https://fedoraproject.org/wiki/Windows_Virtio_Drivers" target="_blank" rel="noopener">Windows Virtio Drivers - FedoraProject</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> KVM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> KVM </tag>
            
            <tag> SPICE </tag>
            
            <tag> VNC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Git] Cheat Sheet]]></title>
      <url>/blog/2016/11/08/Git/Git-Cheat-Sheets/</url>
      <content type="html"><![CDATA[<h1 id="The-Basics"><a href="#The-Basics" class="headerlink" title="The Basics"></a>The Basics</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a Git repository in the current folder.</span></span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># View the status of each file in a repository.</span></span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># Stage a file for the next commit.</span></span><br><span class="line">$ git add &lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Commit the staged files with a descriptive message.</span></span><br><span class="line">$ git commit</span><br><span class="line"></span><br><span class="line"><span class="comment"># View a repository’s commit history.</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以單行的方式顯示 git log (commit log)</span></span><br><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以單行的方式顯示與指定檔案相關的 git log</span></span><br><span class="line">$ git <span class="built_in">log</span> --oneline &lt;file_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 詳細列出所有 commit 的歷史紀錄</span></span><br><span class="line">$ git <span class="built_in">log</span> --graph --abbrev-commit --decorate --date=relative --all</span><br><span class="line">    </span><br><span class="line"><span class="comment"># Define the author name to be used in all repositories.</span></span><br><span class="line">$ git config --global user.name <span class="string">"&lt;name&gt;"</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># Define the author email to be used in all repositories. </span></span><br><span class="line">$ git config --global user.email &lt;email&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Undoing-Changes"><a href="#Undoing-Changes" class="headerlink" title="Undoing Changes"></a>Undoing Changes</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 將 HEAD 指標移到指定的 commit or tag(sha1_checksum_prefix 可由 "git log --oneline" 取得)</span></span><br><span class="line"><span class="comment"># 若 git log 沒有加上 "--all" 參數，就會看不到比 HEAD 更新的 commit snapshot</span></span><br><span class="line">$ git checkout &lt;commit-id | tag-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回到最新的 commit 紀錄("master" 會固定指向最新一筆 commit snapshot)</span></span><br><span class="line">$ git checkout master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 為目前最新的 commit 加上一個 annotated tag (通常 tag 用來作為正式 release 的標記用途)</span></span><br><span class="line">$ git tag -a &lt;tag-name&gt; -m <span class="string">"&lt;description&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出目前所有的 tag 紀錄</span></span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># undo 指定的 commit (重要! 這並非是回到特定 commit 的概念)</span></span><br><span class="line"><span class="comment"># 即使 commit 被 undo，其實歷史紀錄還是永遠保留著，這是 git 的特性</span></span><br><span class="line">$ git revert &lt;commit-id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消所有 tracked 的變更，回到最新的 commit (但不包含 untracked 的部分，例如：新增的檔案)</span></span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除 untracked files (與上一個指令搭配使用，此時應該回復到一個乾淨的 working directory，亦即為最新的 commit snapshot)</span></span><br><span class="line">$ git clean -f</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意 <code>git reset --hard</code> + <code>git clean -f</code> 的使用，是在 working directory 上生效，並不是在 commit snapshot 上，因此一旦 undo 之後，所有尚未 commit 的變更都會完全消失且無法追溯，請確定真的不要這些變更之後，再執行這兩個指令</p>
</blockquote>
<hr>
<h1 id="Branches"><a href="#Branches" class="headerlink" title="Branches"></a>Branches</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 顯示所有的 branch (星號的部分表示目前所在的 branch)</span></span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用目前的 working directory 作為基礎，新增 branch</span></span><br><span class="line">$ git branch &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將 HEAD 指標以及 working directory 移到指定的 branch</span></span><br><span class="line">$ git checkout &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將指定的 branch 與目前所在的 branch(checked-out) 做合併</span></span><br><span class="line">$ git merge &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刪除指定的 branch</span></span><br><span class="line">$ git branch -d &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 強制刪除尚未合併的 branch (將會永遠遺失所有的檔案變更)</span></span><br><span class="line">$ git branch -D &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 從 working directory 中移除 &amp; 停止追蹤指定的檔案</span></span><br><span class="line">$ git rm &lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改檔案名稱</span></span><br><span class="line">$ git mv &lt;old-filename&gt; &lt;new-filename&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用一行指令直接 commit 所有狀態為 tracked 的檔案，並指定 commit 內容</span></span><br><span class="line">$ git commit -a -m <span class="string">"&lt;message&gt;"</span></span><br></pre></td></tr></table></figure>
<p>以下 <strong>master</strong> branch 合併 <strong>css</strong> branch 的狀況稱為 <code>fast-forward merge</code>：</p>
<p><img src="http://rypress.com/tutorials/git/media/3-10.png" alt="fast-forward merge"></p>
<blockquote>
<p>因為 css branch 是從 master branch 中最新的 commit snapshot 所延伸出來，所以 master branch 合併 css branch 是不需要做什麼額外的判斷處理</p>
</blockquote>
<p>使用 branch 的基本原則：</p>
<ol>
<li><p>為每一個主要的新增功能，都使用 branch 的方式來完成</p>
</li>
<li><p>若無法為 branch 取一個實際的名稱(無法定義修改的內容為何)，就不要使用 branch</p>
</li>
</ol>
<p>!3-way merge](<a href="http://rypress.com/tutorials/git/media/4-1.png" target="_blank" rel="noopener">http://rypress.com/tutorials/git/media/4-1.png</a>)</p>
<blockquote>
<p>3-way merge 在當要合併兩個擁有不同 commit snapshot 時會發生，此時 Git 會額外建立一個 merge commit snapshot，並同時指向兩個不同的 branch(如上圖中的 <strong>After</strong>，紅色圈圈表示這個 commit snapshot 同時來自 crazy &amp; master 兩個 branch)</p>
<p>fast-forward merge 不會在 project history 中看到，這是與 3-way merge 不同的地方</p>
</blockquote>
<hr>
<h1 id="Rebasing"><a href="#Rebasing" class="headerlink" title="Rebasing"></a>Rebasing</h1><p>當整個 git 專案越來越多 branch 時，可以透過 rebase 的方式來整理 branch，避免過於凌亂；此外，rebase 也有在不進行 merge 的情況下，取得最新版 master 的效果。</p>
<p>透過 rebase 可以把 branch 指向指定 branch 的最新 commit snapshot；舉例來說，可將多餘的 branch 重新 rebase 後指向 master 最新的 commit snapshot，如此一來後續進行 merge 時就會變成 <strong>fast-forward merge</strong>，相關的 commit snapshot 都變成了 linear history，這樣在後續檢視上會更為直覺。</p>
<blockquote>
<p>rebase 雖然可以讓整體專案的 branch 更為簡潔易讀，但在某些 rebase 操作上會移除(or 修改)某些 commit snapshot，因此後續就會無法還原當初 commit snapshot 的全貌，這也是 rebase 功能有所爭議的地方</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 檢視 branch-feature 是否有落後 branch-dev，有顯示 commit snapshot 則表示落後，可考慮進行 rebase</span></span><br><span class="line">$ git <span class="built_in">log</span> &lt;branch-feature&gt;..&lt;branch-dev&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將目前的 branch 的 root commit snapshot 指向 new-base 最新的 commit snapshot</span></span><br><span class="line">$ git rebase &lt;new-base&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以互動的方式進行 rebse 的設定，並可選擇對每個 commit snapshot 所要執行的動作</span></span><br><span class="line">$ git rebase -i &lt;new-base&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改已經存在的 commit snapshot，不產生新的 (搭配上面 rebase 編輯 commit snapshop list 時使用 edit/squash 等關鍵是)</span></span><br><span class="line">$ git commit --amend</span><br><span class="line"></span><br><span class="line"><span class="comment"># 完成修改了特定的 commit snapshot 資訊後，繼續進行 rebase 工作</span></span><br><span class="line">$ git rebase --<span class="built_in">continue</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 放棄目前的 rebase 結果並回到原先的狀態</span></span><br><span class="line">git rebase --abort</span><br><span class="line"></span><br><span class="line"><span class="comment"># 強制 git 不以 fast-forward 的方式進行 merge，藉此保留 branch 的相關資訊</span></span><br><span class="line">git merge --no-ff &lt;branch-name&gt;</span><br></pre></td></tr></table></figure>
<p>以下用圖說明執行 <code>git merge</code> 指令時有無加上 <code>--no-ff</code> 參數所產生的效果：</p>
<p><img src="https://i0.wp.com/farm6.static.flickr.com/5054/5488984566_359f74ecc2.jpg?resize=463%2C414&amp;ssl=1" alt="git merge"></p>
<hr>
<h1 id="Rewriting-History"><a href="#Rewriting-History" class="headerlink" title="Rewriting History"></a>Rewriting History</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 顯示本地端所有的 commit snapshot (以時間排序，包含已經被 reset 的 commit snapshot)</span></span><br><span class="line">$ git reflog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將 HEAD 指標往前移到第 n 的 commit snapshot，但不變更 working directory 中的內容</span></span><br><span class="line"><span class="comment"># 比 HEAD~&lt;n&gt; 還新的 commit snapshot 中的變更會保留</span></span><br><span class="line">$ git reset --mixed HEAD~&lt;n&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將 HEAD 指標往前移到第 n 的 commit snapshot，但會變更 working directory 中的內容</span></span><br><span class="line"><span class="comment"># 比 HEAD~&lt;n&gt; 還新的 commit snapshot 中的變更會被移除</span></span><br><span class="line">$ git reset --hard HEAD~&lt;n&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示從 &lt;since&gt; &amp; &lt;until&gt; 兩個 branch 之間的 commit snapshot 紀錄</span></span><br><span class="line">$ git <span class="built_in">log</span> &lt;since&gt;..&lt;until&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 git log 顯示訊息中額外包含被修改的檔案資訊</span></span><br><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Remotes"><a href="#Remotes" class="headerlink" title="Remotes"></a>Remotes</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 從遠端複製指定的 Git repository 回來</span></span><br><span class="line">$ git <span class="built_in">clone</span> &lt;remote-path&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出 remote repository 列表(若加上 -v 參數會顯示每個 remote repository 的詳細位址)</span></span><br><span class="line">$ git remote</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增一筆 remote repository 記錄</span></span><br><span class="line">$ git remote add &lt;remote-name&gt; &lt;remote-path&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取得 remote repository 的指定 branch (不進行 merge)</span></span><br><span class="line">$ git fetch &lt;remote-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># merge 指定的 remote repository branch 到目前所在的 branch</span></span><br><span class="line">$ git merge &lt;remote-name&gt;/&lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出 remote repository branch</span></span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將 local repository branch 推送到 remote repository branch 進行更新</span></span><br><span class="line">$ git push &lt;remote-name&gt; &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 為 remote repository 加上一個 tag</span></span><br><span class="line">$ git push &lt;remote-name&gt; &lt;tag-name&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Centralized-Workflows"><a href="#Centralized-Workflows" class="headerlink" title="Centralized Workflows"></a>Centralized Workflows</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立 git repository，但沒有 working directory (只是用來存放檔案用)</span></span><br><span class="line">$ git init --bare &lt;repository-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除 remote connection</span></span><br><span class="line">$ git remote rm &lt;remote-name&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Patch-Workflows"><a href="#Patch-Workflows" class="headerlink" title="Patch Workflows"></a>Patch Workflows</h1><p><img src="http://rypress.com/tutorials/git/media/10-2.png" alt="patch workflows"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立 patch，包含了目前所在的 branch 有的，卻沒有在 &lt;branch-name&gt; branch 出現的 commit snapshot</span></span><br><span class="line">$ git format-patch &lt;branch-name&gt;</span><br><span class="line">    Create a patch <span class="keyword">for</span> each commit contained <span class="keyword">in</span> the current branch but not <span class="keyword">in</span> &lt;branch-name&gt;. You can also specify a commit ID instead of &lt;branch-name&gt;.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 套用  patch 到目前的 branch</span></span><br><span class="line">$ git am &lt; &lt;patch-file&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Tips-amp-Tricks"><a href="#Tips-amp-Tricks" class="headerlink" title="Tips &amp; Tricks"></a>Tips &amp; Tricks</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 備份目前的 branch，但只留下最新的一筆 commit snapshot</span></span><br><span class="line">$ git archive &lt;branch-name&gt; --format=zip --output=&lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 完整匯出指定的 branch 到指定檔案(會包含所有 commit snapshot 記錄)</span></span><br><span class="line">$ git bundle create &lt;file&gt; &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過 bundled repository 重新建立一個 repository 並 checkout 指定的 branch</span></span><br><span class="line">$ git <span class="built_in">clone</span> repo.bundle &lt;repo-dir&gt; -b &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暫時將變更隱藏，將目前的目錄變為乾淨的 working directory</span></span><br><span class="line">$ git stash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將隱藏的變更套用到 working directory</span></span><br><span class="line">$ git stash apply</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視兩個 commit snapshot 之間的差異</span></span><br><span class="line">$ git diff &lt;commit-id&gt;..&lt;commit-id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視目前 working directory 與 staging area 的差異</span></span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視目前 staging area 與最新一筆 commit snapshot 之間的差異</span></span><br><span class="line">$ git diff --cached</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將指令檔案從 commit snapshot 中移到 staged snapshot 中</span></span><br><span class="line">$ git reset HEAD &lt;file&gt;</span><br><span class="line">    Unstage a file, but don’t alter the working directory or move the current branch.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 從指定的 commit snapshot 中取得指定檔案</span></span><br><span class="line">$ git checkout &lt;commit-id&gt; &lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定 git command alias</span></span><br><span class="line">$ git config --global <span class="built_in">alias</span>.&lt;<span class="built_in">alias</span>-name&gt; &lt;git-command&gt;</span><br></pre></td></tr></table></figure>
<p><strong>git reset</strong>：<br><img src="http://rypress.com/tutorials/git/media/11-1.png" alt="git reset"></p>
<p><strong>git checkout</strong>：<br><img src="http://rypress.com/tutorials/git/media/11-2.png" alt="git checkout"></p>
<hr>
<h1 id="Plumbing"><a href="#Plumbing" class="headerlink" title="Plumbing"></a>Plumbing</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 顯示指定的 object 內容(其中 &lt;type&gt; 可以是 commit / tree / blob / tag)</span></span><br><span class="line">$ git cat-file &lt;<span class="built_in">type</span>&gt; &lt;object-id&gt;</span><br></pre></td></tr></table></figure>
<p><img src="http://rypress.com/tutorials/git/media/12-1.png" alt="commit and tree objects"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查詢指定的 object id 是屬於哪種 type</span></span><br><span class="line">$ git cat-file -t &lt;object-id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出指定 tree 物件的內容</span></span><br><span class="line">$ git ls-tree &lt;tree-id&gt;</span><br><span class="line">040000 tree 5aa02e7f90df11621262d7fe91a9357bb44494aa	about</span><br><span class="line">100644 blob 4838a99c7bb4cc75941ff0a5e3a05fe4889570f9	blue.html</span><br><span class="line">.......</span><br><span class="line">100644 blob c9d942d8aadb84617d78455f8e2da25866c079a2	style.css</span><br><span class="line">100644 blob e9d1781fd949fd41d2439ae3824a293531bc38a5	yellow.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示指定 object id(這裡指的是 blob 物件) 的內容</span></span><br><span class="line">$ git cat-file blob e9d178</span><br></pre></td></tr></table></figure>
<p><img src="http://rypress.com/tutorials/git/media/12-2.png" alt="commit, tree, and blob objects"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 對 git object database 進行 garbage collection </span></span><br><span class="line">$ git gc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將指定的檔案從 working directory 移到 staged area (新增的檔案要額外加上 --add 參數)</span></span><br><span class="line">$ git update-index [--add] &lt;file&gt;</span><br><span class="line">    Stage the specified file, using the optional --add flag to denote a new untracked file.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 從目前的 index 中產生一個 tree 物件，並存入 object database 中</span></span><br><span class="line">$ git write-tree</span><br><span class="line"></span><br><span class="line"><span class="comment"># 從指定的 tree object &amp; parent commit 中產生一個新的 commit 物件</span></span><br><span class="line">$ git commit-tree &lt;tree-id&gt; -p &lt;parent-id&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><p><a href="http://rypress.com/tutorials/git/index" target="_blank" rel="noopener">Ry’s Git Tutorial - RyPress</a></p>
</li>
<li><p><a href="https://blog.yorkxin.org/2011/07/29/git-rebase" target="_blank" rel="noopener">Git-rebase 小筆記 - Yu-Cheng Chuang’s Blog</a></p>
</li>
<li><p><a href="https://blog.wu-boy.com/2011/03/git-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6-branch-model-%E5%88%86%E6%94%AF%E6%A8%A1%E7%B5%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%B4%B9/" target="_blank" rel="noopener">Git 版本控制 branch model 分支模組基本介紹 | 小惡魔 - 電腦技術 - 工作筆記 - AppleBOY</a></p>
</li>
<li><p><a href="http://hungyuhei.github.io/2012/08/07/better-git-commit-graph-using-pull---rebase-and-merge---no-ff.html" target="_blank" rel="noopener">洁癖者用 Git：pull –rebase 和 merge –no-ff</a></p>
</li>
<li><p><a href="https://speakerdeck.com/mouson/laradebut-number-03-cong-git-ru-men-dao-tuan-dui-he-zuo-kai-fa" target="_blank" rel="noopener">Laradebut #03 從 git 入門到團隊合作開發 // Speaker Deck</a></p>
</li>
<li><p><a href="http://ithelp.ithome.com.tw/tags/articles/git?page=2" target="_blank" rel="noopener">Tag 列表頁(git) - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Git] Get Started with Git]]></title>
      <url>/blog/2016/10/29/Git/Get-Started-with-Git/</url>
      <content type="html"><![CDATA[<p>介紹開始使用 Git 前調教 config 的相關資訊</p>
<h1 id="初始化-Git-Repository"><a href="#初始化-Git-Repository" class="headerlink" title="初始化 Git Repository"></a>初始化 Git Repository</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化 git repository</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git init</span></span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /root/git/git-lab/.git/</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Git-config"><a href="#Git-config" class="headerlink" title="Git config"></a>Git config</h1><h2 id="常用-Git-config-gitconfig"><a href="#常用-Git-config-gitconfig" class="headerlink" title="常用 Git config (~/.gitconfig)"></a>常用 Git config (~/.gitconfig)</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[user]</span></span><br><span class="line">    email = godleon@gmail.com</span><br><span class="line">    name = godleon</span><br><span class="line"><span class="section">[core]</span></span><br><span class="line">    editor = vim</span><br><span class="line">    </span><br><span class="line">    repositoryformatversion = 0</span><br><span class="line">    filemode = true</span><br><span class="line">    bare = false</span><br><span class="line">    logallrefupdates = true</span><br><span class="line"><span class="section">[color]</span></span><br><span class="line">    ui = true</span><br><span class="line"><span class="section">[alias]</span></span><br><span class="line">    tree = log --all --graph --decorate=short --color --format=format:'%C(bold blue)%h%C(reset) %C(auto)%d%C(reset)\n         %C(black)[%cr]%C(reset)  %x09%C(black)%an: %s %C(reset)'</span><br><span class="line"></span><br><span class="line">    logs = log --all --graph --decorate=short --color --format=format:'%C(bold blue)%h%C(reset)+%C(dim black)(%cr)%C(reset)+%C(auto)%d%C(reset)++\n+++       %C(bold black)%an%C(reset)%C(black): %s%C(reset)'</span><br><span class="line"></span><br><span class="line">    stree = !bash -c '"                                                                             \</span><br><span class="line">    while IFS=+ read -r hash time branch message; do                                            \</span><br><span class="line">        timelength=$(echo \"$time\" | sed -r \"s:[^ ][[]([0-9]&#123;1,2&#125;(;[0-9]&#123;1,2&#125;)?)?m::g\");     \</span><br><span class="line">        timelength=$(echo \"16+$&#123;#time&#125;-$&#123;#timelength&#125;\" | bc);                                 \</span><br><span class="line">        printf \"%$&#123;timelength&#125;s    %s %s %s\n\" \"$time\" \"$hash\" \"$branch\" \"\";          \</span><br><span class="line">    done &lt; &lt;(git logs &amp;&amp; echo);"'</span><br><span class="line"></span><br><span class="line">    logv = log --all --graph --decorate=short --color --format=format:'%C(bold blue)%h%C(reset)+%C(dim black)(%cr)%C(reset)+%C(auto)%d%C(reset)++\n+++       %C(bold black)%an%C(reset)%C(black): %s%C(reset)'</span><br><span class="line"></span><br><span class="line">    vtree = !bash -c '"                                                                             \</span><br><span class="line">    while IFS=+ read -r hash time branch message; do                                            \</span><br><span class="line">        timelength=$(echo \"$time\" | sed -r \"s:[^ ][[]([0-9]&#123;1,2&#125;(;[0-9]&#123;1,2&#125;)?)?m::g\");     \</span><br><span class="line">        timelength=$(echo \"16+$&#123;#time&#125;-$&#123;#timelength&#125;\" | bc);                                 \</span><br><span class="line">        printf \"%$&#123;timelength&#125;s    %s %s %s\n\" \"$time\" \"$hash\" \"$branch\" \"$message\";  \</span><br><span class="line">    done &lt; &lt;(git logv &amp;&amp; echo);"'</span><br></pre></td></tr></table></figure>
<h2 id="Git-config-優先權"><a href="#Git-config-優先權" class="headerlink" title="Git config 優先權"></a>Git config 優先權</h2><p>Git config 的優先權如下：</p>
<ol>
<li><p><code>.git/config</code></p>
</li>
<li><p><code>~/.gitconfig</code></p>
</li>
<li><p><code>/etc/gitconfig</code></p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 檢視 ".git/config" 的內容</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># cat .git/config</span></span><br><span class="line">[core]</span><br><span class="line">        repositoryformatversion = 0</span><br><span class="line">        filemode = <span class="literal">true</span></span><br><span class="line">        bare = <span class="literal">false</span></span><br><span class="line">        logallrefupdates = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示目前有效的 git config</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git config -l</span></span><br><span class="line">core.repositoryformatversion=0</span><br><span class="line">core.filemode=<span class="literal">true</span></span><br><span class="line">core.bare=<span class="literal">false</span></span><br><span class="line">core.logallrefupdates=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 '/etc/gitconfig' 中的設定</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git config --system -l</span></span><br><span class="line">fatal: unable to <span class="built_in">read</span> config file <span class="string">'/etc/gitconfig'</span>: No such file or directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 ~/.gitconfig 中的設定</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git config --global -l</span></span><br><span class="line">fatal: unable to <span class="built_in">read</span> config file <span class="string">'/root/.gitconfig'</span>: No such file or directory</span><br></pre></td></tr></table></figure>
<h2 id="設定-amp-移除-git-config"><a href="#設定-amp-移除-git-config" class="headerlink" title="設定 &amp; 移除 git config"></a>設定 &amp; 移除 git config</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下的設定將會存在 ~/.gitconfig 中</span></span><br><span class="line"><span class="comment"># 若改成 "--system" 參數，則設定會存在 '/etc/gitconfig'</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git config --global user.name 'godleon'</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git config --global user.email 'godleon@gmail.com'</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git config --list</span></span><br><span class="line">user.name=godleon</span><br><span class="line">user.email=godleon@gmail.com</span><br><span class="line">core.repositoryformatversion=0</span><br><span class="line">core.filemode=<span class="literal">true</span></span><br><span class="line">core.bare=<span class="literal">false</span></span><br><span class="line">core.logallrefupdates=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除 git config 設定</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git config --global --unset user.name</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git config --list</span></span><br><span class="line">user.email=godleon@gmail.com</span><br><span class="line">core.repositoryformatversion=0</span><br><span class="line">core.filemode=<span class="literal">true</span></span><br><span class="line">core.bare=<span class="literal">false</span></span><br><span class="line">core.logallrefupdates=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="設定-Git-alias"><a href="#設定-Git-alias" class="headerlink" title="設定 Git alias"></a>設定 Git alias</h2><p>跟 Linux 的 alias 很像，可以自訂簡單的命令來替代複雜的指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 git-lab]<span class="comment"># git config alias.con 'config -l'</span></span><br><span class="line"><span class="comment"># 此命令等同於 "git config -l" 的效果</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git con</span></span><br><span class="line">user.email=godleon@gmail.com</span><br><span class="line">core.repositoryformatversion=0</span><br><span class="line">core.filemode=<span class="literal">true</span></span><br><span class="line">core.bare=<span class="literal">false</span></span><br><span class="line">core.logallrefupdates=<span class="literal">true</span></span><br><span class="line">alias.con=config -l</span><br></pre></td></tr></table></figure>
<h2 id="設定-editor-amp-diff-tool"><a href="#設定-editor-amp-diff-tool" class="headerlink" title="設定 editor &amp; diff tool"></a>設定 editor &amp; diff tool</h2><ul>
<li><p><code>git config --global color.ui true</code>：加上顏色</p>
</li>
<li><p><code>git config --global core.editor vim</code>：把預設的文字編輯器改為 vim</p>
</li>
<li><p><code>git config --global diff.tool meld</code>：把預設的 diff tool 改為 meld (要先安裝 meld，且這是 GUI tool，不適用 text mode)</p>
</li>
<li><p><code>git difftool</code>：查詢檔案差異</p>
</li>
</ul>
<hr>
<h1 id="將檔案存入-Git-Repository"><a href="#將檔案存入-Git-Repository" class="headerlink" title="將檔案存入 Git Repository"></a>將檔案存入 Git Repository</h1><h2 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h2><p>Git 追蹤檔案的方式，會將檔案 &amp; 資料夾分成三類：</p>
<ol>
<li><p>untracked</p>
<blockquote>
<p>一開始所有檔案都是 untracked，執行 <code>git status</code> 可以看到 untracked 的檔案清單</p>
</blockquote>
</li>
<li><p>tracked</p>
<blockquote>
<p>當透過 <code>git add</code> 處理之後的檔案，狀態會變成 tracked，等待使用者進一步的 commit or cancel</p>
</blockquote>
</li>
<li><p>ignored</p>
<blockquote>
<p>會被 git 忽略處理的檔案，需要新增 <code>.gitignore</code> 檔案，並逐行宣告要忽略的檔案 (被設定忽略的檔案狀態不會變成 untracked)</p>
</blockquote>
</li>
</ol>
<p>以下為 <code>.gitignore</code> 設定範例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可用萬用字元(# 開頭為註解)</span></span><br><span class="line">*.txt</span><br><span class="line"><span class="comment"># 不要忽略 note.txt 檔案</span></span><br><span class="line">!note.txt</span><br><span class="line"><span class="comment"># folder 資料夾 &amp; 資料夾內的檔案通通忽略</span></span><br><span class="line">folder</span><br></pre></td></tr></table></figure>
<h2 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h2><h3 id="1、從-tracked-復原到-untracked"><a href="#1、從-tracked-復原到-untracked" class="headerlink" title="1、從 tracked 復原到 untracked"></a>1、從 tracked 復原到 untracked</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加入 file1.txt，狀態變成 tracked</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git add file1.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 從 git index 中移除，狀態變回 untracked</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git rm --cache file1.txt</span></span><br></pre></td></tr></table></figure>
<h3 id="2、從已經-commit-後的狀態回復原狀"><a href="#2、從已經-commit-後的狀態回復原狀" class="headerlink" title="2、從已經 commit 後的狀態回復原狀"></a>2、從已經 commit 後的狀態回復原狀</h3><p>首先先來看看如何顯示目前 commit 的狀態</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此為自訂的 alias，請參考上方設定</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git tree</span></span><br><span class="line">* 72f32d4  (HEAD, master)</span><br><span class="line">|          [25 minutes ago]     root: commit of file1</span><br><span class="line">* fbaedbb</span><br><span class="line"></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git log --graph --oneline --decorate --date=relative --all</span></span><br><span class="line">* 72f32d4 (HEAD, master) commit of file1</span><br><span class="line">* fbaedbb First commit</span><br><span class="line"></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git log --graph --abbrev-commit --decorate --date=relative --all</span></span><br><span class="line">* commit 72f32d4 (HEAD, master)</span><br><span class="line">| Author: root &lt;godleon@gmail.com&gt;</span><br><span class="line">| Date:   23 minutes ago</span><br><span class="line">|</span><br><span class="line">|     commit of file1</span><br><span class="line">|</span><br><span class="line">* commit fbaedbb</span><br><span class="line">  Author: root &lt;godleon@gmail.com&gt;</span><br><span class="line">  Date:   9 hours ago</span><br><span class="line"></span><br><span class="line">      First commit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消剛剛 commit 的狀態，將 file1.txt 狀態回復到 untracked 的狀態</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git reset HEAD^</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git status</span></span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Untracked files:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to include in what will be committed)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       .gitignore</span></span><br><span class="line"><span class="comment">#       file1.txt</span></span><br><span class="line"><span class="comment">#       file2.txt</span></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">"git add"</span> to track)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目前 HEAD 已經回到第一次  commit 的地方</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git tree</span></span><br><span class="line">* fbaedbb  (HEAD, master)</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="比較檔案差異-amp-從-Git-Repository-取回檔案"><a href="#比較檔案差異-amp-從-Git-Repository-取回檔案" class="headerlink" title="比較檔案差異 &amp; 從 Git Repository 取回檔案"></a>比較檔案差異 &amp; 從 Git Repository 取回檔案</h1><h2 id="比較檔案差異"><a href="#比較檔案差異" class="headerlink" title="比較檔案差異"></a>比較檔案差異</h2><p>git 提供了很多方式來檢視不同版本間的檔案差異，主要就是使用 <code>git diff</code> &amp; <code>git difftool</code> 來完成此功能，以下用個簡單範例來說明：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出目前的 commit 紀錄</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git tree</span></span><br><span class="line">* 81618ad  (HEAD, master)</span><br><span class="line">|          [2 hours ago]        godleon: 2nd commit <span class="keyword">for</span> file1.txt</span><br><span class="line">* fbaedbb</span><br><span class="line">           [2 days ago]         root: First commit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目前 file1.txt 已經有修改</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git status</span></span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to update what will be committed)</span></span><br><span class="line"><span class="comment">#   (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       modified:   file1.txt</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Untracked files:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to include in what will be committed)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       .gitignore</span></span><br><span class="line"><span class="comment">#       file2.txt</span></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比較本地端檔案 &amp; git repository 的差異</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git diff</span></span><br><span class="line">diff --git a/file1.txt b/file1.txt</span><br><span class="line">index 7cca94a..3aff906 100644</span><br><span class="line">--- a/file1.txt</span><br><span class="line">+++ b/file1.txt</span><br><span class="line">@@ -1,2 +1,3 @@</span><br><span class="line"> file1, line 1</span><br><span class="line"> file1, line2</span><br><span class="line">+file1, line3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將檔案 file1.txt 移到 staging 中</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git add file1.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 比較 staging 與 HEAD 的版本差異</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git diff --cached file1.txt</span></span><br><span class="line">diff --git a/file1.txt b/file1.txt</span><br><span class="line">index 7cca94a..3aff906 100644</span><br><span class="line">--- a/file1.txt</span><br><span class="line">+++ b/file1.txt</span><br><span class="line">@@ -1,2 +1,3 @@</span><br><span class="line"> file1, line 1</span><br><span class="line"> file1, line2</span><br><span class="line">+file1, line3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比較不同 commit 之間指定檔案的差異</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git diff HEAD HEAD~1 file1.txt</span></span><br><span class="line">diff --git a/file1.txt b/file1.txt</span><br><span class="line">deleted file mode 100644</span><br><span class="line">index 7cca94a..0000000</span><br><span class="line">--- a/file1.txt</span><br><span class="line">+++ /dev/null</span><br><span class="line">@@ -1,2 +0,0 @@</span><br><span class="line">-file1, line 1</span><br><span class="line">-file1, line2</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><p><a href="https://github.com/geeeeeeeeek/git-recipes/wiki" target="_blank" rel="noopener">git-recipes</a></p>
</li>
<li><p><a href="http://www-cs-students.stanford.edu/%7Eblynn/gitmagic/intl/zh_tw/index.html" target="_blank" rel="noopener">Git Magic</a></p>
</li>
<li><p><a href="http://www.cnblogs.com/fanfan259/p/4810517.html" target="_blank" rel="noopener">我所记录的git命令（非常实用） - 糖糖果 - 博客园</a></p>
</li>
<li><p><a href="https://ihower.tw/blog/archives/2622" target="_blank" rel="noopener">Git 版本控制系統(3) 還沒 push 前可以做的事 | ihower { blogging }</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Linux KVM] libvirt & Storage]]></title>
      <url>/blog/2016/10/27/KVM/KVM-libvirt-storage/</url>
      <content type="html"><![CDATA[<h1 id="建立-amp-使用-unmanaged-storage"><a href="#建立-amp-使用-unmanaged-storage" class="headerlink" title="建立 &amp; 使用 unmanaged storage"></a>建立 &amp; 使用 unmanaged storage</h1><p>建立 unmanaged storage 是幫 VM 增加 virtual disk 最快的方式，其中有兩種作法：</p>
<ol>
<li><p><strong>preallocated</strong>：效能好，但完全佔據磁碟空間</p>
</li>
<li><p><strong>thin-provisioned</strong>：效能較差，但僅佔據實際使用到的磁碟空間</p>
</li>
</ol>
<p>以下是兩種不同 image 的建立示範：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 產生 preallocated image</span></span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/zero of=/tmp/dbvm_disk1.img bs=1G count=10</span><br><span class="line">10+0 records <span class="keyword">in</span></span><br><span class="line">10+0 records out</span><br><span class="line">10737418240 bytes (11 GB) copied, 8.32924 s, 1.3 GB/s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 產生 thin-provisioned image</span></span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/zero of=/tmp/dbvm_disk1_seek.img bs=1G seek=10 count=0</span><br><span class="line">0+0 records <span class="keyword">in</span></span><br><span class="line">0+0 records out</span><br><span class="line">0 bytes (0 B) copied, 0.000307303 s, 0.0 kB/s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢 image 資訊 (preallocated image 已經完全佔據磁碟空間)</span></span><br><span class="line">$ qemu-img info /tmp/dbvm_disk1.img </span><br><span class="line">image: /tmp/dbvm_disk1.img</span><br><span class="line">file format: raw</span><br><span class="line">virtual size: 10G (10737418240 bytes)</span><br><span class="line">disk size: 10G</span><br><span class="line"><span class="comment"># 查詢 image 資訊 (thin-provisioned image 並未預先佔據磁碟空間)</span></span><br><span class="line">$ qemu-img info /tmp/dbvm_disk1_seek.img </span><br><span class="line">image: /tmp/dbvm_disk1_seek.img</span><br><span class="line">file format: raw</span><br><span class="line">virtual size: 10G (10737418240 bytes)</span><br><span class="line">disk size: 0</span><br></pre></td></tr></table></figure>
<p>當 image 建立完成，可用以下指令直接掛載到執行中的 VM：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ virsh domblklist centos7</span><br><span class="line">Target     Source</span><br><span class="line">------------------------------------------------</span><br><span class="line">vda        /var/lib/libvirt/images/hdd/vmdisk/centos7.qcow2</span><br><span class="line"></span><br><span class="line"><span class="comment"># vdb =&gt; 指定 image 掛載為 vdb</span></span><br><span class="line"><span class="comment"># --live =&gt; 指定在執行中的 VM 掛載 image</span></span><br><span class="line"><span class="comment"># --config =&gt; 讓此掛載設定可以永久保留，不會因為 VM reboot 而消失</span></span><br><span class="line">$ virsh attach-disk centos7 /tmp/dbvm_disk1.img vdb --live --config</span><br><span class="line">Disk attached successfully</span><br><span class="line"></span><br><span class="line">$ virsh domblklist centos7</span><br><span class="line">Target     Source- [KVM XML 設定檔基本內容](http://www.tfcis.org/~lantw44/download/notes/cs/libvirt.domain(5))</span><br><span class="line">------------------------------------------------</span><br><span class="line">vda        /var/lib/libvirt/images/hdd/vmdisk/centos7.qcow2</span><br><span class="line">vdb        /tmp/dbvm_disk1.img</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="建立-amp-使用-managed-storage"><a href="#建立-amp-使用-managed-storage" class="headerlink" title="建立 &amp; 使用 managed storage"></a>建立 &amp; 使用 managed storage</h1><p>為了讓 storage 有個統一標準的管理，除非是很臨時的測試目的需求，不然上面 unmanage 的作法就盡量少作囉!</p>
<p>libvirt 支援了相當多種的 storage pool，以下一一列出：</p>
<ul>
<li><p><code>-dir</code>：使用<strong>標準的檔案系統目錄</strong>儲存 virtual disk</p>
</li>
<li><p><code>-disk</code>：使用<strong>實體磁碟機</strong>來建立 virtual disk</p>
</li>
<li><p><code>-fs</code>：使用<strong>預設格式化好的磁碟分割</strong>來儲存 virtual disk</p>
</li>
<li><p><code>-netfs</code>：使用 <strong>network-shared storage</strong>(例如：NFS) 來儲存 virtual disk</p>
</li>
<li><p><code>-gluster</code>：使用 <strong>glusterfs</strong> 儲存 virtual disk</p>
</li>
<li><p><code>-iscsi</code>：使用 <strong>iscsi storage</strong> 儲存 virtual disk</p>
</li>
<li><p><code>-scsi</code>：使用 <strong>本地端 scsi storage</strong> 儲存 virtual disk </p>
</li>
<li><p><code>-lvm</code>：使用 <strong>LVM volume group</strong> 儲存 virtual disk</p>
</li>
<li><p><code>-rbd</code>：使用 <strong>Ceph storage</strong> 儲存 virtual disk </p>
</li>
</ul>
<blockquote>
<p>在 libvirt 中，managed storage 是以 <code>pool</code> + <code>volume</code> 所組合而成</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查詢 pool 列表</span></span><br><span class="line">$ $ virsh -c qemu+ssh://root@10.20.190.2/system pool-list</span><br><span class="line"> Name                 State      Autostart </span><br><span class="line">-------------------------------------------</span><br><span class="line"> default              active     yes       </span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視 pool 的詳細資訊</span></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system pool-info default</span><br><span class="line">Name:           default</span><br><span class="line">UUID:           0896bbcd-a502-4ed8-b484-34d8baf05e84</span><br><span class="line">State:          running</span><br><span class="line">Persistent:     yes</span><br><span class="line">Autostart:      yes</span><br><span class="line">Capacity:       1007.80 GiB</span><br><span class="line">Allocation:     70.07 GiB</span><br><span class="line">Available:      937.73 GiB</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">這些資訊會以 XML 的形式存在於 KVM host 上，以 `default` 為例，其 XML 定義檔的位置為 `/etc/libvirt/storage/default.xml`。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">管理 Storage Pool</span><br><span class="line">=================</span><br><span class="line"></span><br><span class="line">以下使用 filesystem &amp; LVM 作為建立 storage pool 的範例：</span><br><span class="line"></span><br><span class="line"><span class="comment">## (1) 建立 fife system directory backed storage pool</span></span><br><span class="line"></span><br><span class="line">這是上述 `defautl` pool 的方式，使用的是 KVM host 上的 `/var/lib/libvirt/images` 資料夾作為儲存 volume 的位置</span><br><span class="line"></span><br><span class="line">以下是建立一個名稱為 **dedicated_storage** 的簡單方式：</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line"><span class="comment"># 定義 storage pool (會產生 XML 定義檔案在 /etc/libvirt/storage 目錄中)</span></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system pool-define-as dedicated_storage dir - - - - <span class="string">"/vms"</span></span><br><span class="line">Pool dedicated_storage defined</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 storage pool (建立指定目錄 &amp; 設定 SELinux 相關權限)</span></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system pool-build dedicated_storage</span><br><span class="line">Pool dedicated_storage built</span><br><span class="line"></span><br><span class="line"><span class="comment"># 啟動 storage pool</span></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system pool-start dedicated_storage</span><br><span class="line">Pool dedicated_storage started</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定 libvirtd 啟動時，同時啟動此 storage pool</span></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system pool-autostart dedicated_storage</span><br><span class="line">Pool dedicated_storage marked as autostarted</span><br></pre></td></tr></table></figure>
<h2 id="2-建立-LVM-volume-Group-backed-storage-pool"><a href="#2-建立-LVM-volume-Group-backed-storage-pool" class="headerlink" title="(2) 建立 LVM volume Group backed storage pool"></a>(2) 建立 LVM volume Group backed storage pool</h2><p>使用 LVM 的優點就會有以下優點啦：</p>
<ol>
<li><p>彈性伸縮磁碟容量</p>
</li>
<li><p>整合不同的磁碟</p>
</li>
<li><p>volume snapshots</p>
</li>
<li><p>自定義的裝置名稱</p>
</li>
<li><p>data striping 提昇 I/O throughput</p>
</li>
<li><p>Mirror volumes</p>
</li>
</ol>
<p>所以使用 LVM 作為 storage pool 也是個相當不錯的選項。</p>
<p>假設目前在 KVM host 中有 <strong>/dev/sdb</strong> &amp; <strong>/dev/sdc</strong> 兩個硬碟可拿來作為 LVM volume，可用以下指令建立 LVM storage pool：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ bash -c <span class="string">'cat &lt;&lt;EOF &gt; /tmp/storage-lvm.xml</span></span><br><span class="line"><span class="string">&lt;pool type="logical"&gt;</span></span><br><span class="line"><span class="string">  &lt;name&gt;HostVG&lt;/name&gt;</span></span><br><span class="line"><span class="string">  &lt;source&gt;</span></span><br><span class="line"><span class="string">    &lt;device path="/dev/sdb"/&gt;</span></span><br><span class="line"><span class="string">    &lt;device path="/dev/sdc"/&gt;</span></span><br><span class="line"><span class="string">  &lt;/source&gt;</span></span><br><span class="line"><span class="string">  &lt;target&gt;</span></span><br><span class="line"><span class="string">    &lt;path&gt;/dev/HostVG&lt;/path&gt;</span></span><br><span class="line"><span class="string">  &lt;/target&gt;</span></span><br><span class="line"><span class="string">&lt;/pool&gt;</span></span><br><span class="line"><span class="string">EOF'</span></span><br><span class="line"></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system pool-define /tmp/storage-lvm.xml </span><br><span class="line">Pool HostVG defined from /tmp/storage-lvm.xml</span><br><span class="line"></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system pool-build HostVG</span><br><span class="line">Pool HostVG built</span><br><span class="line"></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system pool-start HostVG</span><br><span class="line">Pool HostVG started</span><br><span class="line"></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system pool-autostart HostVG</span><br><span class="line">Pool HostVG marked as autostarted</span><br></pre></td></tr></table></figure>
<h2 id="3-刪除-storage-pool"><a href="#3-刪除-storage-pool" class="headerlink" title="(3) 刪除 storage pool"></a>(3) 刪除 storage pool</h2><p>刪除 storage pool 就相對簡單，假設要刪除上面的 <strong>HostVG</strong> pool，只要透過以下指令即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system pool-destroy HostVG</span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system pool-undefine HostVG</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Storage-Volume-的管理"><a href="#Storage-Volume-的管理" class="headerlink" title="Storage Volume 的管理"></a>Storage Volume 的管理</h1><p>透過 virsh 建立 storage volume 的語法類似如下：</p>
<blockquote>
<p>virsh vol-create-as –pool POOL_NAME VOL_NAME VOL_SIZE –format raw|qcow2|qed </p>
</blockquote>
<p>因此假設我們要在 pool <strong>dedicated_storage</strong> 中建立一個格式為 <strong>qcow2</strong>，大小為 <strong>10G</strong> 的 volume，可用下列語法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立一個名稱為 vm_vol1.qcow2 的 storage volume</span></span><br><span class="line">$ $ virsh -c qemu+ssh://root@10.20.190.2/system vol-create-as --pool dedicated_storage vm_vol1.qcow2 10G --format qcow2</span><br><span class="line">Vol vm_vol1.qcow2 created</span><br><span class="line"></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system vol-info --pool dedicated_storage vm_vol1.qcow2</span><br><span class="line">Name:           vm_vol1.qcow2</span><br><span class="line">Type:           file</span><br><span class="line">Capacity:       10.00 GiB</span><br><span class="line">Allocation:     196.00 KiB</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">若要刪除 storage volume，則可用以下指令</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system vol-delete --pool dedicated_storage vm_vol1.qcow2</span><br><span class="line">Vol vm_vol1.qcow2 deleted</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><p><a href="http://beakdoosan.blogspot.tw/2011/01/lvm.html" target="_blank" rel="noopener">Beakdoosan’s Weblog: LVM 筆記 - 觀念篇</a></p>
</li>
<li><p><a href="https://libvirt.org/storage.html" target="_blank" rel="noopener">libvirt: Storage Management</a></p>
</li>
<li><p><a href="https://www.suse.com/documentation/sles11/book_kvm/data/sec_libvirt_storage_virsh.html" target="_blank" rel="noopener">Suse Doc: Virtualization with KVM - Managing Storage with virsh</a></p>
</li>
<li><p><a href="http://docs.ceph.com/docs/hammer/rbd/libvirt/" target="_blank" rel="noopener">Using libvirt with Ceph RBD — Ceph Documentation</a></p>
</li>
<li><p><a href="http://www.tfcis.org/~lantw44/download/notes/cs/libvirt.domain(5" target="_blank" rel="noopener">KVM XML 設定檔基本內容</a>)</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> KVM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> KVM </tag>
            
            <tag> libvirt </tag>
            
            <tag> Storage </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Linux KVM] libvirt & network]]></title>
      <url>/blog/2016/10/21/KVM/KVM-libvirt-network/</url>
      <content type="html"><![CDATA[<p>介紹如何使用 libvirt 來管理 KVM virtual network</p>
<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>以下圖片來說明 libvirt 在整個虛擬化架構中所扮演的角色：</p>
<p><img src="http://smilejay.com/wp-content/uploads/2013/03/libvirt-manage-hypervisors.jpg" alt="libvirt 1"></p>
<blockquote>
<p>其中 other tools 的部份，甚至可以是 <strong>OpenStack</strong>、<strong>oVirt</strong> … 等工具</p>
</blockquote>
<p>libvirt 的管理功能一共包含五個部分：</p>
<ol>
<li><p>Virtual Machine</p>
<blockquote>
<p>包含 VM lifecycle(啟動/停止/暫停/保存/恢復/Live Migration …. 等等) 的管理，也支援對各種設備的熱插拔(不同的 hypervisor 對熱插拔的支援程度不一)</p>
</blockquote>
</li>
<li><p>Remote Node</p>
<blockquote>
<p>只要 remote node 上執行了 libvirtd 服務，libvirt 就可以用遠端的方式進行管理，支援 SSH / TCP socket … 等不同的連線方式，以 SSH 為例，可用像是 <code>virsh -c qemu+ssh://root@remotehost.com/system</code> 的命令進行連線</p>
</blockquote>
</li>
<li><p>Storage</p>
<blockquote>
<p>與上面相同，只要 remote node 上執行了 libvirtd 服務，就可以透過 libvirt 來管理不同類型的 storage，例如：建立不同格式的 virtual machine image(qcow2 / raw / vmdk … 等等)、掛載 remote NFS/iSCSI share、磁碟分割 …. 等等</p>
</blockquote>
</li>
<li><p>Network</p>
<blockquote>
<p>與上面相同，只要 remote node 上執行了 libvirtd 服務，就可以透過 libvirt 進行像是配置 tap device、建立 virtual network tap、bridge device 設定、VLAN/NAT 管理…等功能</p>
</blockquote>
</li>
<li><p>提供穩定、高效 API interface</p>
</li>
</ol>
<p>更清楚一點解釋 libvirt 在整個 QEMU/KVM 虛擬環境中所扮演的角色，可參考下圖：</p>
<p><img src="https://github.com/godleon/godleon.github.io/blob/master/_posts/images/2016/KVM-libvirt/libvirt.png?raw=true" alt="libvirt"></p>
<hr>
<h1 id="遠端操作-libvirtd"><a href="#遠端操作-libvirtd" class="headerlink" title="遠端操作 libvirtd"></a>遠端操作 libvirtd</h1><p>以下用個很簡單的範例，透過 virsh 命令連線到遠端主機的 libvirtd 並執行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 遠端主機為 10.20.190.3</span></span><br><span class="line"><span class="comment"># 執行命令 "list --all"</span></span><br><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system list --all</span><br><span class="line"> Id    Name                           State</span><br><span class="line">----------------------------------------------------</span><br><span class="line"> 3     centos7                        running</span><br></pre></td></tr></table></figure>
<p>用圖來表示的話，遠端操作 libvirtd 的流程如下：</p>
<p><img src="https://github.com/godleon/godleon.github.io/blob/master/_posts/images/2016/KVM-libvirt/remote_access_libvirtd.png?raw=true" alt="Remote Accrss libvirtd"></p>
<hr>
<h1 id="Linux-Virtual-Networking"><a href="#Linux-Virtual-Networking" class="headerlink" title="Linux Virtual Networking"></a>Linux Virtual Networking</h1><p>libvirt networking 的主要元件是 virtual network switch，也就是 Linux 中的 <strong><font color="red">bridge devices</font></strong>，而連接在 bridge 上的 interface，我們稱為 <strong><font color="red">TAP devices</font></strong>。</p>
<blockquote>
<p>TAP device 是由 Linux 的 TUN/TAP 模組所實作出來，其中 TUN(tunnel) 用來模擬 layer 3 的設備，而 TAP(network tap) 則是用來模擬 layer 2 設備</p>
</blockquote>
<p>以下示範如何建立 bridge device &amp; TAP device：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查詢是否已經掛載 bridge 模組</span></span><br><span class="line">$ lsmod | grep bridge</span><br><span class="line">bridge                119562  0</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增 bridge device</span></span><br><span class="line">$ brctl addbr tester</span><br><span class="line">$ brctl show</span><br><span class="line">bridge name	  bridge id		       STP enabled	interfaces</span><br><span class="line">.......</span><br><span class="line">tester		    8000.000000000000	 no		</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢查 TUN/TAP 模組是否已經載入到 kernel 中</span></span><br><span class="line">$ lsmod | grep tun</span><br><span class="line">tun                    27141  4 vhost_net</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 TAP device(vm-vnic)</span></span><br><span class="line">$ ip tuntap add dev vm-vnic mode tap</span><br><span class="line">$ ip addr show vm-vnic</span><br><span class="line">21: vm-vnic: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN qlen 500</span><br><span class="line">    link/ether 92:ee:17:b7:2b:c4 brd ff:ff:ff:ff:ff:ff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將 TAP device 與 bridge 相連</span></span><br><span class="line">$ brctl addif tester vm-vnic</span><br><span class="line">$ brctl show</span><br><span class="line">bridge name	bridge id		       STP enabled	 interfaces</span><br><span class="line">.......</span><br><span class="line">tester		  8000.92ee17b72bc4	 no		         vm-vnic</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視目前連接到 bridge 的 TAP devices</span></span><br><span class="line">$ brctl showmacs tester</span><br><span class="line">port no	mac addr		is <span class="built_in">local</span>?	ageing timer</span><br><span class="line">  1	92:ee:17:b7:2b:c4	yes		   0.00</span><br><span class="line">  1	92:ee:17:b7:2b:c4	yes		   0.00</span><br></pre></td></tr></table></figure>
<p>若以上的 vm-vnic 連接到 VM 後，整個 network topology 會變成類似如下圖：</p>
<p><img src="https://github.com/godleon/godleon.github.io/blob/master/_posts/images/2016/KVM-Virtual-Networking/Linux_bridge_taps.png?raw=true" alt="Linux Bridge &amp; TAP devices"></p>
<p>測試完畢後，我們可以用以下指令移除上面建立的 TAP device &amp; bridge：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ brctl delif tester vm-vnic</span><br><span class="line"></span><br><span class="line">$ brctl show</span><br><span class="line">bridge name	bridge id		       STP enabled	interfaces</span><br><span class="line">........</span><br><span class="line">tester		  8000.000000000000	 no		</span><br><span class="line"></span><br><span class="line">$ ip tuntap del dev vm-vnic mode tap</span><br><span class="line">$ brctl delbr tester</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Virtual-Network-Types"><a href="#Virtual-Network-Types" class="headerlink" title="Virtual Network Types"></a>Virtual Network Types</h1><p>在 KVM 中，virtual network 分為以下幾種類型：</p>
<ul>
<li><p><strong>NATed</strong>：以 host 作為 NAT server 的方式提供網路</p>
</li>
<li><p><strong>Routed</strong>：透過設定在 hypervisor 上的 routing rules，允許 VM 與實體網路卡相連進行資料傳輸</p>
</li>
<li><p><strong>Isolated</strong>：與外界完全區隔的內部私有網路，只有在裡面的 VM 可以互相通訊</p>
</li>
</ul>
<p>透過以下指令可以查詢 virtual network 相關的資訊：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$ virsh -c qemu+ssh://root@10.20.190.3/system net-list --all</span><br><span class="line"> Name                 State      Autostart     Persistent</span><br><span class="line">----------------------------------------------------------</span><br><span class="line"> default              active     yes           yes</span><br><span class="line"></span><br><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system net-info default</span><br><span class="line">Name:           default  <span class="comment"># virtual network 名稱</span></span><br><span class="line">UUID:           83bea138-4c65-4ca2-8199-db3400d87fa5</span><br><span class="line">Active:         yes      <span class="comment"># 目前的啟動狀態</span></span><br><span class="line">Persistent:     yes      </span><br><span class="line">Autostart:      yes      <span class="comment"># 是否隨著 libvird 一起啟動</span></span><br><span class="line">Bridge:         virbr0   <span class="comment"># 使用那個 device 進行對外通訊 </span></span><br><span class="line"></span><br><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system net-dumpxml default</span><br><span class="line">&lt;network&gt;</span><br><span class="line">  &lt;name&gt;default&lt;/name&gt;</span><br><span class="line">  &lt;uuid&gt;83bea138-4c65-4ca2-8199-db3400d87fa5&lt;/uuid&gt;</span><br><span class="line">  &lt;forward mode=<span class="string">'nat'</span>&gt;</span><br><span class="line">    &lt;nat&gt;</span><br><span class="line">      &lt;port start=<span class="string">'1024'</span> end=<span class="string">'65535'</span>/&gt;</span><br><span class="line">    &lt;/nat&gt;</span><br><span class="line">  &lt;/forward&gt;</span><br><span class="line">  &lt;bridge name=<span class="string">'virbr0'</span> stp=<span class="string">'on'</span> delay=<span class="string">'0'</span>/&gt;</span><br><span class="line">  &lt;mac address=<span class="string">'52:54:00:f8:50:f2'</span>/&gt;</span><br><span class="line">  &lt;ip address=<span class="string">'192.168.122.1'</span> netmask=<span class="string">'255.255.255.0'</span>&gt;</span><br><span class="line">    &lt;dhcp&gt;</span><br><span class="line">      &lt;range start=<span class="string">'192.168.122.2'</span> end=<span class="string">'192.168.122.254'</span>/&gt;</span><br><span class="line">    &lt;/dhcp&gt;</span><br><span class="line">  &lt;/ip&gt;</span><br><span class="line">&lt;/network&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 啟動 default virtual network</span></span><br><span class="line">$ virsh net-start default</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刪除 default virtual network</span></span><br><span class="line">$ virsh net-destroy default</span><br></pre></td></tr></table></figure>
<p>系統預設的 <strong><font color="red">default</font></strong> virtual network 屬於 NATed，host 會自動派發 IP 給此網路中 VM，並設定相關的 firewall rule 讓 VM 可以透過 host 對外通訊。</p>
<hr>
<h1 id="使用-libvirt-管理-virtual-network-Isolated"><a href="#使用-libvirt-管理-virtual-network-Isolated" class="headerlink" title="使用 libvirt 管理 virtual network - Isolated"></a>使用 libvirt 管理 virtual network - Isolated</h1><p>顧名思義，isolated network 表示外面是無法與在 isolated network 中的 VM 進行通訊的，只有加入到此 network 的 VM 才可以相互通訊，而在 isolated network 內部的 VM 也無法對外連線。</p>
<p><img src="https://github.com/godleon/godleon.github.io/blob/master/_posts/images/2016/KVM-libvirt/kvm_isolated-network.jpg?raw=true" alt="KVM isolated network"></p>
<p>建立 isolated network 的方式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ bash -c <span class="string">'cat &lt;&lt;EOF &gt; /tmp/isolated.xml</span></span><br><span class="line"><span class="string">&lt;network&gt; </span></span><br><span class="line"><span class="string">  &lt;name&gt;isolated&lt;/name&gt;</span></span><br><span class="line"><span class="string">&lt;/network&gt;</span></span><br><span class="line"><span class="string">EOF'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定義 virtual network </span></span><br><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system net-define /tmp/isolated.xml </span><br><span class="line">Network isolated defined from /tmp/isolated.xml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視目前的 virtual network 清單 (isolated 已經加入，但尚未啟動)</span></span><br><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system net-list --all</span><br><span class="line"> Name                 State      Autostart     Persistent</span><br><span class="line">----------------------------------------------------------</span><br><span class="line"> default              active     yes           yes</span><br><span class="line"> isolated             inactive   no            yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># libvirt 會自動指派 UUID, virtual bridge ...等資訊</span></span><br><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system net-dumpxml isolated</span><br><span class="line">&lt;network&gt;</span><br><span class="line">  &lt;name&gt;isolated&lt;/name&gt;</span><br><span class="line">  &lt;uuid&gt;765e746b-334d-4acf-8b9c-cb32be5b77f5&lt;/uuid&gt;</span><br><span class="line">  &lt;bridge name=<span class="string">'virbr1'</span> stp=<span class="string">'on'</span> delay=<span class="string">'0'</span>/&gt;</span><br><span class="line">  &lt;mac address=<span class="string">'52:54:00:70:8b:87'</span>/&gt;</span><br><span class="line">&lt;/network&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>定義一個新的 virtual network 後，會在 KVM host 上的 <code>/etc/libvirt/qemu/networks</code> 目錄產生對應的 XML 設定檔，以上面為例，XML 設定檔完整名稱是 <code>/etc/libvirt/qemu/networks/isolated.xml</code></p>
</blockquote>
<p>完成 virtual network define 之後，接著要啟動 virtual network：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system net-start isolated</span><br><span class="line">Network isolated started</span><br><span class="line"></span><br><span class="line"><span class="comment"># network isolated 已經啟動</span></span><br><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system net-list --all</span><br><span class="line"> Name                 State      Autostart     Persistent</span><br><span class="line">----------------------------------------------------------</span><br><span class="line"> default              active     yes           yes</span><br><span class="line"> isolated             active     no            yes</span><br></pre></td></tr></table></figure>
<p>完成了 isolated virtual network 的配置後，以下是動態產生 &amp; 刪除 NIC 並與 VM 相連的相關操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 檢視 domain interface list (目前只有連接 default network)</span></span><br><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system domiflist centos7</span><br><span class="line">Interface  Type       Source     Model       MAC</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">vnet0      network    default    virtio      52:54:00:7e:f8:5c</span><br><span class="line"></span><br><span class="line"><span class="comment"># attach-interface =&gt; 產生一個 interface 並連接到後續指定的 virtual network</span></span><br><span class="line"><span class="comment"># --domain =&gt; 指定要變更設定的 VM (稱為 domain)</span></span><br><span class="line"><span class="comment"># --source isolated --type network =&gt; 使用 virtual network isolated</span></span><br><span class="line"><span class="comment"># --model virtio =&gt; 使用 virtio (效能較好)</span></span><br><span class="line"><span class="comment"># --config =&gt; 變更設定 &amp; 儲存 (若沒使用此參數，NIC 僅會暫時出現)</span></span><br><span class="line"><span class="comment"># --live =&gt; 在 VM 執行狀態下動態新增 (若要針對停止中的 VM 新增 NIC 不需要使用此參數)</span></span><br><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system attach-interface --domain centos7 --<span class="built_in">source</span> isolated --<span class="built_in">type</span> network --model virtio --config --live</span><br><span class="line">Interface attached successfully</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新檢視 VM 的 interface list，發現新的 NIC 已經安裝上去了</span></span><br><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system domiflist centos7</span><br><span class="line">Interface  Type       Source     Model       MAC</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">vnet0      network    default    virtio      52:54:00:7e:f8:5c</span><br><span class="line">vnet1      network    isolated   virtio      52:54:00:07:b8:72</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除指定的 NIC</span></span><br><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system detach-interface --domain centos7 --<span class="built_in">type</span> network --mac 52:54:00:07:b8:72 --config --live</span><br><span class="line">Interface detached successfully</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可看出其中一的 NIC 已經被移除</span></span><br><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system domiflist centos7</span><br><span class="line">Interface  Type       Source     Model       MAC</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">vnet0      network    default    virtio      52:54:00:7e:f8:5c</span><br></pre></td></tr></table></figure>
<p>當透過 virsh 新增一個 NIC 與 VM 相連後，直接到 KVM host 上使用 <code>brctl show</code> 指令檢視目前與 bridge device 相連的 interface：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ brctl show</span><br><span class="line">bridge name	bridge id		      STP enabled	interfaces</span><br><span class="line">......</span><br><span class="line">virbr1		  8000.525400708b87	yes		      virbr1-nic</span><br><span class="line">							                            vnet1</span><br></pre></td></tr></table></figure>
<p>可以看出 interface 已經被 libvirt 自動建立且與 bridge 相連。(其中的 <strong>virbr1-nic</strong> 是在 isolated virtual network 建立時，libvirt 一併同時產生的)</p>
<hr>
<h1 id="virtual-network-NATed-amp-Routed"><a href="#virtual-network-NATed-amp-Routed" class="headerlink" title="virtual network - NATed &amp; Routed"></a>virtual network - NATed &amp; Routed</h1><h2 id="NATed-virtual-network"><a href="#NATed-virtual-network" class="headerlink" title="NATed virtual network"></a>NATed virtual network</h2><p>安裝好 KVM 後，預設就會附上一個名稱為 <code>default</code> 的 NATed virtual network，所有使用 default virtual network 的 VM，都可以透過 KVM host 中新增的 bridge device  <code>virbr0</code>，以 NAT 的方式連到外部網路。 </p>
<p>NATed virtual network 的設定步驟如下：</p>
<ol>
<li><p>建立 bridge device，並與特定的 nic 連結</p>
</li>
<li><p>設定防火牆規則 for NAT masquerade</p>
</li>
<li><p>virtual network 中 XML 定義的 <code>forward mode</code> 要設為 yes </p>
</li>
</ol>
<p>接著就是 <code>virsh net-{define,start,autostart}</code> 的工作了，這與上面雷同，就不再贅述</p>
<h2 id="Routed-virtual-network"><a href="#Routed-virtual-network" class="headerlink" title="Routed virtual network"></a>Routed virtual network</h2><p>這在實際應用中很少遇到，因此就略過先不測試，有機會試過之後再來補!</p>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><p><a href="">Networking - KVM</a><a href="http://www.linux-kvm.org/page/Networking" target="_blank" rel="noopener">http://www.linux-kvm.org/page/Networking</a></p>
</li>
<li><p><a href="https://libvirt.org/formatnetwork.html" target="_blank" rel="noopener">libvirt: Network XML format</a></p>
</li>
<li><p><a href="http://www.tfcis.org/~lantw44/download/notes/cs/libvirt.domain(5" target="_blank" rel="noopener">KVM XML 設定檔基本內容</a>)</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> KVM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> KVM </tag>
            
            <tag> libvirt </tag>
            
            <tag> Network </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Linux KVM] 半虛擬化驅動(Paravirtualization Driver)]]></title>
      <url>/blog/2016/08/20/KVM/KVM-Paravirtualization-Drivers/</url>
      <content type="html"><![CDATA[<p>介紹如何使用 QEMU/KVM 中的半虛擬化，並了解此技術如何帶來效能上的提升</p>
<h1 id="QEMU-I-O-Overview"><a href="#QEMU-I-O-Overview" class="headerlink" title="QEMU I/O Overview"></a>QEMU I/O Overview</h1><p>QEMU/KVM 是屬於全虛擬化的解決方案，若沒有硬體加速輔助的情況下，所有的工作都必須透過軟體模擬，其實效率是很不好的，特別是 device I/O 的部分。</p>
<p>以下的圖可以說明純 QEMU 模擬下的 device I/O 狀況：</p>
<p><img src="http://smilejay.b0.upaiyun.com/wp-content/uploads/2012/11/qemu-emulated-io.jpg" alt="KVM virtio"></p>
<p>一個 virtual machine 的 I/O request 會透過以下流程完成：</p>
<ol>
<li><p>被 KVM module 中的 I/O trap 捕捉到 &amp; 處理</p>
</li>
<li><p>將處理結果放到 I/O sharing page 中</p>
</li>
<li><p>通知 QEMU process 來取得 I/O 資訊，並交由 QEMU I/O Emulation Code 來模擬 I/O request</p>
</li>
<li><p>完成後將結果放回 I/O sharing page</p>
</li>
<li><p>通知 KVM module 中的 I/O trap 將處理結果取回並回傳給 virtual machine</p>
</li>
</ol>
<p>透過 QEMU 可以模擬出各式各樣的 I/O device，甚至很老舊的設備都沒有問題；但從上面複雜的步驟不難看出為何使用 QEMU 模擬 device I/O 會效率不彰，除了每次 I/O request 處理的流程繁複之外，過多的 VMEntry, VMExit, context switch，也都是拖垮 QEMU 效能的原因。</p>
<hr>
<h1 id="virtio-Overview"><a href="#virtio-Overview" class="headerlink" title="virtio Overview"></a>virtio Overview</h1><p>有鑑於此，<a href="http://www.linux-kvm.org/page/Virtio" target="_blank" rel="noopener">virtio</a> 被提出來，作為運行在 Hypervisor 上的一組 API interface，讓 virtual machine 知道自己運行在虛擬環境中，並根據 virtio 標準與 hypervisor 互動，藉此達到更好的運作效能(I/O 效能提升最為明顯)。</p>
<p>以下是純 QEMU 模擬 &amp; virtio 的架構比較，可以看出 virtio 省略了 I/O trap，讓 virtual machine 可以直接與 QEMU 的 I/O 模組通訊：</p>
<p><img src="http://images0.cnblogs.com/blog2015/697113/201506/011807259737673.jpg" alt="QEMU v.s. virtio"></p>
<p>更細部一點檢視 virtio 的架構：</p>
<p><img src="http://smilejay.b0.upaiyun.com/wp-content/uploads/2012/11/qemu-kvm-virtio.jpg" alt="virtio architecture"></p>
<ol>
<li><p>第一層 <strong>virtio_blk</strong>、<strong>virtio_net</strong>、<strong>virtio_scsi</strong> …. 等等屬於 <strong><font color="red">virtio Frontend，存在於</font></strong> virtual machine OS kernel module 中</p>
</li>
<li><p>最下面一層稱為 <strong><font color="red">virtio Backend</font></strong>，是在 QEMU 中實作，讓 I/O request 可以透過 QEMU 直接送給 host machine 中的 device driver，減少整體 I/O 的 overhead</p>
</li>
<li><p><strong><font color="red">virtio</font></strong> 屬於虛擬佇列，目的是將 Frontend 的驅動程序附加到 Backend 的處理程序 (一個 Frontend 的驅動程序可以根據需求使用 0 個或多個佇列，例如 virtio_net 同時需要傳送 &amp; 接收用的兩個虛擬佇列，virtio_blk 則僅需要一個)</p>
</li>
<li><p><strong><font color="red">virtio-ring</font></strong> 透過實作 ring buffer 的機制，讓 I/O request 得以批次處理，藉以提升 virtual machine 與 hypervisor 之間訊息交換的效率</p>
</li>
</ol>
<p>雖然 virtio 可以大幅的提升 I/O 性能，但不僅需要 host machine 的 OS kernel 有支援，連 virtual machine 也要同時有安裝 virtio driver，不過目前較新的 Linux 都已經支援 virtio 了! 所以若使用的是最近幾年的 Linux 版本，在 I/O 裝置的部分應該都可以選擇以 virtio 的方式運行。</p>
<blockquote>
<p>Windows 也都有對應的 virtio driver 可對應下載</p>
</blockquote>
<hr>
<h1 id="檢查-virtio-環境"><a href="#檢查-virtio-環境" class="headerlink" title="檢查 virtio 環境"></a>檢查 virtio 環境</h1><h2 id="1-1-virtio-Backend"><a href="#1-1-virtio-Backend" class="headerlink" title="1.1 virtio Backend"></a>1.1 virtio Backend</h2><p>由於 host machine 安裝的是 CentOS 7，因此都已經預設安裝 virtio driver 了! 可以用以下指令查詢：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ find / -name <span class="string">'virtio*.ko'</span> | grep $(uname -r)</span><br><span class="line">/usr/lib/modules/3.10.0-327.28.2.el7.x86_64/kernel/drivers/virtio/virtio_pci.ko</span><br><span class="line">/usr/lib/modules/3.10.0-327.28.2.el7.x86_64/kernel/drivers/virtio/virtio.ko</span><br><span class="line">/usr/lib/modules/3.10.0-327.28.2.el7.x86_64/kernel/drivers/virtio/virtio_ring.ko</span><br><span class="line">/usr/lib/modules/3.10.0-327.28.2.el7.x86_64/kernel/drivers/virtio/virtio_input.ko</span><br><span class="line">/usr/lib/modules/3.10.0-327.28.2.el7.x86_64/kernel/drivers/virtio/virtio_balloon.ko</span><br><span class="line">/usr/lib/modules/3.10.0-327.28.2.el7.x86_64/kernel/drivers/char/virtio_console.ko</span><br><span class="line">/usr/lib/modules/3.10.0-327.28.2.el7.x86_64/kernel/drivers/char/hw_random/virtio-rng.ko</span><br><span class="line">/usr/lib/modules/3.10.0-327.28.2.el7.x86_64/kernel/drivers/scsi/virtio_scsi.ko</span><br><span class="line">/usr/lib/modules/3.10.0-327.28.2.el7.x86_64/kernel/drivers/block/virtio_blk.ko</span><br><span class="line">/usr/lib/modules/3.10.0-327.28.2.el7.x86_64/kernel/drivers/net/virtio_net.ko</span><br></pre></td></tr></table></figure>
<h2 id="1-2-virtio-Frontend"><a href="#1-2-virtio-Frontend" class="headerlink" title="1.2 virtio Frontend"></a>1.2 virtio Frontend</h2><h3 id="1-2-1-Linux"><a href="#1-2-1-Linux" class="headerlink" title="1.2.1 Linux"></a>1.2.1 Linux</h3><p>目前新版本的 Linux(Ubuntu / CentOS / …. 等等)都已經內建 virtio driver 了，不需要再額外安裝囉!</p>
<h3 id="1-2-2-Windows"><a href="#1-2-2-Windows" class="headerlink" title="1.2.2 Windows"></a>1.2.2 Windows</h3><p>若是要安裝 Windows 的 virtio driver，可以使用以下指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://fedorapeople.org/groups/virt/virtio-win/virtio-win.repo -O /etc/yum.repos.d/virtio-win.repo</span><br><span class="line"></span><br><span class="line">$ yum info virtio-win</span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: ftp.yzu.edu.tw</span><br><span class="line"> * epel: mirror01.idc.hinet.net</span><br><span class="line"> * extras: ftp.yzu.edu.tw</span><br><span class="line"> * updates: ftp.yzu.edu.tw</span><br><span class="line">Available Packages</span><br><span class="line">Name        : virtio-win</span><br><span class="line">Arch        : noarch</span><br><span class="line">Version     : 0.1.102</span><br><span class="line">Release     : 1</span><br><span class="line">Size        : 75 M</span><br><span class="line">Repo        : virtio-win-stable</span><br><span class="line">Summary     : VirtIO para-virtualized drivers <span class="keyword">for</span> Windows(R)</span><br><span class="line">URL         : http://www.redhat.com/</span><br><span class="line">License     : GPLv2</span><br><span class="line">Description : VirtIO para-virtualized Windows(R) drivers <span class="keyword">for</span> 32-bit and 64-bit</span><br><span class="line">            : Windows(R) guests.</span><br><span class="line"></span><br><span class="line">$ yum -y install virtio-win</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢目前 virtio-win 的支援程度</span></span><br><span class="line">$ ls -R /usr/share/virtio-win</span><br><span class="line">/usr/share/virtio-win:</span><br><span class="line">drivers  guest-agent  virtio-win-0.1.102_amd64.vfd  virtio-win-0.1.102.iso  virtio-win-0.1.102_x86.vfd  virtio-win_amd64.vfd  virtio-win.iso  virtio-win_x86.vfd</span><br><span class="line"></span><br><span class="line">/usr/share/virtio-win/drivers:</span><br><span class="line">amd64  i386</span><br><span class="line"></span><br><span class="line">/usr/share/virtio-win/drivers/amd64:</span><br><span class="line">Win2003  Win2008  Win2008R2  Win2012  Win2012R2  Win7  Win8  Win8.1</span><br><span class="line">.......</span><br><span class="line">/usr/share/virtio-win/drivers/amd64/Win2012R2:</span><br><span class="line">netkvm.cat  netkvm.inf  netkvm.sys  vioscsi.cat  vioscsi.inf  vioscsi.sys  viostor.cat  viostor.inf  viostor.sys</span><br><span class="line">.......</span><br><span class="line">/usr/share/virtio-win/drivers/amd64/Win7:</span><br><span class="line">netkvm.cat  netkvm.inf  netkvm.sys  qxl.cat  qxldd.dll  qxl.inf  qxl.sys  vioscsi.cat  vioscsi.inf  vioscsi.sys  viostor.cat  viostor.inf  viostor.sys</span><br><span class="line">.......</span><br></pre></td></tr></table></figure>
<blockquote>
<p>從上面的檔案列表得知，目前 stable 的 virtio-win 支援到 Windows 2012R2 &amp; Windows 8.1，若要更新的 Windows OS 需求，可能要使用 latest 版本</p>
</blockquote>
<p>若希望可以在最新版的 Windows 上安裝 virtio driver，那就要升級到最新版的 virtio-win，可以透過以下的指令來啟用最新的 repository &amp; 升級：(目前最新版已經支援 Windows 10)</p>
<blockquote>
<p>yum –enablerepo=virtio-win-latest update virtio-win</p>
</blockquote>
<p>使用方式很容易，只要在啟動 windows virtual machine 時，指定 CDRom 裝置掛載 <font color="red"><strong>/usr/share/virtio-win/virtio-win-0.1.102.iso</strong></font> 後，進入 Windows 把相關的 virtio 裝置驅動即可，詳細的使用方式可以參考 =&gt; <a href="http://www.lijyyh.com/2015/12/linux-kvm-set-up-linux-kvm.html" target="_blank" rel="noopener">傲笑紅塵路: 架設 Linux KVM 虛擬化主機 (Set up Linux KVM virtualization host)</a></p>
<hr>
<h1 id="使用-virtio-balloon"><a href="#使用-virtio-balloon" class="headerlink" title="使用 virtio_balloon"></a>使用 virtio_balloon</h1><h2 id="balloonning-Overview"><a href="#balloonning-Overview" class="headerlink" title="balloonning Overview"></a>balloonning Overview</h2><p><img src="http://smilejay.com/wp-content/uploads/2012/11/linux-ballooning-demo.jpg" alt="KVM ballooning"></p>
<p>透過 balloon 的技術，可以如上圖所示，在 virtual machine 運行時動態調整記憶體的配置，而不需要 virtual machine 關機。</p>
<p>情境如下：</p>
<ol>
<li><p>當 host machine 記憶體空間不足時，在 virtual machine 中的記憶體 balloon 會膨脹(inflate)，讓 virtual machine 實際上無法使用到太多的記憶體，進而讓記憶體空間可以讓 host machine 暫時利用</p>
</li>
<li><p>當 virtual machine 記憶體空間不足時，在 virtual machine 中的記憶體 balloon 則會壓縮(deflate)，讓 host machine 可以分配閒置的記憶體給 virtual machine</p>
</li>
</ol>
<blockquote>
<p>以上功能必須透過 <code>virtio-balloon driver</code> 來達成</p>
</blockquote>
<h2 id="使用-balloonning-技術的優缺點"><a href="#使用-balloonning-技術的優缺點" class="headerlink" title="使用 balloonning 技術的優缺點"></a>使用 balloonning 技術的優缺點</h2><p>使用 balloon 的技術肯定也是有優缺點的，管理者可以根據實際需求評估使用：</p>
<p>優點如下：</p>
<ul>
<li><p>由於 balloonning 是能夠被監控 &amp; 控制的(不同於不可控制的 KSM 技術)，因此能夠有效率的節省記憶體的實際耗用</p>
</li>
<li><p>balloonning 對於記憶體的調度是很靈活的</p>
</li>
<li><p>hypervisor 透過 balloonning 從 virtual machine 中取得歸還的部分記憶體空間，不一定一定要用在其他地方，可自己保留住，端看管理者想要如何管理記憶體空間</p>
</li>
</ul>
<p>但 balloonning 同樣也是有些缺點存在的的：</p>
<ul>
<li><p>virtual machine 必須安裝 virtio_balloon driver 才可使用此功能(新版的 Linux 有內建，但 Windows 就必須要另外安裝了)</p>
</li>
<li><p>若透過 balloonning 從 virtual machine 中取回大量的記憶體空間，可能會提升 virtual machine 對於 swap 的 I/O 存取而導致效能降低；也有可能會造成 virtual machine 中的某些 process 運作時發生記憶體不足的況狀而失敗</p>
</li>
<li><p>雖然 balloonning 可被監控 &amp; 控制，但目前尚缺乏有效的自動化機制，對於大規模佈署使用上是不方便的</p>
</li>
<li><p>記憶體動態調整的過於頻繁，可能會使記憶體空間配置上過於零散而不連續，如此一來記憶體的使用效率就會降低</p>
</li>
</ul>
<h2 id="在-QEMU-KVM-中使用-balloonning"><a href="#在-QEMU-KVM-中使用-balloonning" class="headerlink" title="在 QEMU/KVM 中使用 balloonning"></a>在 QEMU/KVM 中使用 balloonning</h2><p>首先要先檢查 host machine 是否支援 balloonning：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cat /boot/config-`uname -r` | grep VIRTIO</span><br><span class="line">CONFIG_VIRTIO_BLK=m</span><br><span class="line">CONFIG_SCSI_VIRTIO=m</span><br><span class="line">CONFIG_VIRTIO_NET=m</span><br><span class="line">CONFIG_VIRTIO_CONSOLE=m</span><br><span class="line">CONFIG_HW_RANDOM_VIRTIO=m</span><br><span class="line">CONFIG_VIRTIO=m</span><br><span class="line">CONFIG_VIRTIO_PCI=m</span><br><span class="line">CONFIG_VIRTIO_PCI_LEGACY=y</span><br><span class="line">CONFIG_VIRTIO_BALLOON=m</span><br><span class="line">CONFIG_VIRTIO_INPUT=m</span><br><span class="line"><span class="comment"># CONFIG_VIRTIO_MMIO is not set</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>CONFIG_VIRTIO_BALLOON=m 表示已經支援(以 module 方式載入)</p>
</blockquote>
<p>接著要在 virtual machine 中啟用 balloonning，則必須在啟動 virtual machine 的指令中加上以下參數：(預設為 <code>-balloon none</code>)</p>
<blockquote>
<p>-balloon virtio[,addr=addr]</p>
</blockquote>
<p>參數中的 addr 是可用來指定 virtual machine 中 balloon device 的 PCI address</p>
<p>也可以使用 <font color="red"><strong>-device</strong></font> 參數來統一設定不同的 device，使用方法如下：</p>
<blockquote>
<p>-device driver[,prop[=value][,…]]</p>
</blockquote>
<p>了解啟用 balloon 的參數後，可以用以下指令啟動搭載 balloonning 功能的 virtual machine：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kvm -vnc 0.0.0.0:1 -m 2048 /kvm/storage/vm_disks/ubnutu1604.img \</span><br><span class="line">  -net nic -net tap,script=/etc/qemu-ifup \</span><br><span class="line">  -device virtio-balloon-pci --daemonize</span><br></pre></td></tr></table></figure>
<p>接著連線到 virtual machine 中，查詢 balloonning device 的狀態：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># balloon 功能已開啟</span></span><br><span class="line">ubuntu@vm-ubuntu1604:~$ cat /boot/config-`uname -r` | grep VIRTIO</span><br><span class="line">.....</span><br><span class="line">CONFIG_VIRTIO_BALLOON=y</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視目前 pci device 狀態</span></span><br><span class="line">ubuntu@vm-ubuntu1604:~$ lspci</span><br><span class="line">00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)</span><br><span class="line">00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]</span><br><span class="line">00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]</span><br><span class="line">00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03)</span><br><span class="line">00:02.0 VGA compatible controller: Cirrus Logic GD 5446</span><br><span class="line">00:03.0 Ethernet controller: Intel Corporation 82540EM Gigabit Ethernet Controller (rev 03)</span><br><span class="line">00:04.0 Unclassified device [00ff]: Red Hat, Inc Virtio memory balloon</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢 balloonning device 的詳細資訊</span></span><br><span class="line">ubuntu@vm-ubuntu1604:~$ lspci -s 00:04.0 -v</span><br><span class="line">00:04.0 Unclassified device [00ff]: Red Hat, Inc Virtio memory balloon</span><br><span class="line">        Subsystem: Red Hat, Inc Virtio memory balloon</span><br><span class="line">        Physical Slot: 4</span><br><span class="line">        Flags: bus master, fast devsel, latency 0, IRQ 11</span><br><span class="line">        I/O ports at c040 [size=32]</span><br><span class="line">        Kernel driver <span class="keyword">in</span> use: virtio-pci</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視 virtual machine 記憶體狀態</span></span><br><span class="line">ubuntu@vm-ubuntu1604:~$ free -m</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           2000          40        1851           3         108        1823</span><br><span class="line">Swap:          2045           0        2045</span><br></pre></td></tr></table></figure>
<p>接著在 QEMU monitor 中透過 <code>balloon 512</code> 把 virtual machine 的記憶體限縮到僅能使用 512 MB：</p>
<p><img src="https://github.com/godleon/godleon.github.io/blob/master/_posts/images/2016/KVM-Paravirtualization-Drivers/kvm_virtio_balloon.PNG?raw=true" alt="balloon"></p>
<p>以下是 virtual machine 中目前的記憶體狀況：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 經過 balloon 縮小可用記憶體空間後，檢視記憶體狀態</span></span><br><span class="line">ubuntu@vm-ubuntu1604:~$ free -m</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:            464          39         316           3         108         288</span><br><span class="line">Swap:          2045           0        2045</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看出 total memory 已經變少，可見 balloon 的確是起了作用</p>
</blockquote>
<p>另外一個比較需要注意的是，balloon 沒辦法用於增加 virtual machine 的記憶體配置；例如，啟用 virtual machine 時配置了 2048 MB 的記憶體，即使在 QEMU monitor 中使用 <code>ballon 4096</code>，也無法讓 virtual machine 的記憶體變成 4096 MB。</p>
<hr>
<h1 id="使用-virtio-net"><a href="#使用-virtio-net" class="headerlink" title="使用 virtio_net"></a>使用 virtio_net</h1><p>使用 virtio network device，有提高 throughput &amp; 降低 latency 的兩項優點，可以達到接近原生網卡的效能，因此通常是配置網路時的優先選擇。</p>
<p>以下指令可以查詢是否支援 virtio_net：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 有出現 virtio 表示支援 virtio network device</span></span><br><span class="line">$ kvm -net nic,model=?</span><br><span class="line">qemu: Supported NIC models: ne2k_pci,i82551,i82557b,i82559er,rtl8139,e1000,pcnet,virtio</span><br></pre></td></tr></table></figure>
<h2 id="1、啟用支援-virtio-net-的-vitual-machine"><a href="#1、啟用支援-virtio-net-的-vitual-machine" class="headerlink" title="1、啟用支援 virtio_net 的 vitual machine"></a>1、啟用支援 virtio_net 的 vitual machine</h2><p>接著可以用以下指令啟動一個使用 virtio_net 的 virtual machine：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kvm -vnc 0.0.0.0:1 -m 2048 --daemonize \</span><br><span class="line">  -drive format=raw,file=/kvm/storage/vm_disks/ubnutu1604.img \</span><br><span class="line">  -device virtio-balloon-pci \</span><br><span class="line">  -net nic,model=virtio -net tap</span><br></pre></td></tr></table></figure>
<p>當 virtual machine 啟動後，登入檢查 virtio_net 的狀態：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ubuntu 16.04 原生已經搭載 virtio driver</span></span><br><span class="line">ubuntu@vm-ubuntu1604:~$ cat /boot/config-`uname -r` | grep VIRTIO</span><br><span class="line">.....</span><br><span class="line">CONFIG_VIRTIO_NET=y</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可看出目前 virtual machine 的網卡已經以 virtio 模式運作</span></span><br><span class="line">ubuntu@vm-ubuntu1604:~$ lspci</span><br><span class="line">....</span><br><span class="line">00:03.0 Ethernet controller: Red Hat, Inc Virtio network device</span><br><span class="line">00:04.0 Unclassified device [00ff]: Red Hat, Inc Virtio memory balloon</span><br><span class="line"></span><br><span class="line"><span class="comment"># virtio_net 詳細資訊</span></span><br><span class="line">ubuntu@vm-ubuntu1604:~$ lspci -vv -s 00:03.0</span><br><span class="line">00:03.0 Ethernet controller: Red Hat, Inc Virtio network device</span><br><span class="line">        Subsystem: Red Hat, Inc Virtio network device</span><br><span class="line">        Physical Slot: 3</span><br><span class="line">        Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR+ FastB2B- DisINTx+</span><br><span class="line">        Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast &gt;TAbort- &lt;TAbort- &lt;MAbort- &gt;SERR- &lt;PERR- INTx-</span><br><span class="line">        Latency: 0</span><br><span class="line">        Interrupt: pin A routed to IRQ 11</span><br><span class="line">        Region 0: I/O ports at c000 [size=32]</span><br><span class="line">        Region 1: Memory at febd1000 (32-bit, non-prefetchable) [size=4K]</span><br><span class="line">        Expansion ROM at feb80000 [disabled] [size=256K]</span><br><span class="line">        Capabilities: &lt;access denied&gt;</span><br><span class="line">        Kernel driver <span class="keyword">in</span> use: virtio-pci</span><br></pre></td></tr></table></figure>
<h2 id="2、進一步提升半虛擬化網卡效能"><a href="#2、進一步提升半虛擬化網卡效能" class="headerlink" title="2、進一步提升半虛擬化網卡效能"></a>2、進一步提升半虛擬化網卡效能</h2><h3 id="1-關閉-TSO-amp-GSO-以提升-virtio-net-的效能"><a href="#1-關閉-TSO-amp-GSO-以提升-virtio-net-的效能" class="headerlink" title="(1) 關閉 TSO &amp; GSO 以提升 virtio_net 的效能"></a>(1) 關閉 TSO &amp; GSO 以提升 virtio_net 的效能</h3><p>為了提升 virtual machine 網卡的效能，除了使用 virtio 半虛擬化的技術外，還可以透過關閉 host machine 的 TSO &amp; GSO 功能來更進一步提升</p>
<p>以下可以檢查 host machine 的網卡是否支援 TSO &amp; GSO：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ethtool -k ens1f1</span><br><span class="line">Features <span class="keyword">for</span> ens1f1:</span><br><span class="line">.....</span><br><span class="line">tcp-segmentation-offload: on</span><br><span class="line">        tx-tcp-segmentation: on</span><br><span class="line">        tx-tcp-ecn-segmentation: off [fixed]</span><br><span class="line">        tx-tcp6-segmentation: on</span><br><span class="line">.....</span><br><span class="line">generic-segmentation-offload: on</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>
<p>從上面可以看出目前 TSO &amp; GSO 的功能都是開啟的，可以透過以下方式關閉：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ethtool -K ens1f1 tso off</span><br><span class="line">$ ethtool -K ens1f1 gso off</span><br></pre></td></tr></table></figure>
<p>如此一來 virtio_net 的效能就可以進一步的提升。</p>
<h3 id="2-使用-vhost-net-後端驅動"><a href="#2-使用-vhost-net-後端驅動" class="headerlink" title="(2) 使用 vhost-net 後端驅動"></a>(2) 使用 vhost-net 後端驅動</h3><p>一般來說，virtio 在 host machine 是由每個 user space 中的 QEMU 來進行後端處理的，但若是可以將 network I/O 的部分移到 kernel space 來處理，不僅可以提高 network throughput，還可以降低 latency，進而提升網路的效率。</p>
<p>目前比較新的 Linux kernel 中都有搭載稱為 <strong><font color="red">vhost-net</font></strong> 的 module，可用來將 virtio_net 的後端處理移到 Linux kernel 中進行來提升 network I/O 的效率。</p>
<p>首先先來檢查 host machine 是否支援 <strong>vhost-net</strong> 的功能：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat /boot/config-`uname -r` | grep VHOST</span><br><span class="line">CONFIG_VHOST_NET=m</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">$ lsmod | grep vhost</span><br><span class="line">vhost_net              18152  1</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>從上面可以看出 host machine 有支援 vhost-net，接著就可以使用以下指令啟動支援 vhost-net 的 virtual machine：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kvm -vnc 0.0.0.0:1 -m 2048 --daemonize \</span><br><span class="line">  -drive format=raw,file=/kvm/storage/vm_disks/ubnutu1604.img,<span class="keyword">if</span>=virtio \</span><br><span class="line">  -device virtio-balloon-pci \</span><br><span class="line">  -netdev tap,id=net0,vhost=on -device virtio-net-pci,netdev=net0</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="使用-virtio-blk"><a href="#使用-virtio-blk" class="headerlink" title="使用 virtio_blk"></a>使用 virtio_blk</h1><p>virtio_blk 提供了 virtual machine 可以透過 virtio API 進行 block device I/O 的相關驅動程式，藉以提升存取 block device 的效能。</p>
<p>同樣的，要使用 virtio_blk，host machine &amp; virtual machine 都必須要同時支援才行，目前新版的 Linux 都已經預設搭載 virtio driver 了，我們用以下的指令啟動支援 virtio_blk 的 virtual machine：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kvm -vnc 0.0.0.0:1 -m 2048 --daemonize \</span><br><span class="line">  -drive format=raw,file=/kvm/storage/vm_disks/ubnutu1604.img \</span><br><span class="line">  -device virtio-balloon-pci \</span><br><span class="line">  -netdev tap,id=net0,vhost=on -device virtio-net-pci,netdev=net0</span><br></pre></td></tr></table></figure>
<p>進入到 virtual machine 之後，可以透過以下指令確認 block device 的確是以 virtio driver 所驅動：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@vm-ubuntu1604:~$ cat /boot/config-`uname -r` | grep VIRTIO_BLK</span><br><span class="line">CONFIG_VIRTIO_BLK=y</span><br><span class="line"></span><br><span class="line">ubuntu@vm-ubuntu1604:~$ lspci | grep -i virtio</span><br><span class="line">00:03.0 Unclassified device [00ff]: Red Hat, Inc Virtio memory balloon</span><br><span class="line">00:04.0 Ethernet controller: Red Hat, Inc Virtio network device</span><br><span class="line">00:05.0 SCSI storage controller: Red Hat, Inc Virtio block devicei</span><br><span class="line"></span><br><span class="line">ubuntu@vm-ubuntu1604:~$ lspci -vv -s 00:05.0</span><br><span class="line">00:05.0 SCSI storage controller: Red Hat, Inc Virtio block device</span><br><span class="line">        Subsystem: Red Hat, Inc Virtio block device</span><br><span class="line">        Physical Slot: 5</span><br><span class="line">        Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR+ FastB2B- DisINTx+</span><br><span class="line">        Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast &gt;TAbort- &lt;TAbort- &lt;MAbort- &gt;SERR- &lt;PERR- INTx-</span><br><span class="line">        Latency: 0</span><br><span class="line">        Interrupt: pin A routed to IRQ 10</span><br><span class="line">        Region 0: I/O ports at c000 [size=64]</span><br><span class="line">        Region 1: Memory at febd2000 (32-bit, non-prefetchable) [size=4K]</span><br><span class="line">        Capabilities: &lt;access denied&gt;</span><br><span class="line">        Kernel driver <span class="keyword">in</span> use: virtio-pci</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><p><a href="https://read01.com/4aJdOL.html" target="_blank" rel="noopener">Virtio 基本概念和設備操作 - 壹讀</a></p>
</li>
<li><p><a href="http://www.cnblogs.com/sammyliu/p/4543657.html" target="_blank" rel="noopener">KVM 介绍（3）：I/O 全虚拟化和准虚拟化 [KVM I/O QEMU Full-Virtualizaiton Para-virtualization] - SammyLiu - 博客园</a></p>
</li>
<li><p><a href="http://www.lijyyh.com/2015/12/linux-kvm-set-up-linux-kvm.html" target="_blank" rel="noopener">傲笑紅塵路: 架設 Linux KVM 虛擬化主機 (Set up Linux KVM virtualization host)</a></p>
</li>
<li><p><a href="https://fedoraproject.org/wiki/Windows_Virtio_Drivers" target="_blank" rel="noopener">Windows Virtio Drivers - FedoraProject</a></p>
</li>
<li><p><a href="http://www.linux-kvm.org/page/Virtio" target="_blank" rel="noopener">Virtio - KVM</a></p>
</li>
<li><p><a href="http://seitran.com/2015/04/13/01-gso-gro-lro/" target="_blank" rel="noopener">网卡TSO/GSO/LRO/GRO简要介绍 | Chenny的部落格</a></p>
</li>
<li><p><a href="http://lirobo.blogspot.tw/2014/12/tso-gso-lro-gro.html" target="_blank" rel="noopener">小蘿蔔工作室 Little Robot Studio: TSO, GSO, LRO, GRO</a></p>
</li>
<li><p><a href="https://kris.io/2015/10/01/kvm-network-performance-tso-and-gso-turn-it-off/" target="_blank" rel="noopener">KVM Network Performance : TSO and GSO - Turn it off - kris.io : virtualization &amp; cloud</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> KVM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> KVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Linux KVM] Linux KVM concept - Networking]]></title>
      <url>/blog/2016/08/10/KVM/KVM-Basic-Concept-Networking/</url>
      <content type="html"><![CDATA[<p>此篇文章介紹學習 Linux KVM 時所需要了解的 Networking 相關知識</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>現今的虛擬化技術中，網路的部分永遠都是比重相當高的一部分，許多大型的 service provider 透過網路提供各種不同的服務給使用者，讓使用者在 IT 科技的幫助下，生活更加便利。</p>
<p>也因為這樣，當網路發生故障時，這些公司的損失常常難以估計，因此網路架構的設計上，保有彈性 &amp; 穩定性是相當重要的。</p>
<p>而現在 server 普遍都擁有多張網路卡，為了提高網路使用效率 &amp; 增加備援功能，建議 <strong><font color="red">透過 Linux bonding 的技術將所有的網路卡設定成為 single virtual channel</font></strong>。</p>
<blockquote>
<p>bonding mode 有分為 Mode 1(active-backup)、Mode 2(balance-xor)、Mode 4(802.3ad/LACP)、Mode 5(balance-tlb)，其中建議使用 <code>Mode 1(active-backup)</code> &amp; <code>Mode 5(balance-tlb)</code></p>
</blockquote>
<hr>
<h1 id="KVM-QEMU-支援的-Network-Type"><a href="#KVM-QEMU-支援的-Network-Type" class="headerlink" title="KVM/QEMU 支援的 Network Type"></a>KVM/QEMU 支援的 Network Type</h1><p>網路絕對是使用 vitual machine 時最不可或缺的一部分，而 QEMU 提供了 virtual machine 一共四種不同的 network type：</p>
<ol>
<li><p>bridge</p>
</li>
<li><p>NAT</p>
</li>
<li><p>user mode networking</p>
</li>
<li><p>VT-d &amp; SR-IOV (直接分配網路設備)</p>
</li>
</ol>
<p>要透過 QEMU 配置 virtual machine 的網路，必須使用 <code>-net</code> 參數，若是完全沒使用任何的網路相關參數，會系統自動帶上 <code>-net nic -net user</code> 做為網路預設值。</p>
<p>而 QEMU 可以模擬那些網路卡呢? 肯定必須是主流且被廣泛支援的，可以用以下指令查詢：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kvm -net nic,model=?</span><br><span class="line">qemu: Supported NIC models: ne2k_pci,i82551,i82557b,i82559er,rtl8139,e1000,pcnet,virtio</span><br></pre></td></tr></table></figure>
<blockquote>
<p>若沒指定任何網路相關參數，則預設會使用 RTL8139 網卡</p>
</blockquote>
<hr>
<h1 id="設定第一張虛擬網卡"><a href="#設定第一張虛擬網卡" class="headerlink" title="設定第一張虛擬網卡"></a>設定第一張虛擬網卡</h1><p>為了要設定虛擬網卡，必須先了解 <code>-net nic</code> 相關參數：</p>
<blockquote>
<p>-net nic[,vlan=n][,macaddr=mac][,model=type] [,name=name][,addr=addr][,vectors=v]</p>
</blockquote>
<ul>
<li><p><code>-net nic</code>：表示這是一個網卡的設定 (<strong><font color="red">必要!</font></strong>)</p>
</li>
<li><p><code>vlan=n</code>：將網卡連結到 ID 為 <strong><font color="red">n</font></strong> 的 VLAN</p>
</li>
<li><p><code>macaddr=mac</code>：指定網卡 MAC address</p>
</li>
<li><p><code>model=type</code>：設定網卡的種類，預設為 <strong><font color="red">rtl8139</font></strong></p>
</li>
<li><p><code>name=name</code>：為網卡命名(但僅有在 QEMU monitor 看的到)</p>
</li>
<li><p><code>addr=addr</code>：指定網卡在 virtual machine 中的 PCI device address</p>
</li>
<li><p><code>vectors=v</code>：設定網卡設備的 MSI-X 向量的數量，用於 virtio 驅動的網卡上</p>
</li>
</ul>
<p>簡單做個測試，我們透過以下指令指定網卡：</p>
<blockquote>
<p>kvm -vnc 0.0.0.0:1 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img -net nic,vlan=0,macaddr=52:53:00:11:12:13,model=e1000,addr=08 -net user</p>
</blockquote>
<p>於是在系統中可以得到以下訊息：</p>
<p><img src="https://lh3.googleusercontent.com/abxoQOVs8BrZGNtB7rvarf28_a0AomNu_UBJvLgblFG6uoAj2lWJnlMGMuujMu_V3ldlY2p2ZPYTQJa84180vlnBkGp4bkJmidQN29QBEO9zb9cWOOQOK5HTTOwglaXnEJ_WXdSnKO1xGFmKkdHZji1tulTDI_mihaOaghtA3YlT_I5ss4-OQbsdK2lIdLz_deaKnb5AcAQA9cmAt6rPaW0pocvL4THwvZY3d4QXOOMso96DPPTWntwl0qsHEd19BMg4B0uzuAbNlIVglYMX8k80YOTZxTQDsAFi16q5MDlgrTPDa0VY7UOoNFvI-7PWmktPf3RYSpXa1QQ6kmASVax3x3NCYC3pZW_HA27dxjwyA3GRM4IYtsjKA9EBjMkhpVZmHeoxAeCk9_gSXKMJUqEdg8u63JRm9xsJobEcOy_g_1YXmMPCc1v-8Mx1QFpwctMr5C7DXq8DI-C_Voz2Y8DGpz1p7prWgDb2j1v6daMfvJwJvtKAyw2p2HyulbsMuSZE3JNB6bsZLmJgi4WjvXT3rr32l1mJQcE64B4MK-ZLQMZjTA0g18g5w5wk5d83XtQiSahUc-5wGhudJ6l5sqqRwDQ1Nec=w771-h384-no" alt="System NIC Information"></p>
<p>在 QEMU monitor 則可以看到以下資訊：</p>
<p><img src="https://lh3.googleusercontent.com/RPzHnMisxvsHZx5xpTctONaavpAXkcjUxfqHdaiNfwYL-RyspfM2dGW4rffxz7Z-NyzLHH1ChC0zGwjNes5AclVYiW4-8Bb8YOgg61jHs58jmMchhv_ICNNvwhm-vkyHmkffIukmKxX7BqufthPly1VgVMNI1J2x17l66DD2LicTEbGPQB-414rpc8tTR1l3pBPnoNPZuaxTNCXNYlkfmvQUdx1ltYfWusoEUsxhLckpakEJ_F8qCEGrJ-dmLgh6BbLjDNlDfqBix-bMJaBdGlyngC8XvWR-f45eTKUyPCukFb-oSFVFH1VspTRqsBgccbSH06fKlq12CDu0pNhBNbte6zFPt7oJMAFn_Yf2ENBWXQbFjRs2H0x8eaCcQ0MiXY01wUmsNYoGJsgmZgKJZ2jQdhLDXu4bjtoH-0DuZw1NSfKPuIkDks9FdQR0j-adxK_rOg9oqpTdNOBOkU_QPfqQJUejhwlTr5OwjLjGkD5XIYHKbXU72D66eDCZNTMVUGxWo_EkhVluszNlN1PiCzOdqlRK4StC0LVWUFscHLHwyEjHuwTwg0BEIRs91_-nD0DrJT5mZF7emdCRPStDDdWGdP9ftVY=w541-h153-no" alt="Network Info in QEMU monitor"></p>
<hr>
<h1 id="設定-Bridge-Mode"><a href="#設定-Bridge-Mode" class="headerlink" title="設定 Bridge Mode"></a>設定 Bridge Mode</h1><h2 id="設定參數說明"><a href="#設定參數說明" class="headerlink" title="設定參數說明"></a>設定參數說明</h2><p>在 bridge mode 下，virtual machine 的網路可視為與 host machine 是相同的，可以有自己的獨立 ip，外部網路可以直接存取 virtual machine。</p>
<p>以下是建立 bridge mode NIC 的參數：</p>
<blockquote>
<p>-net tap[,vlan=n][,name=name][,fd=h][,ifname=name][,script=file][,downscript=dfile][,helper=helper]</p>
</blockquote>
<ul>
<li><p><code>tap</code>：表示使用 tap device(屬於 layer 2 的虛擬網路設備；附帶一提，<code>tun</code> 則是屬於 layer 3 的虛擬網路設備)</p>
</li>
<li><p><code>vlan=n</code>：指定使用的 VLAN ID</p>
</li>
<li><p><code>name=name</code>：設定網卡名稱(可從 QEMU monitor 中檢視，但大多數情況下可忽略)</p>
</li>
<li><p><code>fd=h</code>：連接到已經開啟 tap 的 file descriptor (<strong>一般交給 QEMU 自行建立</strong>)</p>
</li>
<li><p><code>ifname=name</code>：設定 tap device 名稱(未設定的話會由 QEMU 自行產生)</p>
</li>
<li><p><code>script=file</code>：指定啟動 virtual machine 時自動執行的 script</p>
</li>
<li><p><code>downscript=dfile</code>：指定關閉 virtual machine 時自動執行的 script</p>
</li>
<li><p><code>helper=helper</code>：指定啟動 virtual machine 時會在 host machine 上執行的 helper 程式(例如：建立 tap device)，一般可以忽略使用預設值即可</p>
</li>
</ul>
<h2 id="建立支援-bridge-mode-的環境"><a href="#建立支援-bridge-mode-的環境" class="headerlink" title="建立支援 bridge mode 的環境"></a>建立支援 bridge mode 的環境</h2><h3 id="1、檢查環境支援程度"><a href="#1、檢查環境支援程度" class="headerlink" title="1、檢查環境支援程度"></a>1、檢查環境支援程度</h3><p>在建立 bridge 模式的網路配置之前，我們必須先確定 host machine 已經掛載相關模組：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 檢查是否有掛載 tun 模組</span></span><br><span class="line">$ lsmod | grep tun</span><br><span class="line">tun                    27141  1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 確認目前的 user 有 /dev/net/tun 的讀寫權限</span></span><br><span class="line">$ ls -al /dev/net/tun</span><br><span class="line">crw-rw-rw-. 1 root root 10, 200 Aug  3 20:14 /dev/net/tun</span><br></pre></td></tr></table></figure>
<h3 id="2、在-host-machine-上可建立-bridge-device-的環境"><a href="#2、在-host-machine-上可建立-bridge-device-的環境" class="headerlink" title="2、在 host machine 上可建立 bridge device 的環境"></a>2、在 host machine 上可建立 bridge device 的環境</h3><p>環境說明：</p>
<ul>
<li><p>bridge device：<code>br0</code></p>
</li>
<li><p>physical device：<code>ens1f0</code></p>
</li>
<li><p>ip address：<code>10.20.190.2/24</code></p>
</li>
<li><p>gateway：<code>10.20.190.1</code></p>
</li>
</ul>
<p>以下要在 host machine 上建立一個 bridge device，並綁定到要連外的實體網卡，並讓 bridge device 成為連接 host machine 與外網的設備：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># nmcli connection add type bridge ifname br0</span></span><br><span class="line">[root@localhost ~]<span class="comment"># nmcli connection modify bridge-br0 bridge.stp yes</span></span><br><span class="line"><span class="comment"># 以下請根據自身的 lab 環境做調整</span></span><br><span class="line">[root@localhost ~]<span class="comment"># nmcli connection modify bridge-br0 ipv4.method manual ipv4.address "10.20.190.2/24" ipv4.gateway "10.20.190.1" ipv4.dns 8.8.8.8</span></span><br><span class="line">[root@localhost ~]<span class="comment"># nmcli connection add type bridge-slave ifname ens1f0 master br0</span></span><br><span class="line">[root@localhost ~]<span class="comment"># nmcli connection delete ens1f0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bridge device 設定完成後，可以檢查是否有與實體網卡連動</span></span><br><span class="line">$ brctl show</span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">br0             8000.2c600cb163d5       yes             ens1f0</span><br><span class="line">virbr0          8000.5254001001dc       yes             virbr0-nic</span><br></pre></td></tr></table></figure>
<p>設定完成後，實體網路卡會進入到 <strong><font color="red">promiscuous mode</font></strong>，而 bridge device 則會進入到 <strong><font color="red">forwarding state</font></strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ dmesg | grep ens1f0</span><br><span class="line">.....</span><br><span class="line">[807464.149861] device ens1f0 entered promiscuous mode</span><br><span class="line">.....</span><br><span class="line">[807494.252510] br0: port 1(ens1f0) entered forwarding state</span><br></pre></td></tr></table></figure>
<p>接著建立要進行 bridge 網路配置用的 script(<strong><font color="red">/etc/qemu-if{up,down}</font></strong>) 並設定可執行權限：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立 script (/etc/qemu-ifup)</span></span><br><span class="line">$ cat &lt;&lt;\EOF &gt;/etc/qemu-ifup</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#This is a qemu-ifup script for bridging.</span></span><br><span class="line"><span class="comment">#You can use it when starting a KVM guest with bridge mode network.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#set your bridge name</span></span><br><span class="line">switch=br0</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$1</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="comment">#start up the TAP interface</span></span><br><span class="line">  ip link <span class="built_in">set</span> <span class="variable">$1</span> up</span><br><span class="line">  sleep 1</span><br><span class="line">  <span class="comment">#add TAP interface to the bridge</span></span><br><span class="line">  brctl addif <span class="variable">$&#123;switch&#125;</span> <span class="variable">$1</span></span><br><span class="line">  <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> “Error: no interface specified”</span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">$ cat &lt;&lt;\EOF &gt;/etc/qemu-ifdown</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#This is a qemu-ifdown script for bridging.</span></span><br><span class="line"><span class="comment">#You can use it when starting a KVM guest with bridge mode network.</span></span><br><span class="line"><span class="comment">#Don’t use this script in most cases; QEMU will handle it automatically.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#set your bridge name</span></span><br><span class="line">switch=br0</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$1</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="comment"># Delete the specified interfacename</span></span><br><span class="line">  tunctl -d <span class="variable">$1</span></span><br><span class="line">  <span class="comment">#release TAP interface from bridge</span></span><br><span class="line">  brctl delif <span class="variable">$&#123;switch&#125;</span> <span class="variable">$1</span></span><br><span class="line">  <span class="comment">#shutdown the TAP interface</span></span><br><span class="line">  ip link <span class="built_in">set</span> <span class="variable">$1</span> down</span><br><span class="line">  <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> “Error: no interface specified”</span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定執行權限</span></span><br><span class="line">$ chmod +x /etc/qemu-if&#123;up,down&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>若是目前使用者沒有 script 的 execute 權限，就無法新增 tap interface for bridge mode 喔!</p>
</blockquote>
<h3 id="3、啟動-bridge-mode-virtual-machine"><a href="#3、啟動-bridge-mode-virtual-machine" class="headerlink" title="3、啟動 bridge-mode virtual machine"></a>3、啟動 bridge-mode virtual machine</h3><p>當上述環境都準備好後，可使用以下指令啟動 virtual machine：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -net nic -net tap =&gt; 指定 virtual machine 網卡為 bridge mode，建立 tap interface</span></span><br><span class="line"><span class="comment"># script=/etc/qemu-ifup =&gt; 指定 script 配置網卡</span></span><br><span class="line"><span class="comment"># downscript=/etc/qemu-ifdown =&gt; 指定 script 移除網卡 (若設定為 no 則 QEMU 會自動協助處理)</span></span><br><span class="line"><span class="comment"># --daemonize =&gt; QEMU 程序背景執行</span></span><br><span class="line">$ kvm -vnc 0.0.0.0:1 -m 2048 /kvm/storage/vm_disks/ubnutu1604.img -net nic -net tap,script=/etc/qemu-ifup,downscript=/etc/qemu-ifdown --daemonize</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢是否有啟動 tap interface 並與 bridge device 相連</span></span><br><span class="line">$ brctl show</span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">br0             8000.26503b3a5e74       yes             ens1f0</span><br><span class="line">                                                        tap0</span><br><span class="line">virbr0          8000.5254001001dc       yes             virbr0-nic</span><br></pre></td></tr></table></figure>
<p>當 virtual machine 啟動後(會在 DHCP 的地方卡一段時間)，在 virtual machine 中可以透過以下指令設定 IP：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假設新增的 network interface 為 ens3</span></span><br><span class="line">$ sudo ip addr add 10.20.190.3/24 dev ens3</span><br><span class="line">$ sudo ip route add 0.0.0.0/0 via 10.20.190.1 dev ens3</span><br></pre></td></tr></table></figure>
<p>如此一來在網路的部分就可以等同 host machine 一樣，正常存取 Internet &amp; 提供網路服務了</p>
<p>詳細的設定操作可以參考下圖：</p>
<p><img src="https://github.com/godleon/godleon.github.io/blob/master/_posts/images/2016/KVM-Basic-Concept-Networking/kvm_network-bridge-mode-configure-ip.PNG?raw=true" alt="Configure static IP by using ip command"></p>
<hr>
<h1 id="設定-NAT-mode"><a href="#設定-NAT-mode" class="headerlink" title="設定 NAT mode"></a>設定 NAT mode</h1><h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p>NAT 是為了解決 public ip address 不足而產生的，其詳細的原理這邊就不贅述了，可參考下列網址：</p>
<ul>
<li><a href="http://linux.vbird.org/linux_server/0250simple_firewall/0320nat.php" target="_blank" rel="noopener">鳥哥的 Linux 私房菜 – Network Address Transfer ( NAT ) 架設</a></li>
</ul>
<h2 id="檢查-host-machine-環境"><a href="#檢查-host-machine-環境" class="headerlink" title="檢查 host machine 環境"></a>檢查 host machine 環境</h2><h3 id="1、檢查-bridge-device"><a href="#1、檢查-bridge-device" class="headerlink" title="1、檢查 bridge device"></a>1、檢查 bridge device</h3><p>在 QEMU/KVM 中，使用 NAT mode 的 virtual machine 其實是透過 host machine 中的 <strong><font color="red">virbr0</font></strong> 這個 bridge device 連外的，可以來檢視一下相關資訊：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ ip addr show</span><br><span class="line">1: lo: .......</span><br><span class="line">2: eno1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP qlen 1000</span><br><span class="line">    link/ether 2c:60:0c:c1:b9:2d brd ff:ff:ff:ff:ff:ff</span><br><span class="line">3: ens1f0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq master br0 state UP qlen 1000</span><br><span class="line">    link/ether 2c:60:0c:b1:63:d5 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">4: ens1f1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP qlen 1000</span><br><span class="line">    link/ether 2c:60:0c:b1:63:d6 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">5: virbr0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN</span><br><span class="line">    link/ether 52:54:00:10:01:dc brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.122.1/24 brd 192.168.122.255 scope global virbr0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">6: virbr0-nic: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc pfifo_fast master virbr0 state DOWN qlen 500</span><br><span class="line">    link/ether 52:54:00:10:01:dc brd ff:ff:ff:ff:ff:ff</span><br><span class="line">7: br0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP</span><br><span class="line">    link/ether 2c:60:0c:b1:63:d5 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.20.190.2/24 brd 10.20.190.255 scope global br0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::2e60:cff:feb1:63d5/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<p>從上面可以看出，QEMU/KVM 已經幫我們把 virbr0 設定完成，使用的是 <code>192.168.122.1/24</code> 的網段。</p>
<h3 id="2、檢查-DHCP-服務"><a href="#2、檢查-DHCP-服務" class="headerlink" title="2、檢查 DHCP 服務"></a>2、檢查 DHCP 服務</h3><p>但關於 DHCP 的部分呢? QEMU/KVM 同樣也設定好 <strong><font color="red">dnsmasq</font></strong> 幫我們處理好 ip 的分配 &amp; traffic forwarding 的相關問題，若是要進一步的了解詳細的設定細節，可使用下面方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ ps -aux | grep dns</span><br><span class="line">nobody    4322  0.0  0.0  15552   888 ?        S    Jul27   0:01 /sbin/dnsmasq --conf-file=/var/lib/libvirt/dnsmasq/default.conf --leasefile-ro --dhcp-script=/usr/libexec/libvirt_leaseshelper</span><br><span class="line">root      4323  0.0  0.0  15524   176 ?        S    Jul27   0:00 /sbin/dnsmasq --conf-file=/var/lib/libvirt/dnsmasq/default.conf --leasefile-ro --dhcp-script=/usr/libexec/libvirt_leaseshelper</span><br><span class="line">root     16414  0.0  0.0 112652   976 pts/2    S+   06:02   0:00 grep --color=auto dns</span><br><span class="line"></span><br><span class="line">[root@ocp-kvm-host ~]<span class="comment"># cat /var/lib/libvirt/dnsmasq/default.conf</span></span><br><span class="line"><span class="comment">##WARNING:  THIS IS AN AUTO-GENERATED FILE. CHANGES TO IT ARE LIKELY TO BE</span></span><br><span class="line"><span class="comment">##OVERWRITTEN AND LOST.  Changes to this configuration should be made using:</span></span><br><span class="line"><span class="comment">##    virsh net-edit default</span></span><br><span class="line"><span class="comment">## or other application using the libvirt API.</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">## dnsmasq conf file created by libvirt</span></span><br><span class="line">strict-order</span><br><span class="line">pid-file=/var/run/libvirt/network/default.pid</span><br><span class="line">except-interface=lo</span><br><span class="line"><span class="built_in">bind</span>-dynamic</span><br><span class="line">interface=virbr0</span><br><span class="line">dhcp-range=192.168.122.2,192.168.122.254</span><br><span class="line">dhcp-no-override</span><br><span class="line">dhcp-lease-max=253</span><br><span class="line">dhcp-hostsfile=/var/lib/libvirt/dnsmasq/default.hostsfile</span><br><span class="line">addn-hosts=/var/lib/libvirt/dnsmasq/default.addnhosts</span><br></pre></td></tr></table></figure>
<h3 id="3、檢查-traffic-forward-設定"><a href="#3、檢查-traffic-forward-設定" class="headerlink" title="3、檢查 traffic forward 設定"></a>3、檢查 traffic forward 設定</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/sys/net/ipv4/ip_forward</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>‵<code>1</code> 表示 traffic forward 的功能是開啟的</p>
</blockquote>
<h3 id="3、檢查-firewall-設定"><a href="#3、檢查-firewall-設定" class="headerlink" title="3、檢查 firewall 設定"></a>3、檢查 firewall 設定</h3><p>最後要確認 host machine 可以將 virtual machine 對外的流量透過 virbr0 送出，因此要確認防火牆的設定：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iptables -t nat -L -vn</span></span><br><span class="line">Chain PREROUTING (policy ACCEPT 29 packets, 4041 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line"></span><br><span class="line">Chain INPUT (policy ACCEPT 5 packets, 1044 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 39 packets, 2906 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line"></span><br><span class="line">Chain POSTROUTING (policy ACCEPT 39 packets, 2906 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">    0     0 RETURN     all  --  *      *       192.168.122.0/24     224.0.0.0/24</span><br><span class="line">    0     0 RETURN     all  --  *      *       192.168.122.0/24     255.255.255.255</span><br><span class="line">    0     0 MASQUERADE  tcp  --  *      *       192.168.122.0/24    !192.168.122.0/24     masq ports: 1024-65535</span><br><span class="line">    0     0 MASQUERADE  udp  --  *      *       192.168.122.0/24    !192.168.122.0/24     masq ports: 1024-65535</span><br><span class="line">    0     0 MASQUERADE  all  --  *      *       192.168.122.0/24    !192.168.122.0/24</span><br></pre></td></tr></table></figure>
<blockquote>
<p>從上面可看出，來自於 192.168.122.0/24 網段且對外的流量，會以 NAT 的形式連外</p>
</blockquote>
<h2 id="建立可運行-NAT-mode-的環境"><a href="#建立可運行-NAT-mode-的環境" class="headerlink" title="建立可運行 NAT mode 的環境"></a>建立可運行 NAT mode 的環境</h2><p>確認好目前的環境後，我們便根據環境設定了兩支 script，分別用來產生 &amp; 移除 tap interface for NAT mode：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置 tap interface for NAT mode 的 script</span></span><br><span class="line">$ cat &lt;&lt;\EOF &gt;/etc/qemu-ifup-NAT</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># network information</span></span><br><span class="line">BRIDGE=virbr0</span><br><span class="line">NETWORK=192.168.122.0</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=192.168.122.1</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$1</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="comment"># 啟用 bridge device for NAT mode</span></span><br><span class="line">  brctl stp <span class="variable">$&#123;BRIDGE&#125;</span> on</span><br><span class="line">  ifconfig <span class="variable">$&#123;BRIDGE&#125;</span> <span class="variable">$&#123;GATEWAY&#125;</span> netmask <span class="variable">$&#123;NETMASK&#125;</span> up</span><br><span class="line"></span><br><span class="line">  ifconfig <span class="string">"<span class="variable">$1</span>"</span> 0.0.0.0 up</span><br><span class="line">  brctl addif <span class="variable">$&#123;BRIDGE&#125;</span> <span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line">  <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Error: no interface specified."</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除 tap interface for NAT mode 的 script</span></span><br><span class="line">$ cat &lt;&lt;\EOF &gt;/etc/qemu-ifdown-NAT</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># network information</span></span><br><span class="line">BRIDGE=virbr0</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$1</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Tearing down network bridge for <span class="variable">$1</span>"</span></span><br><span class="line">  ip link <span class="built_in">set</span> <span class="string">"<span class="variable">$1</span>"</span> down</span><br><span class="line">  brctl delif <span class="variable">$&#123;BRIDGE&#125;</span> <span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line">  <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Error: no interface specified."</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 為目前的使用者加入</span></span><br><span class="line">$ chmod +x /etc/qemu-if&#123;up,down&#125;-NAT</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上的 script 可能會因為自身的環境不同而有增減，需要特別注意一下</p>
</blockquote>
<h2 id="啟動-NAT-mode-virtual-machine"><a href="#啟動-NAT-mode-virtual-machine" class="headerlink" title="啟動 NAT-mode virtual machine"></a>啟動 NAT-mode virtual machine</h2><p>當環境都準備好後，可以使用以下指令啟動 virtual machine：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -net nic -net tap =&gt; 設定 tap interface</span></span><br><span class="line"><span class="comment"># script=/etc/qemu-ifup-NAT,downscript=/etc/qemu-ifdown-NAT =&gt; 使用指定的 script 配置網路</span></span><br><span class="line">$ kvm -vnc 0.0.0.0:1 -m 2048 /kvm/storage/vm_disks/ubnutu1604.img -net nic -net tap,script=/etc/qemu-ifup-NAT,downscript=/etc/qemu-ifdown-NAT --daemonize</span><br><span class="line"></span><br><span class="line"><span class="comment"># 從下面結果可看出 tap0 是與 virbr0 這個 bridge device 相連</span></span><br><span class="line">$ brctl show</span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">br0             8000.2c600cb163d5       yes             ens1f0</span><br><span class="line">virbr0          8000.1a507abb7dff       yes             tap0</span><br><span class="line">                                                        virbr0-nic</span><br></pre></td></tr></table></figure>
<p>最後確認一下 virtual machine 的狀況：</p>
<p><img src="https://github.com/godleon/godleon.github.io/blob/master/_posts/images/2016/KVM-Basic-Concept-Networking/kvm_network-NAT-mode-VM.PNG?raw=true" alt="NAT mode - virtual machine"></p>
<p>從上圖可看出 virtual machine 的確拿到了 192.168.122.0/24 網段中的 ip address，表示 host machine 中的 dnsmasq 運作正常；此外連外也正常，表示防火牆的設定部分也沒有問題</p>
<hr>
<h1 id="設定用戶模式-user-mode-網路-內部網路"><a href="#設定用戶模式-user-mode-網路-內部網路" class="headerlink" title="設定用戶模式(user-mode)網路(內部網路)"></a>設定用戶模式(user-mode)網路(內部網路)</h1><p>若在啟動 virtual machine 沒加上 <code>-net</code> 參數，預設 QEMU 就會使用 <code>-net nic -net user</code> 把 virtual machine 設定為 user mode。</p>
<p>user mode network 完全是由 QEMU 透過 <a href="http://wiki.qemu.org/Documentation/Networking" target="_blank" rel="noopener">SLiRP</a> 所實現的一個虛擬 NAT 網路，不用依賴先前所安裝的 <strong>bridge-utils</strong>、<strong>dnsmaq</strong>、<strong>iptables</strong> 等工具，也不需要 root 的權限就可執行。</p>
<p>以下是 user mode network 的架構圖：</p>
<p><img src="http://wiki.qemu.org/images/9/93/Slirp_concept.png" alt="SLiRP concept"></p>
<p>使用參數：<code>-net user[,option][,option][,...]</code></p>
<p>以下列出比較常用的 option：</p>
<ul>
<li><p><code>vlan=n</code>：將 user mode network 連接到 VLAN ID=n 的 VLAN</p>
</li>
<li><p><code>net=addr[/mask]</code>：設定 virtual machine 的 ip address (預設為 <strong><font color="red">10.0.2.0/24</font></strong>)</p>
</li>
<li><p><code>host=addr</code>：設定 host machine 的 ip address (預設為 <strong><font color="red">10.0.2.2</font></strong>)</p>
</li>
<li><p><code>dns=addr</code>：設定 virtual DNS 的 ip address (預設為 <strong><font color="red">10.0.2.3</font></strong>)</p>
</li>
<li><p><code>dhcpstart=addr</code>：設定 DHCP 的第一個 ip address (預設為 <strong><font color="red">10.0.2.15</font></strong>)</p>
</li>
<li><p><code>restrict=y|yes|n|no</code>：若設定 yes，virtual machine 將無法與 host machine 通訊，但不會影響 hostfwd 的設定</p>
</li>
<li><p><code>hostfwd=[tcp|udp]:[hostaddr]:hostport-[guestaddr]:guestport</code>：將 host machine 中的 hostport 導向 virtual machine 的 guestport (可一次定義多個 hostfwd 設定)</p>
</li>
</ul>
<p>以下是簡單的應用範例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -net nic -net user =&gt; user mode network</span></span><br><span class="line"><span class="comment"># hostfwd=tcp::5022-:22 =&gt; 將 host machine 的 tcp port 5022 導向 virtual machine 的 tcp port 22</span></span><br><span class="line">$ kvm -vnc 0.0.0.0:1 -m 2048 /kvm/storage/vm_disks/ubnutu1604.img -net nic -net user,hostfwd=tcp::5022-:22 --daemonize</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 tcp port 5022 連線到 virtual machine</span></span><br><span class="line">$ ssh -p 5022 ubuntu@10.20.190.2</span><br><span class="line">ubuntu@10.20.190.2\<span class="string">'s password:</span></span><br><span class="line"><span class="string">.......</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 查詢 ip address</span></span><br><span class="line"><span class="string">ubuntu@vm-ubuntu1604:~$ ip addr show</span></span><br><span class="line"><span class="string">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1</span></span><br><span class="line"><span class="string">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span></span><br><span class="line"><span class="string">    inet 127.0.0.1/8 scope host lo</span></span><br><span class="line"><span class="string">       valid_lft forever preferred_lft forever</span></span><br><span class="line"><span class="string">    inet6 ::1/128 scope host</span></span><br><span class="line"><span class="string">       valid_lft forever preferred_lft forever</span></span><br><span class="line"><span class="string">2: ens3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span></span><br><span class="line"><span class="string">    link/ether 52:54:00:12:34:56 brd ff:ff:ff:ff:ff:ff</span></span><br><span class="line"><span class="string">    inet 10.0.2.15/24 brd 10.0.2.255 scope global ens3</span></span><br><span class="line"><span class="string">       valid_lft forever preferred_lft forever</span></span><br><span class="line"><span class="string">    inet6 fe80::5054:ff:fe12:3456/64 scope link</span></span><br><span class="line"><span class="string">       valid_lft forever preferred_lft forever</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 實際上是可以上網的</span></span><br><span class="line"><span class="string">ubuntu@vm-ubuntu1604:~$ curl www.google.com.tw</span></span><br><span class="line"><span class="string">..........(省略一大堆內容)</span></span><br></pre></td></tr></table></figure>
<p>必須一提的是，使用 user mode network 也是有些缺點在的，像是：</p>
<ol>
<li><p>由於網路都是由 QEMU 虛擬出來的，因此效能比起其他模式相對差一些</p>
</li>
<li><p>不支援部分網路功能(例如：ICMP)，所以也就無法使用 ping command</p>
</li>
<li><p>無法從 host machine or 外部直接存取 virtual machine</p>
</li>
</ol>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><p><a href="http://linux.die.net/man/1/qemu-kvm" target="_blank" rel="noopener">qemu-kvm(1): QEMU Emulator User Documentation - Linux man page</a></p>
</li>
<li><p><a href="http://wiki.qemu.org/download/qemu-doc.html" target="_blank" rel="noopener">QEMU Emulator User Documentation</a></p>
</li>
<li><p><a href="http://www.it610.com/article/4332744.htm" target="_blank" rel="noopener">桥网络配置 - info5 - IT610.com</a></p>
</li>
<li><p><a href="http://smilejay.com/2012/03/kvm_qemu_network_error/" target="_blank" rel="noopener">KVM “qemu-ifup: could not configure /dev/net/tun: Operation not permitted”解决方案 – 笑遍世界</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> KVM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> KVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Linux KVM] Linux KVM concept - Storage]]></title>
      <url>/blog/2016/08/03/KVM/KVM-Basic-Concept-Storage/</url>
      <content type="html"><![CDATA[<p>此篇文章介紹學習 Linux KVM 時所需要了解的 Storage 相關知識</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 Linux KVM 中，是由 QEMU 來提供 storage device 的模擬，可以模擬的 storage 類型很多，包含 IDE device / SCSI device / Floopy disk / USB disk / virtio disk …. 等等，可根據使用者需求的不同來提供不同組合以及不同的開機順序。</p>
<hr>
<h1 id="Host-Machine-Swap-空間應該要設定多大"><a href="#Host-Machine-Swap-空間應該要設定多大" class="headerlink" title="Host Machine Swap 空間應該要設定多大?"></a>Host Machine Swap 空間應該要設定多大?</h1><p>以前學 Linux 時知道，swap 是用來作為當記憶體不足時的 buffer 用，而現在虛擬化環境中，每台 host machine 的記憶體容量都很大，那 swap 應該如何規劃配置呢? 以下有幾個原則：</p>
<h3 id="不使用-memory-overcommit"><a href="#不使用-memory-overcommit" class="headerlink" title="不使用 memory overcommit"></a>不使用 memory overcommit</h3><ol>
<li><p>若實體記憶體 &lt;= 4GB，則 swap space 設定為 2GB</p>
</li>
<li><p>若 4GB &lt; 實體記憶體 &lt;= 16GB，則 swap space 設定為 4GB</p>
</li>
<li><p>若 16GB &lt; 實體記憶體 &lt;= 64GB，則 swap space 設定為 8GB</p>
</li>
<li><p>若 64GB &lt; 實體記憶體 &lt;= 526GB，則 swap space 設定為 16GB</p>
</li>
</ol>
<h3 id="使用-memory-overcommit"><a href="#使用-memory-overcommit" class="headerlink" title="使用 memory overcommit"></a>使用 memory overcommit</h3><p>假設配置 memory overcommit rate 為 0.5 (例如：128 GB 的記憶體卻配置 <code>128 * (1 + 0.5) = 192 GB</code>)，那 swap space 除了上面的大小外，還要額外在加上記憶體容量 x 0.5 的空間。</p>
<p>亦即設定 memory overcommit，還要多增加 <strong><font color="red">physical memory x memory overcommit rate</font></strong> 的容量大小給 swap space。</p>
<p>舉個實際例子，假設 host machine 有 32GB 記憶體，memory overcommit ratio 設定為 0.5，則 swap space 的容量計算如下：</p>
<blockquote>
<p>(32 * 0.5) + 8 = 24 GB</p>
</blockquote>
<hr>
<h1 id="Storage-Device-amp-開機順序的配置"><a href="#Storage-Device-amp-開機順序的配置" class="headerlink" title="Storage Device &amp; 開機順序的配置"></a>Storage Device &amp; 開機順序的配置</h1><p>在 <strong>qemu-kvm</strong> 可以直接在命令行中進行 storage device &amp; 開機順序的配置，以下是常用的參數：</p>
<h2 id="Storage-Devices"><a href="#Storage-Devices" class="headerlink" title="Storage Devices"></a>Storage Devices</h2><ul>
<li><code>-hd[a:d] file_path</code>：以 file_path 指定的 image 檔案作為系統的 IDE HDD，在 virtual machine 中會以 <strong>/dev/hd[a:d]</strong> or <strong>/dev/sd[a:d]</strong> 呈現</li>
</ul>
<blockquote>
<p>若在 qemu-kvm 中直接指定檔案而沒有設定 -hd[a:d]，則預設為 <strong>-hda</strong></p>
</blockquote>
<ul>
<li><p><code>-fd[a:b] file_path</code>：以 file_path 指定的 image 檔案作為系統的軟碟機，在 virtual machine 中會以 <strong>/dev/fd[a:b]</strong> 呈現</p>
</li>
<li><p><code>-cdrom file_path</code>：用來指定 iso 檔案作為 virtual machine 的 <strong>/dev/cdrom</strong> 時使用：不可與 <strong>-hdc</strong> 參數同時使用，會衝突</p>
</li>
<li><p><code>-driver option[, option[, option[, option[,....]]]]</code>：透過 <strong>-driver</strong> 參數指定 storage device 的設定細節</p>
</li>
</ul>
<p>由於以上的設定參數太多，所以這邊直接貼 man page 的內容來看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">-drive option[,option[,option[,...]]]</span><br><span class="line">    Define a new drive. Valid options are:</span><br><span class="line">    file=file</span><br><span class="line">      This option defines <span class="built_in">which</span> disk image to use with this drive. If the filename contains comma, you must double it (<span class="keyword">for</span> instance, <span class="string">"file=my,,file"</span> to use file <span class="string">"my,file"</span>).</span><br><span class="line">    <span class="keyword">if</span>=interface</span><br><span class="line">      This option defines on <span class="built_in">which</span> <span class="built_in">type</span> on interface the drive is connected. Available types are: ide, scsi, sd, mtd, floppy, pflash, virtio.</span><br><span class="line">    bus=bus,unit=unit</span><br><span class="line">      These options define <span class="built_in">where</span> is connected the drive by defining the bus number and the unit id.</span><br><span class="line">    index=index</span><br><span class="line">      This option defines <span class="built_in">where</span> is connected the drive by using an index <span class="keyword">in</span> the list of available connectors of a given interface <span class="built_in">type</span>.</span><br><span class="line">    media=media</span><br><span class="line">      This option defines the <span class="built_in">type</span> of the media: disk or cdrom.</span><br><span class="line">    cyls=c,heads=h,secs=s[,trans=t]</span><br><span class="line">      These options have the same definition as they have <span class="keyword">in</span> -hdachs.</span><br><span class="line">    snapshot=snapshot</span><br><span class="line">      snapshot is <span class="string">"on"</span> or <span class="string">"off"</span> and allows to <span class="built_in">enable</span> snapshot <span class="keyword">for</span> given drive (see -snapshot).</span><br><span class="line">    cache=cache</span><br><span class="line">      cache is <span class="string">"none"</span>, <span class="string">"writeback"</span>, <span class="string">"unsafe"</span>, or <span class="string">"writethrough"</span> and controls how the host cache is used to access block data.</span><br><span class="line">    aio=aio</span><br><span class="line">      aio is <span class="string">"threads"</span>, or <span class="string">"native"</span> and selects between pthread based disk I/O and native Linux AIO .</span><br><span class="line">    format=format</span><br><span class="line">      Specify <span class="built_in">which</span> disk format will be used rather than detecting the format. Can be used to specifiy format=raw to avoid interpreting an untrusted format header.</span><br><span class="line">    serial=serial</span><br><span class="line">      This option specifies the serial number to assign to the device.</span><br><span class="line">    addr=addr</span><br><span class="line">      Specify the controller\<span class="string">'s PCI address (if=virtio only).</span></span><br><span class="line"><span class="string">    copy-on-read=copy-on-read</span></span><br><span class="line"><span class="string">      copy-on-read is "on" or "off" and enables whether to copy read backing file sectors into the image file.</span></span><br></pre></td></tr></table></figure>
<p>在預設情況下，QEMU 會為所有的 block device 自動帶上 writethrough caching 的功能，這功能是利用 host page cache 所達成的，效率較差，但安全性高。</p>
<p>而另外一個 Writeback caching 可以提供更好的效率，但安全性較低，因為若是 host machine 突然掛點或發生電力中斷的情況，cache 中的資料很有可能會遺失；若是加上 <code>snapshot</code> 參數，則會預設使用 Writeback caching。</p>
<p>若是要完全關閉 cache 功能，可以加上參數 <code>cache=none</code>。</p>
<p>此外，其實每一個 storage device 都可以用 <code>-drive</code> 來設定，舉例來說：</p>
<ul>
<li><p><code>-cdrom file_path</code> = <code>-drive file=file,index=2,media=cdrom</code></p>
</li>
<li><p><code>-hda file_path</code> = <code>-drive file=file,index=0,media=disk</code></p>
</li>
<li><p><code>-fda file_path</code> = <code>-drive file=file,index=0,if=floppy</code></p>
</li>
</ul>
<h2 id="開機順率"><a href="#開機順率" class="headerlink" title="開機順率"></a>開機順率</h2><p>開機順序的參數設定如下：</p>
<blockquote>
<p>-boot [order=drives][,once=drives][,menu=on|off][,splash=sp_name][,splash-time=sp_time][,reboot-timeout=rb_timeout][,strict=on|off]</p>
</blockquote>
<p>QEMU 的開機順序，是以英文字母表示：</p>
<ul>
<li><p><code>a</code>：第一台軟碟機</p>
</li>
<li><p><code>b</code>：第二台軟碟機</p>
</li>
<li><p><code>c</code>：第一顆硬碟</p>
</li>
<li><p><code>d</code>：光碟機</p>
</li>
<li><p><code>n</code>：網路啟動</p>
</li>
</ul>
<p>以下是幾個簡單的範例：</p>
<ul>
<li><p><code>-boot order=d</code>：光碟開機</p>
</li>
<li><p><code>-boot once=d</code>：第一次以光碟開機，系統重開後以第一顆硬碟開機</p>
</li>
</ul>
<p>此外其他參數的說明：</p>
<ul>
<li><p><code>menu=on|off</code>：是否顯示開機選單</p>
</li>
<li><p><code>splash=sp_name</code> &amp; <code>splash-time=sp_time</code>：在 <code>menu=on</code> 時才有效，<code>splash</code> 設定開機 logo，<code>splash-time</code> 設定開機 logo 時間</p>
</li>
<li><p><code>-boot order=dc,menu=on</code>：開機順序為光碟機 &gt;&gt; 硬碟，顯示開機選單</p>
</li>
</ul>
<hr>
<h1 id="qemu-img"><a href="#qemu-img" class="headerlink" title="qemu-img"></a>qemu-img</h1><p><strong><a href="http://wiki.qemu.org/download/qemu-doc.html#qemu_005fimg_005finvocation" target="_blank" rel="noopener">qemu-img</a></strong> 是 QEMU 的磁碟管理工具，安裝好 QEMU 相關套件時就會存在於系統中，基本使用語法如下：</p>
<blockquote>
<p>qemu-img command [command options]</p>
</blockquote>
<p>以下就常用的相關命令 &amp; 參數進行介紹：</p>
<ul>
<li><code>create [-f fmt] [-o options] filename [size]</code>：建立 disk image；其中 <code>options</code> 的部分可以使用 <code>-o ?</code> 來查詢特定格式所支援的選項；<code>size</code> 則是支援 <code>k</code>(KB) / <code>M</code>(MB) / <code>G</code>(GB) / <code>T</code>(TB) 等大小。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 顯示目前 qcow2 格式支援的 options</span></span><br><span class="line">$ qemu-img create -f qcow2 -o ?</span><br><span class="line">Supported options:</span><br><span class="line">size             Virtual disk size</span><br><span class="line">compat           Compatibility level (0.10 or 1.1)</span><br><span class="line">backing_file     File name of a base image</span><br><span class="line">backing_fmt      Image format of the base image</span><br><span class="line">encryption       Encrypt the image</span><br><span class="line">cluster_size     qcow2 cluster size</span><br><span class="line">preallocation    Preallocation mode (allowed values: off, metadata, falloc, full)</span><br><span class="line">lazy_refcounts   Postpone refcount updates</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增檔名為 ubuntu1604.qcow2，格式為 qcow2，大小為 10GB 的 disk image</span></span><br><span class="line">$ qemu-img create -f qcow2 ubuntu1604.qcow2 10G</span><br><span class="line">Formatting <span class="string">'ubuntu1604.qcow2'</span>, fmt=qcow2 size=10737418240 encryption=off cluster_size=65536 lazy_refcounts=off</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增有 backing file(centos7.img，原生大小為 10GB) 的 disk image</span></span><br><span class="line"><span class="comment"># disk image 檔名為 centos7.qcow2，格式為 qcow2，大小為 20GB</span></span><br><span class="line">$ qemu-img create -f qcow2 centos7.img 10G</span><br><span class="line">Formatting <span class="string">'centos7.img'</span>, fmt=qcow2 size=10737418240 encryption=off cluster_size=65536 lazy_refcounts=off</span><br><span class="line">$ qemu-img create -f qcow2 -o backing_file=centos7.img,size=20G centos7.qcow2</span><br><span class="line">Formatting <span class="string">'centos7.qcow2'</span>, fmt=qcow2 size=21474836480 backing_file=<span class="string">'centos7.img'</span> encryption=off cluster_size=65536 lazy_refcounts=off</span><br></pre></td></tr></table></figure>
<ul>
<li><code>check [-f fmt] filename</code>：對 disk image 進行一致性 &amp; 錯誤的檢查，但目前只有支援 qcow2 / qed / vdi 等格式；若不加上 <code>[-f fmt]</code> 參數則會自動偵測格式</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ qemu-img check centos7.qcow2</span><br><span class="line">No errors were found on the image.</span><br><span class="line">Image end offset: 262144</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>commit [-f fmt] filename</code>：將指定 disk image 的修改 commit 到 backing file 中(例如上面範例中，把 centos7.qcow2 的修改 commit 回 centos7.img 中)</p>
</li>
<li><p><code>convert [-c] [-f fmt] [-O output_fmt] [-o options] filename [filename2 [...]] output_filename</code>：轉換 disk image 的格式；input file 的格式可自動偵測，但 output file 則需要指定，不指定則預設為 <code>raw</code>；<code>-c</code> 則是指定對 output file 進行壓縮，但只支援 qcow &amp; qcow2 格式的檔案；<code>-o options</code> 用來指定各種選項，例如 backing file，檔案大小、是否加密…等，附帶一提，使用 backing file 可以使產生的檔案變成 copy-on-write 的增量檔案</p>
</li>
</ul>
<blockquote>
<p>若是由 raw 轉成 qcow2，一般來說檔案還會有瘦身的效果</p>
</blockquote>
<ul>
<li><code>info [-f fmt] filename</code>：顯示 disk image 的詳細資訊</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ qemu-img info /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">image: /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">file format: raw</span><br><span class="line">virtual size: 8.0G (8589934592 bytes)</span><br><span class="line">disk size: 8.0G</span><br><span class="line"></span><br><span class="line">$  qemu-img info centos7.qcow2</span><br><span class="line">image: centos7.qcow2</span><br><span class="line">file format: qcow2</span><br><span class="line">virtual size: 20G (21474836480 bytes)</span><br><span class="line">disk size: 196K</span><br><span class="line">cluster_size: 65536</span><br><span class="line">backing file: centos7.img</span><br><span class="line">Format specific information:</span><br><span class="line">    compat: 1.1</span><br><span class="line">    lazy refcounts: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>snapshot [-l | -a snapshot | -c snapshot | -d snapshot] filename</code>：snapshot 的管理，包含查詢 snapshot 列表資訊(<code>-l</code>) / 使用快照作為 disk image(<code>-a snapshot</code>) / 建立 snapshot(<code>-c snapshot</code>) / 刪除 snapshot(<code>-d snapshot</code>)</p>
</li>
<li><p><code>resize filename [+ | -]size</code>：改變 disk image 的大小；縮小空間要確保 disk image 有足夠的空間，否則會有資料損毀的風險；qcow2 格式不支援縮小；增加空間後，在 virtual machine 中需要使用 fdisk or parted 才可以使用到增加的空間</p>
</li>
</ul>
<blockquote>
<p>強烈建議在 resize 之前要做好備份</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@ocp-kvm-host ~]<span class="comment"># qemu-img resize ubuntu1604.qcow2 +1G</span></span><br><span class="line">Image resized.</span><br><span class="line"></span><br><span class="line">[root@ocp-kvm-host ~]<span class="comment"># qemu-img info ubuntu1604.qcow2</span></span><br><span class="line">image: ubuntu1604.qcow2</span><br><span class="line">file format: qcow2</span><br><span class="line">virtual size: 11G (11811160064 bytes)</span><br><span class="line">disk size: 200K</span><br><span class="line">cluster_size: 65536</span><br><span class="line">Format specific information:</span><br><span class="line">    compat: 1.1</span><br><span class="line">    lazy refcounts: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Storage-Types"><a href="#Storage-Types" class="headerlink" title="Storage Types"></a>Storage Types</h1><p>在 QEMU/KVM 中，virual machine 的 disk image 其實可以用很多種不同方式來儲存，例如：</p>
<ol>
<li><p>Local storage (最常用的方式)</p>
</li>
<li><p>physical disk/partition</p>
</li>
<li><p>LVM</p>
</li>
<li><p>NFS</p>
</li>
<li><p>iSCSI</p>
</li>
<li><p>在 Local 端 or 透過 Fiber 連接的 LUN</p>
</li>
<li><p>GFS2</p>
</li>
</ol>
<blockquote>
<p>上面的幾個選項中，phtsical partition &amp; LVM 由於無法存放 MBR，因此無法作為 virtual machine 的開機磁碟，只能用來存放資料用。</p>
</blockquote>
<p>基本上，以 file-based 的方式管理 disk images 是比較有彈性的，可放在 Local / NFS / iSCSI / LUN / GFS2 … 等，若是 virtual machine 對於 I/O 效能不是非常要求時，選擇 qcow2 則是較為建議的 disk image 格式，其優點如下：</p>
<ul>
<li><p>儲存方便 (file-baed)</p>
</li>
<li><p>比起其他方式相對容易使用</p>
</li>
<li><p>可移動性佳</p>
</li>
<li><p>容易複製</p>
</li>
<li><p>可透過 sparse 的機制節省硬碟空間(類似 thin provision)</p>
</li>
<li><p>可放在透過網路連結的檔案系統中(例如：NFS，可把 backing file 放在 NFS，差異部分放在 local)，因此可以輕鬆達到 live migration 的效果</p>
</li>
</ul>
<p>最後，若需要高效能的 I/O，則可以使用半虛擬化的 <strong><font color="red">virtio</font></strong> 作為 disk image 的 driver。</p>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><p><a href="http://linux.die.net/man/1/qemu-kvm" target="_blank" rel="noopener">qemu-kvm(1): QEMU Emulator User Documentation - Linux man page</a></p>
</li>
<li><p><a href="http://wiki.qemu.org/download/qemu-doc.html" target="_blank" rel="noopener">QEMU Emulator User Documentation</a></p>
</li>
<li><p><a href="http://benjr.tw/20361" target="_blank" rel="noopener">Cache 的 write back 和 write through – Benjr.tw</a></p>
</li>
<li><p><a href="http://www.pcdvd.com.tw/showthread.php?t=285217" target="_blank" rel="noopener">請教Cache運作方式的Write Back與Write Through之分別 - PCDVD數位科技討論區</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> KVM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> KVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Linux KVM] Linux KVM concept - Memory]]></title>
      <url>/blog/2016/08/01/KVM/KVM-Basic-Concept-Memory/</url>
      <content type="html"><![CDATA[<p>此篇文章介紹學習 Linux KVM 時所需要了解的 Memory 相關知識</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Memory 在作業系統是用來暫時存放 cpu 要執行的指令以及資料，所有 process 都必須先載入到 memory 中才能正確執行。</p>
<p>而在虛擬化的環境中，virtual machine 中 memory 的使用是需要額外的 mapping 機制對應到 host machine，在這個部分的效率的高低，當然也就會決定 virtual machine 整體的系統性能。</p>
<hr>
<h1 id="VM-可以使用多少記憶體"><a href="#VM-可以使用多少記憶體" class="headerlink" title="VM 可以使用多少記憶體?"></a>VM 可以使用多少記憶體?</h1><p>也許這是很多人想要了解的，在 host machine 上安裝了一大堆實體記憶體，究竟可以分配給 VM 的可以有多少呢? 以下有兩個簡單公式可以計算：</p>
<ol>
<li><p>實體記憶體 &lt;= 64 GB</p>
<blockquote>
<p>RAM - 2 GB = Amount of RAM available to VMs in GBs</p>
</blockquote>
</li>
<li><p>實體記憶體 &gt; 64GB</p>
<blockquote>
<p>RAM - (2 GiB + .5* (RAM/64)) = Amount of RAM available to VMs in GBs</p>
</blockquote>
</li>
</ol>
<p>假設 host machine 記憶體有 32GB，則一共可以配置 <code>32 - 2 = 10</code>GB 的記憶體給 VM。</p>
<p>假設 host machine 記憶體有 256GB，則一共可以配置 <code>256 - (2 + 0.5 * (256 / 64)) = 252</code>GB 的記憶體給 VM</p>
<hr>
<h1 id="配置-VM-記憶體"><a href="#配置-VM-記憶體" class="headerlink" title="配置 VM 記憶體"></a>配置 VM 記憶體</h1><p>幫 virtual machine 配置記憶體是很容易的，只要使用 <strong><font color="red">-m</font></strong> 參數即可，預設的格式是：</p>
<blockquote>
<p>-m megs</p>
</blockquote>
<p>預設是以 <strong><font color="red">MB</font></strong> 作為預設的單位，也可以使用 <strong><font color="red">G</font></strong> 表示要使用 GB 為單位，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 記憶體大小為 2048 MB</span></span><br><span class="line">$ kvm -vnc 0.0.0.0:1 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line"></span><br><span class="line"><span class="comment"># 記憶體大小為 4 GB</span></span><br><span class="line">$ kvm -vnc 0.0.0.0:1 -m 4G -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="EPT"><a href="#EPT" class="headerlink" title="EPT"></a>EPT</h1><p>傳統要把 virtual machine 中運行的應用程式所使用的 memory 對應到 host machine 的 memory，一共是有三層關係的，下圖可做個簡單說明：</p>
<p><img src="http://m.eet.com/media/1200411/CloudFig4a.jpg" alt="VM memory mapping"></p>
<blockquote>
<p>Guest Virtual Address(GVA) &lt;–&gt; Guest Physical Address(GPA) &lt;–&gt; Host Physical Address(HPA)</p>
</blockquote>
<p>但由於上面三層的轉換效率是很差的，因此後來透過軟體實作了稱為 <strong><font color="red">Shadow Page Tables</font></strong> 的機制，將三層中的第二層拿掉，直接讓 Guest Virtual Address 與 Host Physical Address 可以有直接對應的機制：</p>
<p><img src="http://image.slidesharecdn.com/windays-virtualization-090428034228-phpapp01/95/windows-server-virtualization-hyperv-2008-r2-30-728.jpg?cb=1240890219" alt="Shadow Page Tables"></p>
<p>此時 hypervisor 就可以把 shadow page tables 載入到 MMU(Memory Management Unit) 中進行 address translation 的工作。</p>
<p>但 shadow page tables 實作起來不僅複雜，也會 memory 的額外消耗(每一個 virtual machine 都需要一個 shadow page table)；因此 Intel 提出了 EPT(Extended Page Tables)，AMD 提出了 NPT(Nested Page Tables)，在硬體層直接提供了 <code>GVA &lt;--&gt; GPA &lt;--&gt; HPA</code> 的轉換，不僅提升了 memory 虛擬化的效能，也降低了 memory 虛擬化的複雜度。</p>
<p>以下是 Intel EPT 技術的概觀：</p>
<p><img src="http://virtualization.info/images/EPT-716833.png" alt="Intel EPT"></p>
<p>其中可以看到 Intel 在硬體中增加了 CR3(Control Registor 3) 來處理 GVA &lt;–&gt; GPA 的轉換，以及 EPT 來處理 GPA &lt;–&gt; HPA 的轉換。</p>
<p>由於所有的轉換都在硬體層級完成，因此速度很快；而且由於整個轉換過程只需要一個 EPT Page Table，因此在 memory 的消耗上也相對的低。</p>
<hr>
<h1 id="VPID"><a href="#VPID" class="headerlink" title="VPID"></a>VPID</h1><p>要了解 VPID，首先要知道 TLB(Translation Lookaside Buffer) 是什麼? 可以參考以下連結：</p>
<ul>
<li><a href="http://www.wikiwand.com/zh-hk/%E8%BD%89%E8%AD%AF%E5%BE%8C%E5%82%99%E7%B7%A9%E8%A1%9D%E5%8D%80" target="_blank" rel="noopener">TLB 轉譯後備緩衝區 - Wikiwand</a></li>
</ul>
<blockquote>
<p>分配給 virtual machine 的每一個 vCPU 都會有一個 TLB</p>
</blockquote>
<p>而 VPID 則是在硬體層級對 TLB 資源管理的優化，在 virtual machine 進行 migration / VM Entry / VM Exit 時，避免對 TLB 進行轉存 &amp; 清除，進而降低 memory 的額外消耗，對於 live migration 有顯著的效能提升。</p>
<hr>
<h1 id="查詢-EPT-amp-VPID-的支援度"><a href="#查詢-EPT-amp-VPID-的支援度" class="headerlink" title="查詢 EPT &amp; VPID 的支援度"></a>查詢 EPT &amp; VPID 的支援度</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查詢 CPU 是否支援 EPT &amp; VPID</span></span><br><span class="line">$  grep -E <span class="string">"\sept\s|\svpid\s"</span> /proc/cpuinfo | uniq</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢 kvm_intel 模組是否有開啟 EPT &amp; VPID 的功能</span></span><br><span class="line">$ cat /sys/module/kvm_intel/parameters/ept</span><br><span class="line">Y</span><br><span class="line">$ cat /sys/module/kvm_intel/parameters/vpid</span><br><span class="line">Y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 開啟 kvm_intel 模組 EPT &amp; VPID 的功能</span></span><br><span class="line">$ modprobe kvm_intel ept=1,vpid=1</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Huge-Page"><a href="#Huge-Page" class="headerlink" title="Huge Page"></a>Huge Page</h1><p>x86 架構的 CPU 預設的 memory page table 大小為 4KB，而 x86-64 則可以支援到 2MB 大小的 memory page table(亦稱為 <strong><font color="red">Huge Page</font></strong>)，在 Linux 2.6 以上的 kernel 都支援這個特性。</p>
<p>而使用 Huge Page 有何優缺點呢?</p>
<h3 id="優點："><a href="#優點：" class="headerlink" title="優點："></a>優點：</h3><ul>
<li><p>page table 數量減少，更節省 memory</p>
</li>
<li><p>由於 memory address translation 的工作減少了，因此 page fault 機率降低為 <strong><font color="red">Huge Page Size / 4KB</font></strong> 分之一</p>
</li>
<li><p>提升了 memory 存取的效能</p>
</li>
<li><p>提高 TLB 命中率，因而減少 CPU cache 的使用，最後提升了系統整體效能</p>
</li>
<li><p>適合用在 memory 存取密集的 virtual machine 上</p>
</li>
</ul>
<h3 id="缺點："><a href="#缺點：" class="headerlink" title="缺點："></a>缺點：</h3><ul>
<li><p>Huge Page 無法被 swap out 到硬碟上</p>
</li>
<li><p>無法使用 Ballooning 的方式自動增長</p>
</li>
<li><p>並非適合所有不同工作類型的 virtual machine</p>
</li>
</ul>
<h2 id="在-KVM-中使用-Huge-Page"><a href="#在-KVM-中使用-Huge-Page" class="headerlink" title="在 KVM 中使用 Huge Page"></a>在 KVM 中使用 Huge Page</h2><h3 id="1、檢查-host-machine-中-Huge-Page-的設定資訊："><a href="#1、檢查-host-machine-中-Huge-Page-的設定資訊：" class="headerlink" title="1、檢查 host machine 中 Huge Page 的設定資訊："></a>1、檢查 host machine 中 Huge Page 的設定資訊：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 目前預設的 page size</span></span><br><span class="line">$ getconf PAGESIZE</span><br><span class="line">4096</span><br><span class="line"></span><br><span class="line"><span class="comment"># 記憶體資訊中 Huge Page 的相關資訊 (size = 2048 KB)</span></span><br><span class="line">$ cat /proc/meminfo | grep Huge</span><br><span class="line">AnonHugePages:     14336 kB</span><br><span class="line">HugePages_Total:       0</span><br><span class="line">HugePages_Free:        0</span><br><span class="line">HugePages_Rsvd:        0</span><br><span class="line">HugePages_Surp:        0</span><br><span class="line">Hugepagesize:       2048 kB</span><br></pre></td></tr></table></figure>
<h3 id="2、掛載-hugetlbfs-檔案系統"><a href="#2、掛載-hugetlbfs-檔案系統" class="headerlink" title="2、掛載 hugetlbfs 檔案系統"></a>2、掛載 hugetlbfs 檔案系統</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 掛載 hugetlbfs 檔案系統</span></span><br><span class="line">$ mount -t hugetlbfs hugetlbfs /dev/hugepages</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢檔案系統資訊</span></span><br><span class="line">$ mount | grep huge</span><br><span class="line">cgroup on /sys/fs/cgroup/hugetlb <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)</span><br><span class="line">hugetlbfs on /dev/hugepages <span class="built_in">type</span> hugetlbfs (rw,relatime,seclabel)</span><br><span class="line">hugetlbfs on /dev/hugepages <span class="built_in">type</span> hugetlbfs (rw,relatime,seclabel)</span><br></pre></td></tr></table></figure>
<h3 id="3、設定-Huge-Page-的數量"><a href="#3、設定-Huge-Page-的數量" class="headerlink" title="3、設定 Huge Page 的數量"></a>3、設定 Huge Page 的數量</h3><p>假設要啟動一個 memory 為 2048 MB 的 virtual machine，可以算出 Huge Page(2048 KB) 的數量為：</p>
<blockquote>
<p>2048 * 1024 / 2048 = 1024</p>
</blockquote>
<p>因此這邊設定 Huge Page 的數量為 1024 個：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 設定 Huge Page 的數量為 1024 個</span></span><br><span class="line">$ sysctl vm.nr_hugepages=1024</span><br><span class="line">vm.nr_hugepages = 1024</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此時 host machine 中的記憶體資訊已經有 Huge Page 的數量資訊</span></span><br><span class="line">$ cat /proc/meminfo | grep Huge</span><br><span class="line">AnonHugePages:     14336 kB</span><br><span class="line">HugePages_Total:    1024</span><br><span class="line">HugePages_Free:     1024</span><br><span class="line">HugePages_Rsvd:        0</span><br><span class="line">HugePages_Surp:        0</span><br><span class="line">Hugepagesize:       2048 kB</span><br></pre></td></tr></table></figure>
<h3 id="4、啟動-virtual-machine-使用-Huge-Page"><a href="#4、啟動-virtual-machine-使用-Huge-Page" class="headerlink" title="4、啟動 virtual machine 使用 Huge Page"></a>4、啟動 virtual machine 使用 Huge Page</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ kvm -vnc 0.0.0.0:1 -smp 4 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img -mem-path /dev/hugepages</span><br><span class="line"></span><br><span class="line">$ cat /proc/meminfo | grep Huge</span><br><span class="line">AnonHugePages:     26624 kB</span><br><span class="line">HugePages_Total:    1024</span><br><span class="line">HugePages_Free:      738</span><br><span class="line">HugePages_Rsvd:      738</span><br><span class="line">HugePages_Surp:        0</span><br><span class="line">Hugepagesize:       2048 kB</span><br></pre></td></tr></table></figure>
<p>可以看出 virtual machine 的確消耗了一些 huge page，但其實並不是全部，因為 virtual machine 實際上並沒有完整分配到 2048 MB 的 memory；若要完整分配指定的 memory，則需要加上 <code>-mem-prealloc</code> 參數。</p>
<hr>
<h1 id="Memory-Overcommit"><a href="#Memory-Overcommit" class="headerlink" title="Memory Overcommit"></a>Memory Overcommit</h1><p>除了之前介紹 CPU 可以 overcommit 之外，memory 也可以設定一定程度的 overcommit，原因是因為每台電腦在運作時一般都不會耗盡記憶體。對 host machine 來說，virtual machine 也只是一個 QEMU process，在啟動的當下是不會分配完整記憶體的，而是隨著 virtual machine 的更多要求下逐步分配到位，因此可以在此行為的前提下設定 memory overcommit。</p>
<p>在 KVM 中有三種方式可以達到 memory overcommit：</p>
<ol>
<li><p><strong><font color="red">Swapping</font></strong>：透過 system swap(一般為硬碟空間) 來彌補 memory 不足的問題</p>
</li>
<li><p><strong><font color="red">Ballooning</font></strong>：透過 <code>virtio_balloon</code> driver 來達成</p>
</li>
<li><p><strong><font color="red">Page Sharing</font></strong>：使用 <code>KSM(Kernel Samepage Merging)</code> 合併多台 virtual machine 中相同的 memory page</p>
</li>
</ol>
<p>關於第一個方式的 swap，根據 <a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Storage_Administration_Guide/ch-swapspace.html#tb-recommended-system-swap-space" target="_blank" rel="noopener">RedHat RHEL 7 官方文件</a>所提供的建議，swap 大小的設定建議如下：</p>
<table>
<thead>
<tr>
<th>系統記憶體</th>
<th>建議 swap 大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>⩽ 2 GB</td>
<td>2 x memory size</td>
</tr>
<tr>
<td>&gt; 2 GB – 8 GB</td>
<td>等同 memory size</td>
</tr>
<tr>
<td>&gt; 8 GB – 64 GB</td>
<td>至少 4 GB</td>
</tr>
<tr>
<td>&gt; 64 GB</td>
<td>至少 4 GB</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><p><a href="http://linux.die.net/man/1/qemu-kvm" target="_blank" rel="noopener">qemu-kvm(1): QEMU Emulator User Documentation - Linux man page</a></p>
</li>
<li><p><a href="http://www.gegugu.com/2016/03/22/9088.html" target="_blank" rel="noopener">精品：KVM學習筆記 : 歌穀穀</a></p>
</li>
<li><p><a href="http://tc.wangchao.net.cn/it/detail_128378.html" target="_blank" rel="noopener">Huge Page 是否是拯救性能的萬能良藥？ - 王朝網路 - wangchao.net.cn</a></p>
</li>
<li><p><a href="http://brandon-hy-lin.blogspot.tw/2016/04/compound-page-huge-page-transparent.html" target="_blank" rel="noopener">隨意寫寫: Compound Page, Huge Page, 和Transparent Huge Page(THP)</a></p>
</li>
<li><p><a href="http://jaychu649.blogspot.tw/2014/09/linux-huge-memory-greater-then-hundred.html" target="_blank" rel="noopener">IT 研究室 ( 前IT DBA’s 資訊站): 如何在Linux 使用大記憶體(huge memory greater then hundred of GB)</a></p>
</li>
<li><p><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Storage_Administration_Guide/ch-swapspace.html#tb-recommended-system-swap-space" target="_blank" rel="noopener">RedHat RHEL 7 Support &gt; Product Documentation &gt; Storage &gt; Administration Guide</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> KVM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> KVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Linux KVM] Linux KVM concept - CPU]]></title>
      <url>/blog/2016/07/30/KVM/KVM-Basic-Concept-CPU/</url>
      <content type="html"><![CDATA[<p>此篇文章介紹學習 Linux KVM 時所需要了解的 CPU 相關知識</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>KVM 在 Linux x86 硬體平台上提供了全虛擬化(Full Virtualization)的 solution，透過 QEMU 的模擬，顯示特定數量的 CPU &amp; 相關 feature 給使用者，而在支援 KVM 的前提下，virtual machine 的 CPU 指令則是直接由 CPU 來輔助執行，藉此大幅提升運作效率。</p>
<hr>
<h1 id="vCPU"><a href="#vCPU" class="headerlink" title="vCPU"></a>vCPU</h1><p>QEMU/KVM 提供每一台 virtual machine 有一個模擬的完整硬體環境，在 virual machine 中所看到的 CPU，即是 host machine 上的 vCPU。</p>
<p>在 KVM 環境中，每一台 virtual machine 都是一個的 QEMU userspace process，而 vCPU 則是 QEMU process 中的 thread。</p>
<p><img src="http://image.slidesharecdn.com/els305-100323102407-phpapp02/95/virtualization-with-kvm-kernelbased-virtual-machine-4-728.jpg" alt="KVM environment"></p>
<p>vCPU 一共有以下三種執行模式：</p>
<ol>
<li><p>User Mode</p>
</li>
<li><p>Kernel Mode</p>
</li>
<li><p>Guest Mode</p>
</li>
</ol>
<p>其中前兩個執行模式(<strong>User Mode</strong> &amp; <strong>Kernel Mode</strong>)是一般的 process 所擁有的執行模式，詳細的說明可以參考下面連結：</p>
<ul>
<li><p><a href="https://www.ptt.cc/bbs/b97902HW/M.1267018497.A.3B1.html" target="_blank" rel="noopener">[系程] 教學: 簡介 Kernel/User Mode 的概念 - 看板 b97902HW - 批踢踢實業坊</a></p>
</li>
<li><p><a href="http://peachwaneversay.blogspot.tw/2007/05/user-mode-vs-kernel-mode.html" target="_blank" rel="noopener">企鵝幫魚，魚幫兔: User mode vs. Kernel mode</a></p>
</li>
</ul>
<p>而 KVM 多了一個 <strong>Guest Mode</strong>，功能是用來<strong>執行關於 virtual machine 中的相關 I/O request</strong>，無法直接；所有 Memory &amp; CPU 的 I/O request，會透過 <strong>/dev/kvm(QUME)</strong> 來模擬完成，並可透過 QEMU 執行一些特權指令來存取 host machine 的資源。</p>
<p><img src="http://benjr.tw/wp-content/uploads/2013/11/kvm_qemu01.png" alt="KVM Guest Mode"></p>
<hr>
<h1 id="SMP-Symmetric-Multi-Processor"><a href="#SMP-Symmetric-Multi-Processor" class="headerlink" title="SMP(Symmetric Multi-Processor)"></a>SMP(Symmetric Multi-Processor)</h1><p>由於現在 multiple core、hyper threading 等相關技術已經很普遍，這讓作業系統可以進行真正的平行處理；而現在較新的作業系統都已經有對 SMP 的支援(Linux kernel 2.6 以上)，這對虛擬化的推展有相當大的助益。</p>
<p>透過以下指令，可以用來檢查目前 host machine 對 SMP 的支援程度：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查詢 logic cpu 數量</span></span><br><span class="line">$ cat /proc/cpuinfo | grep <span class="string">"processor"</span> | wc -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 實體 CPU 數量</span></span><br><span class="line">$ cat /proc/cpuinfo | grep <span class="string">"physical id"</span> | sort | uniq | wc -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每個 CPU 上的 core 數量</span></span><br><span class="line">$ cat /proc/cpuinfo | grep <span class="string">"core id"</span> | sort | uniq | wc -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每個 physical cpu 上分配的 logic cpu 的數量</span></span><br><span class="line">$ cat /proc/cpuinfo | grep <span class="string">"siblings"</span> | sort | uniq | awk -F: <span class="string">'&#123;print $2&#125;'</span></span><br></pre></td></tr></table></figure>
<p>以上一篇文章中的範例來說明：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kvm -smp 4 -m 2048 \</span><br><span class="line">  -vnc 0.0.0.0:5 -boot order=<span class="built_in">cd</span> \</span><br><span class="line">  -hda /kvm/storage/vm_disks/ubnutu1604.img \</span><br><span class="line">  -cdrom /kvm/os_images/ubuntu-16.04.1-server-amd64.iso</span><br></pre></td></tr></table></figure>
<p>其中 <code>-smp</code> 參數就是指定要使用多少的 vCPU 支援，完整的使用設定如下：(上例為使用 4 個 vCPU)</p>
<blockquote>
<p>-smp n[,<strong>cores=</strong>cores][,<strong>threads=</strong>threads][,<strong>sockets=</strong>sockets][,<strong>maxcpus=</strong>maxcpus]</p>
</blockquote>
<h2 id="範例-1-僅使用-smp"><a href="#範例-1-僅使用-smp" class="headerlink" title="範例 1 (僅使用 -smp)"></a>範例 1 (僅使用 -smp)</h2><p>而在 Linux 系統中，每一個 vCPU 的分配都會成為一個 process 運行在 host machine 中，以下開啟一個 vCPU=8 的 virtual machine：</p>
<blockquote>
<p>kvm -vnc 0.0.0.0:1 -smp 8 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</p>
</blockquote>
<p>可以從 QEMU monitor 中觀察 vCPU 對應到 kvm 的 process：</p>
<p><img src="https://lh3.googleusercontent.com/hHP9T9hWydFXixyMUCuCVFDkl7hlZ6Yv_lbljFDdv_azyt_rh01M6X8bHI1fRMV82a2UObBH6wQgAElavdVxByZ99u0cDBToT-t9OIqgWpSY6ZGreqooEuin8WvQqXpQ9g84uwed3-qO2akJatJTCJqpY0Xt_xU9J1ak4702nyJicXQ7h6HqppYXz0G_86NhyQMd6tv2w5venHGgaBoOF46L8UcYYTskX5rPptWqlmhJtNQSkFGj8F6t3DVVGpOJQfgErjdrfFm162spjhQGwZJ6OWiKTsdBAuXbeUscC-NUTPtGbVjSvAHXa-MVo3-h6jjWZ-TlNkjSmQYCICiRiTGIcFsLAkbIVMGw7-PXkPdqXhJyaC9bEWplxhPzhgGptGUeJCAOrdIhvF_l8lXzaSqeWGL-BSnBbA5qCuV-9UUZVGrcHgiQo2p5_Q_iUBBazlkqnRuM69ULxGEeM-q82gIztEmQiqqOrynKeAf9w5MZnJeb_w29u6qu6B-6d81hRGXwc68A1YHKH256EWxgtrd7_aVfsu08fLEIsPwo5qEuDnkef9G_hGNUHccLcWMSIOIr4J1ViP1vOrDsLpAA_qW-08QfZ4Q=w463-h210-no" alt="QEMU monitor - cpu infos"></p>
<p>以下則可以看出在 host machine 有相對應的 process 存在：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ps -efL | grep kvm</span><br><span class="line">root      1122     2  1122  0    1 Jul27 ?        00:00:00 [kvm-irqfd-clean]</span><br><span class="line">root     14606 11601 14606  3   11 17:46 pts/0    00:00:02 kvm -vnc 0.0.0.0:1 -smp 8 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">root     14606 11601 14610 10   11 17:46 pts/0    00:00:06 kvm -vnc 0.0.0.0:1 -smp 8 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">root     14606 11601 14611  2   11 17:46 pts/0    00:00:01 kvm -vnc 0.0.0.0:1 -smp 8 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">root     14606 11601 14612  1   11 17:46 pts/0    00:00:01 kvm -vnc 0.0.0.0:1 -smp 8 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">root     14606 11601 14613  1   11 17:46 pts/0    00:00:00 kvm -vnc 0.0.0.0:1 -smp 8 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">root     14606 11601 14614  1   11 17:46 pts/0    00:00:00 kvm -vnc 0.0.0.0:1 -smp 8 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">root     14606 11601 14615  1   11 17:46 pts/0    00:00:00 kvm -vnc 0.0.0.0:1 -smp 8 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">root     14606 11601 14616  1   11 17:46 pts/0    00:00:00 kvm -vnc 0.0.0.0:1 -smp 8 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">root     14606 11601 14617  1   11 17:46 pts/0    00:00:01 kvm -vnc 0.0.0.0:1 -smp 8 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">root     14606 11601 14619  1   11 17:46 pts/0    00:00:00 kvm -vnc 0.0.0.0:1 -smp 8 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">root     14606 11601 14631  0   11 17:46 pts/0    00:00:00 kvm -vnc 0.0.0.0:1 -smp 8 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">root     14618     2 14618  0    1 17:46 ?        00:00:00 [kvm-pit/14606]</span><br><span class="line">root     14633 12908 14633  0    1 17:47 pts/1    00:00:00 grep --color=auto kvm</span><br></pre></td></tr></table></figure>
<p>最後可以用上面的 grep 查詢 physical / cores / threads 等資訊：</p>
<p><img src="https://lh3.googleusercontent.com/mD_mnwyxWHinCr-2GSCfaMs-kyhi7p5c9cspDW5go_wM_76oHUj0Phj4n5dAahx39fazYXbMYa5xknxe1oRcoErP0cG84fMRu0WRwm9A1-_p4_bH0XediFmabBPzQQ6omUqJeBgJkwuyj0YRQ8-5kQ6zrE6elocc5sAt4q4tVKOXISDO0CZzSiYU9jHr6HeQVWO4xyLcBBkEUTZEeCfeR_tIrJzZF23nMGWDLI9CSu84ADbuL6KilIp4zDwQPNGrZmxNEwi2kUWyKcxC9-iZBm1W3wNdDYdIESmnVkTQuMe19XnTYsGdPiyRiOtMYv01WQ_KmBoCdRRZ1vfn0syyYdkt9PagLY3TjJ75dt57p918PI4z04YUZomaZ0lZ6Pqb8bt1Iaz1oljrslZpyveJ2AtAGWIdO9hFvE_9r3uvzK-ND77ZL1nAMbvuBPcD3rxuAGGr9ZqZTH_RACGOKtUN44cffI9VMvDp261xOj2NvYUDAVKxLogUNUj_ltOSyLGZ3uSffQtBkybY8OBAR3o3ycSsVy6Riwk8x2n6buCDR05dA4oTlaUqmR_o39TyTKsF6c1hzgoiJN9d_tc4cLS2c1PINXUh7W8=w785-h194-no" alt="SMP only"></p>
<ul>
<li>logic cpu = 8</li>
<li>physical cpu = 8</li>
<li>每個 CPU 上的 core 數量 = 1</li>
<li>每個 physical cpu 上分配的 logic cpu 的數量 = 1</li>
</ul>
<h2 id="範例-2-使用-smp，搭配-sockets-2-cores-2-threads-2"><a href="#範例-2-使用-smp，搭配-sockets-2-cores-2-threads-2" class="headerlink" title="範例 2 (使用 -smp，搭配 sockets=2,cores=2,threads=2)"></a>範例 2 (使用 -smp，搭配 sockets=2,cores=2,threads=2)</h2><p>此範例搭配 socket, cores, threads 等 smp 相關參數</p>
<blockquote>
<p> kvm -vnc 0.0.0.0:1 -smp 8,sockets=2,cores=2,threads=2 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</p>
</blockquote>
<p>用 grep 查詢 physical / cores / threads 等資訊：</p>
<p><img src="https://lh3.googleusercontent.com/JmmR_lsIlsIsr66SlLZXaBJfVKdo6gim3rLxj7oMrVrTbDEYnluhtz-uj5FdlYwUAN4_W-FZDL2a6ykDgFBdwIlYNVrorpLPc7olTSl7oOsHlEoUVT1U9o9yDroSYZFNEGoJVJaMcKoIrtRr9HKB7R9uKrz5VNLR6iX_n2OZs5gL_UxPrxL5UOeYeqyyuZwswNDTyqh61qmqlJ2i0KBAHkSauTcUbASZScuk1rCL_wlp0B0VguRIhd2WZtq2oEe_G9nL6zRMclrXsOqhWsVBy0DyBibyGtqsUPIG7-7rYHcSGs1ao8j_fuTELJVA0P4nWoPpAX5sRI9p84M32vGuppudVSkFDdzACIo43FdB6ZkFftc4sPfRLk-qLXldYJ5ss_waqmqcIA2Qr-be1M443d0QiqYV6BF4XkIn6cKud7gCzy15I30CdM31gVZwK7rkQ6O_eWSCLYhiQoBR1y-B9jXV5qnN7axQfTC8hL46gRlQSyozEG4HXp-X2UmU12rfMWv8rZop2alI6pLa29CE5oywHl40BYI8qKgok52V0znrX1klcmgiCn5iYYdEFPYELqHwDW_EQv0-Z8oAXxmyIpk8tKnSR0E=w777-h190-no" alt="SMP with sockets, cores, and threads"></p>
<ul>
<li>logic cpu = 8</li>
<li>physical cpu = 2</li>
<li>每個 CPU 上的 core 數量 = 2</li>
<li>每個 physical cpu 上分配的 logic cpu 的數量 = 4</li>
</ul>
<hr>
<h1 id="Over-Commit"><a href="#Over-Commit" class="headerlink" title="Over-Commit"></a>Over-Commit</h1><p>一般正常使用情況下，每一台 virtual machine 不會總是在高負載狀況，很多時間會是閒置的；此時透過 over-commit 的方式，可以分配比 host machine 中所有的 vCPU 給 virtual machine。</p>
<p>但不建議分配給單一 virtual machine 超過 host machine 所有 vCPU 的數量，因為這會大大降低 virtual machine 的效能，例如：host machine 總共有 4 個 vCPU，但分配 8 個 vCPU 給 virtual machine。</p>
<p>若是 4 個 vCPU，分配 1 個 vCPU 給 virtual machine，但分配到 8 台 virtual machine，這樣的效能會比上面的配置更有效率。</p>
<blockquote>
<p>若是在 production 的環境，建議還是不要 over-commit</p>
</blockquote>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><p><a href="http://linux.die.net/man/1/qemu-kvm" target="_blank" rel="noopener">qemu-kvm(1): QEMU Emulator User Documentation - Linux man page</a></p>
</li>
<li><p><a href="https://ncucsie.hackpad.com/ep/pad/static/QrwxkWD88gd" target="_blank" rel="noopener">虛擬化技術與應用</a></p>
</li>
<li><p><a href="https://www.ptt.cc/bbs/b97902HW/M.1267018497.A.3B1.html" target="_blank" rel="noopener">[系程] 教學: 簡介 Kernel/User Mode 的概念 - 看板 b97902HW - 批踢踢實業坊</a></p>
</li>
<li><p><a href="http://peachwaneversay.blogspot.tw/2007/05/user-mode-vs-kernel-mode.html" target="_blank" rel="noopener">企鵝幫魚，魚幫兔: User mode vs. Kernel mode</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> KVM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> KVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Linux KVM] 使用 Linux KVM 啟用第一個 virtual machine]]></title>
      <url>/blog/2016/07/26/KVM/QEMU-KVM-In-CentOS7-GettingStart/</url>
      <content type="html"><![CDATA[<p>介紹如何使用 QEMU/KVM 在 Linux 上啟用第一個 virtual machine</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="KVM"><a href="#KVM" class="headerlink" title="KVM"></a>KVM</h2><p>KVM 屬於全虛擬化(Full Virtualization) 的技術，因此在上面運行的 OS 不需要經過任何修改。</p>
<p>原本因為 Full Virtualization 效能應該是很差的，但因為硬體虛擬化的支援(例如：<a href="http://stenlyho.blogspot.tw/2009/01/vt-xvt-d-intel.html" target="_blank" rel="noopener">Intel VT-d</a>，因此大幅提升了 KVM 的效能；此外 KVM 與 QEMU(負責周邊設備的模擬) 的搭配，提供了使用者在 CPU、Memory、Storage、Network、Display 上都有完全相同的虛擬化體驗。</p>
<h2 id="Linux-kernel"><a href="#Linux-kernel" class="headerlink" title="Linux kernel"></a>Linux kernel</h2><p>關於 Linux kernel 上，建議使用目前較新的 kernel，在以下的環境中，會選用安裝 CentOS 7 作為 host machine，搭配 3.10 版的 Linux kernel 做為測試環境之用。</p>
<h2 id="環境說明"><a href="#環境說明" class="headerlink" title="環境說明"></a>環境說明</h2><h3 id="硬體"><a href="#硬體" class="headerlink" title="硬體"></a>硬體</h3><p>CPU：Intel(R) Xeon(R) CPU E5-2660 v3 @ 2.60GHz</p>
<h3 id="軟體"><a href="#軟體" class="headerlink" title="軟體"></a>軟體</h3><ul>
<li><p>OS: CentOS 7</p>
</li>
<li><p>Linux Kernel: 3.10</p>
</li>
<li><p>qemu-kvm: 1.5.3 (預設開啟 KVM 加速)</p>
</li>
<li><p>qemu-img: 1.5.3</p>
</li>
</ul>
<hr>
<h1 id="前置環境設定"><a href="#前置環境設定" class="headerlink" title="前置環境設定"></a>前置環境設定</h1><h2 id="安裝套件"><a href="#安裝套件" class="headerlink" title="安裝套件"></a>安裝套件</h2><p>首先要安裝 KVM、QEMU、libvirtd 相關套件 &amp; 啟動 libvirtd service：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># KVM v2.3 需要使用此 repository</span></span><br><span class="line">$ bash -c <span class="string">"echo '[kvm-common]</span></span><br><span class="line"><span class="string">name=Latest KVM rpms</span></span><br><span class="line"><span class="string">baseurl=http://mirror.centos.org/centos-7/7/virt/x86_64/kvm-common/</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=0' &gt; /etc/yum.repos.d/kvm.repo"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安裝 KVM 1.5</span></span><br><span class="line">$ yum install -y qemu-kvm \</span><br><span class="line">    qemu-img \</span><br><span class="line">    qemu-system-x86 \</span><br><span class="line">    libvirt \</span><br><span class="line">    virt-install \</span><br><span class="line">    libvirt-python \</span><br><span class="line">    virt-manager \</span><br><span class="line">    python-virtinst \</span><br><span class="line">    libvirt-client \</span><br><span class="line">    bridge-utils \</span><br><span class="line">    net-tools \</span><br><span class="line">    libguestfs-tools-c \</span><br><span class="line">    iptables-services</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可使用 groupinstall 來批次安裝</span></span><br><span class="line">$ yum groupinstall <span class="string">"virtualization"</span> -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若要安裝 KVM 2.3 可使用下面指令</span></span><br><span class="line">$ yum install -y qemu-kvm-ev \</span><br><span class="line">    qemu-img-ev \</span><br><span class="line">    qemu-system-x86 \</span><br><span class="line">    libvirt \</span><br><span class="line">    virt-install \</span><br><span class="line">    libvirt-python \</span><br><span class="line">    virt-manager \</span><br><span class="line">    python-virtinst \</span><br><span class="line">    libvirt-client \</span><br><span class="line">    bridge-utils \</span><br><span class="line">    net-tools \</span><br><span class="line">    libguestfs-tools-c \</span><br><span class="line">    iptables-services</span><br></pre></td></tr></table></figure>
<p>也可以順便設定 <a href="http://www.linux-kvm.org/images/3/33/02x03-NestedVirtualization.pdf" target="_blank" rel="noopener">nested virtualization</a>，可以在虛擬環境中再虛擬一層而不會有太多的 performance lose：(此步驟可以略過)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 目前 nested virtualization 是關閉的 </span></span><br><span class="line">$ cat /sys/module/kvm_intel/parameters/nested</span><br><span class="line">N</span><br><span class="line"></span><br><span class="line"><span class="comment"># 開啟 nested virtualization</span></span><br><span class="line">$ sudo rmmod kvm-intel</span><br><span class="line">$ sudo sh -c <span class="string">"echo 'options kvm-intel nested=y' &gt;&gt; /etc/modprobe.d/dist.conf"</span></span><br><span class="line">$ sudo modprobe kvm-intel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 開啟 nested virtualization 成功</span></span><br><span class="line">$ cat /sys/module/kvm_intel/parameters/nested</span><br><span class="line">Y</span><br></pre></td></tr></table></figure>
<h2 id="防火牆設定"><a href="#防火牆設定" class="headerlink" title="防火牆設定"></a>防火牆設定</h2><p>停用預設的 <strong>firewalld.service</strong>，並啟用 <strong>iptables.service</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 關閉 firewalld</span></span><br><span class="line">$ systemctl stop firewalld.service</span><br><span class="line">$ systemctl <span class="built_in">disable</span> firewalld.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 啟用 iptables</span></span><br><span class="line">$ systemctl stop iptables.service</span><br><span class="line">$ systemctl <span class="built_in">disable</span> iptables.service</span><br></pre></td></tr></table></figure>
<p>改用傳統的 itpables 來進行防火牆設定，並使用以下 script 建立防火牆：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># global variables</span></span><br><span class="line">IIF=<span class="string">"ens1f0"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 防止 sync flooding 攻擊(開啟 tcp sync cookie)</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/tcp_syncookies</span><br><span class="line"></span><br><span class="line">iptables -t filter -F</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定 connection track</span></span><br><span class="line">iptables -t filter -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br><span class="line"><span class="comment"># 避免 INVALID 封包被其他服務所接收</span></span><br><span class="line">iptables -t filter -A INPUT -m state --state INVALID -j DROP</span><br><span class="line"></span><br><span class="line">iptables -t filter -A INPUT -p tcp --dport 22 -j ACCEPT</span><br><span class="line"><span class="comment"># 提供 vnc access</span></span><br><span class="line">iptables -t filter -A INPUT -p tcp --dport 5900:5910 -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用來取代 chain default policy</span></span><br><span class="line">iptables -t filter -A INPUT -i <span class="variable">$&#123;IIF&#125;</span> -j DROP</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的套件安裝 &amp; 防火牆設定完成後，要將 KVM host 重新開啟，並啟動 <strong><font color="red">libvirtd.service</font></strong></p>
</blockquote>
<hr>
<h1 id="驗證環境"><a href="#驗證環境" class="headerlink" title="驗證環境"></a>驗證環境</h1><p>安裝好 QEMU/KVM 相關套件後，我們可以來檢查目前的環境是否可以正確的運行虛擬化功能：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ virt-host-validate</span><br><span class="line">  QEMU: Checking <span class="keyword">for</span> hardware virtualization                                 : PASS</span><br><span class="line">  QEMU: Checking <span class="keyword">for</span> device /dev/kvm                                         : PASS</span><br><span class="line">  QEMU: Checking <span class="keyword">for</span> device /dev/vhost-net                                   : PASS</span><br><span class="line">  QEMU: Checking <span class="keyword">for</span> device /dev/net/tun                                     : PASS</span><br><span class="line">   LXC: Checking <span class="keyword">for</span> Linux &gt;= 2.6.26                                         : PASS</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">$ virsh nodeinfo</span><br><span class="line">CPU model:           x86_64</span><br><span class="line">CPU(s):              48</span><br><span class="line">CPU frequency:       1200 MHz</span><br><span class="line">CPU socket(s):       1</span><br><span class="line">Core(s) per socket:  12</span><br><span class="line">Thread(s) per core:  2</span><br><span class="line">NUMA cell(s):        2</span><br><span class="line">Memory size:         263930636 KiB</span><br><span class="line"></span><br><span class="line">$ virsh domcapabilities</span><br><span class="line">&lt;domainCapabilities&gt;</span><br><span class="line">  &lt;path&gt;/usr/bin/qemu-system-x86_64&lt;/path&gt;</span><br><span class="line">  &lt;domain&gt;qemu&lt;/domain&gt;</span><br><span class="line">  &lt;machine&gt;pc-i440fx-2.0&lt;/machine&gt;</span><br><span class="line">  &lt;arch&gt;x86_64&lt;/arch&gt;</span><br><span class="line">  &lt;vcpu max=<span class="string">'255'</span>/&gt;</span><br><span class="line">  &lt;os supported=<span class="string">'yes'</span>&gt;</span><br><span class="line">    &lt;loader supported=<span class="string">'yes'</span>&gt;</span><br><span class="line">      &lt;enum name=<span class="string">'type'</span>&gt;</span><br><span class="line">        &lt;value&gt;rom&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;pflash&lt;/value&gt;</span><br><span class="line">      &lt;/enum&gt;</span><br><span class="line">      &lt;enum name=<span class="string">'readonly'</span>&gt;</span><br><span class="line">        &lt;value&gt;yes&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;no&lt;/value&gt;</span><br><span class="line">      &lt;/enum&gt;</span><br><span class="line">    &lt;/loader&gt;</span><br><span class="line">  &lt;/os&gt;</span><br><span class="line">  &lt;devices&gt;</span><br><span class="line">    &lt;disk supported=<span class="string">'yes'</span>&gt;</span><br><span class="line">      &lt;enum name=<span class="string">'diskDevice'</span>&gt;</span><br><span class="line">        &lt;value&gt;disk&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;cdrom&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;floppy&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;lun&lt;/value&gt;</span><br><span class="line">      &lt;/enum&gt;</span><br><span class="line">      &lt;enum name=<span class="string">'bus'</span>&gt;</span><br><span class="line">        &lt;value&gt;ide&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;fdc&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;scsi&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;virtio&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;usb&lt;/value&gt;</span><br><span class="line">      &lt;/enum&gt;</span><br><span class="line">    &lt;/disk&gt;</span><br><span class="line">    &lt;hostdev supported=<span class="string">'yes'</span>&gt;</span><br><span class="line">      &lt;enum name=<span class="string">'mode'</span>&gt;</span><br><span class="line">        &lt;value&gt;subsystem&lt;/value&gt;</span><br><span class="line">      &lt;/enum&gt;</span><br><span class="line">      &lt;enum name=<span class="string">'startupPolicy'</span>&gt;</span><br><span class="line">        &lt;value&gt;default&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;mandatory&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;requisite&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;optional&lt;/value&gt;</span><br><span class="line">      &lt;/enum&gt;</span><br><span class="line">      &lt;enum name=<span class="string">'subsysType'</span>&gt;</span><br><span class="line">        &lt;value&gt;usb&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;pci&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;scsi&lt;/value&gt;</span><br><span class="line">      &lt;/enum&gt;</span><br><span class="line">      &lt;enum name=<span class="string">'capsType'</span>/&gt;</span><br><span class="line">      &lt;enum name=<span class="string">'pciBackend'</span>&gt;</span><br><span class="line">        &lt;value&gt;default&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;vfio&lt;/value&gt;</span><br><span class="line">      &lt;/enum&gt;</span><br><span class="line">    &lt;/hostdev&gt;</span><br><span class="line">  &lt;/devices&gt;</span><br><span class="line">&lt;/domainCapabilities&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="啟動第一個-virtual-machine"><a href="#啟動第一個-virtual-machine" class="headerlink" title="啟動第一個 virtual machine"></a>啟動第一個 virtual machine</h1><p>由於 RedHat 建議使用 virsh，因此 <strong><font color="red">qemu-kvm</font></strong> 就不存在於預設路徑中，用以下指令把它找出來：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 將 qemu-kvm 以 symlink 的形式複製到 $PATH</span></span><br><span class="line"><span class="comment"># qemu-kvm 指令已經預設啟用 KVM 支援</span></span><br><span class="line">$ ln -sf /usr/libexec/qemu-kvm /usr/bin/kvm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 製作一個 size = 8GB 的 raw image 作為 virtual machine disk</span></span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/zero of=/kvm/storage/vm_disks/ubnutu1604.img bs=1M count=8192</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目前系統中存在的 iso</span></span><br><span class="line">$ ls /kvm/os_images</span><br><span class="line">ubuntu-16.04.1-server-amd64.iso</span><br><span class="line"></span><br><span class="line"><span class="comment"># 啟動 VM (以光碟開機，安裝作業系統)</span></span><br><span class="line"><span class="comment"># -smp 4 =&gt; vCPU=4</span></span><br><span class="line"><span class="comment"># -m 2048 =&gt; RAM=2048MB</span></span><br><span class="line"><span class="comment"># -vnc 0.0.0.0:5 =&gt; 將 vnc 開在第五個 console，因此透過 vnc viewer 連線要使用 "ip:5" 來進行連線</span></span><br><span class="line"><span class="comment"># -boot order=cd =&gt; 開機順序為 cdrom &gt; hdd</span></span><br><span class="line"><span class="comment"># -hda /kvm/storage/vm_disks/ubnutu1604.img =&gt; 指定 hdd raw image</span></span><br><span class="line"><span class="comment"># -cdrom /kvm/os_images/ubuntu-16.04.1-server-amd64.iso =&gt; 指定開機光碟 iso</span></span><br><span class="line">$ kvm -smp 4 -m 2048 \</span><br><span class="line">  -vnc 0.0.0.0:5 -boot order=<span class="built_in">cd</span> \</span><br><span class="line">  -hda /kvm/storage/vm_disks/ubnutu1604.img \</span><br><span class="line">  -cdrom /kvm/os_images/ubuntu-16.04.1-server-amd64.iso</span><br></pre></td></tr></table></figure>
<p>接著可以使用 <a href="http://tigervnc.org/" target="_blank" rel="noopener">TigerVNC</a> or <a href="https://chrome.google.com/webstore/detail/vnc%C2%AE-viewer-for-google-ch/iabmpiboiopbgfabjmgeedhcmjenhbla" target="_blank" rel="noopener">VNC® Viewer for Google Chrome</a> 來進行連線，使用的的連線位置為 <code>server_ip:5</code>；連線進入後，就可以按照一般程序進行 OS 的安裝。</p>
<p>安裝完成後，<code>/kvm/storage/vm_disks/ubnutu1604.img</code> 將會是一個已經安裝好 OS 的硬碟 image 檔案，我們可以透過以下指令使用此 image 檔案來啟動系統：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -smp 4 =&gt; vCPU=4</span></span><br><span class="line"><span class="comment"># -m 2048 =&gt; RAM=2048MB</span></span><br><span class="line"><span class="comment"># -vnc 0.0.0.0:5 =&gt; 將 vnc 開在第五個 console，因此透過 vnc viewer 連線要使用 "ip:5" 來進行連線</span></span><br><span class="line">$ kvm -smp 4 -m 2048 -vnc 0.0.0.0:5 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br></pre></td></tr></table></figure>
<p>使用 VNC viewer 連到 virtual machine 之後，可使用 <code>Ctrl + Alt + 2</code> 切到 QEMU monitor，輸入 <code>kvm info</code> 就可以檢視目前 KVM 是否被使用，或是完全在 QEMU 模擬下產生：</p>
<p><img src="https://lh3.googleusercontent.com/Or8AH3hxAJbdXsIMADxmVkvUKlFYe_-DwTpSuw878fpP3bDAqyLv_ql_7W_HIrLYGHqc1hha7aecKMM6lytj2Wkv-NEyoXsZPuHE5RKa9mp_6apKEoPn7h-tp2DSjLcHaj72ByMefPKXRFKFYCLmYdbhsax0Ro8A-UCjSweOuB03zEL44VM7YbkxNE85vTmFv-JMUUERlX3CAdDotSWpvzl-ztgHzoU2E0iqwgLawhHAhn1JOX19Mn0ib3J0vxqZyLI6CNqaXEIc-7v5QNhAmAysEdWd3AMVKqkPVI41v8FDiUam2G_MDUkWOsAW4aQjnwrAbiw3-Ljpi72gjsM_iJWnsLF5nCuREGQxWC_LOrhRo7-AKLgU_XmzJuobqLRi6LoMzy_BKva5jI7nSgmgAfXDDTWpsXyGoKSgexpg_J7SRuLVZR1iZZ8HCZ9FZpre9qNIdr6xsvnH1NoUobJ73IKMbKn4YmGD0Z9Odi51bpWSh9eV1kOyCMFnF7Q5KZoPk-9lZwChK0gVUj6eObbJDKhlrFTpSvO7vYGJOmIBtfgCfKB9tAZ1-fpDSWxv8tGP38OQmKirl5oh0ozkGGQ-Z9QAr0mC31U=w642-h143-no" alt="QEMU Monitor"></p>
<blockquote>
<p>從上圖來看，可看出關鍵字 <code>kvm support: enabled</code>，表示 KVM 加速是開啟的</p>
<p>由於我們在上面所產生的 kvm 指令是來自於 qemu-kvm，因此已經預設啟用 KVM 加速 (若單純使用 QEMU，可搭配 <code>--enable-kvm</code> 參數來啟用 KVM 加速)</p>
</blockquote>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><ul>
<li><p><a href="http://newtoypia.blogspot.tw/2015/02/qemu-kvm.html" target="_blank" rel="noopener">玩具烏托邦: 五分鐘開始玩 qemu-kvm 虛擬機</a></p>
</li>
<li><p><a href="http://www.vpsee.com/2012/04/install-kvm-on-centos-6-2/" target="_blank" rel="noopener">在 CentOS 6.2 上安装和配置 KVM @vpsee.com</a></p>
</li>
<li><p><a href="http://ot-note.logdown.com/posts/64644/launch-a-vm-with-qemu-kvm" target="_blank" rel="noopener">使用 libvirt 與 qemu-kvm 開啓 VM (內含 libvirt sample XML for KVM ) « OT Coding Note</a></p>
</li>
</ul>
<h2 id="VNC"><a href="#VNC" class="headerlink" title="VNC"></a>VNC</h2><ul>
<li><a href="http://jamyy.us.to/blog/2011/10/3365.html" target="_blank" rel="noopener">KVM/QEMU 設置 VNC 連線密碼 « Jamyy’s Weblog</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> KVM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> KVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Linux] PXE Booting]]></title>
      <url>/blog/2016/07/01/Linux/Linux-PXE-Booting/</url>
      <content type="html"><![CDATA[<p>此篇文章介紹 PXE &amp; iPXE 的開機流程</p>
<h1 id="PXE"><a href="#PXE" class="headerlink" title="PXE"></a>PXE</h1><p>首先以下圖說明一下傳統 PXE 的流程：</p>
<p><img src="https://github.com/coreos/coreos-baremetal/raw/master/Documentation/img/pxelinux.png" alt="PXE"></p>
<p>PXE 的開機流程，簡單來說就是幾個步驟：</p>
<ol>
<li><p>network client 從 DHCP service 取得 IP &amp; 其他 metadata(例如：TFTP 資訊 &amp; NBP 檔名)</p>
</li>
<li><p>network client 從 TFTP 取得 NBP(Network Boot Program，上面中的 <code>pxelinux.0</code>)，並啟動</p>
</li>
<li><p>network client 使用 NBP 載入 configs, scripts, 以及執行 OS 需要的 kernel(範例中的 <code>kernel.vmlinuz</code>) &amp; ramfs image(上圖中的 <code>initrd.cpio.gz</code>)</p>
</li>
</ol>
<hr>
<h1 id="Network-Boot-Program-NBP-也稱為-bootloader"><a href="#Network-Boot-Program-NBP-也稱為-bootloader" class="headerlink" title="Network Boot Program (NBP, 也稱為 bootloader)"></a>Network Boot Program (NBP, 也稱為 bootloader)</h1><p>CoreOS 可用多種不同的 bootloader 開機 &amp; 設定，如果是一個全新的設定環境，<a href="http://ipxe.org/" target="_blank" rel="noopener">iPXE</a> 是個不錯的選擇。</p>
<h2 id="PXELINUX"><a href="#PXELINUX" class="headerlink" title="PXELINUX"></a>PXELINUX</h2><p><a href="http://www.syslinux.org/wiki/index.php?title=PXELINUX" target="_blank" rel="noopener">PXELINUX</a> 是個相當普遍被使用的 bootloader(檔名為 <code>pxelinux.0</code>)，會自動從 <code>/tftp_bootdir/pxelinux.cfg</code> 目錄中載入設定檔。</p>
<p>若要控制特定機器使用特定的設定檔，可以利用 network client 的 UUID、MAC address、IP or default 來進行設定，因此設定檔就會變成如下面的範例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/tftp_bootdir/pxelinux.cfg/b8945908-d6a6-41a9-611d-74a6ab80b83d</span><br><span class="line">/tftp_bootdir/pxelinux.cfg/01-88-99-aa-bb-cc-dd</span><br><span class="line">/tftp_bootdir/pxelinux.cfg/default</span><br></pre></td></tr></table></figure>
<p>按照上圖的流程，可以很清楚知道，設定檔的內容肯定就是會包含了像是 config / script / kernel / ramfs image …. 等檔案的位置資訊(可能還會包含<strong>開機選單</strong>)，以下是個簡單範例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">default coreos</span><br><span class="line">prompt 1</span><br><span class="line">timeout 15</span><br><span class="line"></span><br><span class="line">display boot.msg</span><br><span class="line"></span><br><span class="line">label coreos</span><br><span class="line">  menu default</span><br><span class="line">  kernel coreos_production_pxe.vmlinuz</span><br><span class="line">  append initrd=coreos_production_pxe_image.cpio.gz cloud-config-url=http://example.com/pxe-cloud-config.yml</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面範例中的檔案若沒有指定目錄，就表示應該將其放在 <code>/tftp_bootdir</code> 目錄中<br>其中設定了一個簡單的 menu、顯示訊息、kernel(coreos_production_pxe.vmlinuz)、ramfs(coreos_production_pxe_image.cpio.gz) &amp; 設定 CoreOS 用的 cloud-config.yaml</p>
</blockquote>
<p>PXE 雖然普遍使用，但的確是有些缺點存在的，例如：</p>
<ol>
<li><p>TFTP 速度慢</p>
</li>
<li><p>若有許多針對不同機器的客製化設定檔需求，會需要撰寫很多份 pxelinux config</p>
</li>
</ol>
<h2 id="iPXE"><a href="#iPXE" class="headerlink" title="iPXE"></a>iPXE</h2><p><a href="http://ipxe.org/" target="_blank" rel="noopener">iPXE</a> 可是視為加強版的 PXE bootloader，使用的並非是設定檔，而是 <strong>iPXE script</strong>，而且 iPXE script &amp; image 都可以透過 HTTP 下載</p>
<p>以下是 iPXE 開機流程示意圖：</p>
<p><img src="https://github.com/coreos/coreos-baremetal/raw/master/Documentation/img/ipxe.png" alt="iPXE"></p>
<p>從上圖可以看出，為了可以運作在原有的環境中，使用了一個名稱為 <a href="http://boot.ipxe.org/undionly.kpxe" target="_blank" rel="noopener">undionly.kpxe</a> 的 bootloader 來協助開機，接著會發生以下的事情：</p>
<ol>
<li><p>bootloader undionly.kpxe 會提供給 machine 上網 &amp; 處理後續 iPXE script 的能力</p>
</li>
<li><p>透過網路取得 iPXE script <code>boot.ipxes</code></p>
</li>
<li><p>並會使用檔名為 <code>boot.ipxe</code>(來源可以是 HTTP) 的 iPXE script 來繼續執行後續的開機流程</p>
</li>
</ol>
<p>以下是個簡單的 iPXE script 範例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!ipxe</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> base-url http://stable.release.core-os.net/amd64-usr/current</span><br><span class="line">kernel <span class="variable">$&#123;base-url&#125;</span>/coreos_production_pxe.vmlinuz cloud-config-url=http://provisioner.example.net/cloud-config.yml</span><br><span class="line">initrd <span class="variable">$&#123;base-url&#125;</span>/coreos_production_pxe_image.cpio.gz</span><br><span class="line">boot</span><br></pre></td></tr></table></figure>
<blockquote>
<p>透過 iPXE script，可以用程式化的方式進行更多動態的開機設定</p>
</blockquote>
<p>在 iPXE 開機環境 for CoreOS 的架構中，有一些事情是值得注意一下的：</p>
<ol>
<li><p>TFTP 只用來提供 <a href="http://boot.ipxe.org/undionly.kpxe" target="_blank" rel="noopener">undionly.kpxe</a> bootloader，目的是為了讓老舊的 PXE firmware client 也可以使用 iPXE</p>
</li>
<li><p>CoreOS 提供了 <a href="coreos-baremetal/bootcfg.md at master · coreos/coreos-baremetal">bootcfg</a> 工具，可根據硬體的屬性，用來產生相對應的 iPXE script (把 iPXE script 的來源指向 bootcfg iPXE endpoint)</p>
</li>
</ol>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><p><a href="http://www.syslinux.org/wiki/index.php?title=PXELINUX" target="_blank" rel="noopener">PXELINUX - Syslinux Wiki</a></p>
</li>
<li><p><a href="http://ipxe.org/howto/chainloading" target="_blank" rel="noopener">iPXE - open source boot firmware [howto:chainloading]</a></p>
</li>
<li><p><a href="https://github.com/coreos/coreos-baremetal/blob/master/Documentation/network-booting.md" target="_blank" rel="noopener">coreos-baremetal/network-booting.md at master · coreos/coreos-baremetal</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Linux] 解決使用帶有密碼的 SSH keypair 時需要重複輸入密碼的問題]]></title>
      <url>/blog/2016/07/01/Linux/Auto-Authenticate-with-Password-Protected-SSHKeypair/</url>
      <content type="html"><![CDATA[<blockquote>
<p>use ssh agent and keychain to input the secret of password-protected ssh key</p>
</blockquote>
<p>最近被 GitHub 騙了去產生個帶有密碼的 SSH keypair 來用</p>
<p>發現怎麼每次使用都要我輸入密碼呢….? 於是上網找了一下答案……</p>
<p>要解決這方式，需要 <strong>ssh agent</strong> 搭配 <strong>keychain</strong> 來將密碼安全的儲存起來</p>
<p>假設以下情況已經完成：</p>
<ol>
<li><p>SSK keypair 已經存在於 <code>~/.ssh/id_rsa*</code></p>
</li>
<li><p>keychain 套件已經安裝</p>
</li>
</ol>
<p>接著只要執行以下指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ tee --append ~/.bash_profile &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line"><span class="comment">### START-Keychain ###</span></span><br><span class="line"><span class="comment"># Let  re-use ssh-agent and/or gpg-agent between logins</span></span><br><span class="line">/usr/bin/keychain <span class="variable">$HOME</span>/.ssh/id_rsa</span><br><span class="line"><span class="built_in">source</span> <span class="variable">$HOME</span>/.keychain/<span class="variable">$HOSTNAME</span>-sh</span><br><span class="line"><span class="comment">### End-Keychain ###</span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>接著再重新登入，輸入一次密碼後，後續使用到 SSH keypair 時，就不用一直重複輸入了!</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><p><a href="https://help.github.com/articles/generating-an-ssh-key/" target="_blank" rel="noopener">Generating an SSH key - User Documentation</a></p>
</li>
<li><p><a href="http://unix.stackexchange.com/questions/83608/ssh-agent-how-to-set-it-up-so-my-centos-server-will-only-ask-for-passphrase-onc" target="_blank" rel="noopener">ssh-agent: How to set it up so my CentOS server will only ask for passphrase once? - Unix &amp; Linux Stack Exchange</a></p>
</li>
<li><p><a href="http://www.cyberciti.biz/faq/ssh-passwordless-login-with-keychain-for-scripts/" target="_blank" rel="noopener">keychain: Set Up Secure Passwordless SSH Access For Backup Scripts</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[CoreOS] etcd、fleet & flannel 簡介]]></title>
      <url>/blog/2016/06/22/CoreOS/CoreOS-Introduction-Of-etcd-fleet-and-flannel/</url>
      <content type="html"><![CDATA[<h1 id="環境說明"><a href="#環境說明" class="headerlink" title="環境說明"></a>環境說明</h1><p>測試環境建立於現有的 OpenStack infrastructure 上，使用以下設定：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#cloud-config</span></span><br><span class="line"></span><br><span class="line"><span class="attr">ssh_authorized_keys:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">[YOUR</span> <span class="string">SSH</span> <span class="string">PUBLIC</span> <span class="string">KEY]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">coreos:</span></span><br><span class="line"><span class="attr">  etcd2:</span></span><br><span class="line"><span class="attr">    discovery:</span> <span class="attr">https://discovery.etcd.io/ea524a83ed3f84e550417f0fb89e91c8</span></span><br><span class="line"><span class="attr">    advertise-client-urls:</span> <span class="attr">http://$private_ipv4:2379,http://$private_ipv4:4001</span></span><br><span class="line"><span class="attr">    initial-advertise-peer-urls:</span> <span class="attr">http://$private_ipv4:2380</span></span><br><span class="line"><span class="attr">    listen-client-urls:</span> <span class="attr">http://0.0.0.0:2379,http://0.0.0.0:4001</span></span><br><span class="line"><span class="attr">    listen-peer-urls:</span> <span class="attr">http://$private_ipv4:2380</span></span><br><span class="line"><span class="attr">  flannel:</span></span><br><span class="line"><span class="attr">    interface:</span> <span class="string">$public_ipv4</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  units:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">etcd2.service</span></span><br><span class="line"><span class="attr">      command:</span> <span class="string">start</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">fleet.service</span></span><br><span class="line"><span class="attr">      command:</span> <span class="string">start</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">flanneld.service</span></span><br><span class="line"><span class="attr">      drop-ins:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="number">50</span><span class="bullet">-network-config.conf</span></span><br><span class="line"><span class="attr">          content:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            [Service]</span></span><br><span class="line"><span class="string">            ExecStartPre=/usr/bin/etcdctl set /coreos.com/network/config '&#123; "Network": "10.1.0.0/16" &#125;'</span></span><br><span class="line"><span class="string"></span><span class="attr">      command:</span> <span class="string">start</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">redis.service</span></span><br><span class="line"><span class="attr">      content:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        [Unit]</span></span><br><span class="line"><span class="string">        Requires=flanneld.service</span></span><br><span class="line"><span class="string">        After=flanneld.service</span></span><br><span class="line"><span class="string">        [Service]</span></span><br><span class="line"><span class="string">        ExecStart=/usr/bin/docker run redis</span></span><br><span class="line"><span class="string">        Restart=always</span></span><br><span class="line"><span class="string"></span><span class="attr">      command:</span> <span class="string">start</span></span><br></pre></td></tr></table></figure>
<p>以上設定會把 <strong>etcd</strong>、<strong>fleet</strong>、<strong>flannel</strong>、<strong>docker</strong> 都啟動，還包含了一個執行 <strong>redis</strong> 服務的 container</p>
<hr>
<h1 id="驗證步驟"><a href="#驗證步驟" class="headerlink" title="驗證步驟"></a>驗證步驟</h1><p>當 CoreOS 安裝完成之後，首要之務就是驗證 CoreOS 是否安裝成功，以下測試三個主要的 service 分別是 <code>etcd</code>、<code>docker</code>、<code>fleet</code>：</p>
<h2 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h2><p>在 Machine A 新增資訊到 etcd service：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">core@coreos ~ $ etcdctl <span class="built_in">set</span> /message <span class="string">"Hello CoreOS"</span></span><br><span class="line">Hello CoreOS</span><br><span class="line"></span><br><span class="line">core@coreos ~ $ curl -L http://127.0.0.1:2379/v2/keys/message -XPUT -d value=<span class="string">"Hello CoreOS"</span></span><br><span class="line">&#123;<span class="string">"action"</span>:<span class="string">"set"</span>,<span class="string">"node"</span>:&#123;<span class="string">"key"</span>:<span class="string">"/message"</span>,<span class="string">"value"</span>:<span class="string">"Hello CoreOS"</span>,<span class="string">"modifiedIndex"</span>:1641,<span class="string">"createdIndex"</span>:1641&#125;,<span class="string">"prevNode"</span>:&#123;<span class="string">"key"</span>:<span class="string">"/message"</span>,<span class="string">"value"</span>:<span class="string">"Hello CoreOS"</span>,<span class="string">"modifiedIndex"</span>:1455,<span class="string">"createdIndex"</span>:1455&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>可以從 Machine B 取得：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">core@coreos ~ $ etcdctl get /message   </span><br><span class="line">Hello CoreOS</span><br><span class="line"></span><br><span class="line">core@coreos ~ $ curl -L http://127.0.0.1:2379/v2/keys/message</span><br><span class="line">&#123;<span class="string">"action"</span>:<span class="string">"get"</span>,<span class="string">"node"</span>:&#123;<span class="string">"key"</span>:<span class="string">"/message"</span>,<span class="string">"value"</span>:<span class="string">"Hello CoreOS"</span>,<span class="string">"modifiedIndex"</span>:1641,<span class="string">"createdIndex"</span>:1641&#125;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><p>由於 CoreOS 使用了 systemd port activate 的機制，因此一開始 docker service 是不會啟動的，直到有 container 啟動為止：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一開始 docker service 不會啟動</span></span><br><span class="line">core@coreos ~ $ systemctl status docker</span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (/usr/lib64/systemd/system/docker.service; disabled; vendor preset: disabled)</span><br><span class="line">   Active: inactive (dead)</span><br><span class="line">     Docs: http://docs.docker.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 啟動 container busybox</span></span><br><span class="line">core@coreos ~ $ docker run busybox /bin/<span class="built_in">echo</span> Hello CoreOS</span><br><span class="line">Unable to find image <span class="string">'busybox:latest'</span> locally</span><br><span class="line">latest: Pulling from library/busybox</span><br><span class="line">385e281300cc: Pull complete</span><br><span class="line">a3ed95caeb02: Pull complete</span><br><span class="line">Digest: sha256:4a731fb46adc5cefe3ae374a8b6020fc1b6ad667a279647766e9a3cd89f6fa92</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> busybox:latest</span><br><span class="line">Hello CoreOS</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker service 目前為啟動狀態</span></span><br><span class="line">core@coreos ~ $ systemctl status docker</span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (/usr/lib64/systemd/system/docker.service; disabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Mon 2016-06-20 07:58:52 UTC; 53s ago</span><br><span class="line">     Docs: http://docs.docker.com</span><br><span class="line"> Main PID: 1082 (docker)</span><br><span class="line">   Memory: 41.7M</span><br><span class="line">      CPU: 18.356s</span><br><span class="line">   CGroup: /system.slice/docker.service</span><br><span class="line">           └─1082 docker daemon --host=fd:// --<span class="built_in">exec</span>-opt native.cgroupdriver=systemd --selinux-enabled</span><br><span class="line">.........</span><br></pre></td></tr></table></figure>
<h2 id="fleet"><a href="#fleet" class="headerlink" title="fleet"></a>fleet</h2><p>CoreOS 會使用 fleet 用來管理 container 的生命週期。</p>
<p>fleet 是透過接收 <a href="https://coreos.com/os/docs/latest/getting-started-with-systemd.html" target="_blank" rel="noopener">systemd unit files</a> 為資訊來源進行工作，將 workload 分配到 cluster 中不同的機器執行；管理者可以透過 <code>fleetctl</code> 工具執行像是查詢 unit 的狀態、log 資訊等工作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">core@coreos ~ $ cat &lt;&lt;EOF &gt;hello.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=My Service</span><br><span class="line">After=docker.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">TimeoutStartSec=0</span><br><span class="line">ExecStartPre=-/usr/bin/docker <span class="built_in">kill</span> hello</span><br><span class="line">ExecStartPre=-/usr/bin/docker rm hello</span><br><span class="line">ExecStartPre=/usr/bin/docker pull busybox</span><br><span class="line">ExecStart=/usr/bin/docker run --name hello busybox /bin/sh -c <span class="string">"trap 'exit 0' INT TERM; while true; do echo Hello World; sleep 1; done"</span></span><br><span class="line">ExecStop=/usr/bin/docker stop hello</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">core@coreos ~ $ fleetctl load hello.service</span><br><span class="line">Unit hello.service inactive</span><br><span class="line">Unit hello.service loaded on 0682a8f2.../192.168.50.14</span><br><span class="line"></span><br><span class="line">core@coreos ~ $ fleetctl start hello.service</span><br><span class="line">Unit hello.service launched on 0682a8f2.../192.168.50.14</span><br><span class="line"></span><br><span class="line">core@coreos ~ $ fleetctl status hello.service</span><br><span class="line">● hello.service - My Service</span><br><span class="line">   Loaded: loaded (/run/fleet/units/hello.service; linked-runtime; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Mon 2016-06-20 08:52:43 UTC; 9s ago</span><br><span class="line">...........</span><br><span class="line">Jun 20 08:52:43 coreos docker[1355]: Status: Image is up to date <span class="keyword">for</span> busybox:latest</span><br><span class="line">Jun 20 08:52:43 coreos systemd[1]: Started My Service.</span><br><span class="line">Jun 20 08:52:50 coreos docker[1367]: Hello World</span><br><span class="line">...........</span><br><span class="line">Jun 20 08:52:52 coreos docker[1367]: Hello World</span><br><span class="line"></span><br><span class="line">core@coreos ~ $ fleetctl destroy hello.service</span><br><span class="line">Destroyed hello.service</span><br><span class="line"></span><br><span class="line">core@coreos ~ $ fleetctl status hello.service</span><br><span class="line">Unit hello.service does not exist.</span><br></pre></td></tr></table></figure>
<h2 id="flannel"><a href="#flannel" class="headerlink" title="flannel"></a>flannel</h2><p>flannel 是用來提供 cross hosts 的 container 互相連結之用，在上面的 cloud-config 中，每個 host 預設會從 10.1.0.0/16 的區段中取得自己的 class C subnet。</p>
<p>驗證 flannel 是否運作正常的的步驟如下：</p>
<ol>
<li><p>登入 machine A，並進入 redis container A 中，查詢到 IP A</p>
</li>
<li><p>登入 machine B，並進入 redis container B 中，查詢到 IP B</p>
</li>
<li><p>確認可以從 container A ping 到 container B</p>
</li>
</ol>
<p>若是兩個位於不同機器的 container 可以互通，就表示 flannel 目前的運作是正常的!</p>
<hr>
<h1 id="etcd-1"><a href="#etcd-1" class="headerlink" title="etcd"></a>etcd</h1><p><strong>etcd</strong> 是種分散式 key/value 儲存服務，存在於每一台 CoreOS 機器中，並在 CoreOS cluster 中負責 shared configuration &amp; service discovery 的工作。</p>
<p>而執行在 cluster 環境中的 application container 同樣可以使用 etcd 所提供的服務，可進行像是儲存資料庫連線設定、cache 設定、<a href="Feature Flag 功能發布控制 - 壹讀">feature flag</a> … 等不同的資訊。</p>
<h2 id="在-etcd-讀寫資料"><a href="#在-etcd-讀寫資料" class="headerlink" title="在 etcd 讀寫資料"></a>在 etcd 讀寫資料</h2><p>當對 etcd service 寫入資料後，cluster 內的機器都可以讀取的到(所以說是分散式的)</p>
<h3 id="寫入資料"><a href="#寫入資料" class="headerlink" title="寫入資料"></a>寫入資料</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">core@coreos ~ $ etcdctl <span class="built_in">set</span> /message Hello</span><br><span class="line">Hello</span><br><span class="line"></span><br><span class="line">core@coreos ~ $ curl -L -X PUT http://localhost:2379/v2/keys/message -d value=<span class="string">"Hello"</span></span><br><span class="line">&#123;<span class="string">"action"</span>:<span class="string">"set"</span>,<span class="string">"node"</span>:&#123;<span class="string">"key"</span>:<span class="string">"/message"</span>,<span class="string">"value"</span>:<span class="string">"Hello"</span>,<span class="string">"modifiedIndex"</span>:45040,<span class="string">"createdIndex"</span>:45040&#125;,<span class="string">"prevNode"</span>:&#123;<span class="string">"key"</span>:<span class="string">"/message"</span>,<span class="string">"value"</span>:<span class="string">"CoreOS"</span>,<span class="string">"modifiedIndex"</span>:44979,<span class="string">"createdIndex"</span>:44979&#125;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="讀取資料"><a href="#讀取資料" class="headerlink" title="讀取資料"></a>讀取資料</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">core@coreos ~ $ etcdctl get /message</span><br><span class="line">Hello</span><br><span class="line"></span><br><span class="line">core@coreos ~ $ curl -L http://localhost:2379/v2/keys/message</span><br><span class="line">&#123;<span class="string">"action"</span>:<span class="string">"get"</span>,<span class="string">"node"</span>:&#123;<span class="string">"key"</span>:<span class="string">"/message"</span>,<span class="string">"value"</span>:<span class="string">"Hello"</span>,<span class="string">"modifiedIndex"</span>:45040,<span class="string">"createdIndex"</span>:45040&#125;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="刪除資料"><a href="#刪除資料" class="headerlink" title="刪除資料"></a>刪除資料</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">core@coreos ~ $ etcdctl rm /message</span><br><span class="line">PrevNode.Value: Hello</span><br><span class="line"></span><br><span class="line">core@coreos ~ $ etcdctl <span class="built_in">set</span> /message Hello</span><br><span class="line">Hello</span><br><span class="line"></span><br><span class="line">core@coreos ~ $ curl -L -X DELETE http://localhost:2379/v2/keys/message</span><br><span class="line">&#123;<span class="string">"action"</span>:<span class="string">"delete"</span>,<span class="string">"node"</span>:&#123;<span class="string">"key"</span>:<span class="string">"/message"</span>,<span class="string">"modifiedIndex"</span>:45482,<span class="string">"createdIndex"</span>:45467&#125;,<span class="string">"prevNode"</span>:&#123;<span class="string">"key"</span>:<span class="string">"/message"</span>,<span class="string">"value"</span>:<span class="string">"Hello"</span>,<span class="string">"modifiedIndex"</span>:45467,<span class="string">"createdIndex"</span>:45467&#125;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="從-container-中讀寫-etcd-中的資料"><a href="#從-container-中讀寫-etcd-中的資料" class="headerlink" title="從 container 中讀寫 etcd 中的資料"></a>從 container 中讀寫 etcd 中的資料</h2><p>要從 docker container 中對 etcd 讀寫資料，必須將 ip 指向 <code>docker0</code> interface，預設情況下 ip 為 <code>172.17.0.1</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@cb8e1cb26a7e:/<span class="comment"># curl -L http://172.17.0.1:2379/v2/keys</span></span><br><span class="line">&#123;<span class="string">"action"</span>:<span class="string">"get"</span>,<span class="string">"node"</span>:&#123;<span class="string">"dir"</span>:<span class="literal">true</span>,<span class="string">"nodes"</span>:[&#123;<span class="string">"key"</span>:<span class="string">"/coreos.com"</span>,<span class="string">"dir"</span>:<span class="literal">true</span>,<span class="string">"modifiedIndex"</span>:5,<span class="string">"createdIndex"</span>:5&#125;]&#125;&#125;</span><br><span class="line"></span><br><span class="line">root@cb8e1cb26a7e:/<span class="comment"># curl -L -X PUT http://172.17.0.1:2379/v2/keys/message -d value="I am container"</span></span><br><span class="line">&#123;<span class="string">"action"</span>:<span class="string">"set"</span>,<span class="string">"node"</span>:&#123;<span class="string">"key"</span>:<span class="string">"/message"</span>,<span class="string">"value"</span>:<span class="string">"I am container"</span>,<span class="string">"modifiedIndex"</span>:47075,<span class="string">"createdIndex"</span>:47075&#125;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="監控-etcd-directory-的變化"><a href="#監控-etcd-directory-的變化" class="headerlink" title="監控 etcd directory 的變化"></a>監控 etcd directory 的變化</h2><h3 id="1、新增-etcd-directory"><a href="#1、新增-etcd-directory" class="headerlink" title="1、新增 etcd directory"></a>1、新增 etcd directory</h3><p>除了 <code>/</code> 之外，我們可以在 etcd 中自訂所需要的 directory 用來存放自訂的訊息，以下建立名稱為 <strong>foo-service</strong> 的 directory：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">core@coreos ~ $ etcdctl mkdir /foo-service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 etcd directory 中新增訊息</span></span><br><span class="line">core@coreos ~ $ etcdctl <span class="built_in">set</span> /foo-service/container1 localhost:1111</span><br><span class="line">localhost:1111</span><br></pre></td></tr></table></figure>
<h3 id="2、監控-etcd-directory"><a href="#2、監控-etcd-directory" class="headerlink" title="2、監控 etcd directory"></a>2、監控 etcd directory</h3><p>當其他 CoreOS host 執行 <code>etcdctl set /foo-service/container2 localhost:2222</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">core@coreos ~ $ etcdctl watch --recursive /foo-service</span><br><span class="line">[<span class="built_in">set</span>] /foo-service/container2</span><br><span class="line">localhost:2222</span><br><span class="line"></span><br><span class="line">core@coreos ~ $ curl -L http://localhost:2379/v2/keys/foo-service?<span class="built_in">wait</span>=<span class="literal">true</span>\&amp;recursive=<span class="literal">true</span></span><br><span class="line">&#123;<span class="string">"action"</span>:<span class="string">"set"</span>,<span class="string">"node"</span>:&#123;<span class="string">"key"</span>:<span class="string">"/foo-service/container2"</span>,<span class="string">"value"</span>:<span class="string">"localhost:2222"</span>,<span class="string">"modifiedIndex"</span>:48468,<span class="string">"createdIndex"</span>:48468&#125;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、監控-etcd-directory-並觸發執行特定任務"><a href="#3、監控-etcd-directory-並觸發執行特定任務" class="headerlink" title="3、監控 etcd directory 並觸發執行特定任務"></a>3、監控 etcd directory 並觸發執行特定任務</h3><p>當其他 CoreOS host 執行執行以下指令：</p>
<ol>
<li><p><code>etcdctl set /foo-service/container2 localhost:2222</code></p>
</li>
<li><p><code>etcdctl set /foo-service/container3 localhost:3333</code></p>
</li>
<li><p><code>etcdctl rm /foo-service/container2</code></p>
</li>
<li><p><code>etcdctl rm /foo-service/container3</code></p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">core@coreos ~ $ etcdctl <span class="built_in">exec</span>-watch --recursive /foo-service -- sh -c <span class="string">'echo "\"$ETCD_WATCH_KEY\" key was updated to \"$ETCD_WATCH_VALUE\" value by \"$ETCD_WATCH_ACTION\" action"'</span></span><br><span class="line"><span class="string">"/foo-service/container2"</span> key was updated to <span class="string">"localhost:2222"</span> value by <span class="string">"set"</span> action</span><br><span class="line"><span class="string">"/foo-service/container3"</span> key was updated to <span class="string">"localhost:3333"</span> value by <span class="string">"set"</span> action</span><br><span class="line"><span class="string">"/foo-service/container2"</span> key was updated to <span class="string">""</span> value by <span class="string">"delete"</span> action</span><br><span class="line"><span class="string">"/foo-service/container3"</span> key was updated to <span class="string">""</span> value by <span class="string">"delete"</span> action</span><br></pre></td></tr></table></figure>
<h2 id="Test-and-Set"><a href="#Test-and-Set" class="headerlink" title="Test and Set"></a>Test and Set</h2><p>etcd 也可作為中央協調服務，提供 <strong>TestAndSet</strong> 功能；設定資料的人必須提供先前的值，有符合才可以變更值的內容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 設定值為 Hello</span></span><br><span class="line">core@coreos ~ $ etcdctl <span class="built_in">set</span> /message <span class="string">"Hello"</span></span><br><span class="line">Hello</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若是先前的值為 123，將值換為 Hi (操作失敗)</span></span><br><span class="line">core@coreos ~ $ etcdctl <span class="built_in">set</span> /message <span class="string">"Hi"</span> --swap-with-value=<span class="string">"123"</span></span><br><span class="line">Error:  101: Compare failed ([123 != Hello]) [48752]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若是先前的值為 Hello，將值換為 Hi (操作成功)</span></span><br><span class="line">core@coreos ~ $ etcdctl <span class="built_in">set</span> /message <span class="string">"Hi"</span> --swap-with-value=<span class="string">"Hello"</span></span><br><span class="line">Hi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新值已經變成 Hi</span></span><br><span class="line">core@coreos ~ $ etcdctl get /message</span><br><span class="line">Hi</span><br></pre></td></tr></table></figure>
<h2 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h2><p>將資料寫入 etcd 時，還可以設定 TTL，讓資料在一定的時間之後失效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">core@coreos ~ $ etcdctl <span class="built_in">set</span> /foo <span class="string">"Expiring Soon"</span> --ttl 10</span><br><span class="line">Expiring Soon</span><br><span class="line">core@coreos ~ $ etcdctl get /foo</span><br><span class="line">Expiring Soon</span><br><span class="line">core@coreos ~ $ etcdctl get /foo</span><br><span class="line">Expiring Soon</span><br><span class="line">.........</span><br><span class="line">core@coreos ~ $ etcdctl get /foo</span><br><span class="line">Error:  100: Key not found (/foo) [49020]</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h1><p>systemd 提供了許多強大的功能作為啟動、停止、管理 process 之用，在 CoreOS 中，幾乎所有的 Docker container 的生命週期都是由 systemd 在管理的。</p>
<p>CoreOS 預設所使用的 systemd target 為 <code>multi-user.target</code>，裡面包含了所有常用來管理 container 的 <code>systemd unit</code>。(<strong>target 由多個 unit symbolic link 所集合而成</strong>)</p>
<blockquote>
<p>systemd unit 是一個描述管理者所要執行的 process 的設定檔</p>
</blockquote>
<p>以下用一個簡單範例 <code>/etc/systemd/system/myweb.service</code> 來說明：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=My Web Service</span><br><span class="line"><span class="attr">After</span>=etcd2.service</span><br><span class="line"><span class="attr">After</span>=docker.service</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">TimeoutStartSec</span>=<span class="number">0</span></span><br><span class="line"><span class="comment">; 在 ExecStart 所要執行的命令，"=-" 表示請 systemd 忽略執行命令時所發生的錯誤</span></span><br><span class="line"><span class="attr">ExecStartPre</span>=-/usr/bin/docker kill apache1</span><br><span class="line"><span class="attr">ExecStartPre</span>=-/usr/bin/docker rm apache1</span><br><span class="line"><span class="attr">ExecStartPre</span>=/usr/bin/docker pull coreos/apache</span><br><span class="line"><span class="comment">; service 啟動時所要執行的命令</span></span><br><span class="line"><span class="attr">ExecStart</span>=/usr/bin/docker run --name apache1 -p <span class="number">8081</span>:<span class="number">80</span> coreos/apache /usr/sbin/apache2ctl -D FOREGROUND</span><br><span class="line"><span class="comment">; service 啟動後要執行的指令 (以 machine ID 為 key，寫入訊息到 etcd /domains/example)</span></span><br><span class="line"><span class="attr">ExecStartPost</span>=/usr/bin/etcdctl set /domains/example.com/%m running</span><br><span class="line"><span class="comment">; service 停止時所要執行的指令 (停止 container apache1)</span></span><br><span class="line"><span class="attr">ExecStop</span>=/usr/bin/docker stop apache1</span><br><span class="line"><span class="comment">; service 停止後所要執行的步驟 (以 machine ID 為 key，移除 etcd /domains/example 上的訊息)</span></span><br><span class="line"><span class="attr">ExecStopPost</span>=/usr/bin/etcdctl rm /domains/example.com/%m</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure>
<blockquote>
<p>完整的設定參數可參考 =&gt; <a href="https://www.freedesktop.org/software/systemd/man/systemd.service.html" target="_blank" rel="noopener">systemd.service</a></p>
</blockquote>
<p>另外還可以在 system unit configuration 檔案中指定 <strong>specifiers</strong>，例如：</p>
<ul>
<li><p><code>%n</code>：Full Unit Name</p>
</li>
<li><p><code>%i</code>：Instance Name</p>
</li>
<li><p><code>%m</code>：Machine ID</p>
</li>
<li><p><code>%H</code>：Host Name</p>
</li>
</ul>
<p>詳細的資料可以參考 =&gt; <a href="https://www.freedesktop.org/software/systemd/man/systemd.unit.html#Specifiers" target="_blank" rel="noopener">systemd.unit - Specifiers</a></p>
<p>上述的 systemd service unit configuration 執行的結果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">core@coreos ~ $ sudo systemctl <span class="built_in">enable</span> myweb.service</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/myweb.service to /etc/systemd/system/myweb.service.</span><br><span class="line">core@coreos ~ $ sudo systemctl start myweb.service</span><br><span class="line"></span><br><span class="line">core@coreos ~ $ sudo systemctl status myweb.service</span><br><span class="line">● myweb.service - My Web Service</span><br><span class="line">   Loaded: loaded (/etc/systemd/system/myweb.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Tue 2016-06-21 07:36:22 UTC; 9s ago</span><br><span class="line">  Process: 2403 ExecStartPost=/usr/bin/etcdctl <span class="built_in">set</span> /domains/example.com/%m running (code=exited, status=0/SUCCESS)</span><br><span class="line">  Process: 2391 ExecStartPre=/usr/bin/docker pull coreos/apache (code=exited, status=0/SUCCESS)</span><br><span class="line">  Process: 2379 ExecStartPre=/usr/bin/docker rm apache1 (code=exited, status=0/SUCCESS)</span><br><span class="line">  Process: 2369 ExecStartPre=/usr/bin/docker <span class="built_in">kill</span> apache1 (code=exited, status=1/FAILURE)</span><br><span class="line"> Main PID: 2402 (docker)</span><br><span class="line">   Memory: 11.5M</span><br><span class="line">      CPU: 5.695s</span><br><span class="line">   CGroup: /system.slice/myweb.service</span><br><span class="line">           └─2402 /usr/bin/docker run --name apache1 -p 8081:80 coreos/apache /usr/sbin/apache2ctl -D FOREGROUND</span><br><span class="line">......</span><br><span class="line">Jun 21 07:36:19 coreos docker[2391]: Status: Image is up to date <span class="keyword">for</span> coreos/apache:latest</span><br><span class="line">Jun 21 07:36:22 coreos etcdctl[2403]: running</span><br><span class="line">Jun 21 07:36:22 coreos systemd[1]: Started My Web Service.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢 container 運作狀態</span></span><br><span class="line">core@coreos ~ $ docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES</span><br><span class="line">441cf4a6bf54        coreos/apache       <span class="string">"/usr/sbin/apache2ctl"</span>   35 seconds ago      Up 26 seconds       0.0.0.0:8081-&gt;80/tcp   apache1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 確認 web server 正常服務</span></span><br><span class="line">core@coreos ~ $ curl http://localhost:8081</span><br><span class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;This is the default web page <span class="keyword">for</span> this server.&lt;/p&gt;</span><br><span class="line">&lt;p&gt;The web server software is running but no content has been added, yet.&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢 systemd 寫入 etcd 中的資料</span></span><br><span class="line">core@coreos ~ $ etcdctl ls /domains/example.com</span><br><span class="line">/domains/example.com/72bda15890c14ee89b15214c1b87d71f</span><br><span class="line">core@coreos ~ $ etcdctl get /domains/example.com/72bda15890c14ee89b15214c1b87d71f</span><br><span class="line">running</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止 service</span></span><br><span class="line">core@coreos ~ $ sudo systemctl stop myweb.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢 container 狀態</span></span><br><span class="line">core@coreos ~ $ docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS                        PORTS               NAMES</span><br><span class="line">441cf4a6bf54        coreos/apache       <span class="string">"/usr/sbin/apache2ctl"</span>   About a minute ago   Exited (137) 13 seconds ago                       apache1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢 systemd 寫入 etcd 中的資料 (已經移除)</span></span><br><span class="line">core@coreos ~ $ etcdctl ls /domains/example.com</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="fleet-1"><a href="#fleet-1" class="headerlink" title="fleet"></a>fleet</h1><p>fleet 是個 cluster manager，用途是在 cluster level 上管理 systemd，因此要在 CoreOS cluster 上運行相關服務，正確的方式就是”<strong>使用標準的 systemd unit 搭配 fleet</strong>“來達成。</p>
<h2 id="fleet-unit-type"><a href="#fleet-unit-type" class="headerlink" title="fleet unit type"></a>fleet unit type</h2><p>可以運行在 cluster 上的 unit 有兩種，分別是：</p>
<ol>
<li><p><strong>standard unit</strong>：會被分派到獨立的單一主機上長時間運行的 process，若是機器掛點了，standard unit 就會被轉移到其他正常的主機上重新啟動並繼續執行</p>
</li>
<li><p><strong>global unit</strong>：global unit 將會運行在 cluster 中所有的機器上，這種 unit 適合用在像是 monitoring agent，甚至像是 high level 的 orchestration tool，例如：Kubernetes、Mesos、OpenStack …. 等等。</p>
</li>
</ol>
<h2 id="在-cluster-中啟動-container"><a href="#在-cluster-中啟動-container" class="headerlink" title="在 cluster 中啟動 container"></a>在 cluster 中啟動 container</h2><p>在這邊我們利用之前寫好的 <code>/etc/systemd/system/myweb.service</code> 作示範：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">core@coreos ~ $ fleetctl start /etc/systemd/system/myweb.service</span><br><span class="line">Unit myweb.service inactive</span><br><span class="line">Unit myweb.service launched on 0682a8f2.../192.168.50.14</span><br><span class="line"></span><br><span class="line">core@coreos ~ $ fleetctl list-units   </span><br><span class="line">UNIT		MACHINE				ACTIVE		SUB</span><br><span class="line">myweb.service	0682a8f2.../192.168.50.14	activating	start-pre</span><br><span class="line"></span><br><span class="line">(...... it takes some time to <span class="built_in">wait</span> .......)</span><br><span class="line"></span><br><span class="line">core@coreos ~ $ fleetctl list-units</span><br><span class="line">UNIT		MACHINE				ACTIVE	SUB</span><br><span class="line">myweb.service	0682a8f2.../192.168.50.14	active	running</span><br><span class="line"></span><br><span class="line">core@coreos ~ $ curl http://192.168.50.14:8081</span><br><span class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;This is the default web page <span class="keyword">for</span> this server.&lt;/p&gt;</span><br><span class="line">&lt;p&gt;The web server software is running but no content has been added, yet.&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">core@coreos ~ $ fleetctl list-machines</span><br><span class="line">MACHINE		IP		METADATA</span><br><span class="line">0682a8f2...	192.168.50.14	-</span><br><span class="line">72bda158...	192.168.50.16	-</span><br><span class="line">90c1e40c...	192.168.50.15	-</span><br></pre></td></tr></table></figure>
<h2 id="運行-High-Availability-Service"><a href="#運行-High-Availability-Service" class="headerlink" title="運行 High Availability Service"></a>運行 High Availability Service</h2><p>關於 fleet unit 的詳細設定方式，可以參考 =&gt; <a href="https://coreos.com/fleet/docs/latest/unit-files-and-scheduling.html" target="_blank" rel="noopener">fleet - Overview of Unit Files and Scheduling</a></p>
<p>以下將會設計一個具有 High Availability 的 web service，其中較為重要的設定就是 <code>[X-Fleet]</code> 區塊部份的設定：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">core@coreos ~/demo $ cat &lt;&lt;EOF &gt;apache@.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=My Apache Frontend</span><br><span class="line">After=docker.service</span><br><span class="line">Requires=docker.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">TimeoutStartSec=0</span><br><span class="line">ExecStartPre=-/usr/bin/docker <span class="built_in">kill</span> apache1</span><br><span class="line">ExecStartPre=-/usr/bin/docker rm apache1</span><br><span class="line">ExecStartPre=/usr/bin/docker pull coreos/apache</span><br><span class="line">ExecStart=/usr/bin/docker run --rm --name apache1 -p 80:80 coreos/apache /usr/sbin/apache2ctl -D FOREGROUND</span><br><span class="line">ExecStop=/usr/bin/docker stop apache1</span><br><span class="line"></span><br><span class="line">[X-Fleet]</span><br><span class="line">; 告知 fleet 不要把 apache@* 的 service 放在同一台機器上</span><br><span class="line">Conflicts=apache@*.service</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 複製兩份 unit configuration file</span></span><br><span class="line">core@coreos ~/demo $ cp apache\@.service apache\@1.service</span><br><span class="line">core@coreos ~/demo $ cp apache\@.service apache\@2.service</span><br><span class="line">core@coreos ~/demo $ ls  </span><br><span class="line">apache@.service  apache@1.service  apache@2.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 啟動第 1 個 apache container</span></span><br><span class="line">core@coreos ~/demo $ fleetctl start apache@1</span><br><span class="line">Unit apache@1.service inactive</span><br><span class="line">Unit apache@1.service launched on 0682a8f2.../192.168.50.14</span><br><span class="line"></span><br><span class="line"><span class="comment"># 啟動第 2 個 apache container</span></span><br><span class="line">core@coreos ~/demo $ fleetctl start apache@2</span><br><span class="line">Unit apache@2.service inactive</span><br><span class="line">Unit apache@2.service launched on 72bda158.../192.168.50.16</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視 units</span></span><br><span class="line">core@coreos ~/demo $ fleetctl list-units</span><br><span class="line">UNIT			MACHINE				ACTIVE	SUB</span><br><span class="line">apache@1.service	0682a8f2.../192.168.50.14	active	running</span><br><span class="line">apache@2.service	72bda158.../192.168.50.16	active	running</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 驗證 web 服務有正確啟動</span></span><br><span class="line">core@coreos ~/demo $ curl http://192.168.50.14</span><br><span class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;This is the default web page <span class="keyword">for</span> this server.&lt;/p&gt;</span><br><span class="line">&lt;p&gt;The web server software is running but no content has been added, yet.&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;&lt;/html&gt;</span><br><span class="line">core@coreos ~/demo $ curl http://192.168.50.16</span><br><span class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;This is the default web page <span class="keyword">for</span> this server.&lt;/p&gt;</span><br><span class="line">&lt;p&gt;The web server software is running but no content has been added, yet.&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>接著把 <code>192.168.50.14</code> 這台機器重新開機，此時 service 將會被 fleet 轉移到正常的機器上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">core@coreos ~/demo $ fleetctl list-units</span><br><span class="line">UNIT			MACHINE				ACTIVE		SUB</span><br><span class="line">apache@1.service	90c1e40c.../192.168.50.15	activating	start-pre</span><br><span class="line">apache@2.service	72bda158.../192.168.50.16	active		running</span><br><span class="line"></span><br><span class="line">core@coreos ~/demo $ fleetctl list-units</span><br><span class="line">UNIT			MACHINE				ACTIVE		SUB</span><br><span class="line">apache@1.service	90c1e40c.../192.168.50.15	activating	start-pre</span><br><span class="line">apache@2.service	72bda158.../192.168.50.16	active		running</span><br><span class="line"></span><br><span class="line">core@coreos ~/demo $ fleetctl list-units</span><br><span class="line">UNIT			MACHINE				ACTIVE	SUB</span><br><span class="line">apache@1.service	90c1e40c.../192.168.50.15	active	running</span><br><span class="line">apache@2.service	72bda158.../192.168.50.16	active	running</span><br></pre></td></tr></table></figure>
<blockquote>
<p>存取這些 HA service 比較好的方式是透過 <strong>sidekick container</strong>，這類的 container 是用來提供像是 service discovery、load balancer、DNS 等工作，不建議直接存取 service container</p>
</blockquote>
<h2 id="運行-sidekick"><a href="#運行-sidekick" class="headerlink" title="運行 sidekick"></a>運行 sidekick</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">core@coreos ~/demo $ cat &lt;&lt;EOF &gt;apache_discovery@.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=Announce Apache1</span><br><span class="line">BindsTo=apache@%i.service</span><br><span class="line">After=apache@%i.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/bin/sh -c <span class="string">"while true; do etcdctl set /services/website/apache@%i '&#123; \"machine\": \"%m\", \"port\": 80, \"version\": \"52c7248a14\" &#125;' --ttl 60;sleep 45;done"</span></span><br><span class="line">ExecStop=/usr/bin/etcdctl rm /services/website/apache@%i</span><br><span class="line"></span><br><span class="line">[X-Fleet]</span><br><span class="line">MachineOf=apache@%i.service</span><br><span class="line">EOF</span><br><span class="line">core@coreos ~/demo $ cp apache_discovery\@.service apache_discovery\@1.service</span><br><span class="line">core@coreos ~/demo $ cp apache_discovery\@.service apache_discovery\@2.service</span><br><span class="line">core@coreos ~/demo $ ls</span><br><span class="line">apache@.service  apache@1.service  apache@2.service  apache_discovery@.service  apache_discovery@1.service  apache_discovery@2.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 啟動 service discovery</span></span><br><span class="line">core@coreos ~/demo $ fleetctl start apache_discovery@1         </span><br><span class="line">Unit apache_discovery@1.service inactive</span><br><span class="line">Unit apache_discovery@1.service launched on 90c1e40c.../192.168.50.15</span><br><span class="line"><span class="comment"># 啟動 service discovery</span></span><br><span class="line">core@coreos ~/demo $ fleetctl start apache_discovery@2</span><br><span class="line">Unit apache_discovery@2.service inactive</span><br><span class="line">Unit apache_discovery@2.service launched on 72bda158.../192.168.50.16</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">core@coreos ~/demo $ fleetctl list-units</span><br><span class="line">UNIT				MACHINE				ACTIVE	SUB</span><br><span class="line">apache@1.service		90c1e40c.../192.168.50.15	active	running</span><br><span class="line">apache@2.service		72bda158.../192.168.50.16	active	running</span><br><span class="line">apache_discovery@1.service	90c1e40c.../192.168.50.15	active	running</span><br><span class="line">apache_discovery@2.service	72bda158.../192.168.50.16	active	running</span><br><span class="line"></span><br><span class="line">core@coreos ~/demo $ etcdctl ls /services/ --recursive</span><br><span class="line">/services/website</span><br><span class="line">/services/website/apache@1</span><br><span class="line">/services/website/apache@2</span><br><span class="line"></span><br><span class="line">core@coreos ~/demo $ etcdctl get /services/website/apache@1</span><br><span class="line">&#123; <span class="string">"machine"</span>: <span class="string">"90c1e40ca1e749abbc23fa8b2391ce27"</span>, <span class="string">"port"</span>: 80, <span class="string">"version"</span>: <span class="string">"52c7248a14"</span> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Global-Unit"><a href="#Global-Unit" class="headerlink" title="Global Unit"></a>Global Unit</h2><p>Global Unit 與其他一般的 unit 沒什麼太大差別，只有在 <code>[X-Fleet]</code>區段中多加了 <code>Global=true</code> 設定而已，如此一來這個 system unit 就會在所有機器上執行</p>
<blockquote>
<p>若要把 Global Unit 執行在特定幾台機器上，可搭配 Machine Metadata 使用，就可以達到此目的</p>
</blockquote>
<h2 id="Machine-Metadata"><a href="#Machine-Metadata" class="headerlink" title="Machine Metadata"></a>Machine Metadata</h2><p>Mechine Metadata 的來源是從 cloud-config 所設定的，設定的語法如下：</p>
<blockquote>
<p>metadata=”platform=metal,provider=rackspace,region=east,disk=ssd”</p>
</blockquote>
<p>接著 Machine Metadata 會設定在 unit configuration 中，以下是幾個範例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[X-Fleet]</span><br><span class="line">MachineMetadata=disk=ssd</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[X-Fleet]</span><br><span class="line">Conflicts=webapp*</span><br><span class="line">MachineMetadata=provider=rackspace</span><br><span class="line">MachineMetadata=platform=metal</span><br><span class="line">MachineMetadata=region=east</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><p><a href="https://coreos.com/os/docs/latest/quickstart.html" target="_blank" rel="noopener">CoreOS Quick Start</a></p>
</li>
<li><p><a href="https://coreos.com/etcd/docs/latest/getting-started-with-etcd.html" target="_blank" rel="noopener">Getting Started with etcd on CoreOS</a></p>
</li>
<li><p><a href="https://coreos.com/os/docs/latest/getting-started-with-docker.html" target="_blank" rel="noopener">Getting Started with docker</a></p>
</li>
<li><p><a href="https://coreos.com/os/docs/latest/getting-started-with-systemd.html" target="_blank" rel="noopener">Getting Started with systemd</a></p>
</li>
<li><p><a href="https://coreos.com/fleet/docs/latest/launching-containers-fleet.html" target="_blank" rel="noopener">Launching Containers with fleet</a></p>
</li>
<li><p><a href="https://github.com/coreos/unit-examples/tree/master/simple-fleet" target="_blank" rel="noopener">unit-examples/simple-fleet at master · coreos/unit-examples</a></p>
</li>
<li><p><a href="https://coreos.com/fleet/docs/latest/unit-files-and-scheduling.html" target="_blank" rel="noopener">fleet - Overview of Unit Files and Scheduling</a></p>
</li>
<li><p><a href="https://coreos.com/os/docs/latest/cloud-config.html" target="_blank" rel="noopener">Customize with Cloud-Config</a></p>
</li>
<li><p><a href="https://coreos.com/flannel/docs/latest/flannel-config.html" target="_blank" rel="noopener">Configuring flannel Networking for CoreOS</a></p>
</li>
<li><p><a href="http://dockone.io/article/618" target="_blank" rel="noopener">DockOne技术分享（十八）：一篇文章带你了解Flannel - DockOne.io</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> CoreOS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CoreOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[RHCE7] RH134 Chapter 08. Connecting to Network-defined Users and Groups 學習筆記]]></title>
      <url>/blog/2016/05/09/RHCE/RHCE7-RH134-LearningNotes-CH08_ConnectingToNetwork-DefinedUsersAndGroups/</url>
      <content type="html"><![CDATA[<h1 id="老師補充"><a href="#老師補充" class="headerlink" title="老師補充"></a>老師補充</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取得使用者資訊(跟 /etc/passwd 沒有絕對關係)</span></span><br><span class="line">[vagrant@server tmp]$ getent passwd user1</span><br><span class="line">user1:x:1001:1001::/home/user1:/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取得群組資訊</span></span><br><span class="line">[vagrant@server tmp]$ getent group user1</span><br><span class="line">user1:x:1001:</span><br></pre></td></tr></table></figure>
<p>驗證是否通過：</p>
<ol>
<li><p>帳號 &amp; 密碼正確</p>
</li>
<li><p>可以正確取得使用者資訊</p>
</li>
</ol>
<p>NIS &amp; LDAP 單獨可做到：</p>
<ol>
<li><p>可提供使用者資訊</p>
</li>
<li><p>可提供帳號密碼的驗證方法</p>
</li>
</ol>
<blockquote>
<p>但 Kerberos 僅能提供帳號密碼驗證，無法提供使用者資訊，因此一般會與 LDAP 搭配來解決提供使用者資訊的問題，Windows AD 目前就是依照這種方式達成，安全性提高，且提供了 SSO 的能力)</p>
<p>目前使用 LDAP + Kerberos 架構的產品有 Windows AD, SAMBA 4.x, RedHat IDM(IPA)</p>
</blockquote>
<hr>
<h1 id="8-1-Using-Identity-Management-Services"><a href="#8-1-Using-Identity-Management-Services" class="headerlink" title="8.1 Using Identity Management Services"></a>8.1 Using Identity Management Services</h1><h2 id="8-1-1-User-information-and-authentication-services"><a href="#8-1-1-User-information-and-authentication-services" class="headerlink" title="8.1.1 User information and authentication services"></a>8.1.1 User information and authentication services</h2><p>中央認證系統會包含兩個部分：</p>
<h3 id="1-Account-information"><a href="#1-Account-information" class="headerlink" title="1. Account information"></a>1. Account information</h3><p>此部分用來存放使用者帳號的資訊，以及使用者權限等相關資訊。(例如：<strong>/etc/passwd</strong>)</p>
<h3 id="2-Authentication-information"><a href="#2-Authentication-information" class="headerlink" title="2. Authentication information"></a>2. Authentication information</h3><p>此部分的目的則是驗證使用者是否為其所宣稱的使用者，因此會包含密碼資訊，但這些密碼資訊通常會透過密碼學的技術輔助來加密，避免以明碼的方式呈現。(例如：<strong>/etc/shadow</strong>)</p>
<h3 id="其他補充"><a href="#其他補充" class="headerlink" title="其他補充"></a>其他補充</h3><p>Kerberos 僅能提供安全的驗證功能，無法提供使用者資訊；若需要使用者資訊，需要搭配 LDAP/NIS …. 等服務來提供。</p>
<p>目前 LDAP + Kerberos 的選擇有 Windows AD / SAMBA 4.x / RedHat IDM … 等。</p>
<p>透過調整 <code>/etc/nsswitch.conf</code>，可以調整驗證的順序</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@localhost ~]$ cat /etc/nsswitch.conf | grep <span class="string">'^[^#]'</span></span><br><span class="line">passwd:     files sss</span><br><span class="line">shadow:     files sss</span><br><span class="line">group:      files sss</span><br><span class="line">hosts:      files dns</span><br><span class="line">bootparams: nisplus [NOTFOUND=<span class="built_in">return</span>] files</span><br><span class="line">ethers:     files</span><br><span class="line">netmasks:   files</span><br><span class="line">networks:   files</span><br><span class="line">protocols:  files</span><br><span class="line">rpc:        files</span><br><span class="line">services:   files sss</span><br><span class="line">netgroup:   files sss</span><br><span class="line">publickey:  nisplus</span><br><span class="line">automount:  files</span><br><span class="line">aliases:    files nisplus</span><br></pre></td></tr></table></figure>
<blockquote>
<p>NSS 設定中的 sss 表示指向系統中的 sssd(security system daemon, for cache)，即使在沒網路的狀態下也還是可以進行認証</p>
</blockquote>
<p>RedHat 設計的工具大多以 <code>system-config</code> 開頭：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@localhost ~]$ system-config-</span><br><span class="line">system-config-authentication  system-config-firewall-tui    system-config-kickstart       system-config-printer-applet  </span><br><span class="line">system-config-date            system-config-kdump           system-config-language        system-config-users           </span><br><span class="line">system-config-firewall        system-config-keyboard        system-config-printer</span><br></pre></td></tr></table></figure>
<p>安裝 <code>system-config-authentication</code> 相關的工具：<code>sudo yum -y install authconfig-gtk sssd krb5-workstation</code></p>
<p>若 LDAP 過程中要加密，LDAP server 設定時就不能使用 IP，必須使用 domain name，否則 CA 憑證檢查不會過</p>
<blockquote>
<p>設定 Kerneros 要把 <code>Use DNS to resolve hosts to realm</code> &amp; <code>Use DNS to locate KDCs for realm</code> 兩個選項拿掉</p>
</blockquote>
<h2 id="8-1-2-Attaching-a-system-to-centralized-LDAP-and-Kerberos-servers"><a href="#8-1-2-Attaching-a-system-to-centralized-LDAP-and-Kerberos-servers" class="headerlink" title="8.1.2 Attaching a system to centralized LDAP and Kerberos servers"></a>8.1.2 Attaching a system to centralized LDAP and Kerberos servers</h2><p>設定時建議安裝套件：<code>authconfig-gtk</code>, <code>sssd</code>, <code>krb5-workstation</code></p>
<h3 id="Authconfig"><a href="#Authconfig" class="headerlink" title="Authconfig"></a>Authconfig</h3><p>RHCE 中的示範以 LDAP + Kerberos 為組合，有一些設定資訊是必須了解的：</p>
<ul>
<li><p><strong>/etc/ldap.conf</strong>：提供 LDAP 服務的 server 的相關設定</p>
</li>
<li><p><strong>/etc/krb5.conf</strong>：Kerberos 的相關設定</p>
</li>
<li><p><strong>/etc/sssd/sssd.conf</strong>：system security services daemon(sssd) 的設定，負責用來取得 &amp; 快取使用者的認證資訊</p>
</li>
<li><p><strong>/etc/nsswitch.conf</strong>：用來設定認證使用者所要使用的服務 or 系統</p>
</li>
<li><p><strong>/etc/pam.d</strong>：此目錄包含了提供了不同驗證機制的模組</p>
</li>
<li><p>/etc/openldap/cacerts：儲存 certificate 用</p>
</li>
</ul>
<blockquote>
<p>認證設定的過程建議使用 <code>authconfig-gtk</code>(提供 <strong>system-config-authentication</strong> 指令) or <code>authconfig-tui</code> 套件來協助，有圖形介面較為容易設定；不建議使用 <code>authconfig</code> 套件</p>
</blockquote>
<h3 id="LDAP"><a href="#LDAP" class="headerlink" title="LDAP"></a>LDAP</h3><p>LDAP 帳號描述範例：<code>cn=kevin,ou=sales,ou=tp,ou=tw,dc=example,dc=com</code> (DN, Distinguish Name)</p>
<p>LDAP 認証可用 SSL/TLS 加密</p>
<p><strong>要使用 LDAP 服務，要提供以下必要資訊</strong>：</p>
<ol>
<li><p>LDAP server hostname</p>
</li>
<li><p>base DN(即是上面的 <code>ou=tp,ou=tw,dc=example,dc=com</code>，依據要認證到的層級而定)</p>
</li>
<li><p>若要加密則必須 CA</p>
</li>
</ol>
<h3 id="Kerberos"><a href="#Kerberos" class="headerlink" title="Kerberos"></a>Kerberos</h3><p>兩大訴求：</p>
<ol>
<li><p>SSO (Single Sign On)</p>
</li>
<li><p>安全性高(驗證過程中，帳號密碼不會在網路上傳遞)</p>
</li>
</ol>
<p>密碼儲存 &amp; 認証方式：</p>
<ol>
<li><p>Server 儲存 hash 過後的密碼</p>
</li>
<li><p>client 認証時，會將輸入的密碼 hash 後的結果作為加密帳號資訊的對稱式金鑰，將資訊(user_account,time,….)加密後傳到 server 驗證</p>
</li>
<li><p>server 收到加密結果後，會拿資料庫中的 hash value 並進行解密，若是有符合則通過</p>
</li>
<li><p>為防止重送攻擊，被加密的資料有包含時間資訊(因此系統時間很重要)</p>
</li>
<li><p>假設驗證通過，server 會發送一個 ticket 給 client，之後 client 要存取其他 resource 只要提供 account &amp; ticket 即可，resource owner 會自動去找 KDC(Kerberos Key Distribution Center) 驗證 ticket 是否有效</p>
</li>
</ol>
<p><strong>要使用 Kerberos 服務，要提供以下必要資訊</strong>：</p>
<ol>
<li><p>Kerberos realm，類似 domain name 的概念</p>
</li>
<li><p>至少一個 key distribution center(KDC)，即為 Kerberos hostname</p>
</li>
<li><p>Admin server hostname(用來協助使用者密碼及其他資訊變更之用)，通常與 KDC 會是相同一台機器</p>
</li>
</ol>
<h2 id="8-1-3-Attaching-a-System-to-an-IPA-Server"><a href="#8-1-3-Attaching-a-System-to-an-IPA-Server" class="headerlink" title="8.1.3 Attaching a System to an IPA Server"></a>8.1.3 Attaching a System to an IPA Server</h2><p>在 RHEL 7 中提供了方便工具設定，安裝 <code>ipa-client</code> 套件即可。</p>
<p>以 non-interactive 的方式設定 IPA server 認証：<code>sudo ipa-client-install --domain=serverX.example.com --no-ntp --mkhomedir -p admin -w redhat123 -U</code></p>
<hr>
<h1 id="Practice-Connecting-to-a-Central-LDAP-and-Kerberos-Server"><a href="#Practice-Connecting-to-a-Central-LDAP-and-Kerberos-Server" class="headerlink" title="Practice: Connecting to a Central LDAP and Kerberos Server"></a>Practice: Connecting to a Central LDAP and Kerberos Server</h1><p>設定 LDAP + Kerberos 驗證的步驟：</p>
<p>1、安裝相關套件：<code>sudo yum -y install sssd authconfig-gtk krb5-workstation</code></p>
<p>2、使用圖形工具進行設定(設定如下)</p>
<p><img src="https://lh3.googleusercontent.com/yrIOq6ZotETj8rEMxH3hnoBqJzUmaF4A_aYQQlvMTuqU6u2-xBCA7aUMIkVBUi_uwjiSOcEr5V_TXrlv0jYDX_ikqhPjZVWPiXo5XKIoWUovuYNtbyPu4nibuVU1sZ150Y43kME_1dExiLtYF3cowhoHA_ex4CbHBDGULMGkfPJQnJkoWM_PVlb-xk1ENpKjElCw0If4VUMnyk6QsSjWTeKrUt6gl8A9Szi-DEWgh2FuhnXFFfL2BOlUmcvLeUDDDu7cT1v09QRqQI1usK3bDKIjrmNUaSAYQ8hPoxDqZaT0-KMycPnDwc8SWJXmm4En8uQMHSGMqFKlx1LmJqufLKZMaFZgF3rM1BN8pCYFxkUkws2nNuG-tmzHi0yxVq7T0vYFerWX66XTvhrOHiReMjLKp3IEm7ue4-AUNY9bcwlPgyjoOBJXId1vT4AgyHeR7sivsMFvwfw2jTwZdEEp2723scmSxiYoO0baKp7rrSnls11b9SI_ZIPd7gAD_42AqnstDCEWWsKzXCpGLXuAXFFjk14lO5g0MHtCd73J2aJmsz8QN_rMZK_Hd9YW44VJ6AEQF3rB4Sxq09bT6q8HPF9ht-ak_qg=w474-h710-no" alt="system-config-authentication"></p>
<p>3、驗證設定結果：<code>sudo getent passwd ldapuser1</code> or <code>ssh ldapuser1@server1</code>(密碼 <code>kerberos</code>)</p>
<hr>
<h1 id="Lab-Connecting-to-Network-defined-Users-and-Groups"><a href="#Lab-Connecting-to-Network-defined-Users-and-Groups" class="headerlink" title="Lab: Connecting to Network-defined Users and Groups"></a>Lab: Connecting to Network-defined Users and Groups</h1><p>Lab 設計為連線到 IPA server 進行驗證，步驟如下：</p>
<p>1、安裝相關套件：<code>sudo yum -y install ipa-client</code></p>
<p>2、設定連線：<code>sudo ipa-client-install --domain=server1.example.com --no-ntp --mkhomedir</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ipa-client-install --domain=server0.example.com --no-ntp --mkhomedir</span><br><span class="line"></span><br><span class="line">Discovery was successful!</span><br><span class="line">Hostname: desktop1.example.com</span><br><span class="line">Realm: SERVER0.EXAMPLE.COM</span><br><span class="line">DNS Domain: server1.example.com</span><br><span class="line">IPA Server: server1.example.com</span><br><span class="line">BaseDN: dc=server1,dc=example,dc=com</span><br><span class="line"></span><br><span class="line">Continue to configure the system with these values? [no]: yes</span><br><span class="line">User authorized to enroll computers: admin</span><br><span class="line">Synchronizing time with KDC...</span><br><span class="line">Unable to sync time with IPA NTP server, assuming the time is <span class="keyword">in</span> sync. Please check that 123 UDP port is opened.</span><br><span class="line">Password <span class="keyword">for</span> admin@SERVER1.EXAMPLE.COM:</span><br><span class="line">Successfully retrieved CA cert</span><br><span class="line">    Subject:     CN=Certificate Authority,O=SERVER1.EXAMPLE.COM</span><br><span class="line">    Issuer:      CN=Certificate Authority,O=SERVER1.EXAMPLE.COM</span><br><span class="line">    Valid From:  Tue May 17 20:31:07 2016 UTC</span><br><span class="line">    Valid Until: Sat May 17 20:31:07 2036 UTC</span><br><span class="line"></span><br><span class="line">Enrolled <span class="keyword">in</span> IPA realm SERVER1.EXAMPLE.COM</span><br><span class="line">Created /etc/ipa/default.conf</span><br><span class="line">New SSSD config will be created</span><br><span class="line">Configured /etc/sssd/sssd.conf</span><br><span class="line">Configured /etc/krb5.conf <span class="keyword">for</span> IPA realm SERVER1.EXAMPLE.COM</span><br><span class="line">trying https://server1.example.com/ipa/xml</span><br><span class="line">Forwarding <span class="string">'ping'</span> to server <span class="string">'https://server1.example.com/ipa/xml'</span></span><br><span class="line">Forwarding <span class="string">'env'</span> to server <span class="string">'https://server1.example.com/ipa/xml'</span></span><br><span class="line">Adding SSH public key from /etc/ssh/ssh_host_rsa_key.pub</span><br><span class="line">Adding SSH public key from /etc/ssh/ssh_host_ecdsa_key.pub</span><br><span class="line">Forwarding <span class="string">'host_mod'</span> to server <span class="string">'https://server1.example.com/ipa/xml'</span></span><br><span class="line">Could not update DNS SSHFP records.</span><br><span class="line">SSSD enabled</span><br><span class="line">Configured /etc/openldap/ldap.conf</span><br><span class="line">Configured /etc/ssh/ssh_config</span><br><span class="line">Configured /etc/ssh/sshd_config</span><br><span class="line">Client configuration complete.</span><br></pre></td></tr></table></figure>
<p>3、驗證設定結果：<code>sudo getent passwd ipauser</code> &amp; <code>ssh ipauser@localhost</code>(原本密碼為 <code>password</code>，改為 <code>redhat123</code>)</p>
<p>4、程式驗證：<code>lab ipaclient grade</code> (@desktop)</p>
]]></content>
      
        <categories>
            
            <category> RHCE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH134 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[KVM] Linux KVM 基本觀念]]></title>
      <url>/blog/2016/05/09/KVM/Linux-KVM-GettingStart/</url>
      <content type="html"><![CDATA[<h1 id="1、libvirt-and-libvirt-tools"><a href="#1、libvirt-and-libvirt-tools" class="headerlink" title="1、libvirt and libvirt tools"></a>1、libvirt and libvirt tools</h1><h2 id="libvirt"><a href="#libvirt" class="headerlink" title="libvirt"></a>libvirt</h2><p><code>libvirt</code> 是一組獨立於 hypervisor 之外的 API：</p>
<ol>
<li><p>提供一個標準，一般化且穩定的虛擬層，且可安全的管理主機上的虛擬機器</p>
</li>
<li><p>可用來管理本地系統以及透過網路相連主機的標準介面</p>
</li>
<li><p>提供的 API 包含了 provision, create, modify, monitor, control, migrate, stop 虛擬主機等相關功能，但也必須要 hypervisor 支援的前提下才可使用，但這些 API 緊限定於單一主機上的操作</p>
</li>
</ol>
<h2 id="virsh"><a href="#virsh" class="headerlink" title="virsh"></a>virsh</h2><p>virsh 是一個基於 libvirt management API 所打造出來的 CLI，提供非常多管理 hypervisor &amp; guest VM 的指令，且相當方便搭配 script 一起使用，同時也是 <code>virt-manager</code> GUI tool 的基礎。</p>
<blockquote>
<p>若不想用 virsh，也可以直接使用 <code>qemu-kvm</code> 指令</p>
</blockquote>
<h2 id="virt-manager"><a href="#virt-manager" class="headerlink" title="virt-manager"></a>virt-manager</h2><p>圖形介面的管理工具，也是提供了很多管理 VM 的功能(基於 virsh 為基礎所開發出來的)，包含了 provision VM, 管理 virtual network, 存取 VM console, 檢視效能統計資訊….等等。</p>
<h2 id="virt-install"><a href="#virt-install" class="headerlink" title="virt-install"></a>virt-install</h2><p>virt-install 是專門用來協助 provision VM 的 CLI，支援純文字 &amp; 圖形安裝(可透過 serial, SPICE or VNC 等不同協定)，且可指定 local or remote(NFS, HTTP or FTP) 的安裝媒體，搭配 Kickstart 作大量自動化安裝很好用。</p>
<hr>
<h1 id="2、Virtualized-hardware-devices"><a href="#2、Virtualized-hardware-devices" class="headerlink" title="2、Virtualized hardware devices"></a>2、Virtualized hardware devices</h1><h2 id="Para-virtualized-devices"><a href="#Para-virtualized-devices" class="headerlink" title="Para-virtualized devices"></a>Para-virtualized devices</h2><p>para-virtualized 技術提供了 VM 一個更快速且有效率的方式跟 host 主機溝通；而 KVM 透過 <code>virtio</code> API 作為中介層，提供 para-virtualized devices 給 VM 使用，</p>
<p>對於 I/O 工作頻繁的 VM 來說，建議使用 para-virtualized devices 來取代 emulated devices。</p>
<p>所有的 virtio device 都包含兩個部份：<code>host device</code> &amp; <code>guest driver</code>，而 Para-virtualized device drivers 的目的是在於協助 guest VM 可以直接存取 host 主機上的實體裝置而不需要再經過模擬轉換。</p>
<p>目前有 virtio-net, virtio-blk(block device), virtio-scsi(效能比 virtio-blk 好很多), virtio-balloon ….. 等等。</p>
<h2 id="VFIO"><a href="#VFIO" class="headerlink" title="VFIO"></a>VFIO</h2><p>Virtual Function I/O (VFIO) 是個 kernel driver，讓 guest VM 可直接高效率的存取 host 主機上的硬體裝置；VFIO 將 device assignment 的工作移出 KVM hypervisor 中，並將實體裝置在 kernel level 中獨立出來以達成直接被 VM 存取的目的。</p>
<h2 id="SR-IOV"><a href="#SR-IOV" class="headerlink" title="SR-IOV"></a>SR-IOV</h2><p>SR-IOV (Single Root I/O Virtualization) 是用在 PCI-e 的裝置上，讓裝置可以分享自身的 virtual fcuntion(VF) 出來直接給 guest VM 使用的一種技術。</p>
<h2 id="NPIV"><a href="#NPIV" class="headerlink" title="NPIV"></a>NPIV</h2><p>N_Port ID Virtualization (NPIV) 是種應用在高速企業級儲存裝置的功能(例如：SAN)，功能類似 SR-IOV，都是讓 VM 可以直接存取硬體支援的技術。</p>
<hr>
<h1 id="3、Storage"><a href="#3、Storage" class="headerlink" title="3、Storage"></a>3、Storage</h1><h2 id="Disk-Images-的存在型式"><a href="#Disk-Images-的存在型式" class="headerlink" title="Disk Images 的存在型式"></a>Disk Images 的存在型式</h2><p>Disk Image 會根據在本地 or 遠端存放的不同，而已不同的型式存在：</p>
<ol>
<li>Image files</li>
</ol>
<p>直接以 image 檔案的方式存在，這又可分為 raw &amp; qcow2 兩種格式，其中 raw 格式速度快，但功能少；而 qcow2 則提供很多其他功能(例如：snapshot, compression, encryption, 從 template image 啟動 VM …. 等等)。</p>
<ol>
<li>LVM volumes</li>
</ol>
<p>Logical volume 可以直接作為 disk image 使用，同時也提供了 thin provision, snapshot 等功能。</p>
<ol>
<li>Host devices</li>
</ol>
<p>可以直接使用 CD-ROM, 或是透過 SAN or iSCSI 掛載的 LUN 作為 image</p>
<ol>
<li>Distributed storage systems</li>
</ol>
<p>在 RHEL7 中甚至支援把 disk image 放在 GlusterFS 上</p>
<hr>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Virtualization_Getting_Started_Guide/index.html" target="_blank" rel="noopener">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Virtualization_Getting_Started_Guide/index.html</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> KVM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> KVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[RHCE7] RH134 Chapter 7. Managing SELinux Security 學習筆記]]></title>
      <url>/blog/2016/05/08/RHCE/RHCE7-RH134-LearningNotes-CH07_ManagingSELinuxSecurity/</url>
      <content type="html"><![CDATA[<p><a name="ch7.1"></a></p>
<h1 id="7-1-Enabling-and-Monitoring-Security-Enhanced-Linux-SELinux"><a href="#7-1-Enabling-and-Monitoring-Security-Enhanced-Linux-SELinux" class="headerlink" title="7.1 Enabling and Monitoring Security Enhanced Linux (SELinux)"></a>7.1 Enabling and Monitoring Security Enhanced Linux (SELinux)</h1><h2 id="7-1-1-Basic-SELinux-security-concepts"><a href="#7-1-1-Basic-SELinux-security-concepts" class="headerlink" title="7.1.1 Basic SELinux security concepts"></a>7.1.1 Basic SELinux security concepts</h2><p>SELinux 為系統安全提供了多一層的保護，目的在於當系統服務被攻陷後，還有另外一層機制(object-based)可以保護使用者的資料。</p>
<p><img src="https://lh3.googleusercontent.com/bR6HlmRdHb9TosMXahqB3BxjdVdlFnfgpHh3bYbHeOmr2xGY_tvnAd7YBE4S4UWVzO_DX56XWwh6ytRqH1V27HhfcgRVlSHI5il3oCrJDaq0CRj_SBKElh8LLtCi4oDh3X1YXTK0gRX3p39i0soYp_ILkDBUku85ao5bYgFwmADGGN7S4Hd2FCQaREgbk9SFKgXQRJgMsvpfwmCg3KBKR6yEhG9T9iiQZg2cxZdXxELuzOFLx0jjrbgn84jxtXNnkNJJlWaOKQKtq8qGReElZkvZy2F1ZaJTcJtO208xPgEtoHHbI4N9GJyGUIcQzDhQ3rlXBuPbcuo0TT_W1yULLmLxA-uGR_JnA4cm9wv16tJZs3zMdeUKsFNxALBFZptxtOkOcpi1jopCJUEvCw4NAHhExPVHVHkVdFS2a-KUjRMBRyrFX-sa-xC5Ey3l7dbgKgjHjYta11VozADz7WIUV1FUVkR2tUmdXv6_XJVwVpclaD2PXnd7tHbOmM8Mnf4mwMP4E6yjjWiuTk9YVpoGx_2_8Nyw3xzzJ9CHYJy-WVPgSI1Q-m0Co6ZcR2bK_6p02bE8h9nft0354PiugpLIqV6dKQ0SW6g=w888-h225-no" alt="SELinux"></p>
<p>在傳統架構下，當 web server 被攻陷後，駭客取得 <strong>apache</strong> 使用者的權限，就可以自由地存取 <strong>/var/www/html</strong>, <strong>/tmp</strong>, <strong>/var/tmp</strong> 等目錄；但若是在 SELinux 的限制下，就僅有 <strong>/var/www/html</strong> 可以存取。</p>
<p>從上面就不難看出，SELinux 定義了特定服務可以存取的特定 file、directory、port …. 等資訊，用以限縮 service owner 可以存取檔案的範圍；而方法就在於每一個 file, directory, process, port 都有所謂的 <code>SELinux context</code>。</p>
<p>而 context 大概長這樣 =&gt; <code>system_u:object_r:httpd_sys_content_t:s0</code></p>
<p>以 <strong>:</strong> 作為分隔，分別是 user(system_u), role(object_r), type(httpd_sys_content_t), sensitvity(s0)；而 SELinux rule 的制定則是以 type 為主來設計的。</p>
<p>舉例來說，與 Apache 相關的檔案位於 <strong>/var/www/html</strong> 中，而這裡檔案的 context type 則為 <code>httpd_sys_content_t</code> or <code>httpd_t</code>，與 Apache 服務運行相關的檔案則為 <code>http_port_t</code>，這些 context type　的檔案都可以讓 Apache service 存取；但若是 <strong>/tmp</strong> 與 <strong>/var/tmp</strong> 中的檔案，其 context type 則為 <code>tmp_t</code>，而 Apache service 要嘗試存取時就會被拒絕。</p>
<p>許多指令都可以透過 <code>-Z</code> 參數取得 SELinux context 資訊，例如：<code>ps axZ</code>, <code>ps -ZC httpd</code>, <code>ls -Z /var/www</code> … 等等。</p>
<h2 id="7-1-2-SELinux-modes"><a href="#7-1-2-SELinux-modes" class="headerlink" title="7.1.2 SELinux modes"></a>7.1.2 SELinux modes</h2><p>預設為 <strong>enforcing</strong> mode，但若是基於臨時性的需求而需要關掉 SELinux，可轉換成 <strong>permissive</strong> mode，此時只會有警告 &amp; Log，但不會被安全機制阻擋，且可以 online 切換，不須 reboot；但如果要完全 disable SELinux ，就需要重開機。</p>
<blockquote>
<p>使用 <code>getenforce</code> 指令就可以知道目前的 SELinux mode</p>
</blockquote>
<h2 id="7-1-3-SELinux-Booleans"><a href="#7-1-3-SELinux-Booleans" class="headerlink" title="7.1.3 SELinux Booleans"></a>7.1.3 SELinux Booleans</h2><p><strong>SELinux Booleans</strong> 是用來設定 SELinux Rules 是否啟用，可以用來調整 SELinux 的原始設定；若要檢視 SELinux Booleans 目前的設定值，可使用 <code>getsebool -a</code> 取得。</p>
<hr>
<p><a name="ch7.2"></a></p>
<h1 id="7-2-Changing-SELinux-Modes"><a href="#7-2-Changing-SELinux-Modes" class="headerlink" title="7.2 Changing SELinux Modes"></a>7.2 Changing SELinux Modes</h1><h2 id="7-2-1-Changing-the-current-SELinux-mode"><a href="#7-2-1-Changing-the-current-SELinux-mode" class="headerlink" title="7.2.1 Changing the current SELinux mode"></a>7.2.1 Changing the current SELinux mode</h2><p>檢視目前 SELinux 狀態：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ getenforce</span><br><span class="line">Permissive</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1(enforcing), 0(permissive)</span></span><br><span class="line">[vagrant@server tmp]$ sudo setenforce 1</span><br><span class="line">[vagrant@server tmp]$ getenforce</span><br><span class="line">Enforcing</span><br></pre></td></tr></table></figure>
<h2 id="7-2-2-Setting-the-default-SELinux-mode"><a href="#7-2-2-Setting-the-default-SELinux-mode" class="headerlink" title="7.2.2 Setting the default SELinux mode"></a>7.2.2 Setting the default SELinux mode</h2><p>SELinux 的設定檔位於 <code>/etc/selinux/config</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ cat /etc/selinux/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># This file controls the state of SELinux on the system.</span></span><br><span class="line"><span class="comment"># SELINUX= can take one of these three values:</span></span><br><span class="line"><span class="comment">#     enforcing - SELinux security policy is enforced.</span></span><br><span class="line"><span class="comment">#     permissive - SELinux prints warnings instead of enforcing.</span></span><br><span class="line"><span class="comment">#     disabled - No SELinux policy is loaded.</span></span><br><span class="line">SELINUX=permissive</span><br><span class="line"><span class="comment"># SELINUXTYPE= can take one of three two values:</span></span><br><span class="line"><span class="comment">#     targeted - Targeted processes are protected,</span></span><br><span class="line"><span class="comment">#     minimum - Modification of targeted policy. Only selected processes are protected.</span></span><br><span class="line"><span class="comment">#     mls - Multi Level Security protection.</span></span><br><span class="line">SELINUXTYPE=targeted</span><br></pre></td></tr></table></figure>
<p><code>permissive</code>：僅會 log 不會限制存取</p>
<p><code>enforcing</code>：會 log &amp; 限制存取</p>
<blockquote>
<p>SELINUXTYPE 預設為 targeted, 也許在少數狀況下會使用另外兩個</p>
<p>變更完設定後必須重新啟動，設定才會生效</p>
</blockquote>
<hr>
<p><a name="ch7.3"></a></p>
<h2 id="7-3-Chaging-SELinux-Contexts"><a href="#7-3-Chaging-SELinux-Contexts" class="headerlink" title="7.3 Chaging SELinux Contexts"></a>7.3 Chaging SELinux Contexts</h2><p>在開始這個部分之前，需要先安裝兩個必要套件，分別是 <code>policycoreutils</code> &amp; <code>policycoreutils-python</code>(semanage)</p>
<h3 id="7-3-1-Initial-SELinux-context"><a href="#7-3-1-Initial-SELinux-context" class="headerlink" title="7.3.1 Initial SELinux context"></a>7.3.1 Initial SELinux context</h3><p>在 RHEL7 中，檔案預設的 SELinux context 會由其所在的目錄所決定，新產生的檔案都會繼承目錄的 context(<code>vim</code>, <code>cp</code>, <code>touch</code> 適用)，但若是非新建的或是特別情況則不會(<code>mv</code>, <code>cp -a</code>)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># context =&gt; httpd_sys_content_t</span></span><br><span class="line">[student@server0 ~]$ ls -Zd /var/www/html</span><br><span class="line">drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 /var/www/html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 產生兩個檔案</span></span><br><span class="line">[student@server0 ~]$ sudo touch /var/www/html/index.html</span><br><span class="line">[student@server0 ~]$ sudo cp -a /tmp/rht /var/www/html/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建的繼承目錄的 context，透過 cp -a 的則保留原有的 context</span></span><br><span class="line">[student@server0 ~]$ ls -laZ /var/www/html/</span><br><span class="line">drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 .</span><br><span class="line">drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 ..</span><br><span class="line">-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 index.html</span><br><span class="line">-rw-r--r--. root root system_u:object_r:init_tmp_t:s0  rht</span><br></pre></td></tr></table></figure>
<h3 id="7-3-2-Changing-the-SELinux-context-of-a-file"><a href="#7-3-2-Changing-the-SELinux-context-of-a-file" class="headerlink" title="7.3.2 Changing the SELinux context of a file"></a>7.3.2 Changing the SELinux context of a file</h3><p>有兩種方式可以改變 SELinux context：</p>
<ol>
<li><p><code>chcon</code>：搭配 <code>-t</code> 參數指定所要變更的 context</p>
</li>
<li><p><code>restorecon</code>：直接將 context 改為預設 context (根據檔案 or 目錄所在的位置而定)</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 顯示目錄(/var/www/html)的預設 SELinux context</span></span><br><span class="line">[student@server0 ~]$ ls -laZ /var/www/html/</span><br><span class="line">drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 .</span><br><span class="line">drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 ..</span><br><span class="line">-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 index.html</span><br><span class="line">-rw-r--r--. root root system_u:object_r:init_tmp_t:s0  rht</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 chcon 變更檔案的 context</span></span><br><span class="line">[student@server0 ~]$ sudo chcon -t tmp_t /var/www/html/index.html</span><br><span class="line">[student@server0 ~]$ ls -laZ /var/www/html/</span><br><span class="line">drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 .</span><br><span class="line">drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 ..</span><br><span class="line">-rw-r--r--. root root unconfined_u:object_r:tmp_t:s0   index.html</span><br><span class="line">-rw-r--r--. root root system_u:object_r:init_tmp_t:s0  rht</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 restorecon 直接將檔案變成為預設值</span></span><br><span class="line">[student@server0 ~]$ sudo restorecon -vR /var/www/html</span><br><span class="line">restorecon reset /var/www/html/index.html context unconfined_u:object_r:tmp_t:s0-&gt;unconfined_u:object_r:httpd_sys_content_t:s0</span><br><span class="line">restorecon reset /var/www/html/rht context system_u:object_r:init_tmp_t:s0-&gt;system_u:object_r:httpd_sys_content_t:s0</span><br><span class="line">[student@server0 ~]$ ls -laZ /var/www/html/</span><br><span class="line">drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 .</span><br><span class="line">drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 ..</span><br><span class="line">-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 index.html</span><br><span class="line">-rw-r--r--. root root system_u:object_r:httpd_sys_content_t:s0 rht</span><br></pre></td></tr></table></figure>
<h3 id="7-3-3-Defining-SELinux-default-file-context-rules"><a href="#7-3-3-Defining-SELinux-default-file-context-rules" class="headerlink" title="7.3.3 Defining SELinux default file context rules"></a>7.3.3 Defining SELinux default file context rules</h3><p>使用 <code>semanage fcontext</code> 可以顯示(<code>-l</code>) or 修改(<code>-a</code>) 目錄的預設 SELinux context：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 / 建立新的目錄，其預設 SELinux context 為 default_t</span></span><br><span class="line">[student@server0 ~]$ sudo mkdir /virtual</span><br><span class="line"><span class="comment"># 在此目錄建立的檔案，context 也會變成 default_t</span></span><br><span class="line">[student@server0 ~]$ sudo touch /virtual/index.html</span><br><span class="line">[student@server0 ~]$ ls -alZ /virtual</span><br><span class="line">drwxr-xr-x. root root unconfined_u:object_r:default_t:s0 .</span><br><span class="line">drwxr-xr-x. root root system_u:object_r:root_t:s0      ..</span><br><span class="line">-rw-r--r--. root root unconfined_u:object_r:default_t:s0 index.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 semanage fcontext 修改 /virtual 目錄的預設 SELinux context</span></span><br><span class="line">[student@server0 ~]$ sudo semanage fcontext -a -t httpd_sys_content_t <span class="string">'/virtual(/.*)?'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過 restorecon 將 /virtual 目錄下的檔案還原為預設值</span></span><br><span class="line">[student@server0 ~]$ sudo restorecon -Rv /virtual</span><br><span class="line">restorecon reset /virtual context unconfined_u:object_r:default_t:s0-&gt;unconfined_u:object_r:httpd_sys_content_t:s0</span><br><span class="line">restorecon reset /virtual/index.html context unconfined_u:object_r:default_t:s0-&gt;unconfined_u:object_r:httpd_sys_content_t:s0</span><br><span class="line">[student@server0 ~]$ ls -alZ /virtual</span><br><span class="line">drwxr-xr-x. root root unconfined_u:object_r:httpd_sys_content_t:s0 .</span><br><span class="line">drwxr-xr-x. root root system_u:object_r:root_t:s0      ..</span><br><span class="line">-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 index.html</span><br></pre></td></tr></table></figure>
<hr>
<p><a name="ch7.3"></a></p>
<h1 id="7-4-Chaging-SELinux-Booleans"><a href="#7-4-Chaging-SELinux-Booleans" class="headerlink" title="7.4 Chaging SELinux Booleans"></a>7.4 Chaging SELinux Booleans</h1><p>安裝 <code>selinux-policy-devel</code> 套件可取得與 SELinux Booleans 相關的說明資訊，位於 <strong>selinux(8)</strong>，可使用 <code>man -k _selinux</code> 來查詢目前系統中存在的文件。</p>
<p>SELinux Booleans 是用來決定 rule 是否啟用的設定值，可透過 <code>getsebool</code> &amp; <code>setsebool</code> 兩個指令來設定：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取得 SELinux Booleans 資訊('-a' 參數表示顯示全木)</span></span><br><span class="line">[student@server0 ~]$ getsebool -a | grep httpd_enable_homedir</span><br><span class="line">httpd_enable_homedirs --&gt; off</span><br><span class="line">[student@server0 ~]$ getsebool httpd_enable_homedirs</span><br><span class="line">httpd_enable_homedirs --&gt; off</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 SELinux Boolean</span></span><br><span class="line">[student@server0 ~]$ sudo setsebool httpd_enable_homedirs on</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過 'semanage boolean -l' 可以查詢 SELinux Boolean 是否永久被更改(第二個結果)</span></span><br><span class="line">[student@server0 ~]$ sudo semanage boolean -l | grep httpd_enable_homedirs</span><br><span class="line">httpd_enable_homedirs          (on   ,  off)  Allow httpd to <span class="built_in">read</span> home directories</span><br><span class="line">[student@server0 ~]$ getsebool -a | grep httpd_enable_homedir</span><br><span class="line">httpd_enable_homedirs --&gt; on</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過 '-P' 參數永久變更 SELinux Boolean 的設定</span></span><br><span class="line">[student@server0 ~]$ sudo setsebool -P httpd_enable_homedirs on</span><br><span class="line">[student@server0 ~]$ getsebool -a | grep httpd_enable_homedir</span><br><span class="line">httpd_enable_homedirs --&gt; on</span><br><span class="line">[student@server0 ~]$ sudo semanage boolean -l | grep httpd_enable_homedirs</span><br><span class="line">httpd_enable_homedirs          (on   ,   on)  Allow httpd to <span class="built_in">read</span> home directories</span><br></pre></td></tr></table></figure>
<hr>
<p><a name="ch7.3"></a></p>
<h1 id="7-5-Troublshooting-SELinux"><a href="#7-5-Troublshooting-SELinux" class="headerlink" title="7.5 Troublshooting SELinux"></a>7.5 Troublshooting SELinux</h1><h2 id="7-5-1-Troubleshooting-SELinux-issues"><a href="#7-5-1-Troubleshooting-SELinux-issues" class="headerlink" title="7.5.1 Troubleshooting SELinux issues"></a>7.5.1 Troubleshooting SELinux issues</h2><p>關於 SELinux 會造成的 issue，大概會有幾個原因 &amp; 方向可以思考：</p>
<ol>
<li><p>服務是否有特定目錄 or 檔案的存取權限</p>
</li>
<li><p>可能是錯誤的 file context 造成的，此時可用 <code>restorecon</code> 解決</p>
</li>
<li><p>可能是太嚴格的 SELinux Boolean 設定所造成(例如 <code>ftpd_anon_write</code> 限制了匿名使用者對 FTP 服務的存取)</p>
</li>
<li><p>可能是 SELinux policy 的 bug 所造成</p>
</li>
</ol>
<h2 id="7-5-2-Monitoring-SELinux-violations"><a href="#7-5-2-Monitoring-SELinux-violations" class="headerlink" title="7.5.2 Monitoring SELinux violations"></a>7.5.2 Monitoring SELinux violations</h2><p>套件 <code>setroubleshoot-server</code> 必須安裝，才有辦法紀錄 SELinux 所產生的相關 log 資訊(存在於 <strong>/var/log/audit/audit.log</strong>)。</p>
<ul>
<li><p><code>sealert -l UUID</code>：檢視指定 UUID 的報告</p>
</li>
<li><p><code>sealert -a /var/log/audit/audit.log</code>：檢視 log 中所有的稽核報告</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">[student@server0 ~]$ sudo systemctl start httpd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 /root 下新增檔案，並移到 /var/www/html 目錄</span></span><br><span class="line">[student@server0 ~]$ sudo touch /root/file3</span><br><span class="line">[student@server0 ~]$ sudo mv /root/file3 /var/www/html/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 嘗試透過瀏覽器存取 file3</span></span><br><span class="line">[student@server0 ~]$ curl http://localhost/file3</span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC <span class="string">"-//IETF//DTD HTML 2.0//EN"</span>&gt;</span><br><span class="line">&lt;html&gt;&lt;head&gt;</span><br><span class="line">&lt;title&gt;403 Forbidden&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Forbidden&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;You don\<span class="string">'t have permission to access /file3</span></span><br><span class="line"><span class="string">on this server.&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;&lt;/html&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 從 /var/log/audit/audit.log 中尋找相關的錯誤資訊</span></span><br><span class="line"><span class="string">[student@server0 ~]$ sudo tail /var/log/audit/audit.log</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="string">type=AVC msg=audit(1462720907.786:517): avc:  denied  &#123; getattr &#125; for  pid=1754 comm="httpd" path="/var/www/html/file3" dev="vda1" ino=8846767 scontext=system_u:system_r:httpd_t:s0 tcontext=unconfined_u:object_r:admin_home_t:s0 tclass=file</span></span><br><span class="line"><span class="string">type=SYSCALL msg=audit(1462720907.786:517): arch=c000003e syscall=4 success=no exit=-13 a0=7fd102869b48 a1=7fff0049e4f0 a2=7fff0049e4f0 a3=7fd0f7202752 items=0 ppid=1751 pid=1754 auid=4294967295 uid=48 gid=48 euid=48 suid=48 fsuid=48 egid=48 sgid=48 fsgid=48 tty=(none) ses=4294967295 comm="httpd" exe="/usr/sbin/httpd" subj=system_u:system_r:httpd_t:s0 key=(null)</span></span><br><span class="line"><span class="string">type=AVC msg=audit(1462720907.786:518): avc:  denied  &#123; getattr &#125; for  pid=1754 comm="httpd" path="/var/www/html/file3" dev="vda1" ino=8846767 scontext=system_u:system_r:httpd_t:s0 tcontext=unconfined_u:object_r:admin_home_t:s0 tclass=file</span></span><br><span class="line"><span class="string">type=SYSCALL msg=audit(1462720907.786:518): arch=c000003e syscall=6 success=no exit=-13 a0=7fd102869c18 a1=7fff0049e4f0 a2=7fff0049e4f0 a3=0 items=0 ppid=1751 pid=1754 auid=4294967295 uid=48 gid=48 euid=48 suid=48 fsuid=48 egid=48 sgid=48 fsgid=48 tty=(none) ses=4294967295 comm="httpd" exe="/usr/sbin/httpd" subj=system_u:system_r:httpd_t:s0 key=(null)</span></span><br><span class="line"><span class="string">.......</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 找到 SELinux 相關的 UUID</span></span><br><span class="line"><span class="string">[student@server0 ~]$ sudo tail -50 /var/log/messages</span></span><br><span class="line"><span class="string">.....</span></span><br><span class="line"><span class="string">May  8 11:21:48 localhost setroubleshoot: Plugin Exception restorecon_source</span></span><br><span class="line"><span class="string">May  8 11:21:48 localhost setroubleshoot: SELinux is preventing /usr/sbin/httpd from getattr access on the file . For complete SELinux messages. run sealert -l 26a423d9-3dbd-413b-8048-3e7abec01df1</span></span><br><span class="line"><span class="string">May  8 11:21:48 localhost python: SELinux is preventing /usr/sbin/httpd from getattr access on the file .</span></span><br><span class="line"><span class="string">.....</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 透過 sealert -l 檢視詳細的報告內容</span></span><br><span class="line"><span class="string">[student@server0 ~]$ sudo sealert -l 26a423d9-3dbd-413b-8048-3e7abec01df1</span></span><br><span class="line"><span class="string">SELinux is preventing /usr/sbin/httpd from getattr access on the file .</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">*****  Plugin catchall (100. confidence) suggests   **************************</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">If you believe that httpd should be allowed getattr access on the  file by default.</span></span><br><span class="line"><span class="string">Then you should report this as a bug.</span></span><br><span class="line"><span class="string">You can generate a local policy module to allow this access.</span></span><br><span class="line"><span class="string">Do</span></span><br><span class="line"><span class="string">allow this access for now by executing:</span></span><br><span class="line"><span class="string"># grep httpd /var/log/audit/audit.log | audit2allow -M mypol</span></span><br><span class="line"><span class="string"># semodule -i mypol.pp</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Additional Information:</span></span><br><span class="line"><span class="string">Source Context                system_u:system_r:httpd_t:s0</span></span><br><span class="line"><span class="string">Target Context                unconfined_u:object_r:admin_home_t:s0</span></span><br><span class="line"><span class="string">Target Objects                 [ file ]</span></span><br><span class="line"><span class="string">Source                        httpd</span></span><br><span class="line"><span class="string">Source Path                   /usr/sbin/httpd</span></span><br><span class="line"><span class="string">Port                          &lt;Unknown&gt;</span></span><br><span class="line"><span class="string">Host                          localhost</span></span><br><span class="line"><span class="string">Source RPM Packages           httpd-2.4.6-17.el7.x86_64</span></span><br><span class="line"><span class="string">Target RPM Packages</span></span><br><span class="line"><span class="string">Policy RPM                    selinux-policy-3.12.1-153.el7.noarch</span></span><br><span class="line"><span class="string">Selinux Enabled               True</span></span><br><span class="line"><span class="string">Policy Type                   targeted</span></span><br><span class="line"><span class="string">Enforcing Mode                Enforcing</span></span><br><span class="line"><span class="string">Host Name                     server0.example.com</span></span><br><span class="line"><span class="string">Platform                      Linux server0.example.com 3.10.0-123.el7.x86_64 #1</span></span><br><span class="line"><span class="string">                              SMP Mon May 5 11:16:57 EDT 2014 x86_64 x86_64</span></span><br><span class="line"><span class="string">Alert Count                   1</span></span><br><span class="line"><span class="string">First Seen                    2016-05-09 00:21:47 JST</span></span><br><span class="line"><span class="string">Last Seen                     2016-05-09 00:21:47 JST</span></span><br><span class="line"><span class="string">Local ID                      26a423d9-3dbd-413b-8048-3e7abec01df1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Raw Audit Messages</span></span><br><span class="line"><span class="string">type=AVC msg=audit(1462720907.786:518): avc:  denied  &#123; getattr &#125; for  pid=1754 comm="httpd" path="/var/www/html/file3" dev="vda1" ino=8846767 scontext=system_u:system_r:httpd_t:s0 tcontext=unconfined_u:object_r:admin_home_t:s0 tclass=file</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">type=SYSCALL msg=audit(1462720907.786:518): arch=x86_64 syscall=lstat success=no exit=EACCES a0=7fd102869c18 a1=7fff0049e4f0 a2=7fff0049e4f0 a3=0 items=0 ppid=1751 pid=1754 auid=4294967295 uid=48 gid=48 euid=48 suid=48 fsuid=48 egid=48 sgid=48 fsgid=48 tty=(none) ses=4294967295 comm=httpd exe=/usr/sbin/httpd subj=system_u:system_r:httpd_t:s0 key=(null)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Hash: httpd,httpd_t,admin_home_t,file,getattr</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="補充教材"><a href="#補充教材" class="headerlink" title="補充教材"></a>補充教材</h1><h2 id="初階篇"><a href="#初階篇" class="headerlink" title="初階篇"></a>初階篇</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ id -Z</span><br><span class="line">unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</span><br><span class="line"></span><br><span class="line">[vagrant@server tmp]$ ls</span><br><span class="line">ABC  hosts  passwd  vagrant-shell</span><br><span class="line"></span><br><span class="line">[vagrant@server tmp]$ ls -Z</span><br><span class="line">drwxrwxrwx+ vagrant vagrant unconfined_u:object_r:user_tmp_t:s0 ABC</span><br><span class="line">-rw-r--r--. vagrant vagrant unconfined_u:object_r:user_tmp_t:s0 hosts</span><br><span class="line">-rw-r-xr--+ vagrant vagrant unconfined_u:object_r:user_tmp_t:s0 passwd</span><br><span class="line">-rwx--x--x. vagrant vagrant unconfined_u:object_r:user_tmp_t:s0 vagrant-shell</span><br></pre></td></tr></table></figure>
<p>以上權限對應 =&gt; system_r:object_r:var_t:s0</p>
<ol>
<li>User</li>
<li>Role</li>
<li>Type<br>若 SELinux 設定為 enforcing，只要看 type 即可</li>
</ol>
<p>SELinux 的 check policy 存放於 <code>/etc/selinux/targeted/policy/policy.29</code></p>
<p>安裝 <code>setools-console</code> 後就可以查詢 SELinux policy</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ ps auxZ | grep httpd</span><br><span class="line">system_u:system_r:httpd_t:s0    root     14773  0.0  0.2 221904  4968 ?        Ss   05:44   0:00 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">system_u:system_r:httpd_t:s0    apache   14774  0.0  0.1 221904  2972 ?        S    05:44   0:00 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">system_u:system_r:httpd_t:s0    apache   14775  0.0  0.1 221904  2972 ?        S    05:44   0:00 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">system_u:system_r:httpd_t:s0    apache   14776  0.0  0.1 221904  2972 ?        S    05:44   0:00 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">system_u:system_r:httpd_t:s0    apache   14777  0.0  0.1 221904  2972 ?        S    05:44   0:00 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">system_u:system_r:httpd_t:s0    apache   14778  0.0  0.1 221904  2972 ?        S    05:44   0:00 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可查詢來源端為 httpd_t 相關的權限設定</span></span><br><span class="line">[vagrant@server tmp]$ sesearch -A -s httpd_t</span><br><span class="line">....more</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢來源端為 httpd_t，目的端為 lib_t 的權限設定</span></span><br><span class="line">[vagrant@server tmp]$ sesearch -A -s httpd_t -t lib_t</span><br><span class="line">Found 13 semantic av rules:</span><br><span class="line">   allow domain base_ro_file_type : file \&#123; ioctl <span class="built_in">read</span> getattr lock open \&#125; ;</span><br><span class="line">   allow domain base_ro_file_type : dir \&#123; ioctl <span class="built_in">read</span> getattr lock search open \&#125; ;</span><br><span class="line">   allow domain base_ro_file_type : lnk_file \&#123; <span class="built_in">read</span> getattr \&#125; ;</span><br><span class="line">.... more</span><br></pre></td></tr></table></figure>
<h2 id="進階篇"><a href="#進階篇" class="headerlink" title="進階篇"></a>進階篇</h2><h3 id="限制-Process-對檔案目錄的存取"><a href="#限制-Process-對檔案目錄的存取" class="headerlink" title="限制 Process 對檔案目錄的存取"></a>限制 Process 對檔案目錄的存取</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ ls -ldZ /var/www/html</span><br><span class="line">drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 /var/www/html</span><br><span class="line"></span><br><span class="line">[vagrant@server tmp]$ ls -lZ passwd</span><br><span class="line">-rw-r--r--. vagrant vagrant unconfined_u:object_r:user_tmp_t:s0 passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 變更 SELinux context user/role/type</span></span><br><span class="line">[vagrant@server tmp]$ chcon -u system_u passwd</span><br><span class="line">[vagrant@server tmp]$ chcon -r object_r passwd</span><br><span class="line">[vagrant@server tmp]$ chcon -t httpd_sys_content_t passwd</span><br><span class="line">[vagrant@server tmp]$ ls -lZ passwd</span><br><span class="line">-rw-r--r--. vagrant vagrant system_u:object_r:httpd_sys_content_t:s0 passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同時變更 SELinux context user/role/type</span></span><br><span class="line">[vagrant@server tmp]$ chcon system_u:object_r:httpd_sys_content_t:s0 passwd</span><br></pre></td></tr></table></figure>
<p><code>policycoreutils-python</code> 套件是用來尋找正確的 SELinux Context type 之用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 尋找系統中已經存在的檔案 or 目錄的 context type</span></span><br><span class="line">[vagrant@server tmp]$ sudo semanage fcontext -l | grep /var/www</span><br><span class="line">/var/www(/.*)?                                     all files          system_u:object_r:httpd_sys_content_t:s0</span><br><span class="line">/var/www(/.*)?/logs(/.*)?                          all files          system_u:object_r:httpd_log_t:s0</span><br><span class="line">/var/www/[^/]*/cgi-bin(/.*)?                       all files          system_u:object_r:httpd_sys_script_exec_t:s0</span><br><span class="line">/var/www/svn(/.*)?                                 all files          system_u:object_r:httpd_sys_rw_content_t:s0</span><br><span class="line">/var/www/git(/.*)?                                 all files          system_u:object_r:git_content_t:s0</span><br><span class="line">/var/www/perl(/.*)?                                all files          system_u:object_r:httpd_sys_script_exec_t:s0</span><br><span class="line">.... more</span><br><span class="line"></span><br><span class="line"><span class="comment"># 參考同性質檔案 or 目錄的 context type</span></span><br><span class="line">[vagrant@server tmp]$ ls -ldZ /var/www</span><br><span class="line">drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 /var/www</span><br></pre></td></tr></table></figure>
<p><code>policycoreutils</code> 中的 <code>restorecon</code> 工具可幫助恢復成原有的標籤：例如：<code>restorecon -Rv /var/www/html/</code></p>
<blockquote>
<p>前提是資料庫必須要有相關資料</p>
</blockquote>
<h3 id="修改資料庫"><a href="#修改資料庫" class="headerlink" title="修改資料庫"></a>修改資料庫</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ sudo mkdir /WWW</span><br><span class="line">[vagrant@server tmp]$ ls -ldZ /WWW</span><br><span class="line">drwxr-xr-x. root root unconfined_u:object_r:default_t:s0 /WWW</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過 semanage fcontext 修改目錄預設的 SELinux context</span></span><br><span class="line">[vagrant@server tmp]$ sudo semanage fcontext -a -f a -t httpd_sys_content_t <span class="string">'/WWW(/.*)?'</span></span><br><span class="line">[vagrant@server tmp]$ sudo semanage fcontext -l | grep WWW</span><br><span class="line">/WWW(/.*)?                                         all files          system_u:object_r:httpd_sys_content_t:s0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢復原有設定</span></span><br><span class="line">[vagrant@server tmp]$ sudo restorecon -Rv /WWW</span><br><span class="line">restorecon reset /WWW context unconfined_u:object_r:default_t:s0-&gt;unconfined_u:object_r:httpd_sys_content_t:s0</span><br><span class="line">restorecon reset /WWW/aaa context unconfined_u:object_r:default_t:s0-&gt;unconfined_u:object_r:httpd_sys_content_t:s0</span><br><span class="line">[vagrant@server tmp]$ ls -ldZ /WWW</span><br><span class="line">drwxr-xr-x. root root unconfined_u:object_r:httpd_sys_content_t:s0 /WWW</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ sudo cp /etc/shadow /WWW/</span><br><span class="line">[vagrant@server tmp]$ ls -ldZ /WWW/</span><br><span class="line">drwxr-xr-x. root root unconfined_u:object_r:httpd_sys_content_t:s0 /WWW/</span><br><span class="line"></span><br><span class="line">[vagrant@server tmp]$ ls -ldZ /WWW/*</span><br><span class="line">----------. root root unconfined_u:object_r:httpd_sys_content_t:s0 /WWW/shadow</span><br><span class="line"></span><br><span class="line"><span class="comment"># -a 會保留原檔案的相關 metadata，因此不會被 dest dir 的 SELinux context 複寫</span></span><br><span class="line">[vagrant@server tmp]$ sudo cp -a /etc/shadow /WWW/shadow_a</span><br><span class="line">[vagrant@server tmp]$ ls -ldZ /WWW/*</span><br><span class="line">----------. root root unconfined_u:object_r:httpd_sys_content_t:s0 /WWW/shadow</span><br><span class="line">----------. root root system_u:object_r:shadow_t:s0    /WWW/shadow_a</span><br></pre></td></tr></table></figure>
<p>查詢 SELinux 相關的 log 可到 /var/log/audit/audit.log 查詢</p>
<h3 id="限制應用程式的特定功能是否能夠啟用"><a href="#限制應用程式的特定功能是否能夠啟用" class="headerlink" title="限制應用程式的特定功能是否能夠啟用"></a>限制應用程式的特定功能是否能夠啟用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ sudo semanage boolean -l | grep ftp</span><br><span class="line">ftp_home_dir                   (off  ,  off)  Allow ftp to home dir</span><br><span class="line">ftpd_use_cifs                  (off  ,  off)  Allow ftpd to use cifs</span><br><span class="line">sftpd_write_ssh_home           (off  ,  off)  Allow sftpd to write ssh home</span><br><span class="line">ftpd_use_fusefs                (off  ,  off)  Allow ftpd to use fusefs</span><br><span class="line">..... more</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加了 -P 會永久儲存，沒加就只會存到記憶體中</span></span><br><span class="line">[vagrant@server tmp]$ sudo setsebool -P ftp_home_dir 1</span><br><span class="line">[vagrant@server tmp]$ sudo semanage boolean -l | grep ftp</span><br><span class="line">ftp_home_dir                   (on   ,   on)  Allow ftp to home dir</span><br></pre></td></tr></table></figure>
<h3 id="限制應用程式所能夠存取的-port"><a href="#限制應用程式所能夠存取的-port" class="headerlink" title="限制應用程式所能夠存取的 port"></a>限制應用程式所能夠存取的 port</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ sudo semanage port -l | grep http</span><br><span class="line">http_cache_port_t              tcp      8080, 8118, 8123, 10001-10010</span><br><span class="line">http_cache_port_t              udp      3130</span><br><span class="line">http_port_t                    tcp      80, 81, 443, 488, 8008, 8009, 8443, 9000</span><br><span class="line">pegasus_http_port_t            tcp      5988</span><br><span class="line">pegasus_https_port_t           tcp      5989</span><br><span class="line"></span><br><span class="line"><span class="comment"># -a 增加 port, -d 刪除 port</span></span><br><span class="line">[vagrant@server tmp]$ sudo semanage port -a -t http_port_t -p tcp 5678</span><br><span class="line">[vagrant@server tmp] manage port -l | grep http_port_t</span><br><span class="line">http_port_t                    tcp      5678, 80, 81, 443, 488, 8008, 8009, 8443, 9000</span><br><span class="line">pegasus_http_port_t            tcp      5988</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Practice-Changing-SELinux-Booleans"><a href="#Practice-Changing-SELinux-Booleans" class="headerlink" title="Practice: Changing SELinux Booleans"></a>Practice: Changing SELinux Booleans</h1><p>啟用 web server 的使用者家目錄 web 功能</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安裝 apache</span></span><br><span class="line">$ sudo yum -y install httpd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 啟動 apache server</span></span><br><span class="line">$ sudo systemctl <span class="built_in">enable</span> httpd.service</span><br><span class="line">ln -s <span class="string">'/usr/lib/systemd/system/httpd.service'</span> <span class="string">'/etc/systemd/system/multi-user.target.wants/httpd.service'</span></span><br><span class="line">$ sudo systemctl start httpd.service</span><br><span class="line">$ sudo systemctl status httpd.service</span><br><span class="line">httpd.service - The Apache HTTP Server</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled)</span><br><span class="line">   Active: active (running) since Mon 2016-05-16 17:55:59 JST; 5s ago</span><br><span class="line">.......</span><br><span class="line"></span><br><span class="line"><span class="comment"># 開啟使用者 web 目錄為 ~/public_html</span></span><br><span class="line">$ sudo sed -i <span class="string">'s/^\s*#\(UserDir public_html\)/    \1/g'</span> /etc/httpd/conf.d/userdir.conf</span><br><span class="line">$ sudo sed -i <span class="string">'s/^\s*\(UserDir\sdisabled\)/    # \1/g'</span> /etc/httpd/conf.d/userdir.conf</span><br><span class="line">$ sudo systemctl restart httpd.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 index.html，但還是沒有權限可以存取</span></span><br><span class="line">$ mkdir ~/public_html</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"Hello Internet"</span> | sudo tee /home/student/public_html/index.html</span><br><span class="line">Hello Internet</span><br><span class="line">$ chmod 711 /home/student</span><br><span class="line">$ curl http://localhost/~student/index.html</span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC <span class="string">"-//IETF//DTD HTML 2.0//EN"</span>&gt;</span><br><span class="line">&lt;html&gt;&lt;head&gt;</span><br><span class="line">&lt;title&gt;403 Forbidden&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Forbidden&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;You don\<span class="string">'t have permission to access /~student/index.html</span></span><br><span class="line"><span class="string">on this server.&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;&lt;/html&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 檢視 SELinux Boolean 設定</span></span><br><span class="line"><span class="string">$ getsebool -a | grep httpd | grep home</span></span><br><span class="line"><span class="string">httpd_enable_homedirs --&gt; off</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 開啟 httpd_enable_homedirs</span></span><br><span class="line"><span class="string">$ sudo setsebool -P httpd_enable_homedirs on</span></span><br><span class="line"><span class="string">$ getsebool -a | grep httpd | grep home</span></span><br><span class="line"><span class="string">httpd_enable_homedirs --&gt; on</span></span><br><span class="line"><span class="string">$ curl http://localhost/~student/index.html</span></span><br><span class="line"><span class="string">Hello Internet</span></span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> RHCE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH134 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[RHCE7] RH134 Chapter 6. Controlling Access to Files with Access Control Lists(ACLs) 學習筆記]]></title>
      <url>/blog/2016/05/07/RHCE/RHCE7-RH134-LearningNotes-CH06_ControllingAccessToFilesWithAccessControlLists/</url>
      <content type="html"><![CDATA[<p>透過 ACL 的機制，可以讓一個檔案同時有多個 Owner or Group</p>
<p><a name="ch6.1"></a></p>
<h1 id="6-1-POSIX-Access-Control-Lists-ACLs"><a href="#6-1-POSIX-Access-Control-Lists-ACLs" class="headerlink" title="6.1 POSIX Access Control Lists (ACLs)"></a>6.1 POSIX Access Control Lists (ACLs)</h1><p>若 partition 格式為 ext4，mount 的時候必須加上 <code>-o acl</code> 參數：(以下為範例)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mount -o acl /dev/vdb1 /mnt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>或是在 /etc/fstab 上的參數設定加上 acl 也行</p>
</blockquote>
<p>也可以透過指令 <code>sudo tune2fs -o user_xattr,acl /dev/vdb1</code> 直接把屬性加入到 partition 的 superblock 中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取得 ACL 資訊</span></span><br><span class="line">[vagrant@server tmp]$ getfacl acl_test.txt</span><br><span class="line"><span class="comment"># file: acl_test.txt</span></span><br><span class="line"><span class="comment"># owner: vagrant</span></span><br><span class="line"><span class="comment"># group: vagrant</span></span><br><span class="line">user::rw-</span><br><span class="line">group::rw-</span><br><span class="line">other::r--</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入 User(user1) 權限 (使用 -m)</span></span><br><span class="line">[vagrant@server tmp]$ setfacl -m u:user1:r-x acl_test.txt</span><br><span class="line">[vagrant@server tmp]$ getfacl acl_test.txt</span><br><span class="line"><span class="comment"># file: acl_test.txt</span></span><br><span class="line"><span class="comment"># owner: vagrant</span></span><br><span class="line"><span class="comment"># group: vagrant</span></span><br><span class="line">user::rw-</span><br><span class="line">user:user1:r-x</span><br><span class="line">group::rw-</span><br><span class="line">mask::rwx</span><br><span class="line">other::r--</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入 User(user2 &amp; user3) 權限 (使用 -m)</span></span><br><span class="line">[vagrant@server tmp]$ setfacl -m u:user2:r-- acl_test.txt</span><br><span class="line">[vagrant@server tmp]$ setfacl -m u:user3:rwx acl_test.txt</span><br><span class="line">[vagrant@server tmp]$ getfacl acl_test.txt</span><br><span class="line"><span class="comment"># file: acl_test.txt</span></span><br><span class="line"><span class="comment"># owner: vagrant</span></span><br><span class="line"><span class="comment"># group: vagrant</span></span><br><span class="line">user::rw-</span><br><span class="line">user:user1:r-x</span><br><span class="line">user:user2:r--</span><br><span class="line">user:user3:rwx</span><br><span class="line">group::rw-</span><br><span class="line">mask::rwx</span><br><span class="line">other::r--</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入 Group(user4) 權限 (使用 -m)</span></span><br><span class="line">[vagrant@server tmp]$ setfacl -m g:user4:r-x acl_test.txt</span><br><span class="line">[vagrant@server tmp]$ getfacl acl_test.txt</span><br><span class="line"><span class="comment"># file: acl_test.txt</span></span><br><span class="line"><span class="comment"># owner: vagrant</span></span><br><span class="line"><span class="comment"># group: vagrant</span></span><br><span class="line">user::rw-</span><br><span class="line">user:user1:r-x</span><br><span class="line">user:user2:r--</span><br><span class="line">user:user3:rwx</span><br><span class="line">group::rw-</span><br><span class="line">group:user4:r-x</span><br><span class="line">mask::rwx</span><br><span class="line">other::r--</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除 User(user1 &amp; user2) 權限 (使用 -x)</span></span><br><span class="line">[vagrant@server tmp]$ setfacl -x u:user1 acl_test.txt</span><br><span class="line">[vagrant@server tmp]$ setfacl -x u:user2 acl_test.txt</span><br><span class="line">[vagrant@server tmp]$ getfacl acl_test.txt</span><br><span class="line"><span class="comment"># file: acl_test.txt</span></span><br><span class="line"><span class="comment"># owner: vagrant</span></span><br><span class="line"><span class="comment"># group: vagrant</span></span><br><span class="line">user::rw-</span><br><span class="line">user:user3:rwx</span><br><span class="line">group::rw-</span><br><span class="line">group:user4:r-x</span><br><span class="line">mask::rwx</span><br><span class="line">other::r--</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除 User(user3) &amp; Group(user4) 權限 (使用 -x)</span></span><br><span class="line">[vagrant@server tmp]$ setfacl -x u:user3 acl_test.txt</span><br><span class="line">[vagrant@server tmp]$ setfacl -x g:user4 acl_test.txt</span><br><span class="line">[vagrant@server tmp]$ getfacl acl_test.txt</span><br><span class="line"><span class="comment"># file: acl_test.txt</span></span><br><span class="line"><span class="comment"># owner: vagrant</span></span><br><span class="line"><span class="comment"># group: vagrant</span></span><br><span class="line">user::rw-</span><br><span class="line">group::rw-</span><br><span class="line">mask::rw-</span><br><span class="line">other::r--</span><br><span class="line"></span><br><span class="line"><span class="comment"># 複製指定檔案的 ACL 權限到另外一個檔案</span></span><br><span class="line">$ getfacl acl_test.txt | setfacl --<span class="built_in">set</span>-file=- acl_clone.txt</span><br></pre></td></tr></table></figure>
<h2 id="補充-使用-setfacl-變更檔案的傳統權限"><a href="#補充-使用-setfacl-變更檔案的傳統權限" class="headerlink" title="補充 (使用 setfacl 變更檔案的傳統權限)"></a>補充 (使用 setfacl 變更檔案的傳統權限)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ ll</span><br><span class="line">total 8</span><br><span class="line">-rw-rw-r--+ 1 vagrant vagrant  0 Feb 23 03:09 acl_test.txt</span><br><span class="line">-rwx--x--x. 1 vagrant vagrant 22 Feb 23 01:45 vagrant-shell</span><br><span class="line"></span><br><span class="line">[vagrant@server tmp]$ setfacl -m u::rwx acl_test.txt</span><br><span class="line">[vagrant@server tmp]$ setfacl -m g::rwx acl_test.txt</span><br><span class="line">[vagrant@server tmp]$ setfacl -m o::rwx acl_test.txt</span><br><span class="line">[vagrant@server tmp]$ ll</span><br><span class="line">total 8</span><br><span class="line">-rwxrwxrwx+ 1 vagrant vagrant  0 Feb 23 03:09 acl_test.txt</span><br><span class="line">-rwx--x--x. 1 vagrant vagrant 22 Feb 23 01:45 vagrant-shell</span><br></pre></td></tr></table></figure>
<p><code>flags</code> 表示 SUID, SGID, StickyBit：(下面的範例表示檔案有 SUID 的屬性)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ getfacl /bin/passwd</span><br><span class="line">getfacl: Removing leading <span class="string">'/'</span> from absolute path names</span><br><span class="line"><span class="comment"># file: bin/passwd</span></span><br><span class="line"><span class="comment"># owner: root</span></span><br><span class="line"><span class="comment"># group: root</span></span><br><span class="line"><span class="comment"># flags: s--</span></span><br><span class="line">user::rwx</span><br><span class="line">group::r-x</span><br><span class="line">other::r-x</span><br></pre></td></tr></table></figure>
<h2 id="補充-使用-setfacl-修改-mask-設定"><a href="#補充-使用-setfacl-修改-mask-設定" class="headerlink" title="補充(使用 setfacl 修改 mask 設定)"></a>補充(使用 setfacl 修改 mask 設定)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ getfacl acl_test.txt</span><br><span class="line"><span class="comment"># file: acl_test.txt</span></span><br><span class="line"><span class="comment"># owner: vagrant</span></span><br><span class="line"><span class="comment"># group: vagrant</span></span><br><span class="line">user::rwx</span><br><span class="line">group::rwx</span><br><span class="line">mask::rwx</span><br><span class="line">other::rwx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過 mask 可以限制 group 僅剩下 rw 的權限</span></span><br><span class="line">[vagrant@server tmp]$ setfacl -m m::r-x acl_test.txt</span><br><span class="line">[vagrant@server tmp]$ getfacl acl_test.txt</span><br><span class="line"><span class="comment"># file: acl_test.txt</span></span><br><span class="line"><span class="comment"># owner: vagrant</span></span><br><span class="line"><span class="comment"># group: vagrant</span></span><br><span class="line">user::rwx</span><br><span class="line">group::rwx			<span class="comment">#effective:r-x</span></span><br><span class="line">mask::r-x</span><br><span class="line">other::rwx</span><br></pre></td></tr></table></figure>
<h2 id="補充-已經有-ACL-的設定就不要再用-chmod"><a href="#補充-已經有-ACL-的設定就不要再用-chmod" class="headerlink" title="補充(已經有 ACL 的設定就不要再用 chmod)"></a>補充(已經有 ACL 的設定就不要再用 chmod)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ ll</span><br><span class="line">total 8</span><br><span class="line">-rwxr-xrwx+ 1 vagrant vagrant  0 Feb 23 03:09 acl_test.txt</span><br><span class="line">-rwx--x--x. 1 vagrant vagrant 22 Feb 23 01:45 vagrant-shell</span><br><span class="line">[vagrant@server tmp]$ chmod 123 acl_test.txt</span><br><span class="line">[vagrant@server tmp]$ ll</span><br><span class="line">total 8</span><br><span class="line">---x-w--wx+ 1 vagrant vagrant  0 Feb 23 03:09 acl_test.txt</span><br><span class="line">-rwx--x--x. 1 vagrant vagrant 22 Feb 23 01:45 vagrant-shell</span><br><span class="line">[vagrant@server tmp]$ getfacl acl_test.txt</span><br><span class="line"><span class="comment"># file: acl_test.txt</span></span><br><span class="line"><span class="comment"># owner: vagrant</span></span><br><span class="line"><span class="comment"># group: vagrant</span></span><br><span class="line">user::--x</span><br><span class="line">group::rwx			<span class="comment">#effective:-w-</span></span><br><span class="line">mask::-w-</span><br><span class="line">other::-wx</span><br></pre></td></tr></table></figure>
<h2 id="補充-若要稽核使用者使用檔案的狀況"><a href="#補充-若要稽核使用者使用檔案的狀況" class="headerlink" title="補充(若要稽核使用者使用檔案的狀況)"></a>補充(若要稽核使用者使用檔案的狀況)</h2><p>可使用 kernel 中的 Audit 功能，設定可參考 <code>/etc/audit</code> 目錄中的設定</p>
<h2 id="補充-其他"><a href="#補充-其他" class="headerlink" title="補充(其他)"></a>補充(其他)</h2><p>tar 打包時要包含 ACL &amp; SELinux 的權限，要加入 <code>-xattr</code> 參數</p>
<hr>
<p><a name="ch6.2"></a></p>
<h1 id="6-2-Securing-Files-with-ACLs"><a href="#6-2-Securing-Files-with-ACLs" class="headerlink" title="6.2 Securing Files with ACLs"></a>6.2 Securing Files with ACLs</h1><p>透過 <code>-b</code> 參數可回復沒有 ACL 權限設定的狀態，例如 <code>setfacl -b filename</code></p>
<h2 id="Setting-an-explicit-ACL-mask"><a href="#Setting-an-explicit-ACL-mask" class="headerlink" title="Setting an explicit ACL mask"></a>Setting an explicit ACL mask</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ setfacl -m u:user1:rwx passwd</span><br><span class="line">[vagrant@server tmp]$ setfacl -m u:user2:r-x passwd</span><br><span class="line">[vagrant@server tmp]$ setfacl -m g:user3:rwx passwd</span><br><span class="line">[vagrant@server tmp]$ setfacl -m g:user4:r-x passwd</span><br><span class="line">[vagrant@server tmp]$ getfacl passwd</span><br><span class="line"><span class="comment"># file: passwd</span></span><br><span class="line"><span class="comment"># owner: vagrant</span></span><br><span class="line"><span class="comment"># group: vagrant</span></span><br><span class="line">user::rw-</span><br><span class="line">user:user1:rwx</span><br><span class="line">user:user2:r-x</span><br><span class="line">group::r--</span><br><span class="line">group:user3:rwx</span><br><span class="line">group:user4:r-x</span><br><span class="line">mask::rwx</span><br><span class="line">other::r--</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 mask，限定所能設定的最大權限(注意 rwx 實際只有 r-x 可用)</span></span><br><span class="line">[vagrant@server tmp]$ setfacl -m m::r-x passwd</span><br><span class="line">[vagrant@server tmp]$ getfacl passwd</span><br><span class="line"><span class="comment"># file: passwd</span></span><br><span class="line"><span class="comment"># owner: vagrant</span></span><br><span class="line"><span class="comment"># group: vagrant</span></span><br><span class="line">user::rw-</span><br><span class="line">user:user1:rwx			<span class="comment">#effective:r-x</span></span><br><span class="line">user:user2:r-x</span><br><span class="line">group::r--</span><br><span class="line">group:user3:rwx			<span class="comment">#effective:r-x</span></span><br><span class="line">group:user4:r-x</span><br><span class="line">mask::r-x</span><br><span class="line">other::r--</span><br></pre></td></tr></table></figure>
<h2 id="設定檔案建立時的預設-ACL-權限-d"><a href="#設定檔案建立時的預設-ACL-權限-d" class="headerlink" title="設定檔案建立時的預設 ACL 權限(d)"></a>設定檔案建立時的預設 ACL 權限(<code>d</code>)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ mkdir ABC</span><br><span class="line">[vagrant@server tmp]$ chmod 777 ABC/</span><br><span class="line">[vagrant@server tmp]$ touch ABC/file.txt</span><br><span class="line">[vagrant@server tmp]$ getfacl ABC/file.txt</span><br><span class="line"><span class="comment"># file: ABC/file.txt</span></span><br><span class="line"><span class="comment"># owner: vagrant</span></span><br><span class="line"><span class="comment"># group: vagrant</span></span><br><span class="line">user::rw-</span><br><span class="line">group::rw-</span><br><span class="line">other::r--</span><br><span class="line"></span><br><span class="line">[vagrant@server tmp]$ setfacl -m d:u:user1:rwx ABC/</span><br><span class="line">[vagrant@server tmp]$ touch ABC/file2.txt</span><br><span class="line">[vagrant@server tmp]$ getfacl ABC/file2.txt</span><br><span class="line"><span class="comment"># file: ABC/file2.txt</span></span><br><span class="line"><span class="comment"># owner: vagrant</span></span><br><span class="line"><span class="comment"># group: vagrant</span></span><br><span class="line">user::rw-</span><br><span class="line">user:user1:rwx			<span class="comment">#effective:rw-</span></span><br><span class="line">group::rwx			<span class="comment">#effective:rw-</span></span><br><span class="line">mask::rw-</span><br><span class="line">other::rw-</span><br><span class="line"></span><br><span class="line">[vagrant@server tmp]$ ls -l ABC/</span><br><span class="line">total 4</span><br><span class="line">-rw-rw-rw-+ 1 vagrant vagrant 0 Feb 23 03:50 file2.txt</span><br><span class="line">-rw-rw-r--. 1 vagrant vagrant 0 Feb 23 03:50 file.txt</span><br></pre></td></tr></table></figure>
<h2 id="遞迴設定-ACL-權限-R-X"><a href="#遞迴設定-ACL-權限-R-X" class="headerlink" title="遞迴設定 ACL 權限(-R + X)"></a>遞迴設定 ACL 權限(-R + X)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 大寫 X =&gt; 表示 user1 對於檔案沒有 exec 的權限，但目錄則有 exec 的權限(才可瀏覽)</span></span><br><span class="line"><span class="comment"># -R =&gt; recusive</span></span><br><span class="line">$ setfacl -R -m u:user1:rX /dir</span><br></pre></td></tr></table></figure>
<h2 id="移除-ACL-權限-x"><a href="#移除-ACL-權限-x" class="headerlink" title="移除 ACL 權限(-x)"></a>移除 ACL 權限(<code>-x</code>)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ getfacl acl_clone.txt</span><br><span class="line"><span class="comment"># file: acl_clone.txt</span></span><br><span class="line"><span class="comment"># owner: student</span></span><br><span class="line"><span class="comment"># group: student</span></span><br><span class="line">user::rw-</span><br><span class="line">user:user1:r-x</span><br><span class="line">group::rw-</span><br><span class="line">group:group1:rw-</span><br><span class="line">group:group2:r-x</span><br><span class="line">mask::rwx</span><br><span class="line">other::---</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過 -x 參數，指定移除 user1 &amp; group2 的權限</span></span><br><span class="line">$ setfacl -x u:user1,g:group2 acl_clone.txt</span><br><span class="line">$ getfacl acl_clone.txt</span><br><span class="line"><span class="comment"># file: acl_clone.txt</span></span><br><span class="line"><span class="comment"># owner: student</span></span><br><span class="line"><span class="comment"># group: student</span></span><br><span class="line">user::rw-</span><br><span class="line">group::rw-</span><br><span class="line">group:group1:rw-</span><br><span class="line">mask::rw-</span><br><span class="line">other::---</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Practice-Using-ACLs-to-Grant-and-Limit-Access"><a href="#Practice-Using-ACLs-to-Grant-and-Limit-Access" class="headerlink" title="Practice: Using ACLs to Grant and Limit Access"></a>Practice: Using ACLs to Grant and Limit Access</h1><p>實作結果：</p>
<ol>
<li>讓 <strong>sodor</strong> group 與 <strong>controller</strong> group 在 <strong>/shares/steamies</strong> 目錄有相同的權限，但 user <strong>james</strong> 則是例外沒有任何權限</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 確認 controller 的 ACL 權限</span></span><br><span class="line">[student@server0 ~]$ sudo getfacl /shares/steamies/</span><br><span class="line">getfacl: Removing leading <span class="string">'/'</span> from absolute path names</span><br><span class="line"><span class="comment"># file: shares/steamies/</span></span><br><span class="line"><span class="comment"># owner: root</span></span><br><span class="line"><span class="comment"># group: controller</span></span><br><span class="line"><span class="comment"># flags: -s-</span></span><br><span class="line">user::rwx</span><br><span class="line">group::rwx</span><br><span class="line">other::---</span><br><span class="line">default:user::rwx</span><br><span class="line">default:group::rwx</span><br><span class="line">default:other::---</span><br><span class="line"></span><br><span class="line"><span class="comment"># 讓 sodor group 與 controller group 有相同的權限</span></span><br><span class="line">[student@server0 ~]$ sudo setfacl -Rm g:sodor:rwX /shares/steamies</span><br><span class="line">[student@server0 ~]$ sudo getfacl /shares/steamies/</span><br><span class="line">getfacl: Removing leading <span class="string">'/'</span> from absolute path names</span><br><span class="line"><span class="comment"># file: shares/steamies/</span></span><br><span class="line"><span class="comment"># owner: root</span></span><br><span class="line"><span class="comment"># group: controller</span></span><br><span class="line"><span class="comment"># flags: -s-</span></span><br><span class="line">user::rwx</span><br><span class="line">group::rwx</span><br><span class="line">group:sodor:rwx</span><br><span class="line">mask::rwx</span><br><span class="line">other::---</span><br><span class="line">default:user::rwx</span><br><span class="line">default:group::rwx</span><br><span class="line">default:other::---</span><br><span class="line"></span><br><span class="line"><span class="comment"># 讓 user james 沒有任何權限</span></span><br><span class="line">[student@server0 ~]$ sudo setfacl -Rm u:james:- /shares/steamies</span><br><span class="line">[student@server0 ~]$ sudo getfacl /shares/steamies/</span><br><span class="line">getfacl: Removing leading <span class="string">'/'</span> from absolute path names</span><br><span class="line"><span class="comment"># file: shares/steamies/</span></span><br><span class="line"><span class="comment"># owner: root</span></span><br><span class="line"><span class="comment"># group: controller</span></span><br><span class="line"><span class="comment"># flags: -s-</span></span><br><span class="line">user::rwx</span><br><span class="line">user:james:---</span><br><span class="line">group::rwx</span><br><span class="line">group:sodor:rwx</span><br><span class="line">mask::rwx</span><br><span class="line">other::---</span><br><span class="line">default:user::rwx</span><br><span class="line">default:group::rwx</span><br><span class="line">default:other::---</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>/shares/steamies</strong> 目錄底下的現有檔案都需要設定成上面的 ACL 權限</li>
</ol>
<blockquote>
<p>因為上面已經使用 <code>-R</code> 參數，因此這個部分已經完成</p>
</blockquote>
<ol>
<li>新增的目錄 &amp; 檔案也會有相同的 ACL 權限</li>
</ol>
<p>表示 <strong>sodor</strong> group 還是會有 rwx 權限，<strong>james</strong> user 也是同樣沒權限：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[student@server0 ~]$ sudo setfacl -m d:g:sodor:rwx /shares/steamies</span><br><span class="line">[student@server0 ~]$ sudo setfacl -m d:u:james:- /shares/steamies</span><br><span class="line">[student@server0 ~]$ sudo getfacl /shares/steamies</span><br><span class="line">getfacl: Removing leading <span class="string">'/'</span> from absolute path names</span><br><span class="line"><span class="comment"># file: shares/steamies</span></span><br><span class="line"><span class="comment"># owner: root</span></span><br><span class="line"><span class="comment"># group: controller</span></span><br><span class="line"><span class="comment"># flags: -s-</span></span><br><span class="line">user::rwx</span><br><span class="line">user:james:---</span><br><span class="line">group::rwx</span><br><span class="line">group:sodor:rwx</span><br><span class="line">mask::rwx</span><br><span class="line">other::---</span><br><span class="line">default:user::rwx</span><br><span class="line">default:user:james:---</span><br><span class="line">default:group::rwx</span><br><span class="line">default:group:sodor:rwx</span><br><span class="line">default:mask::rwx</span><br><span class="line">default:other::---</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> RHCE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH134 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[RHCE7] RH134 Chapter 5 Managing Priority of Linux Processes 學習筆記]]></title>
      <url>/blog/2016/05/04/RHCE/RHCE7-RH134-LearningNotes-CH05_ManagingPriorityOfLinuxProcesses/</url>
      <content type="html"><![CDATA[<p><a name="ch5.1"></a></p>
<h1 id="5-1-Process-Priority-and-“nice”-Concepts"><a href="#5-1-Process-Priority-and-“nice”-Concepts" class="headerlink" title="5.1 Process Priority and “nice” Concepts"></a>5.1 Process Priority and “nice” Concepts</h1><p>nice 值範圍 <code>-20</code> ~ <code>19</code>，沒指定預設就是 0，愈小表示 priority 愈高</p>
<blockquote>
<p>root 可以調大 or 調小 nice value，但一般使用者只能調大</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加上參數 -l 可取得 nice value(NI)</span></span><br><span class="line">[vagrant@server ~]$ ps -l</span><br><span class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">0 S  1000 11502 11501  0  80   0 - 28845 <span class="built_in">wait</span>   pts/0    00:00:00 bash</span><br><span class="line">0 R  1000 11572 11502  0  80   0 - 34343 -      pts/0    00:00:00 ps</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PR 20 = nice 0</p>
</blockquote>
<hr>
<p><a name="ch5.2"></a></p>
<h1 id="5-2-Using-nice-and-renice-to-Influence-Process-Priority"><a href="#5-2-Using-nice-and-renice-to-Influence-Process-Priority" class="headerlink" title="5.2 Using nice and renice to Influence Process Priority"></a>5.2 Using nice and renice to Influence Process Priority</h1><p>★★★★★★★★★ Very Important! ★★★★★★★★★ (start)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># o format =&gt; 使用者自訂顯示欄位</span></span><br><span class="line">$ ps axo pid,comm,nice --sort=-nice</span><br><span class="line"> PID COMMAND          NI</span><br><span class="line">   26 khugepaged       19</span><br><span class="line">  476 alsactl          19</span><br><span class="line">   25 ksmd              5</span><br><span class="line">  537 rtkit-daemon      1</span><br><span class="line">    1 systemd           0</span><br><span class="line">......</span><br><span class="line">   11 rcuos/0           0</span><br><span class="line">   12 watchdog/0        -</span><br><span class="line">......</span><br><span class="line">29921 ps                0</span><br><span class="line">  449 auditd           -4</span><br><span class="line">  467 sedispatch       -4</span><br><span class="line">  462 audispd          -8</span><br><span class="line"> 1583 pulseaudio      -11</span><br><span class="line">    5 kworker/0:0H    -20</span><br><span class="line">.......</span><br></pre></td></tr></table></figure>
<p>★★★★★★★★★ Very Important! ★★★★★★★★★ (end)</p>
<p>啟動程式時指定 nice 值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nice 示範</span></span><br><span class="line">$ nice -n 10 top</span><br><span class="line">$ ps -al</span><br><span class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">0 S  1000 11626 11502  0  90  10 - 36537 poll_s pts/0    00:00:00 top</span><br><span class="line">0 R  1000 11627 11604  0  80   0 - 34343 -      pts/1    00:00:00 ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># renice 示範</span></span><br><span class="line">$ renice -n 15 11604</span><br><span class="line">11604 (process ID) old priority 0, new priority 15</span><br><span class="line">$ ps -al</span><br><span class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">0 S  1000 11626 11502  0  90  10 - 36537 poll_s pts/0    00:00:00 top</span><br><span class="line">0 R  1000 11630 11604  0  95  15 - 34343 -      pts/1    00:00:00 ps</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="補充：Hash-Algorithm-特性"><a href="#補充：Hash-Algorithm-特性" class="headerlink" title="補充：Hash Algorithm 特性"></a>補充：Hash Algorithm 特性</h1><ol>
<li><p>計算的資料來源沒有長度限制</p>
</li>
<li><p>雜湊長度永遠固定</p>
</li>
<li><p>雜湊演算法為單向運算</p>
</li>
<li><p>不同的資料來源不會產出相同的雜湊值</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sha1sum /etc/passwd</span><br><span class="line">524dab4b600e8d87cb7aa5b21e4d57f8996a4374  /etc/passwd</span><br><span class="line"></span><br><span class="line">$ echo &quot;1234&quot; | sha1sum</span><br><span class="line">1be168ff837f043bde17c0314341c84271047b31  -</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Practice-Discovery-Process-Properties"><a href="#Practice-Discovery-Process-Properties" class="headerlink" title="Practice: Discovery Process Properties"></a>Practice: Discovery Process Properties</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根據 cpu 的核心數，執行兩倍數量的運算工作</span></span><br><span class="line">$ <span class="keyword">for</span> i <span class="keyword">in</span> $( seq $(($(grep -c <span class="string">'^processor'</span> /proc/cpuinfo) * 2)) ); <span class="keyword">do</span> sha1sum /dev/zero &amp; <span class="keyword">done</span></span><br><span class="line">[1] 31701</span><br><span class="line">[2] 31702</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">jobs</span></span><br><span class="line">[1]-  Running                 sha1sum /dev/zero &amp;</span><br><span class="line">[2]+  Running                 sha1sum /dev/zero &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用參數 u 可檢視資源使用率</span></span><br><span class="line">$ ps u $(pgrep sha1sum)</span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">student  31701 50.0  0.0 116096  1044 pts/0    R    14:26   1:29 sha1sum /dev/zero</span><br><span class="line">student  31702 50.0  0.0 116096  1044 pts/0    R    14:26   1:29 sha1sum /dev/zero</span><br><span class="line"></span><br><span class="line">$ nice -n 10 sha1sum /dev/zero &amp;</span><br><span class="line">[3] 31764</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過參數 o 指定顯示欄位 (nice value = 10 的 process 所佔的資源相對低)</span></span><br><span class="line">$ ps o pid,pcpu,nice,comm $(pgrep sha1sum)</span><br><span class="line">  PID %CPU  NI COMMAND</span><br><span class="line">31701 49.8   0 sha1sum</span><br><span class="line">31702 49.8   0 sha1sum</span><br><span class="line">31764  4.0  10 sha1sum</span><br><span class="line"></span><br><span class="line"><span class="comment"># 調整 process nice value，可看出資源使用率有提升</span></span><br><span class="line">$ sudo renice -n 5 31764</span><br><span class="line">$ ps o pid,pcpu,nice,comm $(pgrep sha1sum)</span><br><span class="line">  PID %CPU  NI COMMAND</span><br><span class="line">31701 48.8   0 sha1sum</span><br><span class="line">31702 48.8   0 sha1sum</span><br><span class="line">31764  6.2   5 sha1sum</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除所有使用 sha1sum 指令產生的 process</span></span><br><span class="line">$ killall sha1sum</span><br><span class="line">$ ps o pid,pcpu,nice,comm $(pgrep sha1sum)</span><br><span class="line">  PID %CPU  NI COMMAND</span><br><span class="line"> 2052  0.0   0 bash</span><br><span class="line">31825  0.0   0 ps</span><br><span class="line">[1]   Terminated              sha1sum /dev/zero</span><br><span class="line">[2]-  Terminated              sha1sum /dev/zero</span><br><span class="line">[3]+  Terminated              nice -n 10 sha1sum /dev/zero</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> RHCE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH134 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[RHCE7] RH134 Chapter 4 Scheduling Future Linux Tasks 學習筆記]]></title>
      <url>/blog/2016/05/04/RHCE/RHCE7-RH134-LearningNotes-CH04_SchedulingFutureLinuxTasks/</url>
      <content type="html"><![CDATA[<p><a name="ch4.1"></a></p>
<h1 id="4-1-Scheduling-One-Time-Tasks-with-at"><a href="#4-1-Scheduling-One-Time-Tasks-with-at" class="headerlink" title="4.1 Scheduling One-Time Tasks with at"></a>4.1 Scheduling One-Time Tasks with at</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server ~]$ at now+5minutes</span><br><span class="line">at&gt; cp /etc/yum.conf /tmp</span><br><span class="line">at&gt; &lt;EOT&gt;</span><br><span class="line">job 1 at Mon Feb 22 08:23:00 2016</span><br><span class="line"></span><br><span class="line"><span class="comment"># 看目前的排程</span></span><br><span class="line">$ atq</span><br><span class="line"></span><br><span class="line"><span class="comment"># 看指定排程的內容</span></span><br><span class="line">$ at -c 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刪除</span></span><br><span class="line">$ atrm 1</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ <span class="built_in">echo</span> <span class="string">"cp /etc/passwd /tmp"</span> &gt; file.txt</span><br><span class="line"></span><br><span class="line">[vagrant@server tmp]$ at now+10minutes &lt; file.txt</span><br><span class="line">job 2 at Mon Feb 22 08:31:00 2016</span><br><span class="line"></span><br><span class="line">[vagrant@server tmp]$ atq</span><br><span class="line">1	Mon Feb 22 08:23:00 2016 a vagrant</span><br><span class="line">2	Mon Feb 22 08:31:00 2016 a vagrant</span><br></pre></td></tr></table></figure>
<h3 id="Practice"><a href="#Practice" class="headerlink" title="Practice"></a>Practice</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ <span class="built_in">echo</span> <span class="string">"date &gt; ~/myjob"</span> | at now+3min</span><br><span class="line">job 3 at Mon Feb 22 08:33:00 2016</span><br><span class="line"></span><br><span class="line">[vagrant@server tmp]$ atq</span><br><span class="line">3	Mon Feb 22 08:33:00 2016 a vagrant</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意 while 的條件式中左右各要帶一個 space</span></span><br><span class="line">[vagrant@server tmp]$ <span class="keyword">while</span> [ $(atq | wc -l) -gt 0 ]; <span class="keyword">do</span> sleep 1s; <span class="keyword">done</span></span><br><span class="line">[vagrant@server tmp]$ cat ~/myjob</span><br><span class="line">Mon Feb 22 08:33:00 UTC 2016</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定 queue</span></span><br><span class="line">[vagrant@server tmp]$ at -q g teatime tomorrow</span><br><span class="line">at&gt; touch ~/cookies</span><br><span class="line">at&gt; &lt;EOT&gt;</span><br><span class="line">job 4 at Tue Feb 23 16:00:00 2016</span><br><span class="line"></span><br><span class="line">[vagrant@server tmp]$ at -q b 16:05 tomorrow</span><br><span class="line">at&gt; touch ~/cookies</span><br><span class="line">at&gt; &lt;EOT&gt;</span><br><span class="line">job 5 at Tue Feb 23 16:05:00 2016</span><br><span class="line"></span><br><span class="line">[vagrant@server tmp]$ atq</span><br><span class="line">4	Tue Feb 23 16:00:00 2016 g vagrant</span><br><span class="line">5	Tue Feb 23 16:05:00 2016 b vagrant</span><br></pre></td></tr></table></figure>
<hr>
<p><a name="ch4.2"></a></p>
<h1 id="4-2-Scheduling-Recurring-Jobs-with-cron-User-cron"><a href="#4-2-Scheduling-Recurring-Jobs-with-cron-User-cron" class="headerlink" title="4.2 Scheduling Recurring Jobs with cron (User cron)"></a>4.2 Scheduling Recurring Jobs with cron (User cron)</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 透過 crontab -e 來設定 user cron jobs</span></span><br><span class="line">[vagrant@server tmp]$ crontab -e</span><br><span class="line">01 * * * *  ~/test.sh</span><br><span class="line">30 2 * * *  run-parts   ~/cron.d</span><br><span class="line"></span><br><span class="line">[vagrant@server tmp]$ sudo ls /var/spool/cron/</span><br><span class="line">vagrant</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 root 身份檢視 vagrant 使用者的 cron jobs</span></span><br><span class="line">[vagrant@server tmp]$ sudo crontab -u vagrant -l</span><br><span class="line">01 * * * *  ~/test.sh</span><br><span class="line">30 2 * * *  run-parts   ~/cron.d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除 vagrant 的 user cron jobs</span></span><br><span class="line">[vagrant@server tmp]$ sudo crontab -u vagrant -r</span><br><span class="line">[vagrant@server tmp]$ sudo crontab -u vagrant -l</span><br><span class="line">no crontab <span class="keyword">for</span> vagrant</span><br></pre></td></tr></table></figure>
<h3 id="Practice-1"><a href="#Practice-1" class="headerlink" title="Practice"></a>Practice</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server ~]$ crontab -e</span><br><span class="line">*/2 9-16 * * 1-5 date &gt;&gt; /home/vagrant/my_first_cron_job</span><br><span class="line"></span><br><span class="line">[vagrant@server ~]$ crontab -l</span><br><span class="line">*/2 9-16 * * 1-5 date &gt;&gt; /home/vagrant/my_first_cron_job</span><br><span class="line"></span><br><span class="line">[vagrant@server ~]$ cat ~/my_first_cron_job</span><br><span class="line">Mon Feb 22 09:12:01 UTC 2016</span><br><span class="line"></span><br><span class="line">[vagrant@server ~]$ crontab -r</span><br><span class="line">[vagrant@server ~]$ crontab -l</span><br><span class="line">no crontab <span class="keyword">for</span> vagrant</span><br></pre></td></tr></table></figure>
<hr>
<p><a name="ch4.3"></a></p>
<h1 id="4-3-Scheduling-System-cron-Jobs"><a href="#4-3-Scheduling-System-cron-Jobs" class="headerlink" title="4.3 Scheduling System cron Jobs"></a>4.3 Scheduling System cron Jobs</h1><p>cron job 設定存在於 <code>/etc/crontab</code> 中，可透過 <code>man 5 crontab</code> 查詢格式 &amp; 設定方式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每個小時的第 1 分鐘</span></span><br><span class="line">01 * * * * *    root  /tmp/aa.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 星期天 02:01</span></span><br><span class="line">01 2 * * * 0    vagrant   /tmp/bb.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每個小時的第 2 分鐘，執行指定目錄中的所有檔案</span></span><br><span class="line">02 * * * * *    root  run-parts   /root/cron.d</span><br></pre></td></tr></table></figure>
<blockquote>
<p>指定的檔案都必須要有 <strong>execute</strong>(chmod +x) 的權限才會正確執行</p>
</blockquote>
<p><code>/etc/anacrontab</code> &amp; <code>/var/spool/anacron</code>(目錄)：用來處理未執行的 cron job</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ sudo cat /etc/anacrontab</span><br><span class="line"><span class="comment"># /etc/anacrontab: configuration file for anacron</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See anacron(8) and anacrontab(5) for details.</span></span><br><span class="line"></span><br><span class="line">SHELL=/bin/sh</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">MAILTO=root</span><br><span class="line"><span class="comment"># the maximal random delay added to the base delay of the jobs</span></span><br><span class="line">RANDOM_DELAY=45</span><br><span class="line"><span class="comment"># the jobs will be started during the following hours only</span></span><br><span class="line">START_HOURS_RANGE=3-22</span><br><span class="line"></span><br><span class="line"><span class="comment">#period in days   delay in minutes   job-identifier   command</span></span><br><span class="line">1	5	cron.daily		nice run-parts /etc/cron.daily</span><br><span class="line">7	25	cron.weekly		nice run-parts /etc/cron.weekly</span><br><span class="line">@monthly 45	cron.monthly		nice run-parts /etc/cron.monthly</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過比較日期的方式，判斷有哪些該執行的 cron job 未執行</span></span><br><span class="line">[vagrant@server tmp]$ ls /var/spool/anacron/</span><br><span class="line">cron.daily  cron.monthly  cron.weekly</span><br><span class="line">[vagrant@server tmp]$ sudo cat /var/spool/anacron/cron.daily</span><br><span class="line">20160222</span><br><span class="line">[vagrant@server tmp]$ sudo cat /var/spool/anacron/cron.monthly</span><br><span class="line">20160222</span><br><span class="line">[vagrant@server tmp]$ sudo cat /var/spool/anacron/cron.weekly</span><br><span class="line">20160222</span><br></pre></td></tr></table></figure>
<hr>
<p><a name="ch4.4"></a></p>
<h1 id="4-4-Managing-Temporary-Files"><a href="#4-4-Managing-Temporary-Files" class="headerlink" title="4.4 Managing Temporary Files"></a>4.4 Managing Temporary Files</h1><p>從 RHEL 7 開始，<code>init</code> 已經被 <code>systemd</code> 所取代</p>
<p>在 RHEL 7 之前，暫存檔的監控 &amp; 移除由 <code>tmpwatch</code> 套件來管理；但在 RHEL 7，systemd 提供了一個稱為 <code>systemd-tmpfiles</code> 的服務來監控 &amp; 管理所指定的目錄</p>
<p>透過 <code>stat filename</code> 可以檢視 inode 的內容，與 systemd-tmpfiles 相關的為 <code>Access Time</code>(atime)、<code>Modify Time</code>(mtime)、以及 <code>Change Time</code>(ctime)</p>
<h3 id="4-4-1-Managing-temporary-files-with-systemd-tmpfiles"><a href="#4-4-1-Managing-temporary-files-with-systemd-tmpfiles" class="headerlink" title="4.4.1 Managing temporary files with systemd-tmpfiles"></a>4.4.1 Managing temporary files with systemd-tmpfiles</h3><p><code>systemd-tmpfiles</code> 的功能在於定期(並非依賴 system cron，而是透過自身的 Timer 機制)的清除指定的目錄內容，或是恢復指定監控的目錄下被務刪的檔案，以下是設定範例(<code>/usr/lib/systemd/system/systemd-tmpfiles-clean.timer</code>)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Timer]</span><br><span class="line">OnBootSec=15min   # 開機後的 15 分鐘執行一次</span><br><span class="line">OnUnitActiveSec=1d  # 之後每天執行一次</span><br></pre></td></tr></table></figure>
<p><code>systemd-tmpfiles</code> 的設定檔有 3 個地方：</p>
<ul>
<li><p>/etc/tmpfiles.d/*.conf</p>
</li>
<li><p>/run/tmpfiles.d/*.conf</p>
</li>
<li><p>/usr/lib/tmpfiles.d/*.conf</p>
</li>
</ul>
<blockquote>
<p>下面兩個是屬於預設的設定檔，建議從下面兩個複製到第一個目錄後再修改，因為系統讀取到第一個目錄中有設定後，就不會執行下面兩個目錄的設定檔</p>
</blockquote>
<p>以上設定表示 <code>systemd-tmpfiles-clean.service</code> 會在 systemd 啟動後的 15 分鐘後啟動執行，並在每 24 小時後重新執行一次，並根據上面三個目錄中的 <code>*.conf</code> 的設定，執行 <code>systemd-tmpfiles --clean</code> 來清除不需要的檔案(藉由比對檔案的 atime/mtime/ctime)。</p>
<p>以下是設定檔範例說明：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 若 /run/tuned 目錄不存在，則建立，user/group 皆為 root，權限為 0755</span></span><br><span class="line">d /run/tuned 0755 root root -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除 /var/run/lsm 目錄中的內容</span></span><br><span class="line">D /var/run/lsm 0755 libstoragemgmt libstoragemgmt -</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tmpfiles.d 詳細的設定檔撰寫方式可參考 tmpfiles.d(5), systemd-tmpfiles(8) 等文件</p>
</blockquote>
<h3 id="補充"><a href="#補充" class="headerlink" title="補充"></a>補充</h3><p>RHEL 7 之前：standalone(daemon) service + xinetd(短暫式服務)</p>
<p>RHEL 7 之後：systemd service unit = service(對應到原先的 daemon) + socket(對應到原先的 xinetd) + path(監控目錄中檔案的變化，來決定執行的程式，例如：cups.path)</p>
<hr>
<h1 id="Practice-Managing-Temporary-Files"><a href="#Practice-Managing-Temporary-Files" class="headerlink" title="Practice: Managing Temporary Files"></a>Practice: Managing Temporary Files</h1><p>RHEL7 中，暫存檔由 <code>systemd-tmpfiles</code> 這個服務來進行管理。</p>
<p>將 /tmp 中的自動清除設定由 10 天改為 5 天：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 複製 template</span></span><br><span class="line">$ sudo cp /usr/lib/tmpfiles.d/tmp.conf /etc/tmpfiles.d/</span><br><span class="line">$ cat /etc/tmpfiles.d/tmp.conf</span><br><span class="line">.......</span><br><span class="line">d /tmp 1777 root root 5d</span><br><span class="line">d /var/tmp 1777 root root 30d</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 /etc/tmpfiles.d/tmp.conf 檔案，將 10d 改為 5d</span></span><br><span class="line">$ sudo sed -i <span class="string">'/^d .tmp /s/10d/5d/'</span> /etc/tmpfiles.d/tmp.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 測試設定是否成功</span></span><br><span class="line">$ sudo systemd-tmpfiles --clean tmp.conf</span><br></pre></td></tr></table></figure>
<p>設定 <strong>/run/gallifrey</strong> 每 30 秒清空一次：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 編輯設定檔</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"d /run/gallifrey 0700 root root 30s"</span> | sudo tee /etc/tmpfiles.d/gallifrey.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立規則</span></span><br><span class="line">$ sudo systemd-tmpfiles create gallifrey.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 測試是否有效</span></span><br><span class="line">$ sudo touch /run/gallifrey/helloworld</span><br><span class="line">$ sudo systemd-tmpfiles --clean gallifrey.conf</span><br><span class="line">$ sudo ls -l /run/gallifrey/</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> RHCE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH134 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[RHCE7] RH134 Chapter 3 Creating and Editing Text Files with vim 學習筆記]]></title>
      <url>/blog/2016/05/04/RHCE/RHCE7-RH134-LearningNotes-CH03_CreatingAndEditingTextFilesWithVim/</url>
      <content type="html"><![CDATA[<h1 id="3-3-Basic-vim-Workflow"><a href="#3-3-Basic-vim-Workflow" class="headerlink" title="3.3 Basic vim Workflow"></a>3.3 Basic vim Workflow</h1><h2 id="Editor-basics"><a href="#Editor-basics" class="headerlink" title="Editor basics"></a>Editor basics</h2><p><code>i</code>：進入 insert mode</p>
<p><code>I</code>：進入 insert mode，從游標所在行首插入新字元(<code>i</code> + <code>HOME</code>)</p>
<p><code>A</code>：<code>i</code> + <code>END</code></p>
<p><code>R</code>：replace mode，所輸入的會取代原本的內容</p>
<p><code>o</code>：在游標上方插入新的一行，並進入 insert mode</p>
<p><code>O</code>：在游標下方插入新的一行，並進入 insert mode</p>
<p><code>:n</code>：移到第 n 行</p>
<p><code>:$</code>：移到最後一行</p>
<p><code>u</code>：undo</p>
<p><code>Ctrl + r</code>： redo</p>
<p><code>w</code>(往後移動一個 word) &amp; <code>b</code>(往前移動一個 word)：可用 Ctrl + 左右鍵 取代</p>
<p><code>DEL</code> or <code>x</code>：刪除一個字元</p>
<p><code>20dd</code>：刪除 20 行</p>
<p><code>5yy</code>：複製 5 行</p>
<hr>
<h1 id="3-4-Editing-with-Vim"><a href="#3-4-Editing-with-Vim" class="headerlink" title="3.4 Editing with Vim"></a>3.4 Editing with Vim</h1><h2 id="Search-and-Replace"><a href="#Search-and-Replace" class="headerlink" title="Search and Replace"></a>Search and Replace</h2><p>簡單來說，就是在 vim 中使用 sed 的功能</p>
<p><code>:1,$s/the/*****/g</code>：將檔案中的 then 全部換成星號</p>
]]></content>
      
        <categories>
            
            <category> RHCE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH134 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[RHCE7] RH134 Chapter 2 Using Regular Expressions with grep 學習筆記]]></title>
      <url>/blog/2016/04/29/RHCE/RHCE7-RH134-LearningNotes-CH02_UsingRegularExpressionsWithGrep/</url>
      <content type="html"><![CDATA[<p><a name="ch2.2"></a></p>
<h1 id="2-2-Matching-Text-with-grep"><a href="#2-2-Matching-Text-with-grep" class="headerlink" title="2.2 Matching Text with grep"></a>2.2 Matching Text with grep</h1><p><code>.</code>(單一任何字元) &amp; <code>\</code>(跳脫字元) 的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 尋找 rcx.d</span><br><span class="line">[vagrant@server etc]$ ls | grep &apos;rc.\.d&apos;</span><br><span class="line">rc0.d</span><br><span class="line">rc1.d</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p><code>[]</code>(中括號，符合其中一個字元) &amp; <code>[^]</code> 的用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server etc]$ ls | grep <span class="string">'rc[134]\.d'</span></span><br><span class="line">rc1.d</span><br><span class="line">rc3.d</span><br><span class="line">rc4.d</span><br><span class="line"></span><br><span class="line">[vagrant@server etc]$ ls | grep <span class="string">'rc[1-3]\.d'</span></span><br><span class="line">rc1.d</span><br><span class="line">rc2.d</span><br><span class="line">rc3.d</span><br><span class="line"></span><br><span class="line">[vagrant@server etc]$ ls | grep <span class="string">'rc[^1-5]\.d'</span></span><br><span class="line">rc0.d</span><br><span class="line">rc6.d</span><br></pre></td></tr></table></figure>
<p><code>*</code>(零個或多個前面的字元) &amp; <code>\+</code>(一個或多個前面的字元) &amp; <code>\?</code>(零個或一個前面的字元) 的用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ cat file.txt</span><br><span class="line">ac</span><br><span class="line">abc</span><br><span class="line">abbc</span><br><span class="line">abbbc</span><br><span class="line">abbbbc</span><br><span class="line">abbbbbc</span><br><span class="line">abbbbbbc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到全部</span></span><br><span class="line">[vagrant@server tmp]$ cat file.txt | grep <span class="string">'ab*c'</span></span><br><span class="line">ac</span><br><span class="line">abc</span><br><span class="line">abbc</span><br><span class="line">abbbc</span><br><span class="line">abbbbc</span><br><span class="line">abbbbbc</span><br><span class="line">abbbbbbc</span><br><span class="line"></span><br><span class="line">[vagrant@server tmp]$ cat file.txt | grep <span class="string">'ab\+c'</span></span><br><span class="line">abc</span><br><span class="line">abbc</span><br><span class="line">abbbc</span><br><span class="line">abbbbc</span><br><span class="line">abbbbbc</span><br><span class="line">abbbbbbc</span><br><span class="line"></span><br><span class="line">[vagrant@server tmp]$ cat file.txt | grep <span class="string">'ab\?c'</span></span><br><span class="line">ac</span><br><span class="line">abc</span><br></pre></td></tr></table></figure>
<p><code>\{i\}</code>(i 個前面的字元) &amp; <code>\{i,\}</code>(大於等於 i 個前面的字元) &amp; <code>\{i,j\}</code>(i 到 j 的前面的字元) 的用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ cat file.txt | grep <span class="string">'ab\&#123;3\&#125;c'</span></span><br><span class="line">abbbc</span><br><span class="line"></span><br><span class="line">[vagrant@server tmp]$ cat file.txt | grep <span class="string">'ab\&#123;3,\&#125;c'</span></span><br><span class="line">abbbc</span><br><span class="line">abbbbc</span><br><span class="line">abbbbbc</span><br><span class="line">abbbbbbc</span><br><span class="line"></span><br><span class="line">[vagrant@server tmp]$ cat file.txt | grep <span class="string">'ab\&#123;3,4\&#125;c'</span></span><br><span class="line">abbbc</span><br><span class="line">abbbbc</span><br></pre></td></tr></table></figure>
<h3 id="練習：尋找包含-IP-address-的行"><a href="#練習：尋找包含-IP-address-的行" class="headerlink" title="練習：尋找包含 IP address 的行"></a>練習：尋找包含 IP address 的行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 尋找 IP address</span></span><br><span class="line">[vagrant@server ~]$ ip addr | grep <span class="string">'[0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125;'</span></span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">    inet 10.0.2.15/24 brd 10.0.2.255 scope global dynamic enp0s3</span><br><span class="line">    inet 172.25.25.11/24 brd 172.25.25.255 scope global enp0s8</span><br></pre></td></tr></table></figure>
<p><code>^</code>(一行的開頭) &amp; <code>$</code>(一行的結尾)的用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ cat passwd | grep <span class="string">'root'</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">operator:x:11:0:operator:/root:/sbin/nologin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 root 為開頭</span></span><br><span class="line">[vagrant@server tmp]$ cat passwd | grep <span class="string">'^root'</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 bsah 為結尾</span></span><br><span class="line">[vagrant@server tmp]$ cat passwd | grep <span class="string">'bash$'</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">vagrant:x:1000:1000:vagrant:/home/vagrant:/bin/bash</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ cat ff</span><br><span class="line">aaaaa cataaa aaaa</span><br><span class="line">aaaaa cat aaaaa</span><br><span class="line">aaaaa aaaacat aaaa</span><br><span class="line"></span><br><span class="line">[vagrant@server tmp]$ cat ff | grep <span class="string">'\&lt;cat\&gt;'</span></span><br><span class="line">aaaaa cat aaaaa</span><br></pre></td></tr></table></figure>
<p><code>-v</code>：反向(<strong>顯示沒符合的</strong>)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 搜尋沒有 root 的行</span></span><br><span class="line">[vagrant@server tmp]$ grep -v <span class="string">'root'</span> passwd</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br></pre></td></tr></table></figure>
<p><code>-n</code>：搜尋結果加上行號</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ grep -n <span class="string">'nologin'</span> passwd</span><br><span class="line">2:bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">3:daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">4:adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br></pre></td></tr></table></figure>
<p><code>-c</code>：列出符合條件的數量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 搜尋 /etc 有多少個目錄</span></span><br><span class="line">[vagrant@server tmp]$ sudo ls -lR /etc | grep -c <span class="string">'^d'</span></span><br><span class="line">179</span><br></pre></td></tr></table></figure>
<p><code>-l</code>：只列出符合條件的檔名</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server etc]$ grep <span class="string">'password'</span> /etc/* 2&gt;/dev/null</span><br><span class="line">/etc/dnsmasq.conf:<span class="comment">#dhcp-option=encap:175, 191, pass     # iSCSI password</span></span><br><span class="line">/etc/login.defs:<span class="comment">#	PASS_MAX_DAYS	Maximum number of days a password may be used.</span></span><br><span class="line">/etc/login.defs:<span class="comment">#	PASS_MIN_DAYS	Minimum number of days allowed between password changes.</span></span><br><span class="line">....</span><br><span class="line">/etc/login.defs:<span class="comment"># Use SHA512 to encrypt password.</span></span><br><span class="line">/etc/services:shell           514/tcp         cmd             <span class="comment"># no passwords used</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[vagrant@server etc]$ grep -l <span class="string">'password'</span> /etc/* 2&gt;/dev/null</span><br><span class="line">/etc/dnsmasq.conf</span><br><span class="line">/etc/login.defs</span><br><span class="line">/etc/services</span><br></pre></td></tr></table></figure>
<p><code>-r</code>：搜尋整個路徑下的檔案</p>
<p><code>-i</code>：不區分大小寫</p>
<p><code>-e</code>：可同時給多個搜尋條件</p>
<h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><ol>
<li><p><code>sed &#39;s/cat/dog/&#39; file.txt</code>：將檔案中每一行左邊的第一個 cat 換成 dog</p>
</li>
<li><p><code>sed &#39;s/cat/dog/gi&#39; file.txt</code>：同上，但全部一起置換，且不區分大小寫</p>
</li>
<li><p><code>sed &#39;s/[Cc]at/dog/gi&#39; file.txt</code>：Cat or cat 都會置換</p>
</li>
<li><p><code>sed &#39;s/\&lt;[Cc]at\&gt;/dog/gi&#39; file.txt</code>：只有精準的 Cat or cat 會被置換</p>
</li>
<li><p><code>sed &#39;1,30s/cat/dog/gi&#39; file.txt</code>：同 2，但僅處理 1~30 行</p>
</li>
<li><p><code>sed &#39;/begin/,/end/s/cat/dog/gi&#39; file.txt</code>：同 2，但僅處理 begin 開頭的行到 end 開頭的行</p>
</li>
<li><p><code>sed -e &#39;s/cat/dog/g&#39; -e &#39;s/Cat/dog/g&#39; file.txt</code>：同時給多個條件</p>
</li>
<li><p><code>set &#39;/^root/d&#39; file.txt</code>：開頭為 root 的行刪除</p>
</li>
<li><p><code>set &#39;/^root/!d&#39; file.txt</code>：開頭為 root 的行不刪除</p>
</li>
</ol>
<blockquote>
<p>加上 <strong><font color="red">-i</font></strong> 參數會將實際的改變反應到檔案中(原本預設是不會變更檔案內容)</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> RHCE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH134 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[RHCE7] RH134 Chapter 1 Automating Installation with Kickstart 學習筆記]]></title>
      <url>/blog/2016/04/29/RHCE/RHCE7-RH134-LearningNotes-CH01_AutomatingInstallationWithKickstart/</url>
      <content type="html"><![CDATA[<p><code>dmesg</code> 觀察由 Linux Kernel 所產生的 log 檔</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 製作 USB 安裝裝置</span></span><br><span class="line"><span class="comment"># /dev/sr0 為光碟機裝置</span></span><br><span class="line"><span class="comment"># /dev/sdb1 為 USB 裝置</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/sr0 of=/dev/sdb1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將 DVD 光碟轉成 iso 檔</span></span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/sr0 of=/tmp/rhel_dvd.iso</span><br></pre></td></tr></table></figure>
<p>安裝 Linux 方式：</p>
<ul>
<li>DVD/USB</li>
<li>Hard Disk</li>
<li>Network (必須先安裝 YUM server)<ul>
<li>FTP</li>
<li>HTTP</li>
<li>NFS</li>
</ul>
</li>
<li>PXE boot (找 CentOS PXE server)</li>
</ul>
<p>Kickstart:</p>
<ol>
<li>使用 boot.iso 開機</li>
<li>準備好 <code>ks.cfg</code>(安裝中需要的設定參數)</li>
<li>會進入到 <code>Boot:</code>，並輸入 <code>Boot: linux ks=floppy</code>，接著程式就會去找 <strong><font color="red">ks.cfg</font></strong> 並開始安裝</li>
</ol>
<blockquote>
<p>ks.cfg 也可以放置於其他地方，不一定要放在磁碟片中</p>
</blockquote>
<p><a name="ch1.1"></a></p>
<h1 id="1-1-Defining-the-Anaconda-Kickstart-System"><a href="#1-1-Defining-the-Anaconda-Kickstart-System" class="headerlink" title="1.1 Defining the Anaconda Kickstart System"></a>1.1 Defining the Anaconda Kickstart System</h1><h2 id="1-1-1-Introduction-to-Kickstart-installations"><a href="#1-1-1-Introduction-to-Kickstart-installations" class="headerlink" title="1.1.1 Introduction to Kickstart installations"></a>1.1.1 Introduction to Kickstart installations</h2><p>每個 seciton 由 <code>%</code> 開頭，並用 <code>%end</code> 結尾</p>
<p><code>%package</code> section 指定要所安裝的軟體</p>
<p><code>@</code> 開頭的設定表示指定 <code>package group</code>，可指定安裝 RedHat 預先設定的軟體群組，例如 core、Web Server …. 等等</p>
<p><code>@^</code>開頭表示指定 <code>enrironmental group</code>(group in package group)</p>
<p>其他客製化的需求可以放到 <code>%pre</code> &amp; <code>%post</code> script 中</p>
<h2 id="1-1-2-Kickstart-configuration-file-commands"><a href="#1-1-2-Kickstart-configuration-file-commands" class="headerlink" title="1.1.2 Kickstart configuration file commands"></a>1.1.2 Kickstart configuration file commands</h2><h3 id="Installation-commands"><a href="#Installation-commands" class="headerlink" title="Installation commands:"></a>Installation commands:</h3><ul>
<li><p><code>url</code>：用來指定安裝媒體的位置(FTP/HTTP/NFS …. etc)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 --url 指定來源</span></span><br><span class="line">url --url=<span class="string">"ftp://installserver.example.com/pub/RHEL7/dvd"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>repo</code>：用來指定要額外安裝的 package repository</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --name 指定名稱，--baseurl 指定 repository 位置</span></span><br><span class="line">repo --name=<span class="string">"Custom Packages"</span> --baseurl=<span class="string">"ftp://repo.example.com/custom"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>text</code>：預設以圖形模式顯示，用 text 可改成強制文字模式顯示</p>
</li>
<li><p><code>vnc</code>：設定 vnc 密碼</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vnc --password=redhat</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Partition-commands"><a href="#Partition-commands" class="headerlink" title="Partition commands"></a>Partition commands</h3><ul>
<li><p><code>clearpart</code>：安裝前清除硬碟上所有的 partition</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定清除 sda, sdb 兩顆硬碟</span></span><br><span class="line">clearpart --all --drivers=sda,sdb --initlabel</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>part</code>：設定 partition 要如何分割</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定 partition 目錄、檔案型態、大小....等資訊</span></span><br><span class="line">part /home --fstype=ext4 --label=homes --size=4096 --maxsize=8192 --grow</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ignoredisk</code>：安裝時忽略特定硬碟</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 忽略 sdc</span></span><br><span class="line">ignoredisk --drivers=sdc</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>bootloader</code>：指定安裝 bootloader 的地方</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 sda 上的 mbr 位置安裝 bootloader</span></span><br><span class="line">bootloader --location=mbr --boot-driver=sda</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>volgroup</code>, <code>logvol</code>：建立 LVM volume groups &amp; logical volumes</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">part pv.01 --size=8192</span><br><span class="line">volgroup myvg pv.01</span><br><span class="line">logvol / --vgname=myvg --fstype=xfs --size=2048 --name=rootvol -grow</span><br><span class="line">logvol /var --vgname=myvg --fstype=xfs --size=4096 --name=varvol</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>zerombr</code>：清除原有的 mbr 設定</p>
</li>
</ul>
<h3 id="Network-commands"><a href="#Network-commands" class="headerlink" title="Network commands"></a>Network commands</h3><ul>
<li><p><code>network</code>：設定網路</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 設定 eth0 為 DHCP</span></span><br><span class="line">network --device=eth0 --bootproto=dhcp</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>firewall</code>：設定防火牆，指定開啟(or 關閉)特定服務</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall --enabled --services=ssh,cups</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>lang</code>：語系設定</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lang en_US.UTF-8</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>keyboard</code>：鍵盤設定</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keyboard --vckeymap=us --xlayouts=<span class="string">'us'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>timezon</code>：設定時區、NTP server 以及是否使用 UTC</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 UTC, 指定 NTP server, 並設定時區</span></span><br><span class="line">timezon --utc --ntpservers=time.example.com Asia/Taipei</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>auth</code>：認證方式的設定</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 設定使用一般登入方式 &amp; 加密強度</span></span><br><span class="line">auth --useshadow --enablemd5 --passalgo=sha512</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>rootpw</code>：設定 root 密碼</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 也可以使用 "--uscrypted" 參數搭配加密過的密碼</span></span><br><span class="line">rootpwd --plaintext redhat</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>selinux</code>：設定 SELinux 的狀態</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selinux --enforcing</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>services</code>：設定各種 service 的預設狀態</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services --disabled=network,iptables,ip6tables</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>group</code>, <code>user</code>：建立指定的群組與使用者</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">group --name=admins --gid=10001</span><br><span class="line">user --name=jdoe --gecos=<span class="string">"John Doe"</span> --group=admins --password=changeme --plaintext</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Miscelaneous-commands"><a href="#Miscelaneous-commands" class="headerlink" title="Miscelaneous commands"></a>Miscelaneous commands</h3><ul>
<li><p><code>logging</code>：定義安裝時的 log 如何處理，可指定 remote logging server</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定 log level &amp; 要儲存的地方</span></span><br><span class="line">logging --host=loghost.example.com --level=INFO</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>reboot</code>, <code>poweroff</code>, <code>halt</code>：系統安裝完執行的動作</p>
</li>
</ul>
<blockquote>
<p>一堆設定不用記，需要的時候再到 <a href="https://access.redhat.com/documentation" target="_blank" rel="noopener">RedHat 官方網站</a> 查詢(Getting Started -&gt; Installation Guide)就好</p>
</blockquote>
<p>產生 ks.cfg 方式：</p>
<ol>
<li><p>透過 <code>system-config-kickstart</code> 可以透過圖形介面產生 ks.cfg</p>
<blockquote>
<p>必須在 /etc/yum.repos.d/rhel-dvd.repo 中要有 <code>rawhide</code> section 的設定，不然出來的圖形介面會沒有 package 可以選</p>
</blockquote>
</li>
<li><p>安裝好一台新的 RHEL，並找到 <code>/root/anaconda-ks.cfg</code> 檔案，拿出來用</p>
</li>
</ol>
<hr>
<p><a name="ch1.2"></a></p>
<h1 id="1-2-Deploying-a-New-Virtual-System-with-Kickstart"><a href="#1-2-Deploying-a-New-Virtual-System-with-Kickstart" class="headerlink" title="1.2 Deploying a New Virtual System with Kickstart"></a>1.2 Deploying a New Virtual System with Kickstart</h1><p><code>ksvalidator</code> 可用來檢查 ks.cfg 的格式是否正確 (什麼都結果都沒有表示正確)</p>
<h3 id="Publish-the-Kickstart-configuration-file-to-Anaconda"><a href="#Publish-the-Kickstart-configuration-file-to-Anaconda" class="headerlink" title="Publish the Kickstart configuration file to Anaconda"></a>Publish the Kickstart configuration file to Anaconda</h3><p>ks.cfg 可以放在很多不同的地方：</p>
<ul>
<li><p>可放在 FTP/HTTP/NFS … 等服務上</p>
</li>
<li><p>DHCP/TFTP server</p>
</li>
<li><p>USB disk or CD-ROM</p>
</li>
<li><p>Local disk</p>
</li>
<li><p>與 PXE server 結合</p>
</li>
</ul>
<h2 id="補充說明"><a href="#補充說明" class="headerlink" title="補充說明"></a>補充說明</h2><h3 id="遠端安裝-scenario-1"><a href="#遠端安裝-scenario-1" class="headerlink" title="遠端安裝 scenario 1"></a>遠端安裝 scenario 1</h3><ul>
<li><p>client: private/puiblic IP</p>
</li>
<li><p>remote server: public IP</p>
</li>
</ul>
<p>在 remote server 端執行如下：(光碟開機 -&gt; ESC 跳到 boot 選項)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 光碟開機 -&gt; ESC 跳到 boot 選項：</span></span><br><span class="line">boot: linux vncpassword=redhat ip=172.25.0.11 netmask=255.255.255.0 gateway=172.25.0.254</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上 IP 組態設定會根據不同的地點而不同</p>
</blockquote>
<h3 id="遠端安裝-scenario-2"><a href="#遠端安裝-scenario-2" class="headerlink" title="遠端安裝 scenario 2"></a>遠端安裝 scenario 2</h3><ul>
<li><p>client: public IP</p>
</li>
<li><p>remote server: private IP</p>
</li>
</ul>
<p>在 client 端下指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vncviewer --listen</span><br></pre></td></tr></table></figure>
<p>在 remote server 端執行如下：(光碟開機 -&gt; ESC 跳到 boot 選項)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boot: linux vnc vncconnect=172.25.254.250 ip=172.25.0.11 netmask=255.255.255.0 gateway=172.25.0.254 dns=8.8.8.8</span><br></pre></td></tr></table></figure>
<p>按下 Enter 後，client 會自動跑一個 VNC console 出來，並顯示 remote server 的安裝畫面。</p>
<blockquote>
<p>也可以通過 direct TCP port 5901 達成第一個方式</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> RHCE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH134 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[RHCE] RH124 Chapter 14 Accessing Linux File Systems 學習筆記]]></title>
      <url>/blog/2016/04/28/RHCE/RHCE7-RH124-LearningNotes-CH14_AccessingLinuxFileSystems/</url>
      <content type="html"><![CDATA[<p><a name="ch14.1"></a></p>
<h1 id="14-1-Identifying-File-Systems-and-Devices"><a href="#14-1-Identifying-File-Systems-and-Devices" class="headerlink" title="14.1 Identifying File Systems and Devices"></a>14.1 Identifying File Systems and Devices</h1><p>常用指令：</p>
<ul>
<li><code>sudo du -h / --max-depth=1 2&gt;/dev/null | sort -h</code>：檢查 root directory 每個目錄所使用的容量</li>
</ul>
<hr>
<p><a name="ch14.2"></a></p>
<h1 id="14-2-Mounting-and-Unmounting-File-Systems"><a href="#14-2-Mounting-and-Unmounting-File-Systems" class="headerlink" title="14.2 Mounting and Unmounting File Systems"></a>14.2 Mounting and Unmounting File Systems</h1><p>常用指令：</p>
<ul>
<li><p><code>blkid</code>：顯示所有 block device 資訊</p>
</li>
<li><p><code>mount source_device destination_dir</code>：透過 device name 掛載</p>
</li>
<li><p><code>mount UUID destination_dir</code>：透過 UUID 掛載</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查詢機器上的 block device</span></span><br><span class="line">$ sudo blkid</span><br><span class="line">/dev/vda1: UUID=<span class="string">"9bf6b9f7-92ad-441b-848e-0257cbb883d1"</span> TYPE=<span class="string">"xfs"</span> </span><br><span class="line">/dev/vdb1: UUID=<span class="string">"bffdaa4a-34f2-4a74-8455-a11aca40a6e1"</span> TYPE=<span class="string">"xfs"</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定 UUID 掛載 block device</span></span><br><span class="line">$ sudo mkdir /mnt/newspace &amp;&amp; sudo mount UUID=<span class="string">"bffdaa4a-34f2-4a74-8455-a11aca40a6e1"</span> /mnt/newspace</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸離 block device</span></span><br><span class="line">$ sudo umount /mnt/newspace</span><br></pre></td></tr></table></figure>
<hr>
<p><a name="ch14.3"></a></p>
<h1 id="14-3-Making-Links-Between-Files"><a href="#14-3-Making-Links-Between-Files" class="headerlink" title="14.3 Making Links Between Files"></a>14.3 Making Links Between Files</h1><h2 id="Partition-UUID-amp-inode"><a href="#Partition-UUID-amp-inode" class="headerlink" title="Partition UUID &amp; inode"></a>Partition UUID &amp; inode</h2><blockquote>
<p>UUID 存於 super block 中</p>
</blockquote>
<p>inode block -&gt; inode table 結構：</p>
<ol>
<li>inode number</li>
<li>Permission</li>
<li>Hard Link Subdirectory 數量</li>
<li>UID</li>
<li>GID</li>
<li>Size</li>
<li>Timestamp</li>
<li>Filename</li>
<li>Pointer</li>
</ol>
<h2 id="Hard-Link"><a href="#Hard-Link" class="headerlink" title="Hard Link"></a>Hard Link</h2><p><strong><font color="red">inode 在 Linux 中是真正指向檔案實際內容的指標</font></strong></p>
<p>透過 <code>ln</code> 可建立 Hard Link，這是個指向 inode 的連結</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 產生檔案</span></span><br><span class="line">[student@server0 ~]$ <span class="built_in">echo</span> <span class="string">"Hello World"</span> &gt; newfile.txt</span><br><span class="line">[student@server0 ~]$ ls -l</span><br><span class="line">total 4</span><br><span class="line">-rw-rw-r--. 1 student student 12  4月 28 15:05 newfile.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 hard link (注意數字從 1 變成 2, inode number 相同)</span></span><br><span class="line">[student@server0 ~]$ ln newfile.txt ~/newfile-hlink.txt</span><br><span class="line">[student@server0 ~]$ ls -li</span><br><span class="line">total 8</span><br><span class="line">12889 -rw-rw-r--. 2 student student 12  4月 28 15:05 newfile-hlink.txt</span><br><span class="line">12889 -rw-rw-r--. 2 student student 12  4月 28 15:05 newfile.txt</span><br></pre></td></tr></table></figure>
<p>Hard Link 特性 &amp; 說明：</p>
<ul>
<li>上面建立 Hard Link 的示範，可看出指向同一個 inode 的連結，從一個變成兩個(可防止檔案誤刪)</li>
<li>增加 hard link 不會增加磁碟空間</li>
<li>不能跨 File System</li>
<li>不能 link 目錄，只能建立在檔案上</li>
</ul>
<h2 id="Symbolic-Link"><a href="#Symbolic-Link" class="headerlink" title="Symbolic Link"></a>Symbolic Link</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立 symbolic link</span></span><br><span class="line">$ ln -s newfile.txt ~/newfile-symlink.txt</span><br><span class="line">$ ls -l</span><br><span class="line">total 8</span><br><span class="line">-rw-rw-r--. 2 student student 12  4月 28 15:05 newfile-hlink.txt</span><br><span class="line">lrwxrwxrwx. 1 student student 11  4月 28 15:19 newfile-symlink.txt -&gt; newfile.txt</span><br><span class="line">-rw-rw-r--. 2 student student 12  4月 28 15:05 newfile.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除 symbolic link 指向的檔案(系統會標示連結失效)</span></span><br><span class="line">$ rm newfile.txt </span><br><span class="line">$ ls -l</span><br><span class="line">total 4</span><br><span class="line">-rw-rw-r--. 1 student student 12  4月 28 15:05 newfile-hlink.txt</span><br><span class="line">lrwxrwxrwx. 1 student student 11  4月 28 15:19 newfile-symlink.txt -&gt; newfile.txt (這裡會有底色標記連結失效)</span><br><span class="line"></span><br><span class="line"><span class="comment"># link 目錄</span></span><br><span class="line">$ ln -s /etc ~/config_files</span><br></pre></td></tr></table></figure>
<p>特色：</p>
<ol>
<li>類似捷徑</li>
<li>不能防止檔案誤刪</li>
</ol>
<hr>
<p><a name="ch14.4"></a></p>
<h1 id="14-4-Locating-Files-on-the-System"><a href="#14-4-Locating-Files-on-the-System" class="headerlink" title="14.4 Locating Files on the System"></a>14.4 Locating Files on the System</h1><h2 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h2><p>要使用 locate 之前必須先執行 <code>sudo updatedb</code>，才會有檔案資料庫可用，若要搜尋最新的檔案，也必須要執行 updatedb</p>
<ul>
<li><p><code>sudo locate passwd</code>：尋找檔名為 passwd 的檔案</p>
</li>
<li><p><code>sudo locate -n 5 passwd</code>：同上，但只列出 5 筆資料</p>
</li>
<li><p><code>sudo locate -i messages</code>：以 case-insensitive 的方式搜尋</p>
</li>
</ul>
<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>即時搜尋，可找到剛新增的檔案</p>
<ul>
<li><p><code>sudo find / -name sshd_config</code>：搜尋檔名為 sshd_config 的檔案</p>
</li>
<li><p><code>sudo find / -name &#39;*.txt&#39;</code>：在 / 目錄下尋找副檔名為 txt 的檔案</p>
</li>
<li><p><code>sudo find / -iname &#39;*messages*&#39;</code>：在 / 目錄下以 case-insensitive 的方式檔名尋找 <em>messages</em> 的檔案</p>
</li>
<li><p><code>sudo find -user student</code>：尋找 /home 目錄中，user 為 student 的檔案</p>
</li>
<li><p><code>sudo find -group student</code>：尋找 /home 目錄中，group 為 student 的檔案</p>
</li>
<li><p><code>sudo find / -user root -group mail</code>：在 / 目錄中尋找 user=root, group=mail 的檔案</p>
</li>
<li><p><code>sudo find /home -perm 764</code>：尋找 /home 中 permission=764 檔案</p>
</li>
<li><p><code>sudo find /home -perm -324</code>：尋找 /home 中，<strong><font color="red">至少</font></strong>有指定權限的檔案</p>
</li>
<li><p><code>sudo find /home -perm /442</code>：尋找 /home 中，user(read)/group(read)/others(write) 至少其中一個符合指定權限的檔案</p>
</li>
<li><p><code>sudo find / -perm /7000</code>：搜尋檔案當中含有 SGID 或 SUID 或 SBIT 的屬性</p>
</li>
<li><p><code>sudo find /run -type s</code>：找出 /run 目錄中，檔案類型為 Socket 的檔名有哪些</p>
<blockquote>
<p>type 選項可以有 f(一般檔案) / d(目錄) / l(symbolic link) / b(block device)</p>
</blockquote>
</li>
<li><p><code>sudo find -size -10M</code>：尋找小於 10MB 的檔案</p>
</li>
<li><p><code>sudo find / -type f -links +1</code>：尋找擁有超過 1 個 hard link 的一般檔案</p>
</li>
</ul>
<h3 id="find-的特別功能"><a href="#find-的特別功能" class="headerlink" title="find 的特別功能"></a>find 的特別功能</h3><p>find 還可以針對搜尋結果加上 action：</p>
<p><code>sudo find /etc/yum.repos.d/ -type f -exec mv {} {}1 \;</code></p>
<p>以上指令表示：</p>
<ol>
<li><p>搜尋 /etc/yum.repos.d/ 目錄中的一般檔案</p>
</li>
<li><p>將每個檔案進行改名，在檔名後面多加一個 1</p>
</li>
</ol>
<hr>
<h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul>
<li><a href="http://linux.vbird.org/linux_basic/0230filesystem.php#link" target="_blank" rel="noopener">鳥哥的 Linux 私房菜 – 第七章、Linux 磁碟與檔案系統管理 &gt;&gt; 7.2.2 實體連結與符號連結： ln</a></li>
<li><a href="http://linux.vbird.org/linux_basic/0220filemanager.php#file_find" target="_blank" rel="noopener">鳥哥的 Linux 私房菜 – 第六章、Linux 檔案與目錄管理 &gt;&gt; 6.5 指令與檔案的搜尋</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> RHCE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH124 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[RHCE] RH124 Chapter 13 Installing and Updating Software Packages 學習筆記]]></title>
      <url>/blog/2016/04/27/RHCE/RHCE7-RH124-LearningNotes-CH13_InstallingAndUpdatingSoftwarePackages/</url>
      <content type="html"><![CDATA[<p><a name="ch13.2"></a></p>
<h1 id="13-2-RPM-Software-Packages-and-YUM"><a href="#13-2-RPM-Software-Packages-and-YUM" class="headerlink" title="13.2 RPM Software Packages and YUM"></a>13.2 RPM Software Packages and YUM</h1><table>
<thead>
<tr>
<th>功能</th>
<th>yum</th>
<th>rpm</th>
</tr>
</thead>
<tbody>
<tr>
<td>查詢</td>
<td>yum list &#124; grep <font color="blue"><em>KEYWORD</em></font> <br>yum search <font color="blue"><em>KEYWORD</em></font> <br>yum info <font color="blue"><em>PACKAGE_NAME</em></font> <br>yum provides <font color="blue"><em>FILE_PATH_NAME</em></font></td>
<td>rpm -qa &#124; grep <font color="blue"><em>KEYWORD</em></font> <br>rpm [ -qi &#124; -ql &#124; -qc &#124; -gd &#124; -q –scripts &#124; -q –changelog ] <font color="blue"><em>PACKAGE_NAME</em></font> <br> rpm -qf <font color="blue"><em>FILE_PATH</em></font></td>
</tr>
<tr>
<td>查詢(Group)</td>
<td>yum groups [ list &#124; info ]</td>
<td>rpm [ -qpi &#124; -qpl &#124; -qpc &#124; -qpd &#124; -qp –scripts &#124; -qp –changelog] <font color="blue"><em>PACKAGE_NAME</em></font></td>
</tr>
<tr>
<td>安裝</td>
<td>yum -y [group] install <font color="blue"><em>PACKAGE_NAME</em></font></td>
<td>rpm -ivh <font color="blue"><em>PACKAGE_NAME</em></font> <br>yum -y localinstall <font color="blue"><em>PACKAGE_NAME</em></font></td>
</tr>
<tr>
<td>更新</td>
<td>yum -y update <font color="blue"><em>PACKAGE_NAME</em></font></td>
<td>rpm -Uvh <font color="blue"><em>PACKAGE_NAME</em></font></td>
</tr>
<tr>
<td>移除</td>
<td>yum -y [group] remove <font color="blue"><em>PACKAGE_NAME</em></font></td>
<td>rpm -e <font color="blue"><em>PACKAGE_NAME</em></font></td>
</tr>
</tbody>
</table>
<hr>
<p><a name="ch13.3"></a></p>
<h1 id="13-3-Managing-Software-Updates-with-yum"><a href="#13-3-Managing-Software-Updates-with-yum" class="headerlink" title="13.3 Managing Software Updates with yum"></a>13.3 Managing Software Updates with yum</h1><ul>
<li><p><code>sudo yum group install &quot;Development Tools&quot;</code>：安裝整包 Development Tools</p>
</li>
<li><p><code>yum list kernel</code>：列出 kernel 清單 (包含已經安裝 &amp; 可安裝的)</p>
</li>
<li><p><code>uname -r</code>：列出 kenal 版本</p>
</li>
<li><p><code>uname -a</code>：列出 kernel 詳細資訊</p>
</li>
<li><p><code>sudo yum history</code>：檢視 yum 歷程記錄</p>
</li>
<li><p><code>sudo yum undo 5</code>：取消 ID=5 所紀錄的 yum 工作</p>
</li>
</ul>
<hr>
<p><a name="ch13.4"></a></p>
<h1 id="13-4-Enabling-yum-Software-Repositories"><a href="#13-4-Enabling-yum-Software-Repositories" class="headerlink" title="13.4 Enabling yum Software Repositories"></a>13.4 Enabling yum Software Repositories</h1><p><code>/etc/yum.repos.d/*.repo</code>：此目錄內的附檔名必須都是 <strong>repo</strong></p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[ID]</span></span><br><span class="line"><span class="attr">name</span>=</span><br><span class="line"><span class="attr">baseurl</span>= YUM server 上的容器</span><br><span class="line"><span class="attr">enabled</span>=</span><br><span class="line"><span class="attr">gpgcheck</span>=</span><br></pre></td></tr></table></figure>
<p>常用指令：</p>
<ul>
<li><p><code>yum repolist all</code>：列出目前所有 repository</p>
</li>
<li><p><code>sudo yum-config-manager --disable rhel_dvd</code>：停用 “rhel_dvd” repository</p>
</li>
<li><p><code>sudo yum-config-manager --add-repo=&quot;http://content.example.com/rhel7.0/x86_64/rht/&quot;</code>：直接指定路徑增加 repository</p>
</li>
<li><p><code>sudo rpm --import http://dl.fedoraproject.org/pub/epel/RPM-GPG-KEY-EPEL-7</code>：加入 GPG Key</p>
</li>
<li><p><code>sudo yum -y install http://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm</code>：透過 rpm 安裝方式加入 repository</p>
</li>
</ul>
<p>其他：</p>
<ul>
<li><p><code>EPEL</code>：Extra Package for Enterprise Linux</p>
</li>
<li><p>使用 yum-config-manager 搭配 <code>--nogpgcheck</code> 表示忽略 GPG key 的檢查，可能會有安全性上的風險</p>
</li>
</ul>
<h3 id="非常重要-Practice-非常重要"><a href="#非常重要-Practice-非常重要" class="headerlink" title="(非常重要) ===== Practice ====== (非常重要)"></a>(<strong><font color="red">非常重要</font></strong>) ===== Practice ====== (<strong><font color="red">非常重要</font></strong>)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum-config-manager --add-repo=<span class="string">"http://content.example.com/rhel7.0/x86_64/rht"</span></span><br><span class="line">[content.example.com_rhel7.0_x86_64_rht]</span><br><span class="line">name=added from: http://content.example.com/rhel7.0/x86_64/rht</span><br><span class="line">baseurl=http://content.example.com/rhel7.0/x86_64/rht</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure>
<p>編輯 <strong><font color="red">/etc/yum.repo.d/errata.repo</font></strong> 內容如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[updates]</span><br><span class="line">name=RedHat updates</span><br><span class="line">baseurl=http://content.example.com/rhel7.0/x86_64/errata</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 檢查詢所有的 repository (包含 enabled &amp; disabled)</span></span><br><span class="line">$ yum repolist all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停用指定 repository</span></span><br><span class="line">$ sudo yum-config-manager --<span class="built_in">disable</span> content.example.com_rhel7.0_x86_64_rht</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次確認 repository 狀態</span></span><br><span class="line">$ yum repolist all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 套件升級(會發現有個 kernel 的 update 來自剛剛的 errata repo)</span></span><br><span class="line">$ sudo yum -y update</span><br><span class="line"><span class="comment"># 檢視目前系統中所有的 kernel 清單</span></span><br><span class="line">$ yum list kernel</span><br></pre></td></tr></table></figure>
<hr>
<p><a name="ch13.5"></a></p>
<h1 id="13-5-Examining-RPM-Package-Files"><a href="#13-5-Examining-RPM-Package-Files" class="headerlink" title="13.5 Examining RPM Package Files"></a>13.5 Examining RPM Package Files</h1><p>rpm 常用參數：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查詢指定套件</span></span><br><span class="line">$ rpm -q yum</span><br><span class="line">yum-3.4.3-118.el7.noarch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢指定檔案(or 目錄)屬於哪個套件</span></span><br><span class="line">$ rpm -q -f /etc/yum.repos.d</span><br><span class="line">yum-3.4.3-118.el7.noarch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢套件資訊，類似 "yum info" 的功能</span></span><br><span class="line">$ rpm -q -i yum</span><br><span class="line">Name        : yum</span><br><span class="line">Version     : 3.4.3</span><br><span class="line">Release     : 118.el7</span><br><span class="line">Architecture: noarch</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出安裝指定套件所產生的檔案列表</span></span><br><span class="line">$ rpm -q -l yum</span><br><span class="line">.....</span><br><span class="line">/etc/yum.conf</span><br><span class="line">/etc/yum.repos.d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出指定套件相關的文件資訊</span></span><br><span class="line">$ rpm -q -d yum</span><br><span class="line">/usr/share/doc/yum-3.4.3/AUTHORS</span><br><span class="line">/usr/share/doc/yum-3.4.3/COPYING</span><br><span class="line">/usr/share/doc/yum-3.4.3/ChangeLog</span><br><span class="line">/usr/share/doc/yum-3.4.3/INSTALL</span><br><span class="line">.......</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出安裝指定套件所會執行的相關 script 內容</span></span><br><span class="line">$ rpm -q --scripts openssh-server</span><br><span class="line">preinstall scriptlet (using /bin/sh):</span><br><span class="line">getent group sshd &gt;/dev/null || groupadd -g 74 -r sshd || :</span><br><span class="line">.......</span><br><span class="line">postinstall scriptlet (using /bin/sh):</span><br><span class="line">.......</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢套件所包含的設定檔</span></span><br><span class="line">$ rpm -q -c yum</span><br><span class="line">/etc/logrotate.d/yum</span><br><span class="line">/etc/yum.conf</span><br><span class="line">/etc/yum/version-groups.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢指定套件的 changelog 資訊</span></span><br><span class="line">$ rpm -q --changelog yum</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> RHCE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH124 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[RHCE] RH124 Chapter 11 Managing Red Hat Enterprise Linux Networking 學習筆記]]></title>
      <url>/blog/2016/04/26/RHCE/RHCE7-RH124-LearningNotes-CH11_ManagingRedHatEnterpriseLinuxNetworking/</url>
      <content type="html"><![CDATA[<p><a name="ch11.1"></a></p>
<h1 id="11-1-Network-Concepts"><a href="#11-1-Network-Concepts" class="headerlink" title="11.1 Network Concepts"></a>11.1 Network Concepts</h1><h2 id="11-1-2-Network-interface-names"><a href="#11-1-2-Network-interface-names" class="headerlink" title="11.1.2 Network interface names"></a>11.1.2 Network interface names</h2><p>網卡命名原則：</p>
<ul>
<li><p>Ethernet 介面卡，開頭為 <code>en</code></p>
<blockquote>
<p>onboard 的網卡名稱為 eno1, eno2 … etc<br>可插拔(PCI 介面)的網卡名稱為 enp2s0</p>
</blockquote>
</li>
<li><p>無線網路卡，開頭為 <code>wl</code></p>
</li>
<li><p>3G/4G 網路卡，開頭為 <code>ww</code></p>
</li>
</ul>
<blockquote>
<p>虛擬機則一律為 <code>eth0</code>, <code>eth1</code>, <code>eth2</code> … etc</p>
</blockquote>
<hr>
<p><a name="ch11.2"></a></p>
<h1 id="11-2-Validating-Network-Configuration"><a href="#11-2-Validating-Network-Configuration" class="headerlink" title="11.2 Validating Network Configuration"></a>11.2 Validating Network Configuration</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 顯示 enp0s8 資訊</span></span><br><span class="line">[student@server0 ~]$ ip addr show eth0</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000</span><br><span class="line">    link/ether 52:54:00:00:00:0b brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.25.0.11/24 brd 172.25.0.255 scope global dynamic eth0</span><br><span class="line">       valid_lft 16494sec preferred_lft 16494sec</span><br><span class="line">    inet6 fe80::5054:ff:fe00:b/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示網路介面的統計紀錄</span></span><br><span class="line">[student@server0 ~]$ ip -s link show eth0</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT qlen 1000</span><br><span class="line">    link/ether 52:54:00:00:00:0b brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    RX: bytes  packets  errors  dropped overrun mcast   </span><br><span class="line">    5641965    4752     0       0       0       0      </span><br><span class="line">    TX: bytes  packets  errors  dropped carrier collsns</span><br><span class="line">    611742     3112     0       0       0       0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視路由</span></span><br><span class="line">[student@server0 ~]$ ip route</span><br><span class="line">default via 172.25.0.254 dev eth0  proto static  metric 1024</span><br><span class="line">172.25.0.0/24 dev eth0  proto kernel  scope link  src 172.25.0.11</span><br><span class="line">172.25.253.254 via 172.25.0.254 dev eth0  proto static  metric 1</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有資訊</span></span><br><span class="line">$ sudo ss</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出已經建立的 connection</span></span><br><span class="line">$ sudo ss -t</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出包含 listen 的 port &amp; connection</span></span><br><span class="line">$ sudo ss -ta</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出 listening 的 tcp socket</span></span><br><span class="line">$ sudo ss -lt</span><br></pre></td></tr></table></figure>
<hr>
<p><a name="ch11.3"></a></p>
<h1 id="11-3-Configuring-Network-with-nmcli"><a href="#11-3-Configuring-Network-with-nmcli" class="headerlink" title="11.3 Configuring Network with nmcli"></a>11.3 Configuring Network with nmcli</h1><p>在 RHEL 7 中提供了 <strong><font color="red">nmcli</font></strong>(NetworkManager) 作為網路設定管理之用。</p>
<h2 id="11-3-1-Network-Manager"><a href="#11-3-1-Network-Manager" class="headerlink" title="11.3.1 Network Manager"></a>11.3.1 Network Manager</h2><p><code>nmcli</code> 命令是修改 <code>/etc/sysconfig/network-scripts/ifcfg-*</code> 中的內容，有兩個觀念必須弄清楚，分別是 <strong><font color="red">device</font></strong> &amp; <strong><font color="red">connection</font></strong>：</p>
<ul>
<li><p><code>device</code>：每一個網路卡(介面)都屬於一個 device</p>
</li>
<li><p><code>connection</code>：每一個 device 可以同時有多個 connection 設定(每次只有一種可以生效)，可快速因應在不同場景所需要的網路設定變更</p>
</li>
</ul>
<h2 id="11-3-2-Viewing-network-information-with-nmcli"><a href="#11-3-2-Viewing-network-information-with-nmcli" class="headerlink" title="11.3.2 Viewing network information with nmcli"></a>11.3.2 Viewing network information with nmcli</h2><ul>
<li><p><code>sudo systemctl status NetworkManager.service</code>：檢查 Network Manager 目前服務狀態</p>
</li>
<li><p><code>nmcli connection show</code>：列出目前所有的 connection</p>
</li>
<li><p><code>nmcli connection show --active</code>：顯示出目前狀態為 active 的 connection</p>
</li>
<li><p><code>nmcli connection show &quot;System eth0&quot;</code>：顯示指定 connection 的詳細內容 (小寫的部分可以變更、大寫的部分無法變更)</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[student@server0 ~]$ nmcli connection show --active</span><br><span class="line">NAME         UUID                                  TYPE            DEVICE</span><br><span class="line">System eth0  5fb06bd0-0bb0-7ffb-45f1-d6edd65f3e03  802-3-ethernet  eth0</span><br><span class="line">[student@server0 ~]$ nmcli connection show <span class="string">"System eth0"</span></span><br><span class="line">connection.id:                          System eth0</span><br><span class="line">connection.uuid:                        5fb06bd0-0bb0-7ffb-45f1-d6edd65f3e03</span><br><span class="line">connection.interface-name:              eth0</span><br><span class="line">connection.type:                        802-3-ethernet</span><br><span class="line">.....</span><br><span class="line">GENERAL.NAME:                           System eth0</span><br><span class="line">GENERAL.UUID:                           5fb06bd0-0bb0-7ffb-45f1-d6edd65f3e03</span><br><span class="line">GENERAL.DEVICES:                        eth0</span><br><span class="line">GENERAL.STATE:                          activated</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>nmcli device status</code>：顯示目前 device 的狀態</p>
</li>
<li><p><code>nmcli device show eth0</code>：顯示指定 device 的詳細狀態</p>
</li>
</ul>
<h2 id="11-3-3-Creating-network-connections-with-nmcli"><a href="#11-3-3-Creating-network-connections-with-nmcli" class="headerlink" title="11.3.3 Creating network connections with nmcli"></a>11.3.3 Creating network connections with nmcli</h2><ul>
<li><p><code>sudo nmcli connection add con-name &quot;my-connect-name&quot; type ethernet ifname eth0</code></p>
<blockquote>
<p>device: eth0<br><br>connection: my-connect-name<br><br>設定內容：DHCP</p>
</blockquote>
</li>
<li><p><code>sudo nmcli connection add con-name &quot;static&quot; ifname eth0 type ethernet autoconnect no ip4 172.25.40.11/24 gw4 172.25.40.254</code></p>
<blockquote>
<p>device: eth0 <br><br>connection: static <br><br>設定內容: 開機時不套用 | IPv4 | IP: 172.25.40.11/24 | Gateway: 172.25.40.254 <br><br><strong><font color="red">但 connection add 無法增加 DNS 設定</font></strong></p>
</blockquote>
</li>
<li><p><code>sudo nmcli connection up static</code>：套用 “staic” connection 設定</p>
</li>
<li><p><code>sudo nmcli connection reload</code>：reload 所有的 connection(設定檔)，不會套用到網路介面上(設定完建議 reload 以確保設定有被 Network Manager 抓到)</p>
</li>
</ul>
<h2 id="11-3-4-Modifying-network-interfaces-with-nmcli"><a href="#11-3-4-Modifying-network-interfaces-with-nmcli" class="headerlink" title="11.3.4 Modifying network interfaces with nmcli"></a>11.3.4 Modifying network interfaces with nmcli</h2><ul>
<li><p><code>sudo nmcli connection modify &quot;static&quot; ipv4.dns 8.8.8.8</code>：在指定的 connection 中設定 DNS(作完要重新 up connection 才會生效)</p>
</li>
<li><p><code>sudo nmcli connection modify &quot;static&quot; +ipv4.dns 8.8.4.4</code>：在指定的 connection 中增加 DNS 設定</p>
</li>
<li><p><code>sudo nmcli connection modify &quot;static&quot; connection.autoconnect on</code>：設定開機自動套用指定 connection</p>
</li>
<li><p><code>sudo nmcli connection delete &quot;static&quot;</code>：刪除指定的 connection</p>
</li>
<li><p><code>sudo nmcli connection down</code>：網路斷掉後，Network Manager 會嘗試找到另外一個 autoconnect=on 的 connection 並套用其設定</p>
</li>
<li><p><code>sudo nmcli device disconnect eth0</code>：強制停用指定 device 的網路設定(不會自動套用設定)</p>
</li>
<li><p><code>sudo nmcli net off</code>：停止所有的網路介面</p>
</li>
</ul>
<hr>
<p><a name="ch11.4"></a></p>
<h1 id="11-4-Editing-Network-Configuration-Files"><a href="#11-4-Editing-Network-Configuration-Files" class="headerlink" title="11.4 Editing Network Configuration Files"></a>11.4 Editing Network Configuration Files</h1><p>直接修改 <code>/etc/sysconfig/network-scripts/ifcfg-*</code> 檔案中的內容，再使用 <code>sudo nmcli connection reload</code>，就可以讓 Network Manager 取得新的設定。</p>
<hr>
<p><a name="ch11.5"></a></p>
<h1 id="11-5-Configuring-Host-Names-and-Name-Resolution"><a href="#11-5-Configuring-Host-Names-and-Name-Resolution" class="headerlink" title="11.5 Configuring Host Names and Name Resolution"></a>11.5 Configuring Host Names and Name Resolution</h1><h2 id="11-5-1-Changing-the-System-host-name"><a href="#11-5-1-Changing-the-System-host-name" class="headerlink" title="11.5.1 Changing the System host name"></a>11.5.1 Changing the System host name</h2><p>若 <code>/etc/hostname</code> 不存在，則系統在網卡被分配到 ip 後，就會進行一個 DNS 的反向查詢</p>
<p>hostname 可透過 <code>hostnamectl</code> 命令來設定</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ hostname</span><br><span class="line">server5.example.com</span><br><span class="line"></span><br><span class="line">$ sudo hostnamectl <span class="built_in">set</span>-hostname sercerX.example.com</span><br><span class="line"></span><br><span class="line">$ hostnamectl status</span><br><span class="line">   Static hostname: sercerx.example.com</span><br><span class="line">   Pretty hostname: sercerX.example.com</span><br><span class="line">         Icon name: computer-vm</span><br><span class="line">           Chassis: vm</span><br><span class="line">        Machine ID: adf65a29af58497b8bb516fc6d366b8d</span><br><span class="line">           Boot ID: 963e5bc0e26a42e8acf285616ed9c9b6</span><br><span class="line">    Virtualization: kvm</span><br><span class="line">  Operating System: CentOS Linux 7 (Core)</span><br><span class="line">       CPE OS Name: cpe:/o:centos:centos:7</span><br><span class="line">            Kernel: Linux 3.10.0-327.3.1.el7.x86_64</span><br><span class="line">      Architecture: x86-64</span><br></pre></td></tr></table></figure>
<h2 id="11-5-2-Configuring-name-resolution"><a href="#11-5-2-Configuring-name-resolution" class="headerlink" title="11.5.2 Configuring name resolution"></a>11.5.2 Configuring name resolution</h2><blockquote>
<p>若查詢簡短名稱，系統會自動戴上 <code>/etc/resolv.conf</code> 中的 <code>domain</code> or <code>search</code> 的值再查詢</p>
</blockquote>
<p>使用 <code>getent</code> &amp; <code>host</code> 測試 DNS 設定：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># getenv 主要以 IPv6 為主</span></span><br><span class="line">$ getent hosts tw.yahoo.com</span><br><span class="line">2406:2000:ec:601::1009 fd-fp3.wg1.b.yahoo.com tw.yahoo.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 沒有 IPv6 的設定，則回傳 IPv4</span></span><br><span class="line">$ getent hosts ptt.cc</span><br><span class="line">140.112.172.3   ptt.cc</span><br><span class="line">140.112.172.4   ptt.cc</span><br><span class="line">140.112.172.2   ptt.cc</span><br><span class="line">140.112.172.11  ptt.cc</span><br><span class="line">140.112.172.5   ptt.cc</span><br><span class="line">140.112.172.1   ptt.cc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 host 查詢 google</span></span><br><span class="line">$ host www.google.com</span><br><span class="line">www.google.com has address 210.242.127.104</span><br><span class="line">www.google.com has address 210.242.127.88</span><br><span class="line">........</span><br><span class="line">www.google.com has address 210.242.127.109</span><br><span class="line">www.google.com has IPv6 address 2404:6800:4008:c01::6a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 getent 查詢 google</span></span><br><span class="line">$ getent hosts www.google.com</span><br><span class="line">2404:6800:4008:c04::6a www.google.com</span><br></pre></td></tr></table></figure>
<p>另外，一般網路設定若使用 DHCP，會把原有的 DNS 設定覆蓋，若要避免此情況，可用 <code>sudo nmcli connection &quot;System eth0&quot; ipv4.ignore-auto-dns yes</code> 來避免這樣的狀況發生。</p>
<blockquote>
<p>也可以用 nslookup 來測試 DNS，但需要額外加裝 <code>bind-utils</code> 套件</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> RHCE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH124 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[RHCE] RH124 Chapter 10 Analyzing and Storing Logs 學習筆記]]></title>
      <url>/blog/2016/04/24/RHCE/RHCE7-RH124-LearningNotes-CH10_AnalyzingAndStoringLogs/</url>
      <content type="html"><![CDATA[<h1 id="10-1-System-Log-Architecture"><a href="#10-1-System-Log-Architecture" class="headerlink" title="10.1 System Log Architecture"></a>10.1 System Log Architecture</h1><h2 id="10-1-1-System-logging"><a href="#10-1-1-System-logging" class="headerlink" title="10.1.1 System logging"></a>10.1.1 System logging</h2><hr>
<p>RHEL 7 有兩支 daemon 管理 log：</p>
<ul>
<li>systemd-journald</li>
<li>rsyslog<ul>
<li>紀錄 message type(or facility) &amp; priority 在 <code>/var/log</code> 內</li>
<li>facility.severity (facility 很多種，severity 則是標準)</li>
</ul>
</li>
</ul>
<h3 id="systemd-journald"><a href="#systemd-journald" class="headerlink" title="systemd-journald"></a>systemd-journald</h3><p>systemd-journald daemon 蒐集以下的訊息:(並且會把資料寫進 structured database)</p>
<ul>
<li><p>kernel 相關的訊息</p>
</li>
<li><p>開機流程中早期的訊息</p>
</li>
<li><p>daemon 啟動時的標準輸出 &amp; 錯誤訊息</p>
</li>
<li><p>syslog (會被 forward 給 rsyslog 處理)</p>
</li>
</ul>
<h3 id="rsyslog"><a href="#rsyslog" class="headerlink" title="rsyslog"></a>rsyslog</h3><p>rsyslog 會把從 syslog 來的資料放到 <strong>/var/log</strong> 中，除了 <strong>/var/log/secure</strong>、<strong>/var/log/maillog</strong>、<strong>/var/log/cron</strong>、<strong>/var/log/boot.log</strong> 四類訊息，其他訊息都會放在 <strong>/var/log/messages</strong> 中</p>
<hr>
<h1 id="10-2-Reviewing-Syslog-Files"><a href="#10-2-Reviewing-Syslog-Files" class="headerlink" title="10.2 Reviewing Syslog Files"></a>10.2 Reviewing Syslog Files</h1><p>rsyslogd 使用 <code>facility</code>(type) &amp; <code>priority</code>(severity) 來決定如何處理 log message，透過設定檔 <code>/etc/rsyslog.config</code> &amp; <code>/etc/rsyslog.d/\*.conf</code> 定義處理方式</p>
<h2 id="10-2-2-Sample-rule-section-of-rsyslog-config"><a href="#10-2-2-Sample-rule-section-of-rsyslog-config" class="headerlink" title="10.2.2 Sample rule section of rsyslog.config"></a>10.2.2 Sample rule section of rsyslog.config</h2><p>左邊的部份指定哪些 facility.severity 要被記錄，右邊的部份則是指定 log message 要存到哪個檔案</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所有 severity INFO 以上的訊息都送往 /var/log/message</span></span><br><span class="line"><span class="comment"># 但 facility mail / authpriv / cron 除外</span></span><br><span class="line"><span class="comment"># boot log message 也會送</span></span><br><span class="line">*.info;mail.none;authpriv.none;cron.none    /var/<span class="built_in">log</span>/messages</span><br><span class="line"></span><br><span class="line"><span class="comment"># kernel facility 的 log message 會往 /dev/console 送</span></span><br><span class="line">kernel.*    /dev/console</span><br><span class="line"></span><br><span class="line"><span class="comment"># authpriv facility 相關的 log message 都會往 /var/log/secure 送</span></span><br><span class="line">authpriv.*  /var/<span class="built_in">log</span>/secure</span><br><span class="line"></span><br><span class="line"><span class="comment"># mail facility 的訊息會先存在於記憶體中，一段時間後詞才會存到檔案中</span></span><br><span class="line">mail.*      -/var/<span class="built_in">log</span>/maillog</span><br><span class="line"></span><br><span class="line"><span class="comment"># severity Emergency 的 log message 會送到目前所有登入使用者的 terminal 上</span></span><br><span class="line">*.emerg     :omusrmsg:*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 開機相關的訊息送往 /var/log/boot.log</span></span><br><span class="line">local7.*    /var/<span class="built_in">log</span>/boot.log</span><br></pre></td></tr></table></figure>
<p>設定完成後，可透過 <code>logger -p [facility].[severity] &quot;log message&quot;</code> 來測試，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ logger -p local7.emerg <span class="string">"boot emergency log message test"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>可安裝 <strong><font color="red">rsyslog-doc</font></strong> 套件取得 rsyslogd 相關的 man page，很有幫助</p>
</blockquote>
<h3 id="10-2-3-Log-file-rotation"><a href="#10-2-3-Log-file-rotation" class="headerlink" title="10.2.3 Log file rotation"></a>10.2.3 Log file rotation</h3><p>透過 <code>/etc/logrotate.conf</code> 進行設定的修改</p>
<p><code>/etc/cron.daily</code> 目錄中有一支 logrotate 的 shell script 作為每天執行的工作</p>
<h3 id="10-2-6-Send-a-syslog-message-with-logger"><a href="#10-2-6-Send-a-syslog-message-with-logger" class="headerlink" title="10.2.6 Send a syslog message with logger"></a>10.2.6 Send a syslog message with logger</h3><p>若是有修改過 rsyslog 的設定後，可用 <code>logger</code> 程式手動發送 log 進行驗證，是否 log 有正確的被記錄：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[student@server0 ~]$ sudo tail -3 /var/<span class="built_in">log</span>/boot.log</span><br><span class="line">[  OK  ] Started GNOME Display Manager.</span><br><span class="line">[  OK  ] Started LSB: Start the ipr dump daemon.</span><br><span class="line">[  OK  ] Started Dynamic System Tuning Daemon.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手動產生一個 local7.notice 的 log message</span></span><br><span class="line">[student@server0 ~]$ logger -p local7.notice <span class="string">"Log entry created on server0"</span></span><br><span class="line"></span><br><span class="line">[student@server0 ~]$ tail -3 /var/<span class="built_in">log</span>/boot.log</span><br><span class="line">[  OK  ] Started LSB: Start the ipr dump daemon.</span><br><span class="line">[  OK  ] Started Dynamic System Tuning Daemon.</span><br><span class="line">Apr 23 23:26:04 server0 student: Log entry created on server0</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="10-3-Reviewing-systemd-Journal-Entries"><a href="#10-3-Reviewing-systemd-Journal-Entries" class="headerlink" title="10.3 Reviewing systemd Journal Entries"></a>10.3 Reviewing systemd Journal Entries</h1><p>特點：</p>
<ul>
<li><p>存放在 <code>/run/log</code> 目錄中 (表示重開機之後就會消失)</p>
</li>
<li><p>最多使用系統 10% 的空間，超過的話，舊的 journal 就會被砍掉</p>
</li>
<li><p>使用 <code>journalctl</code> 命令來查詢 (<font color="red"><strong>只有 root 可用</strong></font>)</p>
</li>
<li><p>severity <code>notice</code> or <code>warning</code> 會以粗體顯示，<code>error</code> 以上會以紅色表示</p>
</li>
</ul>
<h2 id="10-3-1-Finding-events-with-journalctl"><a href="#10-3-1-Finding-events-with-journalctl" class="headerlink" title="10.3.1 Finding events with journalctl"></a>10.3.1 Finding events with journalctl</h2><p><strong><font color="red">journalctl</font></strong> 的使用方式：</p>
<ul>
<li><p><code>sudo journalctl</code>：顯示所有的 system journal</p>
</li>
<li><p><code>sudo journalctl -n 5</code>：使用 <code>-n</code> 參數，顯示最新五筆的 system journal</p>
</li>
<li><p><code>sudo journalctl -p err</code>：使用 <code>-p</code> 參數，指定要顯示 priority 為 error 的 system journal</p>
</li>
<li><p><code>sudo journalctl -f</code>：類似 <code>tail -f</code>，但持續顯示最新十筆</p>
</li>
<li><p><code>sudo journalctl --since today</code>：顯示今天發生的 system journal</p>
</li>
<li><p><code>sudo journalctl --since &#39;2016-04-24 00:00:00&#39; --until &#39;2016-04-24 01:00:00&#39;</code>：顯示特定時段內的 system journal</p>
</li>
<li><p><code>sudo journalctl --since=&quot;$(date -d &quot;-30 minutes&quot; +%F&#39; &#39;%H:%M:%S)&quot;</code>：尋找 30 分鐘前的 system journal</p>
</li>
<li><p><code>sudo journalctl -o verbose</code>：顯示完整 system journal 訊息</p>
</li>
<li><p><code>sudo journalctl _PID=1</code>：顯示 pid=1 的 system journal</p>
</li>
<li><p><code>sudo journalctl -b</code>：顯示上一次開機到目前所存在的 system journal</p>
</li>
</ul>
<hr>
<h1 id="10-4-Preserving-the-systemd-Journal"><a href="#10-4-Preserving-the-systemd-Journal" class="headerlink" title="10.4 Preserving the systemd Journal"></a>10.4 Preserving the systemd Journal</h1><p>保留 systemd journal 的方式：</p>
<ol>
<li><code>/var/log/journal</code> 目錄存在</li>
<li>目錄的 owner 必須為 <code>root</code>，owner_group 必須為 <code>systemd-journal</code>，並設定權限為 <code>2755</code></li>
</ol>
<hr>
<h1 id="10-5-Maintain-Accurate-Time"><a href="#10-5-Maintain-Accurate-Time" class="headerlink" title="10.5 Maintain Accurate Time"></a>10.5 Maintain Accurate Time</h1><h2 id="10-5-1-Set-local-clocks-and-time-zone"><a href="#10-5-1-Set-local-clocks-and-time-zone" class="headerlink" title="10.5.1 Set local clocks and time zone"></a>10.5.1 Set local clocks and time zone</h2><ul>
<li><p><code>timedatectl</code>：顯示目前時區設定</p>
</li>
<li><p><code>timedatectl list-timezones</code>：顯示所有時區</p>
</li>
<li><p><code>timedatectl set-timezone Asia/Taipei</code>：更改時區</p>
</li>
<li><p><code>sudo timedatectl set-ntp true</code>：設定自動 NTP 教時</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 看目前機器上的時間</span></span><br><span class="line">$ timedatectl</span><br><span class="line">      Local time: Thu 2016-01-21 06:35:27 UTC</span><br><span class="line">  Universal time: Thu 2016-01-21 06:35:27 UTC</span><br><span class="line">        RTC time: Thu 2016-01-21 06:35:26</span><br><span class="line">       Time zone: UTC (UTC, +0000)</span><br><span class="line">     NTP enabled: n/a</span><br><span class="line">NTP synchronized: no</span><br><span class="line"> RTC <span class="keyword">in</span> <span class="built_in">local</span> TZ: yes</span><br><span class="line">      DST active: n/a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定時區</span></span><br><span class="line">$ sudo timedatectl <span class="built_in">set</span>-timezone Asis/Taipei</span><br><span class="line"></span><br><span class="line"><span class="comment"># 啟用 NTP 校時</span></span><br><span class="line">$ sudo timedatectl <span class="built_in">set</span>-ntp <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過互動的方式選擇時區(Time Zone)</span></span><br><span class="line">$ tzselect</span><br></pre></td></tr></table></figure>
<h2 id="10-5-2-Configuring-and-monitoring-chronyd"><a href="#10-5-2-Configuring-and-monitoring-chronyd" class="headerlink" title="10.5.2 Configuring and monitoring chronyd"></a>10.5.2 Configuring and monitoring chronyd</h2><p>這個是用在沒有網路環境時，會由一台主要的 NTP server 去取得正確的資料，其他主機再透過 chronyd.service 進行時間同步。</p>
<p>加上 <code>iburst</code> 選項會讓網路校時更快，且更正確</p>
<p><code>sudo hwclock -w</code>：強制將時間資訊寫入硬體</p>
<h2 id="補充：設定-NTP-校時的完整步驟-很重要"><a href="#補充：設定-NTP-校時的完整步驟-很重要" class="headerlink" title="補充：設定 NTP 校時的完整步驟 (很重要)"></a>補充：設定 NTP 校時的完整步驟 (<strong>很重要</strong>)</h2><ul>
<li>NTP server：<code>classroom.example.com</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ sudo timedatectl <span class="built_in">set</span>-ntp <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"server classroom.example.com iburst"</span> | sudo tee --append /etc/chrony.conf</span><br><span class="line">$ sudo systemctl restart chronyd.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 驗證設定結果</span></span><br><span class="line">$ chronyc sources -v</span><br><span class="line">210 Number of sources = 1</span><br><span class="line"></span><br><span class="line">  .-- Source mode  <span class="string">'^'</span> = server, <span class="string">'='</span> = peer, <span class="string">'#'</span> = <span class="built_in">local</span> clock.</span><br><span class="line"> / .- Source state <span class="string">'*'</span> = current synced, <span class="string">'+'</span> = combined , <span class="string">'-'</span> = not combined,</span><br><span class="line">| /   <span class="string">'?'</span> = unreachable, <span class="string">'x'</span> = time may be <span class="keyword">in</span> error, <span class="string">'~'</span> = time too variable.</span><br><span class="line">||                                                 .- xxxx [ yyyy ] +/- zzzz</span><br><span class="line">||                                                /   xxxx = adjusted offset,</span><br><span class="line">||         Log2(Polling interval) -.             |    yyyy = measured offset,</span><br><span class="line">||                                  \            |    zzzz = estimated error.</span><br><span class="line">||                                   |           |                         </span><br><span class="line">MS Name/IP address         Stratum Poll Reach LastRx Last sample</span><br><span class="line">===============================================================================</span><br><span class="line">^* classroom.example.com         8   6    17    18  +2830us[+3050us] +/- 3509us</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> RHCE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH124 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[RHCE] RH124 Chapter 9 Controlling and Securing OpenSSH Service 學習筆記]]></title>
      <url>/blog/2016/04/19/RHCE/RHCE7-RH124-LearningNotes-CH09_ConfiguringAndSecuringOpenSSHService/</url>
      <content type="html"><![CDATA[<h1 id="9-1-Accessing-the-Remote-Command-Line-with-SSH"><a href="#9-1-Accessing-the-Remote-Command-Line-with-SSH" class="headerlink" title="9.1 Accessing the Remote Command Line with SSH"></a>9.1 Accessing the Remote Command Line with SSH</h1><h2 id="9-1-1-SSH-Host-Keys"><a href="#9-1-1-SSH-Host-Keys" class="headerlink" title="9.1.1 SSH Host Keys"></a>9.1.1 SSH Host Keys</h2><p>server 會將 public key copy 送到 client 端，有兩個功能：</p>
<ol>
<li>用來加密 ssh connection 用</li>
<li>用來驗證 server</li>
</ol>
<ul>
<li><p>server public key 會存在於 client 端的 <code>~/.ssh/known_hosts</code> 檔案中</p>
</li>
<li><p>server 端會把 key pair 儲存在 <code>/etc/ssh/ssh_host_key*</code> 目錄下</p>
</li>
<li><p>當 client 透過 ssh 連到 server 時，會把 server 的 public 儲存在 <strong><font color="red">~/.ssh/known_hosts</font></strong> 內，且每次連線都會檢查，若發現內容不會就會警告且中斷連線!</p>
</li>
</ul>
<hr>
<h1 id="9-2-Conguring-SSH-Key-based-Authentication"><a href="#9-2-Conguring-SSH-Key-based-Authentication" class="headerlink" title="9.2 Conguring SSH Key-based Authentication"></a>9.2 Conguring SSH Key-based Authentication</h1><p><code>ssh-copy-id</code>：上傳 <font color="red"><strong>~/.ssh/id_rsa.pub</strong></font> 到 remote server 的 <font color="red"><strong>~user/.ssh/authorized_keys</strong></font> 檔案中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 將指定的 public key 加入到 remote server 的 student 帳號下</span></span><br><span class="line">[student@server0 ~]$ ssh-copy-id -i ~/.ssh/id_rsa.pub student@172.25.0.10</span><br><span class="line"><span class="comment"># 將指定的 public key 加入到 remote server 的 root 帳號下</span></span><br><span class="line">[student@server0 ~]$ ssh-copy-id -i ~/.ssh/id_rsa.pub root@172.25.0.10</span><br></pre></td></tr></table></figure>
<blockquote>
<p>若沒有使用 <code>-i</code> 指定 public key 位置，則就預設為 <code>~/.ssh/id_rsa.pub</code></p>
</blockquote>
<p>若要使用 key-based 認證但又希望在 private key 上加密碼，並達成 password-less 的效果時：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 產生一個新的 ssh agent 並將 private key 驗證加入</span></span><br><span class="line">$ ssh-agent bash</span><br><span class="line">$ ssh-add</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="9-3-Customize-SSH-Service-Configuration"><a href="#9-3-Customize-SSH-Service-Configuration" class="headerlink" title="9.3 Customize SSH Service Configuration"></a>9.3 Customize SSH Service Configuration</h1><p>修改 <code>/etc/ssh/sshd_config</code> 中，調整使用者登入方式：</p>
<ol>
<li><p><code>PermitRootLogin no</code>：禁止 root 使用 ssh 登入</p>
</li>
<li><p><code>PermitRootLogin without-password</code>：root 只能透過 key-based 的方式登入</p>
</li>
<li><p><code>PasswordAuthentication no</code>：關閉密碼登入功能(只能透過 key-based 的方式登入)</p>
</li>
</ol>
<blockquote>
<p>要重新 reload sshd.service 讓設定變更生效 (<code>sudo systemctl restart sshd.service</code>)</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> RHCE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH124 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[RHCE] RH124 Chapter 8 Controlling Services and Daemons 學習筆記]]></title>
      <url>/blog/2016/04/18/RHCE/RHCE7-RH124-LearningNotes-CH08_ControllingServicesAndDaemons/</url>
      <content type="html"><![CDATA[<h1 id="8-1-Identifying-Automatically-Started-System-Processes"><a href="#8-1-Identifying-Automatically-Started-System-Processes" class="headerlink" title="8.1 Identifying Automatically Started System Processes"></a>8.1 Identifying Automatically Started System Processes</h1><h2 id="8-1-1-Introduction-to-systemd"><a href="#8-1-1-Introduction-to-systemd" class="headerlink" title="8.1.1 Introduction to systemd"></a>8.1.1 Introduction to systemd</h2><p>systemd(是一個小型的 kernel) 跟開機流程很有關係</p>
<p>通常一個 service 是由一個或多個 daemon 提供。</p>
<p>多年前，Linux &amp; UNIX 系統中 PID=1 是屬於一支稱為 <code>init</code>(載入 kernel 之後執行) 的 process；當 kernel 載入後執行。</p>
<p>在 RHEL 7 中，PID=1 的 process 已經變成 systemd：</p>
<ul>
<li>有平行處理的能力，可提升系統開機的速度</li>
<li>有些先前需要的 daemon 會自動啟動</li>
<li>自動管理 service 相依性</li>
<li>LCG (Linux control group)</li>
</ul>
<blockquote>
<p>現在的 <code>/usr/sbin/init</code> 已經改由 symbolic link 指到 systemd</p>
</blockquote>
<p>systemd 用來管理各式各樣不同的型態的 object，稱為 <strong>systemd unit</strong>，可以用 <code>systemctl -t help</code> 查詢目前 systemd 可管理的 unit 有那些：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[student@server0 ~]$ systemctl -t <span class="built_in">help</span></span><br><span class="line">Available unit types:</span><br><span class="line">service</span><br><span class="line">socket</span><br><span class="line">target  <span class="comment"># 取代原先 Run Level 的概念</span></span><br><span class="line">device</span><br><span class="line">mount</span><br><span class="line">automount</span><br><span class="line">snapshot</span><br><span class="line">timer   <span class="comment"># 自動排程的功能</span></span><br><span class="line">.....</span><br></pre></td></tr></table></figure>
<ul>
<li><code>service</code>：用來表示系統服務</li>
<li><code>socket</code>：表示 IPC(inter-process communication) socket</li>
<li><code>timer</code>：自動排程工作是由 timer unit 來處理</li>
<li><code>target</code>：取代原先 Run Level 的概念</li>
<li><code>path</code>：通常用來以特定檔案有無變化為前提下，延遲服務發生，例如：列印服務(print pool 的概念)</li>
</ul>
<h3 id="Service-status"><a href="#Service-status" class="headerlink" title="Service status"></a>Service status</h3><p>systemd service unit 有以下幾種狀態：</p>
<ul>
<li><strong>loaded</strong>：unit 設定被處理後(套件剛裝好時，會處於此狀態)</li>
<li><strong>active</strong>：啟用狀態</li>
<li><strong>inactive</strong>：非啟用狀態</li>
<li><strong>enabled</strong>：開機時會自動啟動</li>
<li><strong>disabled</strong>：開機時不會自動啟動</li>
<li><strong>static</strong>：無法控管的狀態，必須由其他 unit 來自動的 enable</li>
</ul>
<h2 id="8-1-2-systemctl-使用方式"><a href="#8-1-2-systemctl-使用方式" class="headerlink" title="8.1.2 systemctl 使用方式"></a>8.1.2 systemctl 使用方式</h2><p><code>systemctl</code> 是用來管理不同 systemd unit 的指令，使用方式大概如下：</p>
<p>列表相關的指令：</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sudo systemctl -l</code></td>
<td>檢視所有的 systemd unit 的狀態，但不包含狀態為 inactive 的(加上 <code>--all</code> or <code>-a</code> 可看到全部)</td>
</tr>
<tr>
<td><code>sudo systemctl status sshd.service</code></td>
<td>檢查 ssh service unit 的狀態<p>(透過 <code>systemctl status name.type</code> 可以檢視 unit 狀態，<code>type</code> 可以不輸入，則預設為 <strong>service</strong>)</p></td>
</tr>
<tr>
<td><code>sudo systemctl --type=service</code></td>
<td>檢視 type 屬於 service 的 systemd unit</td>
</tr>
<tr>
<td><code>sudo systemctl is-active sshd.service</code></td>
<td>檢視 sshd service 是否為 active 狀態</td>
</tr>
<tr>
<td><code>sudo systemctl is-enabled sshd.service</code></td>
<td>檢視 sshd service 是否為 enabled 狀態</td>
</tr>
<tr>
<td><code>sudo systemctl list-unit-files --type=service</code></td>
<td>檢視 service type 所有的 unit 設定</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="8-2-Controlling-System-Services"><a href="#8-2-Controlling-System-Services" class="headerlink" title="8.2 Controlling System Services"></a>8.2 Controlling System Services</h1><h2 id="8-2-1-Starting-and-stopping-daemons-on-a-running-system"><a href="#8-2-1-Starting-and-stopping-daemons-on-a-running-system" class="headerlink" title="8.2.1 Starting and stopping daemons on a running system"></a>8.2.1 Starting and stopping daemons on a running system</h2><p>安裝 apache2，檢視狀態，並啟動服務：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum -y install httpd</span><br><span class="line"></span><br><span class="line"><span class="comment"># inactive + disabled</span></span><br><span class="line">$ sudo systemctl status httpd.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># active(running) + disabled</span></span><br><span class="line">$ sudo systemctl start httpd.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># active(running) + enabled</span></span><br><span class="line">$ sudo systemctl <span class="built_in">enable</span> httpd.service</span><br></pre></td></tr></table></figure>
<p>系統中有 exited &amp; waiting 狀態的 system unit：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 觀察 active(exited) 狀態</span></span><br><span class="line">$ sudo systemctl status network.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 觀察 active(waiting) 狀態</span></span><br><span class="line">$ sudo systemctl status cups.path</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下兩行指令相同</span></span><br><span class="line">$ sudo service sshd restart</span><br><span class="line">$ sudo /bin/systemctl restart sshd.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下兩行指令相同</span></span><br><span class="line">$ sudo systemctl --<span class="built_in">type</span>=service</span><br><span class="line">$ sudo systemctl list-unit --<span class="built_in">type</span>=service</span><br></pre></td></tr></table></figure>
<blockquote>
<p>service reload 時，PID 不會換</p>
</blockquote>
<h3 id="Unit-dependencies"><a href="#Unit-dependencies" class="headerlink" title="Unit dependencies"></a>Unit dependencies</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 檢視該 system unit 被那些 systen unit 所依賴</span></span><br><span class="line">$ sudo systemctl list-dependencies graphical.target | grep target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視指定的 system unit 依賴那些其他的 system unit</span></span><br><span class="line">$ sudo systemctl list-dependencies multi-user.target --reverse</span><br></pre></td></tr></table></figure>
<h3 id="Masking-services"><a href="#Masking-services" class="headerlink" title="Masking services"></a>Masking services</h3><ul>
<li><p><code>disabled</code> 的 service 開機時不會自動啟動，但可以手動啟動</p>
</li>
<li><p><code>mask</code> 的 service 無法透過手動或自動的方式啟動(會在 <code>/etc/systemd/system</code> 目錄中產生指定 system unit 的 symbolic link 並指向 /dev/null)</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> RHCE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH124 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[RHCE] RH124 Chapter 7 Monitoring and Managing Linux Processes 學習筆記]]></title>
      <url>/blog/2016/04/13/RHCE/RHCE7-RH124-LearningNotes-CH07_MonitoringAndManagingLinuxProcesses/</url>
      <content type="html"><![CDATA[<h1 id="7-1-Process"><a href="#7-1-Process" class="headerlink" title="7.1 Process"></a>7.1 Process</h1><h2 id="7-1-1-What-is-a-process"><a href="#7-1-1-What-is-a-process" class="headerlink" title="7.1.1 What is a process?"></a>7.1.1 What is a process?</h2><p>每個 process 都會有個獨一無二的 PID，而 parent process ID(PPID) 則為 PID 的父程序所擁有的 ID；process 可透過 <code>fork</code> 的方式產生 child process，而這些 child process 則會繼承 parent process 的 security identifiers, file descriptors, port, resource privileges, 環境變數….等等，整個 process lifeycle 可以參考下圖：</p>
<p><img src="https://www.freebsd.org/doc/en_US.ISO8859-1/books/design-44bsd/fig1.png" alt="Process Lifecycle"></p>
<p>在 RHEL7 中，所有的 process 都是 <strong><font color="red">systemd(1)</font></strong> 的 child process。</p>
<h2 id="7-1-2-Process-States"><a href="#7-1-2-Process-States" class="headerlink" title="7.1.2 Process States"></a>7.1.2 Process States</h2><p><img src="http://4.bp.blogspot.com/-5jYQDgc6Z4M/UyV1ni478uI/AAAAAAAADZw/rpBf813wpbg/s1600/ProcessStates.JPG" alt="Linux Process States"></p>
<table>
<thead>
<tr>
<th>狀態</th>
<th>Flag</th>
<th>kernel-defined state and description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Running</td>
<td>R</td>
<td><strong><font color="red">TASK_RUNNING</font></strong>：正在等待執行 or 正在執行的 process，正在執行的又包含執行 user routine &amp; kernel routine(system calls)。例如：Data -&gt; Memory</td>
</tr>
<tr>
<td>Sleeping</td>
<td>S</td>
<td><strong><font color="red">TASK_INTERRUPTIBLE</font></strong>：等待特定的情況(硬體要求、系統資源存取、信號….等)發生，當條件滿足時就會回到 Running 的狀態</td>
</tr>
<tr>
<td>Sleeping</td>
<td>D</td>
<td><strong><font color="red">TASK_UNINTERRUPTIBLE</font></strong>：與 <strong><font color="red">S</font></strong> 類似，但不會回應從其他地方送來的信號。例如：寫資料到外接儲存裝置時(Memory -&gt; USB)</td>
</tr>
<tr>
<td>Sleeping</td>
<td>K</td>
<td><strong><font color="red">TASK_KILLABLE</font></strong>：與 <strong><font color="red">D</font></strong> 相反，可以接收來自其他地方的信號，例如：掛載網路磁碟機</td>
</tr>
<tr>
<td>Stopped</td>
<td>T</td>
<td><strong><font color="red">TASK_STOPPED</font></strong>：可能因為 user 或是其他 process 送來訊號而進入 Stopped 狀態，也可能因為特定訊號而返回 Running 狀態</td>
</tr>
<tr>
<td>Stopped</td>
<td>T</td>
<td><strong><font color="red">TASK_TRACED</font></strong>：同上，但可 debug</td>
</tr>
<tr>
<td>Zombie</td>
<td>Z</td>
<td><strong><font color="red">EXIT_ZOMBIE</font></strong>：已通知 parent process 準備離開後的狀態，除了 process identity 之外的資源都會被釋放</td>
</tr>
<tr>
<td>Zombie</td>
<td>X</td>
<td><strong><font color="red">EXIT_DEAD</font></strong>：所有資源都被釋放，ps 也看不見了</td>
</tr>
</tbody>
</table>
<h2 id="7-1-2-Listing-processes"><a href="#7-1-2-Listing-processes" class="headerlink" title="7.1.2 Listing processes"></a>7.1.2 Listing processes</h2><p>ps 指定常用的參數：</p>
<ul>
<li><code>aux</code></li>
<li><code>las</code></li>
<li><code>afx</code> (含階層)</li>
<li><code>-O</code> (指定要顯示的欄位)</li>
<li><code>--sort</code>：排序</li>
</ul>
<p><code>ps</code> 可用來觀察目前 process 的狀態，有以下幾種格式</p>
<ul>
<li><p>UNIX(POSIX)：參數加上一個 <code>-</code></p>
</li>
<li><p>BSD：參數不加上 <code>-</code></p>
</li>
<li><p>GNU long：參數加上兩個 <code>-</code></p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># BSD</span></span><br><span class="line">[student@server0 ~]$ ps f</span><br><span class="line">  PID TTY      STAT   TIME COMMAND</span><br><span class="line"> 1986 pts/0    Ss     0:00 -bash</span><br><span class="line"> 2072 pts/0    R+     0:00  \_ ps f</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 以階層顯示(顯示往上五階)</span></span><br><span class="line">[student@server0 ~]$ ps afx | grep -B5 ssh-agent</span><br><span class="line">  1130 ?        Ss     0:00 /usr/sbin/sshd -D</span><br><span class="line">  2823 ?        Ss     0:00  \_ sshd: student [priv]</span><br><span class="line">  2827 ?        S      0:00      \_ sshd: student@pts/0</span><br><span class="line">  2829 pts/0    Ss     0:00          \_ -bash</span><br><span class="line">  3110 pts/0    R+     0:00              \_ ps afx</span><br><span class="line">  3111 pts/0    S+     0:00              \_ grep --color=auto -B5 ssh-agent</span><br><span class="line"></span><br><span class="line"> <span class="comment"># UNIX(POSIX)</span></span><br><span class="line">[student@server0 ~]$ ps -f</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">student   1986  1983  0 05:28 pts/0    00:00:00 -bash</span><br><span class="line">student   2073  1986  0 05:30 pts/0    00:00:00 ps -f</span><br><span class="line">[student@server0 ~]$ ps --f</span><br></pre></td></tr></table></figure>
<p>檢視全部的 process 常用 <code>aux</code> 選項 or <code>alx</code>(較為詳細)，若想要檢視 process 之間的父子關係可使用 <code>afx</code>(關鍵是 <code>f</code> 參數)</p>
<p>關於 ps 還有幾個重點：</p>
<ul>
<li>若 ps 不加上任何參數，就僅會顯示與目前這個 user terminal 有關係的 process：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[student@server0 ~]$ ps</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line"> 1986 pts/0    00:00:00 bash</span><br><span class="line"> 2326 pts/0    00:00:00 ps</span><br></pre></td></tr></table></figure>
<ul>
<li>顯示結果中，若是以 <strong><font color="red">[ ]</font></strong> 包覆的，表示為 kernel thread</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[student@server0 ~]$ ps aux</span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         1  0.2  0.3  52328  6484 ?        Ss   04:55   0:06 /usr/lib/systemd/systemd --switched-root --system --deserialize 21</span><br><span class="line">root         2  0.0  0.0      0     0 ?        S    04:55   0:00 [kthreadd]</span><br><span class="line">root         3  0.0  0.0      0     0 ?        S    04:55   0:00 [ksoftirqd/0]</span><br><span class="line">root         5  0.0  0.0      0     0 ?        S&lt;   04:55   0:00 [kworker/0:0H]</span><br><span class="line">root         6  0.0  0.0      0     0 ?        S    04:55   0:00 [kworker/u2:0]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>透過 <code>ps afx</code> or <code>pstree</code> 可看到 process 之間的 parent/child 關係</p>
</li>
<li><p>若要排序 ps 出來的結果，可透過 <code>--sort</code> 選項 (<a href="http://alvinalexander.com/linux/unix-linux-process-memory-sort-ps-command-cpu" target="_blank" rel="noopener">參考網址(Linux process memory usage - how to sort the ps command)</a>)</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根據 CPU 遞增排序</span></span><br><span class="line">$ ps au --sort=%cpu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根據 CPU 遞減排序</span></span><br><span class="line">$ ps au --sort=-%cpu</span><br><span class="line"></span><br><span class="line"><span class="comment"># PID 從小到大排序</span></span><br><span class="line">[student@server0 ~]$ ps aux --sort pid</span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         1  0.5  0.3  52328  6472 ?        Ss   19:53   0:09 /usr/lib/systemd/systemd --switched-root --system --deserialize 21</span><br><span class="line">root         2  0.0  0.0      0     0 ?        S    19:53   0:00 [kthreadd]</span><br><span class="line">root         3  0.0  0.0      0     0 ?        S    19:53   0:00 [ksoftirqd/0]</span><br><span class="line"></span><br><span class="line"><span class="comment"># PID 從大到小排序</span></span><br><span class="line">[student@server0 ~]$ ps aux --sort -pid</span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">student   2065  0.0  0.0 123516  1448 pts/0    R+   20:24   0:00 ps aux --sort -pid</span><br><span class="line">root      2064  0.0  0.0 107892   364 ?        S    20:24   0:00 sleep 60</span><br><span class="line">root      2001  0.0  0.0      0     0 ?        S    20:19   0:00 [kworker/0:0]</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="7-2-Controlling-Jobs"><a href="#7-2-Controlling-Jobs" class="headerlink" title="7.2 Controlling Jobs"></a>7.2 Controlling Jobs</h1><p><code>jobs</code> 指令只會顯示目前 session 中的 job</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ gedit &amp;</span><br><span class="line">$ <span class="built_in">jobs</span></span><br><span class="line">$ nautilus &amp;</span><br><span class="line">$ <span class="built_in">jobs</span></span><br><span class="line">$ sleep 1000 &amp;</span><br><span class="line">$ <span class="built_in">jobs</span></span><br><span class="line">$ <span class="built_in">fg</span></span><br><span class="line">CTRL + C (終止目前前景執行的程式)</span><br><span class="line">$ <span class="built_in">jobs</span></span><br><span class="line">$ <span class="built_in">fg</span> %1</span><br><span class="line">CTRL + C (終止目前前景執行的程式)</span><br></pre></td></tr></table></figure>
<h2 id="7-2-1-Jobs-and-sessions"><a href="#7-2-1-Jobs-and-sessions" class="headerlink" title="7.2.1 Jobs and sessions"></a>7.2.1 Jobs and sessions</h2><p>當 terminal or console 被開啟時，會產生一個 process session，所以透過同一個 terminal or console 產生出來的 process，都會使用相同的 session ID，而每個 session 中，一次只能有一個 process 在前景執行。</p>
<p>service daemon 或是 kernel process thread 在 <code>ps</code> 出來的結果中，<code>TTY</code> 欄位會以 <code>?</code> 來呈現，因為此類的 background process 並沒有 controlling terminal。</p>
<h2 id="7-2-2-Running-jobs-in-the-background"><a href="#7-2-2-Running-jobs-in-the-background" class="headerlink" title="7.2.2 Running jobs in the background"></a>7.2.2 Running jobs in the background</h2><p><code>Ctrl + z</code>：可送出 suspend 要求，用來讓 process 進入 Stopped 狀態(T)</p>
<p><code>Ctrl + c</code>：中斷 process 執行</p>
<p><code>bg %JOB_ID</code>：可讓 process 恢復執行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一個執行中的範例</span></span><br><span class="line">$ dd &lt; /dev/zero &gt; /dev/null</span><br><span class="line"></span><br><span class="line"><span class="comment"># R(Running) 狀態</span></span><br><span class="line">$ ps au | grep dd</span><br><span class="line"></span><br><span class="line">Ctrl + Z</span><br><span class="line"></span><br><span class="line"><span class="comment"># 變成 S(Sleeping, TASK_INTERRUPTIBLE) 狀態</span></span><br><span class="line">$ ps au | grep dd</span><br><span class="line"></span><br><span class="line">$ sleep 1000</span><br><span class="line"></span><br><span class="line"><span class="comment"># S(Sleep) 狀態</span></span><br><span class="line">$ ps au | grep sleep</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用來驗證 D(Sleeping, TASK_UNINTERRUPTIBLE) 狀態</span></span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/zero bs=1M count=50 of=/run/media/...../test.txt</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="7-3-Killing-Processes"><a href="#7-3-Killing-Processes" class="headerlink" title="7.3 Killing Processes"></a>7.3 Killing Processes</h1><h2 id="7-3-1-Process-control-using-signals"><a href="#7-3-1-Process-control-using-signals" class="headerlink" title="7.3.1 Process control using signals"></a>7.3.1 Process control using signals</h2><p>signal 是送到 process 的一種軟體型式的中斷，有以下幾種：</p>
<table>
<thead>
<tr>
<th>Signal number</th>
<th>Short name</th>
<th>Definition</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>1</code></td>
<td><code>HUP</code></td>
<td>Hangup</td>
<td></td>
</tr>
<tr>
<td><code>2</code></td>
<td><code>INT</code></td>
<td>Keyboard interrupt</td>
<td>讓程式中止，等同按下 <code>Ctrl + c</code></td>
</tr>
<tr>
<td><code>3</code></td>
<td><code>QUIT</code></td>
<td>Keyboard quit</td>
<td>讓 process 中止，但會執行 core dump 的動作，等同按下 <code>Ctrl + \</code></td>
</tr>
<tr>
<td><code>9</code></td>
<td><code>KILL</code></td>
<td>Kill, unblockable</td>
<td>強行中止</td>
</tr>
<tr>
<td><code>15</code>(default)</td>
<td><code>TERM</code></td>
<td>Terminate</td>
<td>通知程式中止，允許 process 完成 self-cleanup 後才中止</td>
</tr>
<tr>
<td><code>20</code></td>
<td><code>TSTP</code></td>
<td>Keyboard stop</td>
<td>讓 process 中斷執行(但可恢復)，效果等同按下 <code>Ctrl + z</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>詳細的 signal 列表可使用 <code>kill -l</code> 查詢</p>
<p>基本上砍掉 process 時先嘗試用 <code>SIGTERM</code>，不行的話才改用 <code>SIGKILL</code>，會是比較穩妥的作法‧</p>
<p>沒指定 SIG 則預設給 <font color="red"><strong>SIGTERM(15)</strong></font></p>
</blockquote>
<h3 id="Logging-users-out-administratively"><a href="#Logging-users-out-administratively" class="headerlink" title="Logging users out administratively"></a>Logging users out administratively</h3><p><code>w</code> 指令是用來檢視目前登入到系統的使用者以及累積到現在的資源使用狀況：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ w -f</span><br><span class="line"> 06:19:29 up  1:27,  3 users,  load average: 0.04, 0.07, 0.06</span><br><span class="line">USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">kiosk    :0       :0               04:52   ?xdm?  11:36   0.20s gdm-session-worker [pam/gdm-autologin]</span><br><span class="line">kiosk    pts/3    :0               05:27   52:14   0.03s  0.03s bash</span><br><span class="line">kiosk    pts/4    192.168.1.190    06:11    1.00s  0.03s  0.01s w -f</span><br></pre></td></tr></table></figure>
<p><code>pkill</code> 是個強大的關閉 process 的指令，可透過以下方式過濾：</p>
<ul>
<li>command</li>
<li>UID</li>
<li>GID</li>
<li>parent</li>
<li>terminal</li>
</ul>
<p><code>pgrep</code> 指定 user 作 grep</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 刪除使用者 bboop 相關的 process</span></span><br><span class="line">$ pkill -u bboop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刪除使用者 bboop 相關的 process 並強制登出</span></span><br><span class="line">$ pkill -SIGKILL -u bboop</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[student@server0 ~]$ sleep 1000 &amp;</span><br><span class="line">[1] 2893</span><br><span class="line">[student@server0 ~]$ sleep 1000 &amp;</span><br><span class="line">[2] 2894</span><br><span class="line">[student@server0 ~]$ sleep 1000 &amp;</span><br><span class="line">[3] 2895</span><br><span class="line"><span class="comment"># pgrep 視特定使用者</span></span><br><span class="line">[student@server0 ~]$ pgrep -l -u student</span><br><span class="line">2827 sshd</span><br><span class="line">2829 bash</span><br><span class="line">2893 sleep</span><br><span class="line">2894 sleep</span><br><span class="line">2895 sleep</span><br><span class="line"><span class="comment"># pstree 檢視特定使用者，使用 PID</span></span><br><span class="line">[student@server0 ~]$ pstree -p student</span><br><span class="line">sshd(2827)───bash(2829)─┬─pstree(2896)</span><br><span class="line">                        ├─sleep(2893)</span><br><span class="line">                        ├─sleep(2894)</span><br><span class="line">                        └─sleep(2895)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定 PPID(parent ID) 刪除 process</span></span><br><span class="line">[student@server0 ~]$ pkill -SIGKILL -P 2829</span><br><span class="line">[1]   Killed                  sleep 1000</span><br><span class="line">[2]-  Killed                  sleep 1000</span><br><span class="line">[3]+  Killed                  sleep 1000</span><br><span class="line">[student@server0 ~]$ pstree -p student</span><br><span class="line">sshd(2827)───bash(2829)───pstree(2945)</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="7-4-Monitoring-Process-Activity"><a href="#7-4-Monitoring-Process-Activity" class="headerlink" title="7.4 Monitoring Process Activity"></a>7.4 Monitoring Process Activity</h1><h2 id="7-4-1-Load-average"><a href="#7-4-1-Load-average" class="headerlink" title="7.4.1 Load average"></a>7.4.1 Load average</h2><p>靜態呈現，使用 <code>w -f</code> or <code>uptime</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查詢目前系統的 load average</span></span><br><span class="line">$ w -f</span><br><span class="line"> 16:37:45 up  7:29,  3 users,  load average: 0.20, 0.17, 0.14</span><br><span class="line">USER     TTY        LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">godleon  tty8      09:08    7:29m  9:30   0.37s mate-session</span><br><span class="line"></span><br><span class="line"><span class="comment"># $ uptime</span></span><br><span class="line"> 16:43:07 up  7:35,  3 users,  load average: 0.18, 0.15, 0.14</span><br></pre></td></tr></table></figure>
<blockquote>
<p>load average 超過 1 就表示系統負擔過重(要先除以 CPU 執行緒數量)</p>
</blockquote>
<h2 id="7-4-2-Real-time-process-monitoring"><a href="#7-4-2-Real-time-process-monitoring" class="headerlink" title="7.4.2 Real-time process monitoring"></a>7.4.2 Real-time process monitoring</h2><p>動態呈現，使用 <code>top</code>：</p>
<ul>
<li><p><code>VIRT</code>：process 消耗所有記憶體大小(包含實體 &amp; 虛擬)，等同 ps 指令中的 <code>VSZ</code></p>
</li>
<li><p><code>RES</code>：process 所使用的實體記憶體大小，等同 ps 指令中的 <code>RSS</code></p>
</li>
</ul>
<p>在 top 中常用的按鍵：</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>l</code>, <code>t</code>, <code>m</code></td>
<td>開啟 or 關閉 load, thread, memory 資訊</td>
</tr>
<tr>
<td><code>M</code></td>
<td>記憶體使用量從大排到小</td>
</tr>
<tr>
<td><code>P</code></td>
<td>CPU 使用量從大排到小</td>
</tr>
<tr>
<td><code>k</code></td>
<td>指定 PID 並 TERM 該 process</td>
</tr>
<tr>
<td><code>r</code></td>
<td>renice 指定 process</td>
</tr>
<tr>
<td><code>W</code></td>
<td>記錄目前的 top 觀察設定，並可作為下次使用 top 時的預設設定</td>
</tr>
<tr>
<td><code>B</code></td>
<td>header &amp; running process 會以粗體顯示</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> RHCE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH124 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[RHCE] RH124 Chapter 4~6 學習筆記]]></title>
      <url>/blog/2016/04/03/RHCE/RHCE7-RH124-LearningNotes-CH04_06/</url>
      <content type="html"><![CDATA[<h1 id="Chapter-4-Creating-Viewing-and-Editing-Text-Files"><a href="#Chapter-4-Creating-Viewing-and-Editing-Text-Files" class="headerlink" title="Chapter 4. Creating, Viewing, and Editing Text Files"></a>Chapter 4. Creating, Viewing, and Editing Text Files</h1><h2 id="4-1-Redirecting-Output-to-a-File-or-Program"><a href="#4-1-Redirecting-Output-to-a-File-or-Program" class="headerlink" title="4.1 Redirecting Output to a File or Program"></a>4.1 Redirecting Output to a File or Program</h2><h3 id="Standard-input-standard-output-and-standard-error"><a href="#Standard-input-standard-output-and-standard-error" class="headerlink" title="Standard input, standard output, and standard error"></a>Standard input, standard output, and standard error</h3><p><img src="https://upload.wikimedia.org/wikipedia/commons/7/70/Stdstreams-notitle.svg" alt="Process I/O Channel"></p>
<p><img src="http://cs.ucla.edu/classes/fall08/cs111/scribe/4/FDT_diagram.JPG" alt="STDIN、STDOUT &amp; STDERR"></p>
<h3 id="Redirecting-output-to-a-file"><a href="#Redirecting-output-to-a-file" class="headerlink" title="Redirecting output to a file"></a>Redirecting output to a file</h3><table>
<thead>
<tr>
<th>Usage</th>
<th>說明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&amp;&gt;file</code></td>
<td>stdout &amp; stderr 各自輸出到相同的檔案中<br>會複寫指定檔案，若檔案不存在則建立新檔</td>
</tr>
<tr>
<td><code>&gt;&gt;file 2&gt;&amp;1</code><p><code>&amp;&gt;&gt;file</code></p></td>
<td>stderr 會導向變成 stdout 輸出，並附加內容於指定檔案<br><strong><font color="red">不會再有 stderr 輸出，而是全部皆為 stdout 輸出</font></strong></td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ find /etc -name passwd &amp;&gt;/tmp/save-both</span><br><span class="line">[vagrant@server tmp]$ cat /tmp/save-both</span><br><span class="line">....</span><br><span class="line">find: ‘/etc/lvm/backup’: Permission denied</span><br><span class="line">find: ‘/etc/lvm/cache’: Permission denied</span><br><span class="line">/etc/passwd</span><br><span class="line">find: ‘/etc/polkit-1/rules.d’: Permission denied</span><br><span class="line">find: ‘/etc/polkit-1/localauthority’: Permission denied</span><br><span class="line">....</span><br><span class="line">/etc/pam.d/passwd</span><br><span class="line">find: ‘/etc/audisp’: Permission denied</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<h3 id="Constructing-pipelines"><a href="#Constructing-pipelines" class="headerlink" title="Constructing pipelines"></a>Constructing pipelines</h3><p>pipeline 並沒有對 stderr 進行處理，透過以下兩個指令可以看出差別：(看有顏色的部分)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 僅有 stdout 的內容會被篩選</span></span><br><span class="line">[vagrant@server tmp]$ find /etc -name passwd | grep etc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 連同 stderr 的內容都會被篩選(因為 stderr 的內容已經導向 stdout 輸出)</span></span><br><span class="line">[vagrant@server tmp]$ find /etc -name passwd 2&gt;&amp;1 | grep etc</span><br></pre></td></tr></table></figure>
<p><img src="http://civilnet.cn/book/kernel/GNU.Linux.Application.Programming/images/11.1_0.jpg" alt="Linux Pipeline"></p>
<h4 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h4><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/24/Tee.svg/400px-Tee.svg.png" alt="tee pipeline"></p>
<p>tee 的使用範例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -a = append</span></span><br><span class="line">[vagrant@server ~]$ ps -f | tee -a ps_file.txt</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">vagrant   3372  3371  0 14:25 pts/0    00:00:00 -bash</span><br><span class="line">vagrant   3395  3372  0 14:25 pts/0    00:00:00 ps -f</span><br><span class="line">vagrant   3396  3372  0 14:25 pts/0    00:00:00 tee -a ps_file.txt</span><br><span class="line"></span><br><span class="line">[vagrant@server ~]$ cat ps_file.txt</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">vagrant   3372  3371  0 14:25 pts/0    00:00:00 -bash</span><br><span class="line">vagrant   3395  3372  0 14:25 pts/0    00:00:00 ps -f</span><br><span class="line">vagrant   3396  3372  0 14:25 pts/0    00:00:00 tee -a ps_file.txt</span><br></pre></td></tr></table></figure>
<p>以下兩種寄 mail 的方式相同：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat filename | mail -s subject username</span><br><span class="line"></span><br><span class="line">$ mail -s subject username &lt; filename</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Chapter-5-Managing-Local-Linux-Users-and-Groups"><a href="#Chapter-5-Managing-Local-Linux-Users-and-Groups" class="headerlink" title="Chapter 5. Managing Local Linux Users and Groups"></a>Chapter 5. Managing Local Linux Users and Groups</h1><h2 id="5-1-Users-and-Groups"><a href="#5-1-Users-and-Groups" class="headerlink" title="5.1 Users and Groups"></a>5.1 Users and Groups</h2><h3 id="What-is-a-user"><a href="#What-is-a-user" class="headerlink" title="What is a user?"></a>What is a user?</h3><p><code>id</code> 用來顯示目前登入的使用者資訊：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server ~]$ id</span><br><span class="line">uid=1000(vagrant) gid=1000(vagrant) groups=1000(vagrant),10(wheel) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</span><br></pre></td></tr></table></figure>
<blockquote>
<p>context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 是 SELinux 安全脈絡標籤</p>
</blockquote>
<p><strong><font color="red">/etc/passwd</font></strong> 的格式可以參考 <code>man 5 passwd</code></p>
<p>基本上 password 的部分已經都用 x 取代，並移到 <strong><font color="red">/etc/shadow</font></strong> 存放</p>
<h3 id="What-is-a-group"><a href="#What-is-a-group" class="headerlink" title="What is a group?"></a>What is a group?</h3><ol>
<li><p>每個使用者只會有一個 primary group，記錄在 <code>/etc/passwd</code> 內</p>
</li>
<li><p>每個使用者可以有 0 到多個 supplementary group，資訊會記錄在 <code>/etc/group</code> 內</p>
</li>
</ol>
<h2 id="5-2-Gaining-Superuser-Access"><a href="#5-2-Gaining-Superuser-Access" class="headerlink" title="5.2 Gaining Superuser Access"></a>5.2 Gaining Superuser Access</h2><h3 id="The-root-user"><a href="#The-root-user" class="headerlink" title="The root user"></a>The root user</h3><p>一般使用者可透過 <code>su</code>, <code>sudo</code>, <code>PolicyKit</code>(GUI 內用，類似 Windows UAC) 來取得 root 權限</p>
<h3 id="Switching-users-with-su"><a href="#Switching-users-with-su" class="headerlink" title="Switching users with su"></a>Switching users with su</h3><p><code>su [-] username</code>：等同於新的 user 重新登入的效果</p>
<p><code>su username</code>：產生新的 shell 並使用目前的環境變數</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 -c 可達到類似 windows runas 的效果</span></span><br><span class="line">[vagrant@server ~]$ su -c <span class="string">"ls /root"</span> root</span><br><span class="line">Password:</span><br><span class="line">anaconda-ks.cfg</span><br></pre></td></tr></table></figure>
<h3 id="Running-commands-as-root-with-sudo"><a href="#Running-commands-as-root-with-sudo" class="headerlink" title="Running commands as root with sudo"></a>Running commands as root with sudo</h3><p>su 的缺點是，一次就拿到完整的 root 權限，且切換成 root 還必須知道 root 的密碼。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server ~]$ sudo cat /etc/sudoers | grep <span class="string">'^[^#]'</span></span><br><span class="line">Defaults   !visiblepw</span><br><span class="line">Defaults    always_set_home</span><br><span class="line">Defaults    env_reset</span><br><span class="line">Defaults    env_keep =  <span class="string">"COLORS DISPLAY HOSTNAME HISTSIZE INPUTRC KDEDIR LS_COLORS"</span></span><br><span class="line">Defaults    env_keep += <span class="string">"MAIL PS1 PS2 QTDIR USERNAME LANG LC_ADDRESS LC_CTYPE"</span></span><br><span class="line">Defaults    env_keep += <span class="string">"LC_COLLATE LC_IDENTIFICATION LC_MEASUREMENT LC_MESSAGES"</span></span><br><span class="line">Defaults    env_keep += <span class="string">"LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER LC_TELEPHONE"</span></span><br><span class="line">Defaults    env_keep += <span class="string">"LC_TIME LC_ALL LANGUAGE LINGUAS _XKB_CHARSET XAUTHORITY"</span></span><br><span class="line">Defaults    secure_path = /sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">root    ALL=(ALL)       ALL</span><br><span class="line">%wheel  ALL=(ALL)       ALL   <span class="comment">#表示 wheel 群組內的擁有所有權限(% 開頭表示指定群組)</span></span><br><span class="line"></span><br><span class="line">[vagrant@server ~]$ cat /etc/group | grep wheel</span><br><span class="line">wheel:x:10:vagrant</span><br></pre></td></tr></table></figure>
<p>使用 <code>sudo</code> 的特點：</p>
<ol>
<li><p>執行 root 的系統命令不需要記住 root 密碼</p>
</li>
<li><p>所有 sudo 所執行的紀錄都會留在 <code>/var/log/secure</code> 中</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server ~]$ sudo tail /var/<span class="built_in">log</span>/secure</span><br><span class="line">....</span><br><span class="line">Feb 22 13:45:26 localhost sudo: vagrant : TTY=pts/0 ; PWD=/home/vagrant ; USER=root ; COMMAND=/bin/ls /root/</span><br><span class="line">Feb 22 13:45:45 localhost sudo: vagrant : TTY=pts/0 ; PWD=/home/vagrant ; USER=root ; COMMAND=/bin/cat /var/<span class="built_in">log</span>/secure</span><br><span class="line">Feb 22 13:46:10 localhost sudo: vagrant : TTY=pts/0 ; PWD=/home/vagrant ; USER=root ; COMMAND=/bin/tail /var/<span class="built_in">log</span>/secure</span><br></pre></td></tr></table></figure>
<h3 id="補充"><a href="#補充" class="headerlink" title="補充"></a>補充</h3><p><code>NIS</code>：集中驗證</p>
<p><code>IPA</code>：集中授權管理</p>
<p><code>sudo su -</code> or <code>sudo -s</code>：用一般的 user 切換成 root，輸入一般 user 的密碼</p>
<h2 id="5-3-Managing-Local-User-Accounts"><a href="#5-3-Managing-Local-User-Accounts" class="headerlink" title="5.3 Managing Local User Accounts"></a>5.3 Managing Local User Accounts</h2><h3 id="Managing-local-users"><a href="#Managing-local-users" class="headerlink" title="Managing local users"></a>Managing local users</h3><p><code>/etc/login.defs</code> 檔案中紀錄了新增使用者時的相關預設設定，例如 UID range, 密碼有效期限 … 等</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server ~]$ cat /etc/login.defs | grep <span class="string">'^[^#]'</span></span><br><span class="line">MAIL_DIR        /var/spool/mail</span><br><span class="line">PASS_MAX_DAYS   99999</span><br><span class="line">PASS_MIN_DAYS   0</span><br><span class="line">PASS_MIN_LEN    5</span><br><span class="line">PASS_WARN_AGE   7</span><br><span class="line">UID_MIN                  1000</span><br><span class="line">UID_MAX                 60000</span><br><span class="line">SYS_UID_MIN               201</span><br><span class="line">SYS_UID_MAX               999</span><br><span class="line">GID_MIN                  1000</span><br><span class="line">GID_MAX                 60000</span><br><span class="line">SYS_GID_MIN               201</span><br><span class="line">SYS_GID_MAX               999</span><br><span class="line">CREATE_HOME     yes</span><br><span class="line">UMASK           077</span><br><span class="line">USERGROUPS_ENAB yes</span><br><span class="line">ENCRYPT_METHOD SHA512</span><br></pre></td></tr></table></figure>
<h4 id="usermode-modifies-existing-users"><a href="#usermode-modifies-existing-users" class="headerlink" title="usermode modifies existing users"></a>usermode modifies existing users</h4><p><code>usermod</code> 用來修改使用者資訊，相關參數如下：</p>
<table>
<thead>
<tr>
<th>參數</th>
<th>說明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-g/--gid</code> GROUP</td>
<td>設定 user 的 primary group</td>
</tr>
<tr>
<td><code>-G/--groups</code> GROUPS</td>
<td>設定 user 的 supplementary group</td>
</tr>
<tr>
<td><code>-a/--append</code></td>
<td>與 <code>-G</code> 搭配，用來增加 supplementary group 設定</td>
</tr>
<tr>
<td><code>-d/--home</code> HOME_DIR</td>
<td>設定 user 家目錄</td>
</tr>
<tr>
<td><code>-m/--move-home</code></td>
<td>移動 user 家目錄到新的地方，必須與 <code>-d</code> 參數同時使用</td>
</tr>
<tr>
<td><code>-s/--shell</code> SHELL</td>
<td>指定登入 shell</td>
</tr>
<tr>
<td><code>-L/--lock</code></td>
<td>鎖定 user</td>
</tr>
<tr>
<td><code>-U/--unlock</code></td>
<td>解鎖 user</td>
</tr>
</tbody>
</table>
<h4 id="userdel-deletes-users"><a href="#userdel-deletes-users" class="headerlink" title="userdel deletes users"></a>userdel deletes users</h4><p><code>userdel -r username</code>：會將 user 刪除，連同家目錄 &amp; mail 都一併移除</p>
<blockquote>
<p>userdel 命令若沒有加上 -r 參數，可能會有安全疑慮，主要是沒有 owner &amp; owner group 的檔案可能會被新增的 user 取得存取權限</p>
<p>此問題可透過 <code>sudo find / -nouser -o --nogroup 2&gt;/dev/null</code> 指令來找到if沒有 owner &amp; owner group 的檔案</p>
</blockquote>
<h4 id="id-displays-user-information"><a href="#id-displays-user-information" class="headerlink" title="id displays user information"></a>id displays user information</h4><p><code>id</code> 可用來顯示使用者資訊</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server ~]$ id</span><br><span class="line">uid=1000(vagrant) gid=1000(vagrant) groups=1000(vagrant),10(wheel) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</span><br><span class="line"></span><br><span class="line">[vagrant@server ~]$ id root</span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br></pre></td></tr></table></figure>
<h4 id="UID-ranges"><a href="#UID-ranges" class="headerlink" title="UID ranges"></a>UID ranges</h4><p>UID 在 RHEL 7 中的定義：(預設值可參考 <code>/etc/login.defs</code>)</p>
<ul>
<li><p><code>UID 0</code>：root</p>
</li>
<li><p><code>UID 1-200</code>：system users，通常用來啟動系統服務之用</p>
</li>
<li><p><code>UID 201-999</code>：保留的 system users，有其他額外未預先定義的系統服務需要時可使用</p>
</li>
<li><p><code>UID 1000</code>：一般使用者用的 UID</p>
</li>
</ul>
<blockquote>
<p>在 RHEL 7 之前，system user 使用 UID 1-499，一般使用者使用  UID 500+</p>
</blockquote>
<h3 id="Practice"><a href="#Practice" class="headerlink" title="Practice"></a>Practice</h3><p>使用 variable 新增 user：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server ~]$ USER=juliet</span><br><span class="line"></span><br><span class="line">[vagrant@server ~]$ <span class="built_in">echo</span> <span class="variable">$USER</span></span><br><span class="line">juliet</span><br><span class="line"></span><br><span class="line">[vagrant@server ~]$ sudo useradd <span class="variable">$&#123;USER&#125;</span>; <span class="built_in">echo</span> <span class="variable">$&#123;USER&#125;</span> | sudo passwd --stdin <span class="variable">$&#123;USER&#125;</span></span><br><span class="line">Changing password <span class="keyword">for</span> user juliet.</span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br></pre></td></tr></table></figure>
<h2 id="5-4-Managing-Local-Group-Accounts"><a href="#5-4-Managing-Local-Group-Accounts" class="headerlink" title="5.4 Managing Local Group Accounts"></a>5.4 Managing Local Group Accounts</h2><h3 id="5-4-1-Managing-supplementary-groups"><a href="#5-4-1-Managing-supplementary-groups" class="headerlink" title="5.4.1 Managing supplementary groups"></a>5.4.1 Managing supplementary groups</h3><h4 id="groupadd"><a href="#groupadd" class="headerlink" title="groupadd"></a>groupadd</h4><ul>
<li><code>-r</code>：用來增加 system group (GID &gt; 1000)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 -g 選項指定 GID</span></span><br><span class="line">$ sudo groupadd -g 5000 ateam</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 -r 選項姜群組新增成 system group</span></span><br><span class="line">$ sudo groupadd -r appusers</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢系統中預設 GID range</span></span><br><span class="line">[vagrant@server ~]$ cat /etc/login.defs | grep GID</span><br><span class="line">GID_MIN                  1000</span><br><span class="line">GID_MAX                 60000</span><br><span class="line">SYS_GID_MIN               201</span><br><span class="line">SYS_GID_MAX               999</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>/etc/login.defs</code> 檔案中紀錄了許多與使用者 &amp; 群組管理上相關的預設參數</p>
</blockquote>
<h4 id="groupmod"><a href="#groupmod" class="headerlink" title="groupmod"></a>groupmod</h4><ul>
<li><p><code>-n</code>：修改群組名稱</p>
</li>
<li><p><code>-g</code>：修改 GID (這會衍生非預期的問題)</p>
<ul>
<li>家目錄不會改</li>
<li>相對應的檔案 &amp; 目錄皆不會改</li>
</ul>
</li>
</ul>
<h4 id="usermod-alters-group-membership"><a href="#usermod-alters-group-membership" class="headerlink" title="usermod alters group membership"></a>usermod alters group membership</h4><ul>
<li><p><code>-g</code>：指定 primary group</p>
</li>
<li><p><code>sudo usermod -g NEW_PRIMARY_GROUPNAME USERNAME</code>：變更指定使用者的 primary group</p>
</li>
<li><p><code>-G</code>：指定 supplementary group</p>
</li>
<li><p><code>sudo uermod -aG SUPPLYMENTARY_GROUP USERNAME</code>：新增使用者的 supplementary group</p>
</li>
</ul>
<h2 id="5-5-Managing-User-Passwords"><a href="#5-5-Managing-User-Passwords" class="headerlink" title="5.5 Managing User Passwords"></a>5.5 Managing User Passwords</h2><h3 id="5-5-1-Shadow-passwords-and-password-policy"><a href="#5-5-1-Shadow-passwords-and-password-policy" class="headerlink" title="5.5.1 Shadow passwords and password policy"></a>5.5.1 Shadow passwords and password policy</h3><p>現在為了安全性，密碼都已經改存到只有 root 能讀取的 <code>/etc/shadow</code> 中，分為幾個欄位：</p>
<ol>
<li><code>name</code>：使用者名稱</li>
<li><code>password</code>：密碼</li>
<li><code>lastchange</code>：上次修改時間 (為單一數值，從 1970/01/01 作為第1天起算) (改為 0，強制使用者必須在下次登入時改密碼)</li>
<li><code>minage</code>：密碼存活的最小生命周期(0 表示馬上可以改回來)</li>
<li><code>maxage</code>：密碼存活的最大生命周期(最大為 99999，從 <code>lastchange</code> 開始算)</li>
<li><code>warning</code>：提醒使用者的時間 (default: 7，七天前提醒)</li>
<li><code>inactive</code>：寬限期，最多密碼可以存活 (maxage + inactive) 天；在寬限期登入會被強制要求更改密碼</li>
<li><code>expire</code>：密碼失效日期，不受前面欄位影響，過期就表示密碼完全失效</li>
<li><code>blank</code>：保留作為未來使用</li>
</ol>
<p>說明第 2 個欄位 <code>password</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@desktop ~]$ sudo tail -3 /etc/shadow</span><br><span class="line">juliet:<span class="variable">$6</span><span class="variable">$TFn6B61u</span><span class="variable">$sA</span>/maknNkUeghjzgrGkoAiLYzNa/KqDQDR5A0m0PxTZeac4gdXQAleR.sxWcWK5VZnnSIhSAsD/WnIZr51MZA/:16864:0:99999:7:::</span><br><span class="line">romeo:<span class="variable">$6</span><span class="variable">$vRE6wD1I</span><span class="variable">$4eh6QNLPzyMw9pVjr</span>.YwOia6s8y1zixFq2LpHSi/n.Q/A45J/jqiBCNXRJan2rl0p6MwuL.91mf3IkRNZQUVv.:16864:0:99999:7:::</span><br><span class="line">hamlet:<span class="variable">$6</span><span class="variable">$Nu8r</span>/BWW<span class="variable">$PqoSIv9iRx9oQEH2ziw4L2WH0HMXs2YXFvEH8SFHmmKd</span>/WxeAV0qOweqAXUN6TE375W7ShHHLxP6i7jBcHsD/1:16864:0:99999:7:::</span><br></pre></td></tr></table></figure>
<p>以 user juliet <code>$6$TFn6B61u$sA/maknNkUeghjz</code> 為例：(以 <strong><font color="red">$</font></strong> 作為分隔)</p>
<ol>
<li><p><code>6</code>：第一個部分，表示加密用的 hash 演算法，1 = MD5，6 = SHA-512 (RHEL 7 預設為 6)</p>
</li>
<li><p><code>TFn6B61u</code>：用來在加密密碼時用的 random 字串(salt)，加密時會一起用到，為了避免同樣密碼的使用者會有相同的 hash 結果</p>
</li>
<li><p><code>sA/maknNkUeghjz....</code>：hash(password + salt) 的結果</p>
</li>
</ol>
<blockquote>
<p><code>/etc/shadow</code> 的詳細說明，可以參考 <a href="http://linux.vbird.org/linux_basic/0410accountmanager.php#shadow_file" target="_blank" rel="noopener">鳥哥的 Linux 私房菜 – 第十三章、Linux 帳號管理與 ACL 權限設定</a></p>
</blockquote>
<ol>
<li><p><code>name</code>：使用者帳號</p>
</li>
<li><p><code>password</code>：上述的密碼資訊</p>
</li>
<li><p><code>lastchange</code>：從 1970/01/01 起算的日期(0 表示強制使用者下次登入時變更密碼)</p>
</li>
<li><p><code>min days</code>：</p>
</li>
<li><p><code>max days</code></p>
</li>
<li><p><code>warning</code></p>
</li>
<li><p><code>inactive</code></p>
</li>
<li><p><code>expires</code></p>
</li>
<li><p><code>blank</code></p>
</li>
</ol>
<h3 id="5-5-2-Password-aging"><a href="#5-5-2-Password-aging" class="headerlink" title="5.5.2 Password aging"></a>5.5.2 Password aging</h3><p><img src="https://lh3.googleusercontent.com/2bDqeWVGlV0vGtV0lm6TE-1KwHmNixd6pUAaDGh30pcFJGF3tI3WUsV6dxUzdRbSPh7dR3mzznf_EdinGaKeWQA1xrA9cdOJFajn-jQFCcgEfni4Sdpn4zd-6R4T-Rj0Cezry17a0m_hI61F1nD8TjQFomv6NltRNseZgPgHVM1JU0or0xr8Y322N7MfhzoQIXeLQgQMLTsKtLAr19avk7A3yUQiZn5m6RI6T0rVqmW2FsXYwGEiQiDQlmg9POKDIndNH9LknDoIGHK5PAL_03cmbuY5EdouDrBMQu1PCESLO5GvZgzG-UIWNXMYk692Rai3Cpw6zNbyMUdwqpzvUaCgsPFHYcRfA9C3U1VJ4p-O2Q9iIKq5-8DWzEzGb7HELfYNwAHny8QGnXBGnHa7qtzVUJseFngyW3I2T-rCD7rriDbNYep4-V_fSqMSCNFSpVcs6Xnaj9TmnmXoegWDt3p43VTQxqPPb5C1LpyOK8mwwzFJdrYEjRJNmRzz6o4tUTqfbeay_UdKTzARA4MrsP6k2X5wHPWlDOao9eh7cMtRsyQpk9KE3Mp2l44mIHs_tuIE=w657-h235-no" alt="Linux Password Aging"></p>
<p>RHEL7 用來加密密碼的 hash algorithm 已經預設改為 <code>SHA-512</code>(<font color="red"><strong>6</strong></font>)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 強制使用者下次登入修改密碼</span></span><br><span class="line">$ chage -d 0 USER_NAME</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 human readable 的方式顯示 /etc/shadow 的內容</span></span><br><span class="line">$ chage -l USER_NAME</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定密碼失效日期 (也可以改用數字)</span></span><br><span class="line">$ chage -E YYYY-MM-DD USER_NAME</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 檢視 juliet 目前的密碼期限相關設定</span></span><br><span class="line">[vagrant@desktop ~]$ sudo chage -l juliet</span><br><span class="line">Last password change                                    : Mar 04, 2016</span><br><span class="line">Password expires                                        : never</span><br><span class="line">Password inactive                                       : never</span><br><span class="line">Account expires                                         : never</span><br><span class="line">Minimum number of days between password change          : 0</span><br><span class="line">Maximum number of days between password change          : 99999</span><br><span class="line">Number of days of warning before password expires       : 7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 強制 juliet 在下次登入時變更密碼</span></span><br><span class="line">[vagrant@desktop ~]$ sudo chage -d 0 juliet</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 -E YYYY-MM-dd 的設定方式將帳號過期時間設定為 45 天後</span></span><br><span class="line">[vagrant@desktop ~]$ sudo chage -E $(date -d <span class="string">"+45 days"</span> +%F) juliet</span><br></pre></td></tr></table></figure>
<h3 id="5-5-3-Restricting-access"><a href="#5-5-3-Restricting-access" class="headerlink" title="5.5.3 Restricting access"></a>5.5.3 Restricting access</h3><p>限制使用者存取的方式：</p>
<ol>
<li>Lock USER_NAME</li>
<li>給 Expiration Date</li>
<li>把 shell 給成 /sbin/nologin</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下兩個功能相同</span></span><br><span class="line">$ sudo usermod -L USER_NAME</span><br><span class="line">$ sudo passwd -l USER_NAME</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lock user</span></span><br><span class="line">$ sudo usermod -L juliet</span><br><span class="line"></span><br><span class="line"><span class="comment"># unlock user</span></span><br><span class="line">$ sudo usermod -U juliet</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定 nologin shell 給使用者，使用者就沒有 shell 可用(例如：mail service)</span></span><br><span class="line">$ sudo usermod -s /sbin/nologin juliet</span><br></pre></td></tr></table></figure>
<h3 id="5-5-4-Lab-Managing-Local-Linux-Users-and-Groups"><a href="#5-5-4-Lab-Managing-Local-Linux-Users-and-Groups" class="headerlink" title="5.5.4 Lab: Managing Local Linux Users and Groups"></a>5.5.4 Lab: Managing Local Linux Users and Groups</h3><p>修改 <code>/etc/login.defs</code>(<font color="red"><strong>PASS_MAX_DAYS</strong></font>) 將密碼預設過期日改為 30</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新增一個 GID 40000，名稱為 consultants 的群組</span></span><br><span class="line">$ groupadd -g 40000 consultants</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增使用者，指定 GID 為 40000，並設定密碼為 default</span></span><br><span class="line">$ USR=sspade; useradd -G 40000 <span class="variable">$&#123;USR&#125;</span>; <span class="built_in">echo</span> <span class="string">"default"</span> | passwd --stdin <span class="variable">$&#123;USR&#125;</span></span><br><span class="line">$ USR=bboop; useradd -G 40000 <span class="variable">$&#123;USR&#125;</span>; <span class="built_in">echo</span> <span class="string">"default"</span> | passwd --stdin <span class="variable">$&#123;USR&#125;</span></span><br><span class="line">$ USR=dtracy; useradd -G 40000 <span class="variable">$&#123;USR&#125;</span>; <span class="built_in">echo</span> <span class="string">"default"</span> | passwd --stdin <span class="variable">$&#123;USR&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定 sspade, bboop, dreacy 的密碼過期日(expiration date)為 90 天後</span></span><br><span class="line">$ chage -E $(date -d <span class="string">"+90 days"</span> +%Y-%m-%d) sspade</span><br><span class="line">$ chage -E $(date -d <span class="string">"+90 days"</span> +%Y-%m-%d) bboop</span><br><span class="line">$ chage -E $(date -d <span class="string">"+90 days"</span> +%Y-%m-%d) dtracy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 限制 bboop 每 15 天要改一次密碼</span></span><br><span class="line">$ chage -M 15 bboop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 強制 sspade, bboop, dreacy 下次登入時要改密碼</span></span><br><span class="line">$ chage -d 0 sspade</span><br><span class="line">$ chage -d 0 bboop</span><br><span class="line">$ chage -d 0 dtracy</span><br></pre></td></tr></table></figure>
<h2 id="5-6-Practice-Managing-User-Password-Aging"><a href="#5-6-Practice-Managing-User-Password-Aging" class="headerlink" title="5.6 Practice: Managing User Password Aging"></a>5.6 Practice: Managing User Password Aging</h2><p>Lock User：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lock 使用者 romeo</span></span><br><span class="line">[vagrant@desktop ~]$ sudo usermod -L romeo</span><br><span class="line"><span class="comment"># 無法切換使用者，因為已經 lock</span></span><br><span class="line">[vagrant@desktop ~]$ su - romeo</span><br><span class="line">Password:</span><br><span class="line">su: Authentication failure</span><br><span class="line"></span><br><span class="line"><span class="comment"># unlock 之後便可登入</span></span><br><span class="line">[vagrant@desktop ~]$ sudo usermod -U romeo</span><br><span class="line">[vagrant@desktop ~]$ su - romeo</span><br><span class="line">Password:</span><br><span class="line">Last login: Wed Mar  9 14:39:24 UTC 2016 on pts/0</span><br><span class="line">Last failed login: Wed Mar  9 14:40:51 UTC 2016 on pts/0</span><br><span class="line">There were 2 failed login attempts since the last successful login.</span><br><span class="line">[romeo@desktop ~]$</span><br></pre></td></tr></table></figure>
<p>設定密碼過期時間 90 天 &amp; 下次登入時修改密碼：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@desktop ~]$ sudo chage -l romeo</span><br><span class="line">Last password change                                    : Mar 09, 2016</span><br><span class="line">Password expires                                        : never</span><br><span class="line">Password inactive                                       : never</span><br><span class="line">Account expires                                         : never</span><br><span class="line">Minimum number of days between password change          : 0</span><br><span class="line">Maximum number of days between password change          : 99999</span><br><span class="line">Number of days of warning before password expires       : 7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定密碼過期時間 90 天</span></span><br><span class="line">[vagrant@desktop ~]$ sudo chage -M 90 romeo</span><br><span class="line">[vagrant@desktop ~]$ sudo chage -l romeo</span><br><span class="line">Last password change                                    : Mar 09, 2016</span><br><span class="line">Password expires                                        : Jun 07, 2016</span><br><span class="line">Password inactive                                       : never</span><br><span class="line">Account expires                                         : never</span><br><span class="line">Minimum number of days between password change          : 0</span><br><span class="line">Maximum number of days between password change          : 90</span><br><span class="line">Number of days of warning before password expires       : 7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 強制使用者下次登入時變更密碼</span></span><br><span class="line">[vagrant@desktop ~]$ sudo chage -l romeo</span><br><span class="line">Last password change                                    : password must be changed</span><br><span class="line">Password expires                                        : password must be changed</span><br><span class="line">Password inactive                                       : password must be changed</span><br><span class="line">Account expires                                         : never</span><br><span class="line">Minimum number of days between password change          : 0</span><br><span class="line">Maximum number of days between password change          : 90</span><br><span class="line">Number of days of warning before password expires       : 7</span><br></pre></td></tr></table></figure>
<p>設定使用者密碼過期時間為 180 天後：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@desktop ~]$ sudo chage -E $(date -d <span class="string">"+180 days"</span> +%F) romeo</span><br><span class="line">[vagrant@desktop ~]$ sudo chage -l romeo</span><br><span class="line">Last password change                                    : Mar 09, 2016</span><br><span class="line">Password expires                                        : Jun 07, 2016</span><br><span class="line">Password inactive                                       : never</span><br><span class="line">Account expires                                         : Sep 05, 2016</span><br><span class="line">Minimum number of days between password change          : 0</span><br><span class="line">Maximum number of days between password change          : 90</span><br><span class="line">Number of days of warning before password expires       : 7</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Chapter-6-Controlling-Access-to-Files-with-Linux-File-System-Permissions"><a href="#Chapter-6-Controlling-Access-to-Files-with-Linux-File-System-Permissions" class="headerlink" title="Chapter 6. Controlling Access to Files with Linux File System Permissions"></a>Chapter 6. Controlling Access to Files with Linux File System Permissions</h1><h2 id="6-1-Linux-File-System-Permissions"><a href="#6-1-Linux-File-System-Permissions" class="headerlink" title="6.1 Linux File System Permissions"></a>6.1 Linux File System Permissions</h2><h3 id="6-1-1-Linux-file-system-permissions"><a href="#6-1-1-Linux-file-system-permissions" class="headerlink" title="6.1.1 Linux file system permissions"></a>6.1.1 Linux file system permissions</h3><blockquote>
<p>新增/刪除檔案不是看檔案本身權限，而是看上層目錄的權限</p>
</blockquote>
<p>當使用者擁有目錄的 <code>w(write)</code> &amp; <code>x(execute)</code> 權限時，可以刪除該目錄中自己也沒有權限的檔案，但這問題可以透過 <code>sticky bit</code> 來解決!</p>
<p>正常對目錄有存取權限的使用者，會同時有 <code>r(read)</code> &amp; <code>w(write)</code> 兩個權限：</p>
<ul>
<li><p>若沒有目錄的 <code>r(read)</code> 權限，使用者無法列出目錄中的檔案，但若知道明確檔名還是可以存取</p>
</li>
<li><p>若沒有目錄的 <code>w(write)</code> 權限，就只能列出目錄中的檔案內容，但都無法存取目錄中的任何檔案(連 timestamp 資訊都看不到)</p>
</li>
<li><p>但如果進不了目錄(<strong><font color="red">沒有 execute 權限</font></strong>)，還是無法刪除檔案</p>
</li>
</ul>
<h3 id="6-1-2-Viewing-file-directory-permissions-and-ownership"><a href="#6-1-2-Viewing-file-directory-permissions-and-ownership" class="headerlink" title="6.1.2 Viewing file/directory permissions and ownership"></a>6.1.2 Viewing file/directory permissions and ownership</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出目錄中所有子目錄 &amp; 檔案的相關權限資訊</span></span><br><span class="line">[vagrant@server ~]$ ls -l /home</span><br><span class="line">total 4</span><br><span class="line">drwx------. 6 vagrant vagrant 4096 Mar 30 20:23 vagrant</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過 '-d' 參數，僅列出指定目錄的權限 (權限中的最後一個 . 是作為 ACL 控制用)</span></span><br><span class="line">[vagrant@server ~]$ ls -ld /home</span><br><span class="line">drwxr-xr-x. 3 root root 20 Jan  3 04:22 /home</span><br></pre></td></tr></table></figure>
<h2 id="6-2-Managing-File-System-Permissions-from-the-Command-Line"><a href="#6-2-Managing-File-System-Permissions-from-the-Command-Line" class="headerlink" title="6.2 Managing File System Permissions from the Command Line"></a>6.2 Managing File System Permissions from the Command Line</h2><h3 id="6-2-1-Changing-file-directory-permissions"><a href="#6-2-1-Changing-file-directory-permissions" class="headerlink" title="6.2.1 Changing file/directory permissions"></a>6.2.1 Changing file/directory permissions</h3><p>透過 chmod -R 以遞迴的方式指定檔案 &amp; 目錄的權限時，若包含了 x(execute) 權限，會讓檔案 &amp; 目錄同時都有 x(execute) 的權限，但這通常不是我們需要的結果；一般我們只會希望只有目錄才需要 x(execute) 權限，此時只要加上大寫 <code>W</code> 參數即可：</p>
<p>例如：<code>chmod -R g+rwX somedir</code> 表示 somedir 目錄下所有的檔案都給 rw 權限，目錄則是給 rwx 權限。</p>
<h3 id="6-2-2-Changing-file-directory-user-or-group-ownership"><a href="#6-2-2-Changing-file-directory-user-or-group-ownership" class="headerlink" title="6.2.2 Changing file/directory user or group ownership"></a>6.2.2 Changing file/directory user or group ownership</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下兩個指令功能相同，都是修改檔案的 group ownership</span></span><br><span class="line">[vagrant@server ch06]$ sudo chown :vboxsf 1st/aa</span><br><span class="line">[vagrant@server ch06]$ sudo chgrp vboxsf 1st/aa</span><br></pre></td></tr></table></figure>
<blockquote>
<p>只有 root 可以修改檔案的 ownership，一般使用者儘可以針對自己所屬的群組設定 ownership</p>
</blockquote>
<p>一般 web 網站的目錄，只會開啟目錄的 execute 權限，並且讓目錄內的檔案有 others read 的權限，讓使用者可以進入目錄，可以存取目錄中檔案的內容，但卻無法列出目錄中所有的檔案</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 檔案 file1 拿掉 group &amp; others 的 read &amp; write 權限</span></span><br><span class="line">$ chmod go-rw file1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 針對多層目錄 &amp; 檔案透過遞迴的方式設定權限(group 給予所有權限)</span></span><br><span class="line">$ chmod -R g+rwx multi_layer_dir</span><br><span class="line"></span><br><span class="line"><span class="comment"># 針對多層目錄(只有目錄，沒有檔案)，使用遞迴的方式指定所有人有 execute 的權限</span></span><br><span class="line"><span class="comment"># 透過大寫 X，指定套用權限時僅會套用在目錄上，不會在檔案上</span></span><br><span class="line">$ chmod -R a+X multi_layer_dir</span><br></pre></td></tr></table></figure>
<p>只有 root 可以變更檔案的 ownership</p>
<blockquote>
<p>例外：檔案擁有者可以改檔案所屬群組，但只可以改成屬於自己群組</p>
</blockquote>
<h2 id="6-3-Managing-Default-Permissions-and-File-Access"><a href="#6-3-Managing-Default-Permissions-and-File-Access" class="headerlink" title="6.3 Managing Default Permissions and File Access"></a>6.3 Managing Default Permissions and File Access</h2><h3 id="6-3-1-Special-permissions"><a href="#6-3-1-Special-permissions" class="headerlink" title="6.3.1 Special permissions"></a>6.3.1 Special permissions</h3><p>若檔案的 execute 權限標示為 <code>setuid</code> or <code>setgid</code> 時(以 <code>s</code> 表示權限)，表示此檔案不論是哪個使用者執行，會以檔案 owner 的身分(<code>setgid</code> 會以群組的身分)執行，而不是執行檔案的使用者。 例如：<strong>/etc/passwd</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server ~]$ ls -al /usr/bin/passwd</span><br><span class="line">-rwsr-xr-x. 1 root root 27832 Jun 10  2014 /usr/bin/passwd</span><br></pre></td></tr></table></figure>
<p>若 sticky bit(以 <code>t</code> 表示權限) 位於 directory 時，以 <strong><font color="red">/tmp</font></strong> 為例，<strong>只有檔案的擁有者才可以刪除檔案</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server ~]$ ls -ld /tmp/</span><br><span class="line">drwxrwxrwt. 7 root root 88 Apr  3 01:00 /tmp/</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>設定方式</th>
<th>在檔案上的效果</th>
<th>在目錄上的效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>u+s</code>(4)</td>
<td>檔案執行時會以 owner user 的權限執行</td>
<td>N/A</td>
</tr>
<tr>
<td><code>g+s</code>(2)</td>
<td>檔案執行時會以 owner group 的權限執行</td>
<td>在此目錄中新建立的檔案會擁有與目錄相同的 group 權限</td>
</tr>
<tr>
<td><code>o+t</code>(1)</td>
<td>N/A</td>
<td>在此目錄中，使用者僅能移除他們自己所建立的檔案</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># setuid</span></span><br><span class="line">$ chmod u+s some_file</span><br><span class="line"></span><br><span class="line"><span class="comment"># setgid</span></span><br><span class="line">$ chmod g+s,o-rx some_dir</span><br><span class="line">$ chmod 2770 some_dir</span><br></pre></td></tr></table></figure>
<h4 id="SetUID"><a href="#SetUID" class="headerlink" title="SetUID"></a>SetUID</h4><ul>
<li>檔案<blockquote>
<p>-rwsr-xr-x 1 root root 47032 Jul 16  2015 /usr/bin/passwd -&gt; /etc/shadow<br>passwd 指令的 owner 為 root，因此執行此指令時是以 root 的權限執行</p>
</blockquote>
</li>
</ul>
<h4 id="SetGID"><a href="#SetGID" class="headerlink" title="SetGID"></a>SetGID</h4><ul>
<li><p>檔案</p>
<blockquote>
<p>/usr/bin/locate -&gt; /var/lib/mlocate/mlocate.db</p>
</blockquote>
</li>
<li><p>目錄</p>
<blockquote>
<p>SetGID 設定在目錄上，則表示在該目錄中建立的檔案 or 目錄的擁有群組都會被強制設定為該目錄的擁有群組</p>
</blockquote>
</li>
</ul>
<h4 id="Sticky-Bit"><a href="#Sticky-Bit" class="headerlink" title="Sticky Bit"></a>Sticky Bit</h4><ul>
<li>目錄<blockquote>
<p><code>o+t</code> 表示該目錄中的檔案只有擁有者可以移除</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><strong><font color="red">T</font></strong>：表示 others 原本沒有 execute 權限</p>
<p><strong><font color="red">t</font></strong>：表示 others 原本有 execute 權限</p>
</blockquote>
<h3 id="6-3-2-Default-file-permissions"><a href="#6-3-2-Default-file-permissions" class="headerlink" title="6.3.2 Default file permissions"></a>6.3.2 Default file permissions</h3><p>Default permission (system)</p>
<ul>
<li>File: <code>666</code></li>
<li>Directory: <code>777</code></li>
</ul>
<p>Default Umask:</p>
<ul>
<li>root：<code>022</code></li>
<li>regular user：<code>002</code></li>
</ul>
<p>umask 使用 3 個數字進行修改，若少於 3 個數字，前面會被自動補 0；且更改的效果僅限於該 terminal session 中，重新登入後就會無效。</p>
<p>umask 的設定，若是要設定 global 的，可以到 <strong><font color="red">/etc/profile</font></strong> &amp; <strong><font color="red">/etc/bashrc</font></strong> 中進行調整</p>
<p>如果要進行個人化設定，則可以到 <strong><font color="red">~/.bash_profile</font></strong> &amp; <strong><font color="red">~/.bashrc</font></strong> 中進行調整</p>
]]></content>
      
        <categories>
            
            <category> RHCE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH124 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[RHCE] RH124 Chapter 1~3 學習筆記]]></title>
      <url>/blog/2016/02/17/RHCE/RHCE7-RH124-LearningNotes-CH01_03/</url>
      <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h3 id="Internationalization"><a href="#Internationalization" class="headerlink" title="Internationalization"></a>Internationalization</h3><p>若想要讓 desktop &amp; console 環境的語系一致，可以加入以下的 script 到 ~/.bashrc 中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i=$(grep <span class="string">'Language'</span> /var/lib/AccountsService/users/<span class="variable">$&#123;USER&#125;</span> | \</span><br><span class="line">sed <span class="string">'s/Language=//'</span>)</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$i</span>"</span> != <span class="string">""</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">export</span> LANG=<span class="variable">$i</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>透過 <font color="red"><code>locale</code></font> 可以查詢目前語系相關的設定 &amp; 環境變數：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ locale</span><br><span class="line">LANG=zh_TW.UTF-8</span><br><span class="line">.....(LANG-related environment variables)</span><br><span class="line">LC_ALL=</span><br></pre></td></tr></table></figure>
<p>若要修改整個系統的預設語系，可以透過以下指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ localectl <span class="built_in">set</span>-locale LANG=zh_TW.UTF-8</span><br></pre></td></tr></table></figure>
<p>或是修改 <font color="red"><code>/etc/locale.conf</code></font> 檔案的內容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/locale.conf</span><br><span class="line">LANG=zh_TW.UTF-8</span><br></pre></td></tr></table></figure>
<hr>
<p><a name="ch1"></a></p>
<h1 id="Chapter-1-ACCESSING-THE-COMMAND-LINE"><a href="#Chapter-1-ACCESSING-THE-COMMAND-LINE" class="headerlink" title="Chapter 1. ACCESSING THE COMMAND LINE"></a>Chapter 1. ACCESSING THE COMMAND LINE</h1><h2 id="1-1-Accessing-the-Command-Line-Using-the-Local-Console"><a href="#1-1-Accessing-the-Command-Line-Using-the-Local-Console" class="headerlink" title="1.1 Accessing the Command Line Using the Local Console"></a>1.1 Accessing the Command Line Using the Local Console</h2><h3 id="Virtual-Console"><a href="#Virtual-Console" class="headerlink" title="Virtual Console"></a>Virtual Console</h3><p>在 RHEL 7 中，若有 GUI 環境，則會預設執行在第一個 virtual console，另外還會包含 5 個文字模式的 virtual console，可使用 <code>Ctrl + Alt + F[1-6]</code> 在不同的 virtual console 間切換。</p>
<p>若沒有 GUI 環境，則 6 個 virtual console 都會是純文字模式。</p>
<p>要調整 virtual console 的數量，可修改 <code>/etc/systemd/login.conf</code> 中的 <strong><font color="red">NAutoVTs</font></strong> 的選項，</p>
<h2 id="1-2-Accrssing-the-Command-Line-Using-the-Desktop"><a href="#1-2-Accrssing-the-Command-Line-Using-the-Desktop" class="headerlink" title="1.2 Accrssing the Command Line Using the Desktop"></a>1.2 Accrssing the Command Line Using the Desktop</h2><h3 id="Windows-連線至-Linux-GUI"><a href="#Windows-連線至-Linux-GUI" class="headerlink" title="Windows 連線至 Linux GUI"></a>Windows 連線至 Linux GUI</h3><p>要從 Windows 連線到 Linux GUI，可使用 <a href="http://ntu.csie.org/~piaip/pietty/" target="_blank" rel="noopener">pietty</a> + <a href="http://sourceforge.net/projects/xming/" target="_blank" rel="noopener">Xming</a></p>
<p>使用說明可參考 =&gt; <a href="http://blog.jangmt.com/2009/11/xming.html" target="_blank" rel="noopener">八克里: 使用 xming 從windows 系統登入 Linux 系統</a></p>
<h3 id="Auto-Login"><a href="#Auto-Login" class="headerlink" title="Auto Login"></a>Auto Login</h3><p>要在 RHEL 7 作到 Auto Login，要修改 <code>/etc/gdm/custom.conf</code>，並調整 <font color="blue"><strong>daemon</strong></font> section 中的 <strong><font color="red">AutomaticLoginEnable</font></strong> &amp; <strong><font color="red">AutomaticLogin</font></strong> 兩個參數</p>
<h2 id="1-3-Executing-Commands-Using-the-Bash-Shell"><a href="#1-3-Executing-Commands-Using-the-Bash-Shell" class="headerlink" title="1.3 Executing Commands Using the Bash Shell"></a>1.3 Executing Commands Using the Bash Shell</h2><h3 id="Examples-of-simple-commands"><a href="#Examples-of-simple-commands" class="headerlink" title="Examples of simple commands"></a>Examples of simple commands</h3><p><strong><font color="red">file</font></strong> 可用來檢查檔案的型態 &amp; 格式 (也可以用 <strong><a href="http://www.computerhope.com/unix/stat.htm" target="_blank" rel="noopener">stat</a></strong>)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ file /etc/passwd</span><br><span class="line">/etc/passwd: ASCII text</span><br><span class="line"></span><br><span class="line">$ file /bin/passwd</span><br><span class="line">/bin/passwd: setuid ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), <span class="keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=0x91a7160a019b7f5f754264d920e257522c5bce67, stripped</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">stat</span> /etc/passwd</span><br><span class="line">  File: ‘/etc/passwd’</span><br><span class="line">  Size: 961             Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: fd01h/64769d    Inode: 1573453     Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Context: system_u:object_r:passwd_file_t:s0</span><br><span class="line">Access: 2016-01-20 07:38:22.557000000 -0500</span><br><span class="line">Modify: 2015-10-02 10:38:00.710867846 -0400</span><br><span class="line">Change: 2015-10-02 10:38:00.710867846 -0400</span><br><span class="line"> Birth: -</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">stat</span> /bin/passwd</span><br><span class="line">  File: ‘/bin/passwd’</span><br><span class="line">  Size: 27832           Blocks: 56         IO Block: 4096   regular file</span><br><span class="line">Device: fd01h/64769d    Inode: 2234382     Links: 1</span><br><span class="line">Access: (4755/-rwsr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Context: system_u:object_r:passwd_exec_t:s0</span><br><span class="line">Access: 2014-06-10 02:27:56.000000000 -0400</span><br><span class="line">Modify: 2014-06-10 02:27:56.000000000 -0400</span><br><span class="line">Change: 2015-10-02 10:30:36.743867846 -0400</span><br><span class="line"> Birth: -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 甚至可以直接針對目錄來檢查</span></span><br><span class="line">$ file /home</span><br><span class="line">/home: directory</span><br></pre></td></tr></table></figure>
<h3 id="Editing-the-command-Line"><a href="#Editing-the-command-Line" class="headerlink" title="Editing the command Line"></a>Editing the command Line</h3><p>使用 command line 的實用快速鍵：</p>
<table>
<thead>
<tr>
<th>快速鍵</th>
<th>說明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Ctrl + a</code></td>
<td>游標跳至最前</td>
</tr>
<tr>
<td><code>Ctrl + e</code></td>
<td>游標跳至最後</td>
</tr>
<tr>
<td><code>Ctrl + u</code></td>
<td>清除整個命令中，從游標到最前面的內容</td>
</tr>
<tr>
<td><code>Ctrl + k</code></td>
<td>清除整個命令中，從游標到最後面的內容</td>
</tr>
<tr>
<td>`ESC + .</td>
<td>複製上一個命令中的最後一個參數到目前的命令中</td>
</tr>
<tr>
<td>`Alt + .</td>
<td>同上</td>
</tr>
<tr>
<td><code>Ctrl + r</code></td>
<td>可用 keyword 來尋找最近使用過的命令</td>
</tr>
<tr>
<td><code>Ctrl + l(小寫 L)</code></td>
<td>清除螢幕內容(效果等同 <code>clear</code>)</td>
</tr>
</tbody>
</table>
<hr>
<p><a name="ch2"></a></p>
<h1 id="Chapter-2-MANAGING-FILES-FROM-THE-COMMAND-LINE"><a href="#Chapter-2-MANAGING-FILES-FROM-THE-COMMAND-LINE" class="headerlink" title="Chapter 2. MANAGING FILES FROM THE COMMAND LINE"></a>Chapter 2. MANAGING FILES FROM THE COMMAND LINE</h1><h2 id="2-1-The-file-system-hierarchy"><a href="#2-1-The-file-system-hierarchy" class="headerlink" title="2.1 The file system hierarchy"></a>2.1 The file system hierarchy</h2><p>RHEL 中的重要目錄：</p>
<table>
<thead>
<tr>
<th>路徑</th>
<th>目的</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/usr</code><br>(Unix Software Resource)</td>
<td>安裝的軟體、shared library … 等資料都會放在此處，其中幾個重要目錄：<br><code>/usr/bin</code>：使用者用指令<br><code>/usr/sbin</code>：系統管理者用指令<br><code>/usr/local</code>：使用者自行安裝的軟體</td>
</tr>
<tr>
<td><code>/etc</code></td>
<td>設定檔存放路徑</td>
</tr>
<tr>
<td><code>/var</code></td>
<td>持續不斷變動的資料，例如 log、print spool、資料庫檔案 … 等等</td>
</tr>
<tr>
<td><code>/run</code></td>
<td>從上次開機以來的 runtime 資訊(<strong><font color="red">此目錄的資料在每次重開機都會清空</font></strong>)</td>
</tr>
<tr>
<td><code>/tmp</code></td>
<td>所有人都有權限存取的站存資料目錄(<strong><font color="red">此目錄中日期大於 10 天的資料會被自動清除</font></strong>)，若是在目錄 <code>/var/tmp</code> 中的資料，則是超過 30 天的資料會被清除</td>
</tr>
<tr>
<td><code>/boot</code></td>
<td>系統開機所需要的檔案</td>
</tr>
<tr>
<td><code>/dev</code></td>
<td>存放系統用來存取硬體裝置所需要的檔案</td>
</tr>
</tbody>
</table>
<blockquote>
<p>原本在 <code>/</code> 下的某些目錄，在 RHEL 7 後都被移到 <code>/usr</code> 下了，包含 <code>/bin</code>(=&gt; <code>/usr/bin</code>)、<code>/sbin</code>(=&gt; <code>/usr/sbin</code>)、<code>/lib</code>(=&gt; <code>/usr/lib</code>)、<code>/lib64</code>(=&gt; <code>/usr/lib64</code>)<br>但原本在 <code>/</code> 的以上四個目錄都還存在，只是改成用 symbolic link 的方式連到 <code>/usr</code> 中的子目錄</p>
</blockquote>
<p>詳細資料可查詢 <font color="blue"><strong>hier(7)</strong></font> man page</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ man 7 hier</span><br></pre></td></tr></table></figure>
<h2 id="2-2-Locating-Files-by-name"><a href="#2-2-Locating-Files-by-name" class="headerlink" title="2.2 Locating Files by name"></a>2.2 Locating Files by name</h2><p>檔名限制 &amp; 特性：</p>
<ol>
<li><p>完整檔案路徑長度不能超過 4095 bytes (含 <code>/</code>)</p>
</li>
<li><p>兩個 <code>/</code> 之間的長度不能超過 255 bytes</p>
</li>
<li><p>檔名可以是任意的 UTF-8 字元，但不能是 <code>/</code> &amp; <code>NUL</code></p>
</li>
<li><p>Case-Sensative</p>
</li>
</ol>
<h3 id="Navigating-paths"><a href="#Navigating-paths" class="headerlink" title="Navigating paths"></a>Navigating paths</h3><ul>
<li><strong>touch</strong><blockquote>
<p>touch 會更新檔案的 timestamp 到目前的時間，而不會改變檔案內容<br>若是不存在的檔案，則會建立一個空白檔案</p>
</blockquote>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server ~]$ touch /tmp/<span class="built_in">test</span>&#123;1,2&#125;.txt</span><br><span class="line">[vagrant@server ~]$ ls -l /tmp/</span><br><span class="line">total 0</span><br><span class="line">-rw-rw-r--. 1 vagrant vagrant 0 Jan 30 00:23 test1.txt</span><br><span class="line">-rw-rw-r--. 1 vagrant vagrant 0 Jan 30 00:23 test2.txt</span><br></pre></td></tr></table></figure>
<h2 id="2-3-Managing-Files-Using-command-Line-Tools"><a href="#2-3-Managing-Files-Using-command-Line-Tools" class="headerlink" title="2.3 Managing Files Using command-Line Tools"></a>2.3 Managing Files Using command-Line Tools</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保留複製檔案的屬性</span></span><br><span class="line">$ cp -a</span><br></pre></td></tr></table></figure>
<h2 id="2-4-Matching-File-Names-Using-Path-Name-Expansion"><a href="#2-4-Matching-File-Names-Using-Path-Name-Expansion" class="headerlink" title="2.4 Matching File Names Using Path Name Expansion"></a>2.4 Matching File Names Using Path Name Expansion</h2><h3 id="File-globbing-path-name-Expansion"><a href="#File-globbing-path-name-Expansion" class="headerlink" title="File globbing: path name Expansion"></a>File globbing: path name Expansion</h3><table>
<thead>
<tr>
<th>Pattern</th>
<th>Matches</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>~+</code></td>
<td>目前工作目錄</td>
</tr>
<tr>
<td><code>~-</code></td>
<td>上一個工作目錄</td>
</tr>
<tr>
<td><code>[abc...]</code></td>
<td>任何在中括號中的字母都符合</td>
</tr>
<tr>
<td><code>[!abc...]</code></td>
<td>不包含中括號中的任何一個字母</td>
</tr>
<tr>
<td><code>[^abc...]</code></td>
<td>同上</td>
</tr>
<tr>
<td><code>[[:punct:]]</code></td>
<td>任何可印出來的字元(但不包含空白 or 英文字母)</td>
</tr>
</tbody>
</table>
<h4 id="Brace-Expansion"><a href="#Brace-Expansion" class="headerlink" title="Brace Expansion"></a>Brace Expansion</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server ~]$ <span class="built_in">echo</span> &#123;Sunday,Month,Tuesday&#125;.lo</span><br><span class="line">Sunday.log Month.log Tuesday.log</span><br><span class="line"></span><br><span class="line">[vagrant@server ~]$ <span class="built_in">echo</span> file&#123;a..c&#125;.txt</span><br><span class="line">filea.txt fileb.txt filec.txt</span><br><span class="line"></span><br><span class="line">[vagrant@server ~]$ <span class="built_in">echo</span> file&#123;a,b&#125;&#123;1,2&#125;.txt</span><br><span class="line">filea1.txt filea2.txt fileb1.txt fileb2.txt</span><br><span class="line"></span><br><span class="line">[vagrant@server ~]$ <span class="built_in">echo</span> file&#123;a&#123;1,2&#125;,b,c&#125;.txt</span><br><span class="line">filea1.txt filea2.txt fileb.txt filec.txt</span><br></pre></td></tr></table></figure>
<h4 id="Command-Substitution"><a href="#Command-Substitution" class="headerlink" title="Command Substitution"></a>Command Substitution</h4><ul>
<li><p>單引號中的變數 $ 無效</p>
</li>
<li><p>雙引號中的變數 $ 有效</p>
</li>
<li><p>較推薦加大括號確定變數名稱的方式，比較不容易跟單引號混淆</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server ~]$ <span class="built_in">echo</span> Today is `date +%A`</span><br><span class="line">Today is Saturday</span><br><span class="line"></span><br><span class="line">[vagrant@server ~]$ <span class="built_in">echo</span> The time is $(date +%M) minutes past $(date +%l%p)</span><br><span class="line">The time is 33 minutes past 8AM</span><br></pre></td></tr></table></figure>
<h2 id="2-5-Lab-Managing-Files-with-Shell-Expansion"><a href="#2-5-Lab-Managing-Files-with-Shell-Expansion" class="headerlink" title="2.5 Lab: Managing Files with Shell Expansion"></a>2.5 Lab: Managing Files with Shell Expansion</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server lab]$ touch tv_season&#123;1,2&#125;_episode&#123;1..6&#125;.ogg</span><br><span class="line">[vagrant@server lab]$ ls</span><br><span class="line">tv_season1_episode1.ogg  tv_season1_episode3.ogg  tv_season1_episode5.ogg  tv_season2_episode1.ogg  tv_season2_episode3.ogg  tv_season2_episode5.ogg</span><br><span class="line">tv_season1_episode2.ogg  tv_season1_episode4.ogg  tv_season1_episode6.ogg  tv_season2_episode2.ogg  tv_season2_episode4.ogg  tv_season2_episode6.ogg</span><br><span class="line"></span><br><span class="line">[vagrant@server lab]$ touch mystery_chapter&#123;1..8&#125;.odf</span><br><span class="line">[vagrant@server lab]$ ls</span><br><span class="line">mystery_chapter1.odf  mystery_chapter4.odf  mystery_chapter7.odf     tv_season1_episode2.ogg  tv_season1_episode5.ogg  tv_season2_episode2.ogg  tv_season2_episode5.ogg</span><br><span class="line">mystery_chapter2.odf  mystery_chapter5.odf  mystery_chapter8.odf     tv_season1_episode3.ogg  tv_season1_episode6.ogg  tv_season2_episode3.ogg  tv_season2_episode6.ogg</span><br><span class="line">mystery_chapter3.odf  mystery_chapter6.odf  tv_season1_episode1.ogg  tv_season1_episode4.ogg  tv_season2_episode1.ogg  tv_season2_episode4.ogg</span><br><span class="line"></span><br><span class="line">[vagrant@server lab]$ mkdir -p Videos/season&#123;1,2&#125;</span><br><span class="line">[vagrant@server lab]$ ls Videos/</span><br><span class="line">season1  season2</span><br><span class="line"></span><br><span class="line">[vagrant@server lab]$ mv tv_season1* Videos/season1/</span><br><span class="line">[vagrant@server lab]$ mv tv_season2* Videos/season2/</span><br><span class="line">[vagrant@server lab]$ ls -R Videos/</span><br><span class="line">Videos/:</span><br><span class="line">season1  season2</span><br><span class="line"></span><br><span class="line">Videos/season1:</span><br><span class="line">tv_season1_episode1.ogg  tv_season1_episode2.ogg  tv_season1_episode3.ogg  tv_season1_episode4.ogg  tv_season1_episode5.ogg  tv_season1_episode6.ogg</span><br><span class="line"></span><br><span class="line">Videos/season2:</span><br><span class="line">tv_season2_episode1.ogg  tv_season2_episode2.ogg  tv_season2_episode3.ogg  tv_season2_episode4.ogg  tv_season2_episode5.ogg  tv_season2_episode6.ogg</span><br><span class="line"></span><br><span class="line">[vagrant@server lab]$ mkdir -p ./my_bestseller ./chapters</span><br><span class="line"></span><br><span class="line">[vagrant@server lab]$ mkdir ./my_bestseller/&#123;editor,plot_change,vacation&#125;</span><br><span class="line">[vagrant@server lab]$ ls ./my_bestseller/</span><br><span class="line">editor  plot_change  vacation</span><br><span class="line"></span><br><span class="line">[vagrant@server lab]$ <span class="built_in">cd</span> chapters/</span><br><span class="line">[vagrant@server chapters]$ mv ../*chapter*.odf ./</span><br><span class="line"></span><br><span class="line">[vagrant@server chapters]$ mv mystery_chapter&#123;1,2&#125;.odf ../my_bestseller/editor/</span><br><span class="line"></span><br><span class="line">[vagrant@server chapters]$ mv mystery_chapter&#123;7,8&#125;.odf ../my_bestseller/vacation/</span><br><span class="line"></span><br><span class="line">[vagrant@server chapters]$ <span class="built_in">cd</span> ../Videos/season2/</span><br><span class="line">[vagrant@server season2]$ cp tv_season2_episode1.ogg ../../my_bestseller/vacation/</span><br><span class="line"></span><br><span class="line">[vagrant@server season2]$ <span class="built_in">cd</span> /tmp/lab/my_bestseller/vacation/</span><br><span class="line">[vagrant@server vacation]$ ls</span><br><span class="line">mystery_chapter7.odf  mystery_chapter8.odf  tv_season2_episode1.ogg</span><br><span class="line">[vagrant@server vacation]$ <span class="built_in">cd</span> ~-</span><br><span class="line">[vagrant@server season2]$ cp tv_season2_episode2.ogg ~-</span><br><span class="line">[vagrant@server season2]$ <span class="built_in">cd</span> ~-</span><br><span class="line">[vagrant@server vacation]$ ls</span><br><span class="line">mystery_chapter7.odf  mystery_chapter8.odf  tv_season2_episode1.ogg  tv_season2_episode2.ogg</span><br><span class="line"></span><br><span class="line">[vagrant@server vacation]$ cp /tmp/lab/chapters/mystery_chapter5.odf /tmp/lab/my_bestseller/plot_change/mystery_chapter5_$(date +%F).odf</span><br><span class="line">[vagrant@server vacation]$ cp /tmp/lab/chapters/mystery_chapter5.odf /tmp/lab/my_bestseller/plot_change/mystery_chapter5_$(date +%s).odf</span><br><span class="line">[vagrant@server vacation]$ cp /tmp/lab/chapters/mystery_chapter5.odf /tmp/lab/my_bestseller/plot_change/mystery_chapter5_<span class="variable">$USER</span>.odf</span><br><span class="line">[vagrant@server vacation]$ ls /tmp/lab/my_bestseller/plot_change/</span><br><span class="line">mystery_chapter5_1455368579.odf  mystery_chapter5_2016-02-13.odf  mystery_chapter5_vagrant.odf</span><br></pre></td></tr></table></figure>
<hr>
<p><a name="ch3"></a></p>
<h1 id="Chapter-3-GETTING-HELP-IN-RED-HAT-ENTERPRISE-LINUX"><a href="#Chapter-3-GETTING-HELP-IN-RED-HAT-ENTERPRISE-LINUX" class="headerlink" title="Chapter 3. GETTING HELP IN RED HAT ENTERPRISE LINUX"></a>Chapter 3. GETTING HELP IN RED HAT ENTERPRISE LINUX</h1><h2 id="3-1-Reading-Documentation-Using-man-Command"><a href="#3-1-Reading-Documentation-Using-man-Command" class="headerlink" title="3.1 Reading Documentation Using man Command"></a>3.1 Reading Documentation Using man Command</h2><h3 id="3-1-1-Introducing-the-man-command"><a href="#3-1-1-Introducing-the-man-command" class="headerlink" title="3.1.1 Introducing the man command"></a>3.1.1 Introducing the man command</h3><p>Linux manual 包含多個 section：</p>
<table>
<thead>
<tr>
<th>Section</th>
<th>Content Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><font color="red">1</font></strong></td>
<td>一般使用者命令(包含可執行程式 &amp; shell script)</td>
</tr>
<tr>
<td><code>2</code></td>
<td>System calls(kernal routines invoked from user space)</td>
</tr>
<tr>
<td><code>3</code></td>
<td>Library functions (程式函式庫提供)</td>
</tr>
<tr>
<td><code>4</code></td>
<td>特殊檔案(例如：設備檔 /dev 目錄中的檔案)</td>
</tr>
<tr>
<td><strong><font color="red">5</font></strong></td>
<td><font color="blue">檔案格式(設定檔 &amp; 內容結構說明)</font></td>
</tr>
<tr>
<td><code>6</code></td>
<td>Games</td>
</tr>
<tr>
<td><strong><font color="red">7</font></strong></td>
<td>慣例、標準、其他…等等(協定、檔案系統)</td>
</tr>
<tr>
<td><strong><font color="red">8</font></strong></td>
<td><font color="blue">系統管理員以及特殊指令(用於維護工作)</font></td>
</tr>
<tr>
<td><code>9</code></td>
<td>Linux kernal API (internal kernel calls)</td>
</tr>
</tbody>
</table>
<p><code>man 1 passwd</code> or <code>man passwd</code>(未指定 section 則預設帶 1) 可以知道使用指令的方式 &amp; 相關參數</p>
<p><code>man 5 passwd</code> 則是說明 <strong>/etc/passwd</strong> 的檔案結構，組成內容….等資訊</p>
<blockquote>
<p>以上資訊要安裝 <strong><font color="red">man-pages</font></strong> 套件才會有</p>
</blockquote>
<h3 id="3-1-3-Searching-for-man-pages-by-keywords"><a href="#3-1-3-Searching-for-man-pages-by-keywords" class="headerlink" title="3.1.3 Searching for man pages by keywords"></a>3.1.3 Searching for man pages by keywords</h3><p>小寫 k 僅針對 title &amp; description 搜尋關鍵字：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server ~]$ man -k passwd</span><br><span class="line">grub2-mkpasswd-pbkdf2 (1) - Generate a PBKDF2 password <span class="built_in">hash</span>.</span><br><span class="line">sslpasswd (1ssl)     - compute password hashes</span><br></pre></td></tr></table></figure>
<blockquote>
<p>大寫 K 會進行全文搜尋…..內容很多…</p>
</blockquote>
<p>透過 <code>mandb</code> 指令可以立即強制 man page 資料庫更新，但系統其實已經將更新資料庫的工作放在 <strong>/etc/cron.daily/man-db.cron</strong> 中。</p>
<h2 id="3-2-Reading-Documentation-Using-pinfo-Command"><a href="#3-2-Reading-Documentation-Using-pinfo-Command" class="headerlink" title="3.2 Reading Documentation Using pinfo Command"></a>3.2 Reading Documentation Using pinfo Command</h2><p>info 文件是以類似超連結網頁的方式進行編排，透過 pinfo 指令來啟動 <strong>lynx</strong> 文字網頁瀏覽器來瀏覽。</p>
<p><code>--</code> 在指令中代表 command option 的結束，表示後面接的是 command argument，例如：<code>touch -- -r</code> 會產生名稱為 <strong>-r</strong> 的檔案。</p>
]]></content>
      
        <categories>
            
            <category> RHCE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH124 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[VMware] 免費的 vSphere ESXi VM 備份方案 - XSIBACKUP]]></title>
      <url>/blog/2014/11/14/VMware/free-vsphere-esxi-vm-backup-solution-xsibackup/</url>
      <content type="html"><![CDATA[<p>最近公司在找給 VMware vSphere ESXi 用的 shared storage，想當然爾也會考慮到備份的問題</p>
<p>後來學長提供了 <a href="http://sourceforge.net/projects/xsibackup/" target="_blank" rel="noopener">xsibackup</a> 這個 opensource 的免費軟體，雖然是免費，可是備份功能也不差呢。</p>
<h2 id="環境設定"><a href="#環境設定" class="headerlink" title="環境設定"></a>環境設定</h2><ul>
<li>vSphere ESXi <strong>5.5 Update 2</strong></li>
<li>esxibackup <strong>4.1.6</strong></li>
</ul>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>1、 首先必須先開啟 ESXi Host 的 SSH servive，並透過 ssh client 登入到 esxi 中</p>
<p>2、 下載 xsibackup 程式並解壓縮，將 xsibackup 程式設定為可執行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要將檔案放到 ESXi 重開機後不會回復初始設定的路徑(可以是任何 DataStore 的目錄下，只要是 persistent folder 即可)</span></span><br><span class="line"><span class="comment"># 切換到 datastore1 folder，避免 ESXi 重開機之後將檔案刪除</span></span><br><span class="line">$ <span class="built_in">cd</span> /vmfs/volumes/datastore1</span><br><span class="line">$ wget http://sourceforge.net/projects/xsibackup/files/xsibackup_4.1.6.zip/download -O xsibackup.zip</span><br><span class="line">$ unzip xsibackup.zip</span><br><span class="line">$ chmod 0700 xsibackup*</span><br></pre></td></tr></table></figure>
<p>3、執行備份工作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 備份檔存放路徑：/vmfs/volumes/backup</span></span><br><span class="line"><span class="comment"># 備份類型：目前運行中的 VM (running)</span></span><br><span class="line"><span class="comment"># mail &amp; smpt 的相關設定都是與寄信相關</span></span><br><span class="line">$ ./xsibackup --backup-point=/vmfs/volumes/backup --backup-type=running </span><br><span class="line">--mail-from=email.sender@yourdomain.com --mail-to=email.recipient@anotherdomain.com </span><br><span class="line">--smtp-srv=smtp.yourdomain.com --smtp-port=25 --smtp-usr=username </span><br><span class="line">--smtp-pwd=password</span><br></pre></td></tr></table></figure>
<p><code>/vmfs/volumes/backup 目錄也可以是 remote host 所提供的 NFS share folder</code></p>
<p>其中 <code>--backup-type</code> 有以下三種：</p>
<ul>
<li><strong>all</strong> (所有 vm)</li>
<li><strong>running</strong> (執行中的 vm)</li>
<li><strong>custom</strong> (指定 vm，需搭配 –backup-vms 參數指令要備份的 vm，多個 vm 可用逗號隔開)</li>
</ul>
<p>custom 應用如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定備份 WINDOWSVM1 &amp; LINUXVM2 兩台 vm</span></span><br><span class="line">$ ./xsibackup --backup-point=/vmfs/volumes/backup --backup-type=custom --backup-vms=WINDOWSVM1,LINUXVM2</span><br></pre></td></tr></table></figure>
<h2 id="其他參數"><a href="#其他參數" class="headerlink" title="其他參數"></a>其他參數</h2><ul>
<li><code>--test-mode=true</code> (測試模式，不實際進行備份；但若有設定 EMail 相關參數則會發信)</li>
<li><code>--backup-how (hot | cold)</code> (hot 會在 vm 開機情況下備份，cold 則會將 vm 關機後再備份)`</li>
</ul>
<h2 id="寄送-Mail-的問題"><a href="#寄送-Mail-的問題" class="headerlink" title="寄送 Mail 的問題"></a>寄送 Mail 的問題</h2><p>設定了 EMail 發送相關參數後，實際執行會發現竟然不行，排除方法如下：</p>
<p>xsibackup 程式會在 <strong>/etc/vmware/firewall/service.xml</strong> 這個檔案補上這一段內容：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">id</span>=<span class="string">'9999'</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span>&gt;</span>SMTPout<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">rule</span> <span class="attr">id</span>=<span class="string">'0000'</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">direction</span>&gt;</span>outbound<span class="tag">&lt;/<span class="name">direction</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">protocol</span>&gt;</span>tcp<span class="tag">&lt;/<span class="name">protocol</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">porttype</span>&gt;</span>dst<span class="tag">&lt;/<span class="name">porttype</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">port</span>&gt;</span><span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">required</span>&gt;</span>false<span class="tag">&lt;/<span class="name">required</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但其實這是錯誤的，要把 <code>&lt;port&gt;&lt;/port&gt;</code>這個部分改成 <code>&lt;port&gt;25&lt;/port&gt;</code>，並執行以下指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ esxcli network firewall refresh</span><br></pre></td></tr></table></figure>
<p>如此一來 EMail 的功能就會正常啟動了!</p>
<h2 id="排程備份"><a href="#排程備份" class="headerlink" title="排程備份"></a>排程備份</h2><p>xsibackup 也支援排程喔! 設定方式如下：</p>
<ol>
<li>在 ESXi 主機上執行 <code>xsibackup --install-cron</code> 指令，此時會在 <strong>/vmfs/volumes/datastore1</strong> 目錄中產生 <code>xsibackup-cron</code>這個檔案，可以直接進入編輯：(若是星期一、五晚上 20:00 要備份)</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加入 --time 參數，格式為 --time="Day HH:mm"(注意這邊要用 UTC 時間)</span></span><br><span class="line"><span class="comment"># 星期一 20:00 備份</span></span><br><span class="line">/vmfs/volumes/datastore1/xsibackup --time=<span class="string">"Mon 12:00"</span> --backup-point=/vmfs/volumes/backup --backup-type=running --mail-from=email.sender@yourdomain.com --mail-to=email.recipient@anotherdomain.com --smtp-srv=smtp.yourdomain.com --smtp-port=25 --smtp-usr=username --smtp-pwd=password</span><br><span class="line"><span class="comment"># 星期五 20:00 備份</span></span><br><span class="line">/vmfs/volumes/datastore1/xsibackup --time=<span class="string">"Fri 12:00"</span> --backup-point=/vmfs/volumes/backup --backup-type=running --mail-from=email.sender@yourdomain.com --mail-to=email.recipient@anotherdomain.com --smtp-srv=smtp.yourdomain.com --smtp-port=25 --smtp-usr=username --smtp-pwd=password</span><br></pre></td></tr></table></figure>
<ol>
<li>重新啟動 ESXi Host 讓 cron 的功能啟用</li>
</ol>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>因此總結一下，優缺點大致如下：</p>
<h3 id="優點"><a href="#優點" class="headerlink" title="優點"></a>優點</h3><ol>
<li><p>免費、開放</p>
</li>
<li><p>可進行完整備份，非特殊格式，不需要透過其他軟體還原</p>
</li>
<li><p>在單純的環境下使用簡單</p>
</li>
</ol>
<h3 id="缺點"><a href="#缺點" class="headerlink" title="缺點"></a>缺點</h3><ol>
<li><p>無法執行差異備份，自然也就沒有 dedupication 的功能。</p>
</li>
<li><p>目前沒有 exclude 的參數，若是有不想備份的 VM(例如：VDP)，只能透過 custom or running(搭配將 vm 關機)的方式來完成 (也可以透過改 source code 的方式來做….)</p>
</li>
<li><p>若是 vSphere 授權版本有 DRS(Dynamic Resource Scheduler) 的話，VM 可能會隨著資源耗損不同而跑來跑去，備份工作就很難透過 custom 方式來達成。</p>
</li>
</ol>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><p><a href="http://sourceforge.net/projects/xsibackup/" target="_blank" rel="noopener">Free Backup Software for VMware ESXi VMs | SourceForge.net</a></p>
</li>
<li><p><a href="http://blog.depicus.com/add-outbound-port-25-for-smtp-in-vmware-esxi-v5/" target="_blank" rel="noopener">Add outbound port 25 for SMTP in VMware ESXi v5 – depicus</a></p>
</li>
<li><p><a href="http://kb.vmware.com/selfservice/microsites/search.do?language=en_US&amp;cmd=displayKC&amp;externalId=2008226" target="_blank" rel="noopener">VMware KB: Creating custom firewall rules in VMware ESXi 5.x</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> VMware </category>
            
        </categories>
        
        
        <tags>
            
            <tag> VMware </tag>
            
            <tag> Backup </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
