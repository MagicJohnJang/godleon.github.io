<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[[OpenShift] 如何計算在 Jenkins pipeline 中工作所花費的時間]]></title>
      <url>/blog/2017/11/29/OpenShift/OpenShift-Howto-Calculate-Time-Duration-in-Jenkins/</url>
      <content type="html"><![CDATA[<p>最近的工作都是使用 OpenShift + Jenkins 在進行 CI/CD 的相關工作，在時間的顯示上遇到了兩個問題：</p>
<ol>
<li><p>Jenkins 系統上使用的是 UTC 時間，希望改成 Taiwan 時間(+8:00)</p>
</li>
<li><p>想要知道整個 pipeline 的工作完成後一共花了多少時間</p>
</li>
</ol>
<p>上網找了很多資料，拼拼湊湊寫出了以下的 groovy script 來完成這件事情：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat</span><br><span class="line"><span class="keyword">import</span> java.util.Calendar</span><br><span class="line"><span class="keyword">import</span> groovy.time.*</span><br><span class="line"></span><br><span class="line"><span class="comment">// human-readable format</span></span><br><span class="line"><span class="keyword">def</span> dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// convert time from UTC to Taiwan Time(+8:00)</span></span><br><span class="line"><span class="keyword">def</span> startTime = <span class="keyword">new</span> Date((Calendar.getInstance()).getTimeInMillis() + (<span class="number">480</span> * <span class="number">60000</span>))</span><br><span class="line"><span class="keyword">def</span> strStartTime = dateFormat.format(startTime)</span><br><span class="line"></span><br><span class="line">sleep <span class="number">5</span></span><br><span class="line"></span><br><span class="line">openshift.withCluster() &#123;</span><br><span class="line">    stage(<span class="string">'Calculate Time Duration'</span>) &#123;</span><br><span class="line">        node &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">def</span> endTime = <span class="keyword">new</span> Date((Calendar.getInstance()).getTimeInMillis() + (<span class="number">480</span> * <span class="number">60000</span>))</span><br><span class="line">            strEndTime = dateFormat.format(endTime)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// calculate time duration</span></span><br><span class="line">            TimeDuration duration = TimeCategory.minus(endTime, startTime)</span><br><span class="line">            <span class="keyword">def</span> strDuration = String.format(<span class="string">"%02d"</span>, duration.getHours()) + <span class="string">":"</span> + String.format(<span class="string">"%02d"</span>, duration.getMinutes()) + <span class="string">":"</span> + String.format(<span class="string">"%02d"</span>, duration.getSeconds())</span><br><span class="line">            <span class="comment">// it's necessary to set it to null for avoiding "not serializable exception"</span></span><br><span class="line">            duration = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">            echo <span class="string">"Start Time = $&#123;strStartTime&#125;"</span></span><br><span class="line">            echo <span class="string">"End Time = $&#123;strEndTime&#125;"</span></span><br><span class="line">            echo <span class="string">"Time Duration = $&#123;strDuration&#125;"</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="comment">// ---------- End of stage('Configure IAAS')</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>透過以下步驟，可以直接使用我放在 GitHub 上面的範例，直接建立一個 build job 來測試：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/godleon/openshift-jenkins-customization.git</span><br><span class="line"></span><br><span class="line">$ oc create -f openshift-objects/</span><br><span class="line"></span><br><span class="line">$ oc start-build calculate-time-duration</span><br></pre></td></tr></table></figure>
<p>接著到 Jenkins 系統內部就可以看到執行結果囉!</p>
<hr>
<h1 id="關於-Script-Approval-的處理"><a href="#關於-Script-Approval-的處理" class="headerlink" title="關於 Script Approval 的處理"></a>關於 Script Approval 的處理</h1><p>預設 Jenkins pipeline 會在 sandbox 的環境中執行，因此很多 grovvy or java method 都會無法使用，因此在 OpenShift 中需要對 Jenkins 進行客製化，預先設定 script whitelist，讓某些 method 可以在 pipeline 中使用，如何客製化 Jenkins 詳情可以參考之前寫過的文章。</p>
]]></content>
      
        <categories>
            
            <category> OpenShift </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OpenShift </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[OpenShift] 如何客製化 Jenkins Image]]></title>
      <url>/blog/2017/11/07/OpenShift/OpenShift-Howto-Customize-builtin-Jenkins-Image/</url>
      <content type="html"><![CDATA[<p>本文章的主題在於如何將客製化 OpenShift 原生提供的 Jenkins image</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Openshift 在 DevOps 的方面的確是下了不少功夫，使用 OpenShift 的確可以讓 DevOps engineer 省下不少工，但相對的也有蠻多新東西要學的! XD</p>
<p>在 OpenShift 建立第一個 BuildConfig(pipeline) 時，它會自動幫使用者佈署一個用來驅動 build pipeline 的 Jenkins server(此 container 會由 OpenShift 本身納管，因此掛了會自己再起一個新的)，佈署的行為如下：</p>
<ol>
<li><p>使用 <code>openshift</code> namespace 中的 template <code>jenkins-ephemeral</code> 為範本產生 Jenkins server</p>
</li>
<li><p>此 tempate 使用的 image stream 為 <code>jenkins:latest</code></p>
</li>
<li><p>Image Stream <code>jenkins:latest</code> 則是指到 Red Hat 官方所提供的 Jenkins image(<strong>registry.access.redhat.com/openshift3/jenkins-2-rhel7</strong>)</p>
</li>
</ol>
<p>當 Jenkins server 佈署好之後，就會自動的與 OpenShift 本身的認証機制進行整合，完全不用使用者進行額外的設定，相關的 credential 也都會設定在 Jenkins server 內部，使用者需要做的就是開始設計 pipeline 就對了!</p>
<hr>
<h1 id="Jenkins-image-for-OpenShift"><a href="#Jenkins-image-for-OpenShift" class="headerlink" title="Jenkins image for OpenShift"></a>Jenkins image for OpenShift</h1><p>由於 Jenkins 並不是一個很容易入門上手的系統，因此為了提供使用者能更方便的使用 Jenkins，OpenShift 將 Jenkins 系統打包成 docker image，並加入了許多常用的 plugin 以及與 OpenShift 整合所需要的 plugin，還很貼心的做好相關整合的設定，讓使用者在建立 pipeline 時就會同時產生相對應的 Jenkins server 來使用，省略許多繁複且容易造成錯誤的設定過程。</p>
<p>目前使用者可能比較容易用到的 Jenkins image for OpenShift 可能會有以下兩種：</p>
<ul>
<li>Red Hat 版本：<code>registry.access.redhat.com/openshift3/jenkins-2-rhel7</code><br>本文章的主題在於如何將客製化 OpenShift 原生提供的 Jenkins image</li>
</ul>
<h1 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h1><p>Openshift 在 DevOps 的方面的確是下了不少功夫，使用 OpenShift 的確可以讓 DevOps engineer 省下不少工，但相對的也有蠻多新東西要學的! XD</p>
<p>在 OpenShift 建立第一個 BuildConfig(pipeline) 時，它會自動幫使用者佈署一個用來驅動 build pipeline 的 Jenkins server(此 container 會由 OpenShift 本身納管，因此掛了會自己再起一個新的)，佈署的行為如下：</p>
<ol>
<li><p>使用 <code>openshift</code> namespace 中的 template <code>jenkins-ephemeral</code> 為範本產生 Jenkins server</p>
</li>
<li><p>此 tempate 使用的 image stream 為 <code>jenkins:latest</code></p>
</li>
<li><p>Image Stream <code>jenkins:latest</code> 則是指到 Red Hat 官方所提供的 Jenkins image(<strong>registry.access.redhat.com/openshift3/jenkins-2-rhel7</strong>)</p>
</li>
</ol>
<p>當 Jenkins server 佈署好之後，就會自動的與 OpenShift 本身的認証機制進行整合，完全不用使用者進行額外的設定，相關的 credential 也都會設定在 Jenkins server 內部，使用者需要做的就是開始設計 pipeline 就對了!</p>
<hr>
<h1 id="Jenkins-image-for-OpenShift-1"><a href="#Jenkins-image-for-OpenShift-1" class="headerlink" title="Jenkins image for OpenShift"></a>Jenkins image for OpenShift</h1><p>由於 Jenkins 並不是一個很容易入門上手的系統，因此為了提供使用者能更方便的使用 Jenkins，OpenShift 將 Jenkins 系統打包成 docker image，並加入了許多常用的 plugin 以及與 OpenShift 整合所需要的 plugin，還很貼心的做好相關整合的設定，讓使用者在建立 pipeline 時就會同時產生相對應的 Jenkins server 來使用，省略許多繁複且容易造成錯誤的設定過程。</p>
<p>目前使用者可能比較容易用到的 Jenkins image for OpenShift 可能會有以下兩種：</p>
<ul>
<li><p>Red Hat 版本：<code>registry.access.redhat.com/openshift3/jenkins-2-rhel7</code></p>
</li>
<li><p>CentOS 版本：<code>openshift/jenkins-2-centos7</code> (位於 DockerHub 上)</p>
</li>
</ul>
<p>由於新版的 OpenShift pipeline plugin for Jenkins 目前僅在 CentOS 版本的 Jenkins image 支援，因此後面的範例將會以 CentOS 版本為主，並提供將原有的 Jenkins image 從 Red Hat 版本改成 CentOS 版本的方法。</p>
<hr>
<h1 id="安裝額外的-Jenkins-plugin"><a href="#安裝額外的-Jenkins-plugin" class="headerlink" title="安裝額外的 Jenkins plugin"></a>安裝額外的 Jenkins plugin</h1><p>由於 OpenShift 提供的 Jenkins image 本身就是一個具有 s2i 功能的 docker image，因此我們可以透過 s2i 的流程，將所需要安裝的 plugin 以 source code injection 的方式指定進來並安裝。</p>
<p>以下的範例將會進行以下的客製化：</p>
<ol>
<li><p>安裝 <strong>redmine</strong>, <strong>gitlab-plugin</strong>, <strong>testlink</strong> 三個 plugin (詳細版本可參考<a href="https://github.com/godleon/learning_openshift/blob/master/jenkins_customization/plugins.txt" target="_blank" rel="noopener">原始碼</a>)</p>
</li>
<li><p>預先加入 <strong>scriptApproval.xml</strong> 檔案，讓某些 method 可在 sandbox 的環境中執行 (詳細清單可參考<a href="https://github.com/godleon/learning_openshift/blob/master/jenkins_customization/configuration/scriptApproval.xml" target="_blank" rel="noopener">原始碼</a>)</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取得原始碼</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/godleon/openshift-jenkins-customization.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 ImageStream(custom-jenkins-2-centos7) BuildConfig(custom-jenkins-build)</span></span><br><span class="line">$ oc create -f openshift-jenkins-customization/openshift-objects/</span><br><span class="line"></span><br><span class="line">$ oc -n openshift start-build custom-jenkins-build</span><br><span class="line"></span><br><span class="line">$ oc -n openshift get pods</span><br><span class="line">NAME                           READY     STATUS      RESTARTS   AGE</span><br><span class="line">custom-jenkins-build-1-build   0/1       Completed   0          22m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視 build log</span></span><br><span class="line">$ oc logs -f custom-jenkins-build-1-build</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用者必須先安裝 <a href="https://github.com/openshift/origin/releases" target="_blank" rel="noopener">OpenShift CLI tool</a> 才可以執行上述的 oc 指令</p>
</blockquote>
<p>在最後一行指令中檢視 build log 時，就可以看見 OpenShift 透過 s2i 流程將我們在程式碼中所指定的 plugin 都已經安裝完成，此時我們就可以透過 ImageStream <code>custom-jenkins-2-centos7</code>(定義於 <strong>Jenkins_Customization/bc_custom-jenkins-build.yml</strong> 中) 來作為啟動 Jenkins server 的 default image。</p>
<hr>
<h1 id="更換原有的-Jenkins-Image"><a href="#更換原有的-Jenkins-Image" class="headerlink" title="更換原有的 Jenkins Image"></a>更換原有的 Jenkins Image</h1><p>今天在測試設計較為複雜的 Jenkins pipeline 時，發現 <a href="https://github.com/openshift/origin/tree/master/examples/jenkins/pipeline" target="_blank" rel="noopener">OpenShift 在 GitHub 提供的範例</a> 無法正常的使用，會出現 openshift class 不存在的錯誤，後來仔細的查了一下，發現原來裡面的範例需要搭配 <a href="https://github.com/openshift/jenkins-client-plugin" target="_blank" rel="noopener">OpenShift Jenkins Pipeline (DSL) Plugin</a> 一起使用。</p>
<p><strong>問題是，Red Hat 版本的 Jenkins image 並沒有內建這一個 plugin，此 plugin 目前僅有內建在 Centos 版本的 Jenkins image 中。</strong></p>
<p>而在上一個步驟中，我們使用了 CentOS 版本的 Jenkins image，並安裝了額外的 plugin 作為後續使用，因此以下便使用已經客製化完成的 Jenkins image 來作為啟動 Jenkins server 的 image。</p>
<p>為了更改自動佈署的 Jenkins server 所使用的 docker image，需要調整 <code>jenkins-ephemeral</code> 的內容，將 image 從 Red Hat 版本改到在上一個步驟完成的客製化 CentOS 版本，執行以下指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ oc edit template/jenkins-ephemeral -n openshift</span><br></pre></td></tr></table></figure>
<p>找到 <code>parameters</code> –&gt; <code>JENKINS_IMAGE_STREAM_TAG</code>，將 <strong>value</strong> 從 <code>jenkins:latest</code> 改為 <code>custom-jenkins-2-centos7:latest</code>，存檔即可。</p>
<p>經過了以上的設定，後面自動佈署出來的 Jenkins server 都會是 CentOS7 的版本，也會同時預載好 <a href="https://github.com/openshift/jenkins-client-plugin" target="_blank" rel="noopener">OpenShift Jenkins Pipeline (DSL) Plugin</a> 以及在上一個步驟額外安裝好的 plugin。</p>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><p><a href="https://github.com/jenkinsci/openshift-pipeline-plugin" target="_blank" rel="noopener">OpenShift V3 Plugin for Jenkins (based on Kubernetes plugin)</a></p>
</li>
<li><p><a href="https://github.com/openshift/jenkins-client-plugin" target="_blank" rel="noopener">OpenShift Jenkins Pipeline (DSL) Plugin (newly design)</a></p>
</li>
<li><p><a href="https://github.com/openshift/origin/tree/master/examples/jenkins/pipeline" target="_blank" rel="noopener">Using Jenkins Pipelines with OpenShift @GitbHub</a></p>
</li>
<li><p><a href="https://docs.openshift.com/container-platform/3.6/using_images/other_images/jenkins.html" target="_blank" rel="noopener">Jenkins - Other Images | Using Images | OpenShift Container Platform 3.6</a></p>
</li>
<li><p><a href="https://github.com/openshift/jenkins-sync-plugin/issues/57" target="_blank" rel="noopener">Script approvals needed for changes to build config Jenkinsfile · Issue #57 · openshift/jenkins-sync-plugin</a></p>
</li>
<li><p><a href="https://github.com/fabric8io/jenkins-docker" target="_blank" rel="noopener">fabric8io/jenkins-docker: docker file for a jenkins docker image</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> OpenShift </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OpenShift </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[OpenShift] Concept - Image Stream]]></title>
      <url>/blog/2017/11/06/OpenShift/OpenShift-Concept-ImageStream/</url>
      <content type="html"><![CDATA[<h1 id="What-is-Image-Stream"><a href="#What-is-Image-Stream" class="headerlink" title="What is Image Stream?"></a>What is Image Stream?</h1><p>每一個 image stream 代表著一個 Docker-formatted container image；它其實只是一個在 OpenShift 中內部對於 docker image 的命名方式，讓系統可以使用指定的名稱找到正確的 docker image 來使用。(類似 Docker 中對每個 image 使用 tag 來命名)</p>
<p>也因為有自己內部的命名方式，因此 Image Stream 就可以包含以下來源的 image：</p>
<ul>
<li><p>OpenShift 內部的 container registry</p>
</li>
<li><p>其他的 image stream</p>
</li>
<li><p>外部的 image repository (例如：DockerHub, CoreOS Quay)</p>
</li>
</ul>
<p>在 OpenShift 中，image stream 可與 Build &amp; Deployment 搭配完成特定的自動化功能；由於 Build &amp; Deployment 都可以監控特定 image stream，當 image stream 指向的 image 有新版產生時，可自動的進行特定的 build or deploy 的工作。</p>
<hr>
<h1 id="建立第一個-Image-Stream"><a href="#建立第一個-Image-Stream" class="headerlink" title="建立第一個 Image Stream"></a>建立第一個 Image Stream</h1><p>以下是一個 ImageStream 的定義範例：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ImageStream</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">"myubuntu:xenial"</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  tags:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">'16.04'</span></span><br><span class="line"><span class="attr">    from:</span></span><br><span class="line"><span class="attr">      kind:</span> <span class="string">DockerImage</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">ubuntu</span></span><br></pre></td></tr></table></figure>
<p>透過以上的 image stream 定義，在 OpenShift Build or Deployment 中，就可以使用 <code>myubuntu:xenial</code> 指定外部 DockerHub 中的 <code>ubuntu:16.04</code> image。</p>
<p>當以上 ImageStream 被建立後，我們可以查詢到以下資訊：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ oc get is</span><br><span class="line">NAME       DOCKER REPO                                           TAGS      UPDATED</span><br><span class="line">myubuntu   docker-registry.default.svc:5000/leon-test/myubuntu   16.04     2 seconds ago</span><br></pre></td></tr></table></figure>
<p>若使用 <code>oc get is/myubuntu -o=yaml</code> 指令檢視 YAML 輸出，得到以下內容：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ImageStream</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">openshift.io/image.dockerRepositoryCheck:</span> <span class="number">2017</span><span class="bullet">-11</span><span class="bullet">-06</span><span class="attr">T04:12:59Z</span></span><br><span class="line"><span class="attr">  creationTimestamp:</span> <span class="number">2017</span><span class="bullet">-11</span><span class="bullet">-06</span><span class="attr">T04:12:58Z</span></span><br><span class="line"><span class="attr">  generation:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">myubuntu</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">leon-test</span></span><br><span class="line"><span class="attr">  resourceVersion:</span> <span class="string">"9145705"</span></span><br><span class="line"><span class="attr">  selfLink:</span> <span class="string">/oapi/v1/namespaces/leon-test/imagestreams/myubuntu</span></span><br><span class="line"><span class="attr">  uid:</span> <span class="string">c59725ce-c2a8-11e7-a13b-faf564e56811</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  lookupPolicy:</span></span><br><span class="line"><span class="attr">    local:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  tags:</span></span><br><span class="line"><span class="attr">  - annotations:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">    from:</span></span><br><span class="line"><span class="attr">      kind:</span> <span class="string">DockerImage</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">ubuntu</span></span><br><span class="line"><span class="attr">    generation:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">    importPolicy:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">"16.04"</span></span><br><span class="line"><span class="attr">    referencePolicy:</span></span><br><span class="line"><span class="attr">      type:</span> <span class="string">Source</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line"><span class="attr">  dockerImageRepository:</span> <span class="string">docker-registry.default.svc:5000/leon-test/myubuntu</span></span><br><span class="line"><span class="attr">  tags:</span></span><br><span class="line"><span class="attr">  - items:</span></span><br><span class="line"><span class="attr">    - created:</span> <span class="number">2017</span><span class="bullet">-11</span><span class="bullet">-06</span><span class="attr">T04:12:59Z</span></span><br><span class="line"><span class="attr">      dockerImageReference:</span> <span class="string">ubuntu@sha256:152b4ccc429f6f28533aff625d8345baf1ba3808e9a99446e86b2bf3efa18571</span></span><br><span class="line"><span class="attr">      generation:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">sha256:152b4ccc429f6f28533aff625d8345baf1ba3808e9a99446e86b2bf3efa18571</span></span><br><span class="line"><span class="attr">    tag:</span> <span class="string">"16.04"</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Image-Stream-Image"><a href="#Image-Stream-Image" class="headerlink" title="Image Stream Image"></a>Image Stream Image</h1><p>image stream image(簡稱 <strong>isimage</strong>) 是一種 virtual resource，讓使用者可以透過 isimage 從特定的 image stream 取得 image，isimage 以 <code>&lt;image stream name&gt;@&lt;image name&gt;</code> 的方式呈現，因此以上面的範例來看，image steam image 就會是：</p>
<blockquote>
<p>myubuntu@sha256:152b4ccc429f6f28533aff625d8345baf1ba3808e9a99446e86b2bf3efa18571</p>
</blockquote>
<hr>
<h1 id="Image-Stream-Tag"><a href="#Image-Stream-Tag" class="headerlink" title="Image Stream Tag"></a>Image Stream Tag</h1><p>image stream tag(簡稱 <strong>istag</strong>) 是一個指到上面 image stream image 的 name pointer，可指向 local or 外部的 image，此外 isiage 還包含了 image 內容變動的歷史紀錄，這樣的設計讓使用者可以在有需要的時候方便的進行 rollback。</p>
<p>istag 以 <code>&lt;image stream name&gt;:&lt;tag&gt;</code> 的方式呈現，因此以上面的範例來看， istag 就會是：</p>
<blockquote>
<p>　myubuntu:16.04</p>
</blockquote>
<hr>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>有了 Image Stream(is), Image Stream Image (isimage), 以及 Image Stream Tag(istag) 的觀念之後，下一個階段將會介紹如何在 OpenShift 中管理 Image。</p>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><p><a href="https://docs.openshift.com/container-platform/3.6/architecture/core_concepts/builds_and_image_streams.html" target="_blank" rel="noopener">Builds and Image Streams - Core Concepts | Architecture | OpenShift Container Platform 3.6</a></p>
</li>
<li><p><a href="https://docs.openshift.com/enterprise/3.0/architecture/core_concepts/builds_and_image_streams.html" target="_blank" rel="noopener">Builds and Image Streams - Core Concepts | Architecture | OpenShift Enterprise 3.0</a></p>
</li>
<li><p><a href="https://github.com/openshift/origin/tree/master/examples/image-streams" target="_blank" rel="noopener">OpenShift ImageStream Examples @GitHub</a></p>
</li>
<li><p><a href="https://docs.openshift.com/container-platform/3.6/dev_guide/managing_images.html" target="_blank" rel="noopener">Managing Images | Developer Guide | OpenShift Container Platform 3.6</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> OpenShift </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OpenShift </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Kubernetes 學習筆記]]></title>
      <url>/blog/2017/06/29/Kubernetes/Learning-Kubernetes/</url>
      <content type="html"><![CDATA[<p>此篇文章為研究 Kubernetes 時所留下的學習筆記索引</p>
<h1 id="Concepts"><a href="#Concepts" class="headerlink" title="Concepts"></a>Concepts</h1><h2 id="kubeconfig"><a href="#kubeconfig" class="headerlink" title="kubeconfig"></a>kubeconfig</h2><ul>
<li><a href="https://github.com/godleon/learning_kubernetes/blob/master/concept/howto_configure_kubeconfig.md" target="_blank" rel="noopener">如何設定 kubeconfig 與 Kubernetes cluster 互動</a></li>
</ul>
<h2 id="Overview-amp-Components"><a href="#Overview-amp-Components" class="headerlink" title="Overview &amp; Components"></a>Overview &amp; Components</h2><ul>
<li><p><a href="https://github.com/godleon/learning_kubernetes/blob/master/concept/component_overview.md" target="_blank" rel="noopener">組成元件概觀</a></p>
</li>
<li><p><a href="https://github.com/godleon/learning_kubernetes/blob/master/concept/overview.md" target="_blank" rel="noopener">Kubernetes Overview</a></p>
</li>
</ul>
<h2 id="Networking"><a href="#Networking" class="headerlink" title="Networking"></a>Networking</h2><ul>
<li><p><a href="https://github.com/godleon/learning_kubernetes/blob/master/concept/network/service.md" target="_blank" rel="noopener">Service</a></p>
</li>
<li><p><a href="https://github.com/godleon/learning_kubernetes/blob/master/concept/network/ingress.md" target="_blank" rel="noopener">Ingress</a></p>
</li>
</ul>
<h2 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h2><ul>
<li><a href="https://github.com/godleon/learning_kubernetes/blob/master/concept/storage/volume.md" target="_blank" rel="noopener">Volume, PersistentVolume &amp; PersistentVolumeClaim</a></li>
</ul>
<hr>
<h1 id="Operating"><a href="#Operating" class="headerlink" title="Operating"></a>Operating</h1><ul>
<li><a href="https://github.com/godleon/learning_kubernetes/blob/master/operation/basic.md" target="_blank" rel="noopener">Kubernetes 基本操作</a></li>
</ul>
<h2 id="Persistent-Volume"><a href="#Persistent-Volume" class="headerlink" title="Persistent Volume"></a>Persistent Volume</h2><ul>
<li><a href="https://github.com/godleon/learning_kubernetes/blob/master/operation/use_PersistentVolume_NFS.md" target="_blank" rel="noopener">使用 Persistent Volume - 以 NFS 為例</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Kubernetes </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Ceph 簡單指令操作]]></title>
      <url>/blog/2017/05/25/Ceph/Ceph-Cheatsheet/</url>
      <content type="html"><![CDATA[<h1 id="Monitoring-and-Health"><a href="#Monitoring-and-Health" class="headerlink" title="Monitoring and Health"></a>Monitoring and Health</h1><p>剛安裝完，首先先檢查 ceph cluster 的狀態：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 檢視 ceph cluster status</span></span><br><span class="line">$ ceph -s</span><br><span class="line">    cluster cd6fcb41-c373-48fb-aab3-f8d330a26ccb</span><br><span class="line">     health HEALTH_WARN</span><br><span class="line">            too few PGs per OSD (16 &lt; min 30)</span><br><span class="line">     monmap e1: 3 mons at &#123;ceph01=10.102.41.101:6789/0,ceph02=10.102.41.102:6789/0,ceph03=10.102.41.103:6789/0&#125;</span><br><span class="line">            election epoch 8, quorum 0,1,2 ceph01,ceph02,ceph03</span><br><span class="line">     osdmap e36: 12 osds: 12 up, 12 <span class="keyword">in</span></span><br><span class="line">            flags sortbitwise,require_jewel_osds</span><br><span class="line">      pgmap v84: 64 pgs, 1 pools, 0 bytes data, 0 objects</span><br><span class="line">            405 MB used, 2174 GB / 2174 GB avail</span><br><span class="line">                  64 active+clean</span><br></pre></td></tr></table></figure>
<blockquote>
<p>也可以用 <code>ceph -w</code> 檢視即時的狀態</p>
</blockquote>
<p>檢查健康狀態：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ceph health detail</span><br><span class="line">HEALTH_WARN too few PGs per OSD (16 &lt; min 30)</span><br><span class="line">too few PGs per OSD (16 &lt; min 30)</span><br></pre></td></tr></table></figure>
<p>接著檢視目前 ceph cluster 提供了多少容量可用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 檢視目前可用的容量、每個 pool 的使用狀況 &amp; quota 等資訊</span></span><br><span class="line">$ ceph df</span><br><span class="line">GLOBAL:</span><br><span class="line">    SIZE      AVAIL     RAW USED     %RAW USED </span><br><span class="line">    2174G     2174G         405M          0.02 </span><br><span class="line">POOLS:</span><br><span class="line">    NAME     ID     USED     %USED     MAX AVAIL     OBJECTS </span><br><span class="line">    rbd      0         0         0          724G           0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 連到 CRUSH tree, 顯示 weight, variance, capacity ... etc</span></span><br><span class="line">$ ceph osd df tree</span><br><span class="line">ID WEIGHT  REWEIGHT SIZE  USE    AVAIL %USE VAR  PGS TYPE NAME       </span><br><span class="line">-1 2.12384        - 2174G   405M 2174G 0.02 1.00   0 root default    </span><br><span class="line">-2 0.70795        -  724G   135M  724G 0.02 1.00   0     host ceph01 </span><br><span class="line"> 0 0.17699  1.00000  181G 35200k  181G 0.02 1.02  11         osd.0   </span><br><span class="line"> 3 0.17699  1.00000  181G 34708k  181G 0.02 1.00  19         osd.3   </span><br><span class="line"> 6 0.17699  1.00000  181G 34420k  181G 0.02 0.99  14         osd.6   </span><br><span class="line"> 8 0.17699  1.00000  181G 34336k  181G 0.02 0.99  20         osd.8   </span><br><span class="line">-3 0.70795        -  724G   135M  724G 0.02 1.00   0     host ceph03 </span><br><span class="line"> 1 0.17699  1.00000  181G 35568k  181G 0.02 1.03  17         osd.1   </span><br><span class="line"> 5 0.17699  1.00000  181G 34432k  181G 0.02 0.99  12         osd.5   </span><br><span class="line"> 9 0.17699  1.00000  181G 34272k  181G 0.02 0.99  18         osd.9   </span><br><span class="line">11 0.17699  1.00000  181G 34200k  181G 0.02 0.99  17         osd.11  </span><br><span class="line">-4 0.70795        -  724G   135M  724G 0.02 1.00   0     host ceph02 </span><br><span class="line"> 2 0.17699  1.00000  181G 35076k  181G 0.02 1.01  19         osd.2   </span><br><span class="line"> 4 0.17699  1.00000  181G 34652k  181G 0.02 1.00  18         osd.4   </span><br><span class="line"> 7 0.17699  1.00000  181G 34456k  181G 0.02 0.99  11         osd.7   </span><br><span class="line">10 0.17699  1.00000  181G 34280k  181G 0.02 0.99  16         osd.10  </span><br><span class="line">              TOTAL 2174G   405M 2174G 0.02</span><br></pre></td></tr></table></figure>
<h1 id="Working-with-Pools-and-OSDs"><a href="#Working-with-Pools-and-OSDs" class="headerlink" title="Working with Pools and OSDs"></a>Working with Pools and OSDs</h1><p>若要尋找單顆 OSD 的相關資訊：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 尋找 OSD physical location</span></span><br><span class="line">$ ceph osd find 1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"osd"</span>: 1,</span><br><span class="line">    <span class="string">"ip"</span>: <span class="string">"10.102.41.103:6800\/63011"</span>,</span><br><span class="line">    <span class="string">"crush_location"</span>: &#123;</span><br><span class="line">        <span class="string">"host"</span>: <span class="string">"ceph03"</span>,</span><br><span class="line">        <span class="string">"root"</span>: <span class="string">"default"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示指定 OSD metadata</span></span><br><span class="line">$ ceph osd metadata 1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"id"</span>: 1,</span><br><span class="line">    <span class="string">"arch"</span>: <span class="string">"x86_64"</span>,</span><br><span class="line">    <span class="string">"back_addr"</span>: <span class="string">"10.102.41.103:6801\/63011"</span>,</span><br><span class="line">    <span class="string">"backend_filestore_dev_node"</span>: <span class="string">"unknown"</span>,</span><br><span class="line">    <span class="string">"backend_filestore_partition_path"</span>: <span class="string">"unknown"</span>,</span><br><span class="line">    <span class="string">"ceph_version"</span>: <span class="string">"ceph version 10.2.5-37.el7cp (033f137cde8573cfc5a4662b4ed6a63b8a8d1464)"</span>,</span><br><span class="line">    ......</span><br><span class="line">    <span class="string">"osd_data"</span>: <span class="string">"\/var\/lib\/ceph\/osd\/ceph-1"</span>,</span><br><span class="line">    <span class="string">"osd_journal"</span>: <span class="string">"\/var\/lib\/ceph\/osd\/ceph-1\/journal"</span>,</span><br><span class="line">    <span class="string">"osd_objectstore"</span>: <span class="string">"filestore"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建立/移除 pool: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立 pool, 名稱為 pve_image, pg 數量為 1024</span></span><br><span class="line">$ ceph osd pool create pve_images 1024</span><br><span class="line">pool <span class="string">'pve_images'</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示目前 pool 詳細狀態</span></span><br><span class="line">$ ceph osd pool ls detail</span><br><span class="line">pool 0 <span class="string">'rbd'</span> replicated size 3 min_size 2 crush_ruleset 0 object_hash rjenkins pg_num 64 pgp_num 64 last_change 1 flags hashpspool stripe_width 0</span><br><span class="line">pool 1 <span class="string">'pve_images'</span> replicated size 3 min_size 2 crush_ruleset 0 object_hash rjenkins pg_num 1024 pgp_num 1024 last_change 37 flags hashpspool stripe_width 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示指定 pool 的詳細資料</span></span><br><span class="line">$ ceph osd pool get pve_images all</span><br><span class="line">size: 3</span><br><span class="line">min_size: 2</span><br><span class="line">crash_replay_interval: 0</span><br><span class="line">pg_num: 1024</span><br><span class="line">pgp_num: 1024</span><br><span class="line">crush_ruleset: 0</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除 pool (要重複 pool name 兩次還要加上那有趣的參數)</span></span><br><span class="line">$ ceph osd pool delete pve_images pve_images --yes-i-really-really-mean-it</span><br><span class="line">pool <span class="string">'pve_images'</span> removed</span><br></pre></td></tr></table></figure>
<p>調整現有 pool 的狀態：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 設定 placement groups 的數量</span></span><br><span class="line">$ ceph osd pool <span class="built_in">set</span> rbd pg_num 384</span><br><span class="line"><span class="built_in">set</span> pool 0 pg_num to 384</span><br><span class="line"></span><br><span class="line"><span class="comment"># pgp =&gt; The effective number of placement groups to use when calculating data placement.</span></span><br><span class="line">$ ceph osd pool <span class="built_in">set</span> rbd pgp_num 384</span><br><span class="line"><span class="built_in">set</span> pool 0 pgp_num to 384</span><br><span class="line"></span><br><span class="line"><span class="comment"># 調整完就會從原本的 warning 狀態變成 health_ok 了!</span></span><br><span class="line">$ ceph -s</span><br><span class="line">    cluster cd6fcb41-c373-48fb-aab3-f8d330a26ccb</span><br><span class="line">     health HEALTH_OK</span><br><span class="line">     monmap e1: 3 mons at &#123;ceph01=10.102.41.101:6789/0,ceph02=10.102.41.102:6789/0,ceph03=10.102.41.103:6789/0&#125;</span><br><span class="line">            election epoch 8, quorum 0,1,2 ceph01,ceph02,ceph03</span><br><span class="line">     osdmap e47: 12 osds: 12 up, 12 <span class="keyword">in</span></span><br><span class="line">            flags sortbitwise,require_jewel_osds</span><br><span class="line">      pgmap v177: 384 pgs, 1 pools, 0 bytes data, 0 objects</span><br><span class="line">            461 MB used, 2174 GB / 2174 GB avail</span><br><span class="line">                 384 active+clean</span><br></pre></td></tr></table></figure>
<h1 id="RBD-Block-Storage"><a href="#RBD-Block-Storage" class="headerlink" title="RBD Block Storage"></a>RBD Block Storage</h1><p>這個部份是用在把 Ceph 作為 block-based storage 時所需要了解的指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 顯示目前的 RBD volume</span></span><br><span class="line">$ rbd ls</span><br><span class="line">vm-101-disk-1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示指定 RBD volume 的狀態</span></span><br><span class="line">$ rbd status vm-101-disk-1</span><br><span class="line">Watchers:</span><br><span class="line">	watcher=10.102.70.124:0/3361738208 client.143192 cookie=140498849842176</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示指定 RBD volume 的相關資訊</span></span><br><span class="line">$ rbd info vm-101-disk-1</span><br><span class="line">rbd image <span class="string">'vm-101-disk-1'</span>:</span><br><span class="line">	size 32768 MB <span class="keyword">in</span> 8192 objects</span><br><span class="line">	order 22 (4096 kB objects)</span><br><span class="line">	block_name_prefix: rbd_data.22f52238e1f29</span><br><span class="line">	format: 2</span><br><span class="line">	features: layering, exclusive-lock, object-map, fast-diff, deep-flatten</span><br><span class="line">	flags: </span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除指定的 RBD volume</span></span><br><span class="line">$ rbd rm vm-101-disk-1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立名稱為 Jenkins_Data，大小為 40GB 的 RBD volume</span></span><br><span class="line">$ rbd create --pool rbd --image Jenkins_Data --size 40960</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視 RBD volume 資訊</span></span><br><span class="line">$ rbd --image Jenkins_Data info</span><br><span class="line">rbd image <span class="string">'Jenkins_Data'</span>:</span><br><span class="line">	size 40960 MB <span class="keyword">in</span> 10240 objects</span><br><span class="line">	order 22 (4096 kB objects)</span><br><span class="line">	block_name_prefix: rbd_data.a71d6238e1f29</span><br><span class="line">	format: 2</span><br><span class="line">	features: layering, exclusive-lock, object-map, fast-diff, deep-flatten</span><br><span class="line">	flags: </span><br><span class="line"></span><br><span class="line"><span class="comment"># 變更 RBD volume 大小，縮小要加上 "--allow-shrink" 以確保安全</span></span><br><span class="line">$ rbd --image Jenkins_Data resize --size 10240 --allow-shrink</span><br><span class="line">Resizing image: 100% complete...done.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 確認 RBD volume 容量正確變更</span></span><br><span class="line">$ rbd --image Jenkins_Data info</span><br><span class="line">rbd image <span class="string">'Jenkins_Data'</span>:</span><br><span class="line">	size 10240 MB <span class="keyword">in</span> 2560 objects</span><br><span class="line">	order 22 (4096 kB objects)</span><br><span class="line">	block_name_prefix: rbd_data.a71d6238e1f29</span><br><span class="line">	format: 2</span><br><span class="line">	features: layering, exclusive-lock, object-map, fast-diff, deep-flatten</span><br><span class="line">	flags: </span><br><span class="line"></span><br><span class="line"><span class="comment"># 放大 RBD Volume</span></span><br><span class="line">$ rbd --image Jenkins_Data resize --size 20480</span><br><span class="line">Resizing image: 100% complete...done.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 確認 RBD volume 容量正確變更</span></span><br><span class="line">$ rbd --image Jenkins_Data info</span><br><span class="line">rbd image <span class="string">'Jenkins_Data'</span>:</span><br><span class="line">	size 20480 MB <span class="keyword">in</span> 5120 objects</span><br><span class="line">	order 22 (4096 kB objects)</span><br><span class="line">	block_name_prefix: rbd_data.a71d6238e1f29</span><br><span class="line">	format: 2</span><br><span class="line">	features: layering, exclusive-lock, object-map, fast-diff, deep-flatten</span><br><span class="line">	flags:</span><br></pre></td></tr></table></figure>
<h1 id="Authentication-and-Authorization"><a href="#Authentication-and-Authorization" class="headerlink" title="Authentication and Authorization"></a>Authentication and Authorization</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 檢視目前可使用 ceph cluster 的 user list</span></span><br><span class="line">$ ceph auth list</span><br><span class="line">installed auth entries:</span><br><span class="line"></span><br><span class="line">osd.0</span><br><span class="line">	key: ABxxxxxxx</span><br><span class="line">	caps: [mon] allow profile osd</span><br><span class="line">	caps: [osd] allow *</span><br><span class="line">......</span><br><span class="line">client.admin</span><br><span class="line">	key: ABxxxxxxx</span><br><span class="line">	caps: [mds] allow *</span><br><span class="line">	caps: [mon] allow *</span><br><span class="line">	caps: [osd] allow *</span><br><span class="line">client.bootstrap-mds</span><br><span class="line">	key: ABxxxxxxx</span><br><span class="line">	caps: [mon] allow profile bootstrap-mds</span><br><span class="line">client.bootstrap-osd</span><br><span class="line">	key: ABxxxxxxx</span><br><span class="line">	caps: [mon] allow profile bootstrap-osd</span><br><span class="line">client.bootstrap-rgw</span><br><span class="line">	key: ABxxxxxxx</span><br><span class="line">	caps: [mon] allow profile bootstrap-rgw</span><br></pre></td></tr></table></figure>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><p><a href="https://www.gitbook.com/book/tobegit3hub1/ceph_from_scratch/details" target="_blank" rel="noopener">Ceph From Scratch · GitBook</a></p>
</li>
<li><p><a href="https://sabaini.at/pages/ceph-cheatsheet.html" target="_blank" rel="noopener">Ceph Cheatsheet - sabaini.at</a></p>
</li>
<li><p><a href="http://michaelkang.blog.51cto.com/1553154/1698287" target="_blank" rel="noopener">最新ceph集群常用命令梳理 - 康建华 - 51CTO技术博客</a></p>
</li>
<li><p><a href="http://docs.ceph.com/docs/jewel/rados/operations/pools/" target="_blank" rel="noopener">Pools — Ceph Documentation</a></p>
</li>
<li><p><a href="http://docs.ceph.com/docs/master/rados/operations/placement-groups/" target="_blank" rel="noopener">Placement Groups — Ceph Documentation</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Ceph </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Ceph </tag>
            
            <tag> SDS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[AWS 學習筆記 - S3(Simple Storage Service)]]></title>
      <url>/blog/2017/05/14/AWS/AWS-Learning-Notes-S3/</url>
      <content type="html"><![CDATA[<h1 id="What-is-S3"><a href="#What-is-S3" class="headerlink" title="What is S3?"></a>What is S3?</h1><p>Amazon Simple Storage Service (Amazon S3) is object storage with a simple web service interface to store and retrieve any amount of data from anywhere on the web. It is designed to deliver 99.999999999% durability, and scale past trillions of objects worldwide.</p>
<p>Customers use S3 as primary storage for cloud-native applications; as a bulk repository, or “<a href="https://aws.amazon.com/big-data/data-lake-on-aws/download/" target="_blank" rel="noopener">data lake</a>,” for analytics; as a target for <a href="https://aws.amazon.com/backup-recovery/getting-started/" target="_blank" rel="noopener">backup &amp; recovery</a> and disaster recovery; and with <a href="https://aws.amazon.com/lambda/details/" target="_blank" rel="noopener">serverless computing</a>.</p>
<p>It’s simple to move large volumes of data into or out of Amazon S3 with Amazon’s <a href="https://aws.amazon.com/cloud-data-migration/" target="_blank" rel="noopener">cloud data migration</a> options. Once data is stored in S3, it can be automatically tiered into lower cost, longer-term cloud storage classes like S3 Standard - Infrequent Access and <a href="https://aws.amazon.com/glacier/details/" target="_blank" rel="noopener">Amazon Glacier</a> for archiving.</p>
<h1 id="S3-The-Basics"><a href="#S3-The-Basics" class="headerlink" title="S3 - The Basics"></a>S3 - The Basics</h1><ul>
<li><p>單一檔案大小的限制為 <code>0 bytes</code> ~ <code>5 TB</code></p>
</li>
<li><p>檔案一律存在 bucket 中 (Bucket 裏面無法再放一個 bucket，但可以放 folder)</p>
</li>
<li><p>單一帳號預設最大上限可存放 100 個 buckets，但可以通知 AWS 協助放大上限</p>
</li>
<li><p>S3 裡面的每個 bucket 都會有一個全球獨一無二的 DNS 名稱(ex: <a href="https://s3-eu-west-1.amazonaws.com/YOUR_UNIQUE_BUCKET_NAME" target="_blank" rel="noopener">https://s3-eu-west-1.amazonaws.com/YOUR_UNIQUE_BUCKET_NAME</a>)</p>
<blockquote>
<p>因此可以做為 static website hosting 之用</p>
</blockquote>
</li>
<li><p>成功上傳檔案到 S3 後，會收到 HTTP 200 的回應</p>
</li>
<li><p>Built for 99.99% availability for S3 platform</p>
</li>
<li><p>Amazon 實際保證 99.9% availability</p>
</li>
<li><p>Amazon 保證 11 個 9 的 durability for S3 information (資料遺失的可能性)</p>
<blockquote>
<p>為避免人為不小心刪除的狀況發生，最好的方法還是建議把 versioning, cross-regsion replication, MFA 刪除等機制啟用</p>
</blockquote>
</li>
<li><p>Tiered Storage available</p>
</li>
<li><p>Lifecycle Management</p>
<blockquote>
<p>可以設定前 30 天在正常的 <strong>standard</strong> tier, 接著 30 天移到另外一個 IA(Infrequently Accessed) tier, 90 天後進行 archive</p>
</blockquote>
</li>
<li><p>Versioning</p>
</li>
<li><p>Encryption</p>
</li>
<li><p>可透過 Access Control Lists &amp; Bucket Policies 來提升安全性</p>
<blockquote>
<p>剛建立好的 bucket or 上傳的 object 所預設的權限僅限於自己可以存取(private &amp; inaccessible)，完全沒有預設對外開放的規則</p>
</blockquote>
</li>
</ul>
<h1 id="Data-Consistency-Model-for-S3"><a href="#Data-Consistency-Model-for-S3" class="headerlink" title="Data Consistency Model for S3"></a>Data Consistency Model for S3</h1><ul>
<li><p>Read after consistency for PUTS of new Object (新增檔案後馬上就可以讀取)</p>
</li>
<li><p>Eventually Consistency for overwrite PUTS and DELETES(can take some time to propagate)</p>
<blockquote>
<p>若是針對已經存在的檔案進行修改 or 刪除，這樣的變更需要花點時間才會完全套用到所有的硬體設施中</p>
</blockquote>
</li>
</ul>
<h1 id="S3-is-a-simple-key-value-store"><a href="#S3-is-a-simple-key-value-store" class="headerlink" title="S3 is a simple key, value store"></a>S3 is a simple key, value store</h1><p>S3 is object based. 每個 object 都包含以下資訊：</p>
<ul>
<li><p><strong>Key</strong>: object name (檔案會依照字母順序排序，新增時要考量這個問題，建議在每個檔案名稱前 random 一個字串作為開始)</p>
</li>
<li><p><strong>Value</strong>: 基本上就是此檔案的資料本身</p>
</li>
<li><p><strong>Version ID</strong>: 作為版本控管之用</p>
</li>
<li><p><strong>Metadata</strong>: 額外用來記錄 object 相關資訊的資料(ex: 上傳檔案的時間、最後變更的時間…etc)</p>
<blockquote>
<p>使用者也可以自訂客製化的 metadata，藉此來為 object 標註不同的屬性值</p>
</blockquote>
</li>
<li><p><strong>Subresources</strong></p>
<ul>
<li>Access Control Lists (用來做細部的存取控管)</li>
<li>Torrent (S3 支援 bittorrent protocol)</li>
</ul>
</li>
</ul>
<h1 id="S3-vs-Glacier"><a href="#S3-vs-Glacier" class="headerlink" title="S3 vs Glacier"></a>S3 vs Glacier</h1><table>
<thead>
<tr>
<th></th>
<th style="text-align:center">Standard</th>
<th style="text-align:center">Standard - IA</th>
<th style="text-align:center">Glacier</th>
</tr>
</thead>
<tbody>
<tr>
<td>Designed for Durability</td>
<td style="text-align:center">11 x 9’s</td>
<td style="text-align:center">11 x 9’s</td>
<td style="text-align:center">11 x 9’s</td>
</tr>
<tr>
<td>Designed for Availability</td>
<td style="text-align:center">99.99%</td>
<td style="text-align:center">99.99%</td>
<td style="text-align:center">N/A</td>
</tr>
<tr>
<td>Availability SLA</td>
<td style="text-align:center">99.9%</td>
<td style="text-align:center">99%</td>
<td style="text-align:center">N/A</td>
</tr>
<tr>
<td>Minumum Object Size</td>
<td style="text-align:center">N/A</td>
<td style="text-align:center">128KB</td>
<td style="text-align:center">N/A</td>
</tr>
<tr>
<td>Minumum Storage Duration</td>
<td style="text-align:center">N/A</td>
<td style="text-align:center">30 days</td>
<td style="text-align:center">90 days</td>
</tr>
<tr>
<td>Retrieval Fee</td>
<td style="text-align:center">N/A</td>
<td style="text-align:center">per GB retrieved</td>
<td style="text-align:center">per GB retrieved</td>
</tr>
<tr>
<td>First Byte Latency</td>
<td style="text-align:center">ms</td>
<td style="text-align:center">ms</td>
<td style="text-align:center">select minutes or hours</td>
</tr>
<tr>
<td>Storage Class</td>
<td style="text-align:center">object level</td>
<td style="text-align:center">object level</td>
<td style="text-align:center">object level</td>
</tr>
<tr>
<td>Lifecycle Transitions</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">S3</th>
<th style="text-align:center">Glacier</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">up to 5TB object</td>
<td style="text-align:center">up to 40TB archive</td>
</tr>
<tr>
<td style="text-align:center">user-definable key</td>
<td style="text-align:center">system-generated archive ID</td>
</tr>
<tr>
<td style="text-align:center">encrypt is optional</td>
<td style="text-align:center">automatically encrypted</td>
</tr>
</tbody>
</table>
<h1 id="S3-收費標準"><a href="#S3-收費標準" class="headerlink" title="S3 收費標準"></a>S3 收費標準</h1><ul>
<li><p>Storage Pricing</p>
</li>
<li><p>Request Pricing</p>
</li>
<li><p>Storage Management Pricing</p>
<blockquote>
<p>例如：analysis, tagging, inventory check</p>
</blockquote>
</li>
<li><p>Data Transfer Pricing</p>
<blockquote>
<p>資料存入 S3 免費，往其他地方傳則要付費，即使是 region 之間互傳</p>
</blockquote>
</li>
<li><p>Transfer Acceleration</p>
<blockquote>
<p>Amazon S3 Transfer Acceleration enables fast, easy, and secure transfers of files over long distances between your client and an S3 bucket. Transfer Acceleration takes advantage of Amazon CloudFront’s globally distributed edge locations. As the data arrives at an edge location, data is routed to Amazon S3 over an optimized network path.</p>
</blockquote>
</li>
</ul>
<h1 id="Advanced-Features"><a href="#Advanced-Features" class="headerlink" title="Advanced Features"></a>Advanced Features</h1><h2 id="Prefix-amp-Delimiter"><a href="#Prefix-amp-Delimiter" class="headerlink" title="Prefix &amp; Delimiter"></a>Prefix &amp; Delimiter</h2><p>以下面的 object 名稱為例：</p>
<blockquote>
<p>logs/2016/January/server42.log<br>logs/2016/February/server42.log<br>logs/2016/March/server42.log</p>
</blockquote>
<ul>
<li><p>S3 可透過 prefix &amp; delimiter 作到類似檔案階層的功能(hierachy &amp; folder)，但事實那些都只是透過 object 的檔名虛構出來的，並沒有實際階層功能</p>
</li>
<li><p>REST API, SDK, CLI, Management Console 都支援使用 prefix &amp; delimiter</p>
</li>
<li><p>與 IAM or S3 Bucket Plicies 搭配，可以在單一個 bucket 中達成像是 department subdirectories, user home directories … 等效果</p>
</li>
</ul>
<h2 id="Storage-Tiers-Classes"><a href="#Storage-Tiers-Classes" class="headerlink" title="Storage Tiers/Classes"></a>Storage Tiers/Classes</h2><table>
<thead>
<tr>
<th></th>
<th style="text-align:center">Standard</th>
<th style="text-align:center">Standard (Infrequent Access)</th>
<th style="text-align:center">Reduced Redundancy Storage</th>
</tr>
</thead>
<tbody>
<tr>
<td>Durability</td>
<td style="text-align:center">99.999999999%</td>
<td style="text-align:center">99.999999999%</td>
<td style="text-align:center">99.99%</td>
</tr>
<tr>
<td>Availability</td>
<td style="text-align:center">99.99%</td>
<td style="text-align:center">99.99%</td>
<td style="text-align:center">99.99%</td>
</tr>
<tr>
<td>Concurrect facility fault tolerance</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>SSL support</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">Yes</td>
</tr>
<tr>
<td>First byte latency</td>
<td style="text-align:center">Miliseconds</td>
<td style="text-align:center">Miliseconds</td>
<td style="text-align:center">Miliseconds</td>
</tr>
<tr>
<td>Lifecycle Management Policies</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">Yes</td>
</tr>
<tr>
<td>附註</td>
<td style="text-align:center"></td>
<td style="text-align:center">object 大小限制為最小 128KB, 最少要存放 30 天, 存取資料要額外收費</td>
</tr>
</tbody>
</table>
<h3 id="1-Standard"><a href="#1-Standard" class="headerlink" title="1. Standard"></a>1. Standard</h3><p>99.99 availability, 99.999999999% durability, stored redundantly across multiple devices in multiple facilities and is designed to sustain the loss of 2 facilities concurrently.</p>
<h3 id="2-IA-Infrequently-Accessed"><a href="#2-IA-Infrequently-Accessed" class="headerlink" title="2. IA(Infrequently Accessed)"></a>2. IA(Infrequently Accessed)</h3><p>適合不常存取的資料，比 standard 便宜，要存取時可以馬上取得，但存取需要額外付費</p>
<h3 id="3-Reduced-Redundancy-Storage-RRS"><a href="#3-Reduced-Redundancy-Storage-RRS" class="headerlink" title="3. Reduced Redundancy Storage (RRS)"></a>3. Reduced Redundancy Storage (RRS)</h3><p>Design to provide 99.99% durability and 99.99 availability of objects over a given year.</p>
<blockquote>
<p>durability 從 <strong>11 x 9’s</strong> 變成 <strong>4 x 9’s</strong>，適合存像是圖片的 thumb nails 之類的資料</p>
</blockquote>
<h3 id="4-Glacier"><a href="#4-Glacier" class="headerlink" title="4. Glacier"></a>4. Glacier</h3><ul>
<li><p>very cheap, but used for archival only. </p>
</li>
<li><p>存取前需先執行 restore 命令，並需要等待 3~5 個小時的資料準備時間</p>
</li>
<li><p>Glacier 上的資料不會因為 restore 命令而刪除，除非明確執行刪除指令</p>
</li>
<li><p>資料還原時會放到 S3 <strong>RRS(Reduced Redundancy Storage)</strong> class</p>
</li>
<li><p>AWS 提供每個月免費取得 5% Glacier 資料的額度 (每日為單位計算)</p>
<blockquote>
<p>可透過設定 <strong>retrieval policy</strong> or <strong>設定 max GB-per-hour limit</strong> 來確保存取資料會在免費的額度下進行，來降低甚至避免還原費用的發生</p>
</blockquote>
</li>
<li><p>雖然是 S3 Storage Class 的一個選項，但其實 Glacier 是個獨立服務且有獨立的 API，並提供一些 S3 沒有的功能</p>
</li>
<li><p>可用來作為取代傳統磁帶作為長期備份的選項 (在某些行業必須有保留資料 N 年的規定)</p>
</li>
<li><p>非常可靠，也是有 11 個 9 的 durability</p>
</li>
</ul>
<h4 id="Archive"><a href="#Archive" class="headerlink" title="Archive"></a>Archive</h4><ul>
<li><p>在 Glacier 上儲存的備份單位稱為 <strong>archive</strong>（等同 S3 上 object 的概念)</p>
</li>
<li><p>每個 archive 最大可以到 <strong>40TB</strong></p>
</li>
<li><p>使用者可以擁有無限數量的 archive</p>
</li>
<li><p>每個 archive 都會有一個 unique archive ID (無法自己取名字)</p>
</li>
<li><p>所有的 archive 都會被自動加密 &amp; 無法被修改</p>
</li>
</ul>
<h4 id="Vault"><a href="#Vault" class="headerlink" title="Vault"></a>Vault</h4><ul>
<li><p>在 Glacier 中存放 archive 的容器稱為 <strong>vault</strong> (等同 S3 上 bucket 的概念)</p>
</li>
<li><p>可透過設定 IAM policy or vault access policy 來限制存取</p>
</li>
</ul>
<h4 id="Vaults-Locks"><a href="#Vaults-Locks" class="headerlink" title="Vaults    Locks"></a>Vaults    Locks</h4><ul>
<li><p>使用者可透過 Vaults    Locks 針對 Glacier 設定強制管理</p>
</li>
<li><p>可藉由設定 Write Once Read Many(WORM) 在 vault lock policy 中來套用到未來所有存放到 valut 的 archive</p>
</li>
<li><p>一旦設定了 vault lock policy，就無法再度變更規則</p>
</li>
</ul>
<h2 id="Lifecycle-Management"><a href="#Lifecycle-Management" class="headerlink" title="Lifecycle Management"></a>Lifecycle Management</h2><ul>
<li><p>等同於傳統 IT storage infra 中的 <strong>automated storage tiering</strong> 功能，是一種 data 從 <code>hot</code>(frequently    accessed) -&gt; <code>warm</code>(less    frequently    accessed) -&gt; <code>cold</code>(long-term    backup    or    archive) 的概念</p>
</li>
<li><p>Can be used in conjuction with versioning.</p>
</li>
<li><p>Can be applied to current versions and previous versions</p>
</li>
<li><p>Following actions can now be done:</p>
<ul>
<li>Transition to the <strong>Standard - Infrequent Access</strong> storage class (128Kb and 30 days after the creation date)</li>
<li>Archive to the <strong>Glacier</strong> storage class (30 days after IA, if relevent)</li>
<li>Permanently Delete (若有移到 Glacier 要把刪除的日期設為 90 天以上，因為 Glacier 費用低消是 90 days)</li>
</ul>
</li>
</ul>
<h2 id="Encryption"><a href="#Encryption" class="headerlink" title="Encryption"></a>Encryption</h2><h3 id="1-In-Transit"><a href="#1-In-Transit" class="headerlink" title="1. In Transit"></a>1. In Transit</h3><p>透過 AWS SSL API endpoints 存取 S3 (<strong>HTTPS</strong>)，存取的流量都會被加密</p>
<h3 id="2-At-Rest"><a href="#2-At-Rest" class="headerlink" title="2. At Rest"></a>2. At Rest</h3><h4 id="1-Server-Side-Encryption"><a href="#1-Server-Side-Encryption" class="headerlink" title="(1) Server Side Encryption"></a>(1) Server Side Encryption</h4><ul>
<li><p>S3 Managed Keys (<code>SSE-S3</code>)</p>
<blockquote>
<p>AWS 會將資料用 master key(AES-256) 進行加密，且 key 會定期更換，全由 AWS 託管</p>
</blockquote>
</li>
<li><p>AWS Key Management Service, Managed Keys (<code>SSE-KMS</code>)</p>
<blockquote>
<p>透過 KMS 指定 master key 來進行加密，<strong>需要額外支付 KMS 的費用</strong><br>但可以控管 S3 的存取，也可以確認存取 S3 的人是擁有 key 的使用者(可以搭配 AWS 的追蹤功能之道誰在何時存取了 S3 並解密，甚至可以檢視哪個沒有權限的使用者嘗試解密資料時發生的錯誤)</p>
</blockquote>
</li>
<li><p>Server Side Encryption with Customer Provided Keys (<code>SSE-C</code>)</p>
</li>
</ul>
<h4 id="2-Client-Side-Encryption-將資料加密後傳到-S3"><a href="#2-Client-Side-Encryption-將資料加密後傳到-S3" class="headerlink" title="(2) Client Side Encryption (將資料加密後傳到 S3)"></a>(2) Client Side Encryption (將資料加密後傳到 S3)</h4><p>AWS 可從兩個管道取得 data encryption key:</p>
<ul>
<li><p>AWS KMS-managed customer master key</p>
</li>
<li><p>client-side master key</p>
</li>
</ul>
<h2 id="Versioning"><a href="#Versioning" class="headerlink" title="Versioning"></a>Versioning</h2><ul>
<li><p>object 的所有版本資訊都會被保留下來，<strong>包含所有的寫入資訊甚至是刪除的資訊</strong>都會被完整保留 (<strong>同樣也要支付多倍的費用來儲存不同的版本</strong>)</p>
</li>
<li><p>Great backup tool</p>
</li>
<li><p>Once enabled, Versioning cannot be disabled, only suspended.</p>
</li>
<li><p>Integrates with Lifecycle rules</p>
</li>
<li><p>Versioning’s MFA Delete capability, which uses multi-factor authentication, can be used to provide an additional layer of security. (<strong>只能由 root 帳號啟用此功能</strong>)</p>
<blockquote>
<p>刪除 object 前必須提供 token or security code 來完成</p>
</blockquote>
</li>
<li><p>Cross Region Replication, requires versioning enabled on the source bucket</p>
</li>
</ul>
<h2 id="Pre-Signed-URLs"><a href="#Pre-Signed-URLs" class="headerlink" title="Pre-Signed URLs"></a>Pre-Signed URLs</h2><p>object owner 可以透過 <strong>pre-signed URL</strong> 的機制，提供給其他人<strong>暫時</strong>存取 object 的權限，而有效期限則是由 owner 自行指定；也可以透過來保護公開的網頁資料，避免未授權的惡意行為發生。</p>
<h2 id="Multipart-Upload"><a href="#Multipart-Upload" class="headerlink" title="Multipart Upload"></a>Multipart Upload</h2><p>當使用者有大檔案要上傳時，可開啟 multipart upload 的功能，檔案會被切成多個部份同時上傳，到 S3 上後會自動重組而成原本的檔案。</p>
<blockquote>
<p>建議超過 100MB 的檔案使用 multipart upload；此外，超過 5GB 的檔案一定要用 multipart upload 才可以上傳</p>
<p>可以針對未完成上傳的檔案設定 lifecycle policy，如此可以減少費用的支出，讓超過期限未完成上傳的檔案自動失效</p>
</blockquote>
<h2 id="Range-GETs"><a href="#Range-GETs" class="headerlink" title="Range    GETs"></a>Range    GETs</h2><p>可下載指定 object 的部份內容，透過指定 byte 的範圍來取得 object 的部份資料；而這功能必須透過 SDK 搭配 Range HTTP header 才能實現。</p>
<blockquote>
<p>若是網路品質很差，或是想要從很大的 Glacier 備份中取得部份資料時可能會用到</p>
</blockquote>
<h2 id="Cross-Region-Replication"><a href="#Cross-Region-Replication" class="headerlink" title="Cross-Region Replication"></a>Cross-Region Replication</h2><p>cross-region replication 允許使用者將指定 bucket 的 object 非同步的複製到其他的 region。</p>
<ul>
<li><p>啟用 cross-region replication 的功能前，必須先啟動 bucket 的 versioning 功能</p>
</li>
<li><p>任何與 object 相關的 metadata or ACL 設定更動時，都會觸發 replication 的發生</p>
</li>
<li><p>必須設定正確的 IAM policy 讓 S3 本身可以進行 replication 的工作</p>
</li>
<li><p>若是已經存在的 bucket 開啟 cross-region replication 的功能，原有的資料不會被複製，必須自行複製 or 透過額外的命令來進行資料搬移</p>
</li>
</ul>
<blockquote>
<p>此功能常被用來將 object 放在靠使用者較近的地方來減少延遲；或是滿足不同地理區域備份的需求</p>
</blockquote>
<h2 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h2><ul>
<li><p>針對 bucket 存取的 logging 功能預設關閉，可透過 S3 server access logs 功能開啟</p>
</li>
<li><p>log 可儲存在同一個 bucket 內，也可以存在另外一個 bucket 中；但重點是設定 prefix(例如：<code>logs/</code> or <code>bucket_name/logs/</code>) 讓後續尋找 log 方便是很重要的</p>
</li>
<li><p>log 資訊包含：</p>
<ul>
<li>requestor account &amp; IP</li>
<li>request time</li>
<li>bucket name</li>
<li>action (GET, PUT, LIST … etc)</li>
<li>response status &amp; error code</li>
</ul>
</li>
</ul>
<h2 id="Event-Notification"><a href="#Event-Notification" class="headerlink" title="Event Notification"></a>Event Notification</h2><p>event notification 可以用來在 bucket 狀態有變更(例如：上傳 object)時驅動某些事件的發生，使用者可以透過此特性來加入到 workflow 的設計，發送警告，或是執行特定工作…等等。</p>
<ul>
<li><p>設定於 bucket level</p>
</li>
<li><p>可在 object 被建立(PUT, POST, COPY or multipart upload), 被刪除(DELETE)，或是偵測到有 RRS(Reduced Redundancy Storage) object 遺失的時候發送通知</p>
</li>
<li><p>可透過 Amazon SNS(Simple Notification Service) or SQS(Simple Queue Service) 發送通知，也可以直接呼叫 AWS Lambda function</p>
</li>
</ul>
<h1 id="S3-Management-Console"><a href="#S3-Management-Console" class="headerlink" title="S3 Management Console"></a>S3 Management Console</h1><h2 id="Permissions"><a href="#Permissions" class="headerlink" title="Permissions"></a>Permissions</h2><p>在權限管理的部分，有分成 <code>Objects</code> &amp; <code>Object permissions</code> 兩種：</p>
<ol>
<li><p><strong>Objects</strong>: 對於 object 本身內容的存取權限</p>
<blockquote>
<p>Grant permissions to the user to list, create, overwrite, or delete objects in the bucket.</p>
</blockquote>
</li>
<li><p><strong>Object permissions</strong>: 對於 object 的 ACL 的存取權限，並非 object 本身</p>
<blockquote>
<p>Grant permissions to the user to read or write to an access control list (ACL) for the bucket</p>
</blockquote>
</li>
</ol>
<p>即使 bucket 的權限被設定為 public readable，也不代表後續上傳到此 bucket 的 object 也是 public readable，權限是分開管理的</p>
<h2 id="Versioning-1"><a href="#Versioning-1" class="headerlink" title="Versioning"></a>Versioning</h2><ul>
<li><p>當此功能開啟後，之後無法移除，只能關閉</p>
</li>
<li><p>上傳相同名稱的檔案多次，S3 會在介面上看到一個檔案搭配多個 version 可選 (透過檢視 metadata 可以發現其實根本就是不同的 object)</p>
<blockquote>
<p>而使用容量的計算當然就是所有版本 object 的 size 總和 (<strong>計算成本的時候要特別注意這件事情</strong>)</p>
</blockquote>
</li>
<li><p>若移除 object 的 version，永遠就會消失無法還原</p>
</li>
<li><p>刪除 object 之後，會在系統上留下一個 <code>Delete Marker</code>(需要在 Versions 的地方選 <strong>Show</strong> 藉以顯示所有歷程記錄)，刪除 Delete Marker 之後就可以回復原本被刪除的檔案 </p>
<blockquote>
<p>目前還原功能是在舊版的版面上找到的，新版的目前沒有看到類似的功能頁面</p>
</blockquote>
</li>
</ul>
<h1 id="S3-Transfer-Acceleration"><a href="#S3-Transfer-Acceleration" class="headerlink" title="S3 Transfer Acceleration"></a>S3 Transfer Acceleration</h1><h2 id="What-is-S3-Transfer-Acceleration"><a href="#What-is-S3-Transfer-Acceleration" class="headerlink" title="What is S3 Transfer Acceleration?"></a>What is S3 Transfer Acceleration?</h2><p>S3 Transfer Acceleration utilise the CloudFront Edge Network to accelerate your uploads to S3. Instead of uploading directly to your S3 bucket, you can use a distinct URL to upload directly to an edge location which will then transfer that file to S3. You will get a distinct URL to upload to:</p>
<blockquote>
<p>your-bucket-name.s3-accelerate.amazonaws.com</p>
</blockquote>
<p>若要上傳大量的資料到距離本地端很遠的 region，使用 S3 Transfer Acceleration 會很有幫助</p>
<h1 id="Create-a-Static-Website-using-S3"><a href="#Create-a-Static-Website-using-S3" class="headerlink" title="Create a Static Website using S3"></a>Create a Static Website using S3</h1><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol>
<li><p>建立 bucket</p>
</li>
<li><p>啟用 <strong>Static website hosting</strong></p>
</li>
</ol>
<blockquote>
<p>這裡會取得一個 <strong><a href="http://your-bucket-name.s3-website.region-alias.amazonaws.com" target="_blank" rel="noopener">http://your-bucket-name.s3-website.region-alias.amazonaws.com</a></strong> 的 domain name</p>
</blockquote>
<ol>
<li><p>可以額外設定 index/error pages.</p>
</li>
<li><p>依然要提供 object read permission 才可以</p>
</li>
</ol>
<h1 id="Exam-Tips"><a href="#Exam-Tips" class="headerlink" title="Exam Tips"></a>Exam Tips</h1><h2 id="S3-101"><a href="#S3-101" class="headerlink" title="S3 101"></a>S3 101</h2><ul>
<li><p>S3 is Object based.</p>
</li>
<li><p>Files can be from 0 Bytes ~ 5 TB.</p>
</li>
<li><p>There is unlimited storage.</p>
</li>
<li><p>Files are stored in Buckets.</p>
</li>
<li><p>S3 is a universal namespace, that is, names must be unique globally.</p>
<blockquote>
<p>網址的格式為: <a href="https://[RegionName].amazonaws.com/[YourBucketName" target="_blank" rel="noopener">https://[RegionName].amazonaws.com/[YourBucketName</a>]</p>
</blockquote>
</li>
<li><p>Read after Write consistency for PUTS of new Object</p>
</li>
<li><p>Eventual Consistency for overwrite PUTS and DELETES (can take some time to propagate)</p>
</li>
<li><p>S3 Storage Classes/Tiers</p>
<ul>
<li>S3 (durable, immediately available, frequently accessed)</li>
<li>S3 - IA (durable, immediately available, infrequently accessed)</li>
<li>S3 - Reduced Redundancy Storage (data that is easily reproducible, such as thumb nails etc)</li>
<li>Glacier - Archived data, where you can wait 3~5 hours before accessing</li>
</ul>
</li>
<li><p>Remember the core fundamentals of an S3 object</p>
<ul>
<li>Key (name)<blockquote>
<p>這是一個 1024 bytes 的 UTF-8 字元所組成，在同一個 bucket 內不會重複(但不同的 bucket 可能會有同樣的 key)</p>
</blockquote>
</li>
<li>Value (data)</li>
<li>version ID</li>
<li>metadata</li>
<li>subresource (ACL, torrent)</li>
</ul>
</li>
<li><p>Object based storage only (for files).</p>
</li>
<li><p><strong>Not suitable to install an operating system</strong>.</p>
</li>
<li><p>Successfuly upload will generate a HTTP 200 status code.</p>
</li>
</ul>
<h2 id="Versioning-2"><a href="#Versioning-2" class="headerlink" title="Versioning"></a>Versioning</h2><ul>
<li><p>object 的所有版本資訊都會被保留下來，<strong>包含所有的寫入資訊甚至是刪除的資訊</strong>都會被完整保留 (<strong>同樣也要支付多倍的費用來儲存不同的版本</strong>)</p>
</li>
<li><p>Great backup tool</p>
</li>
<li><p>Once enabled, Versioning cannot be disabled, only suspended.</p>
</li>
<li><p>Integrates with Lifecycle rules</p>
</li>
<li><p>Versioning’s MFA Delete capability, which uses multi-factor authentication, can be used to provide an additional layer of security. (<strong>只能由 root 帳號啟用此功能</strong>)</p>
<blockquote>
<p>刪除 object 前必須提供 token or security code 來完成</p>
</blockquote>
</li>
<li><p>Cross Region Replication, requires versioning enabled on the source bucket</p>
</li>
</ul>
<h2 id="Cross-Region-Replication-1"><a href="#Cross-Region-Replication-1" class="headerlink" title="Cross Region Replication"></a>Cross Region Replication</h2><ul>
<li><p>要啟用 cross region replication 的功能，source &amp; destination bucket 都必須要啟用 versioning 才可以</p>
</li>
<li><p>設定 replication 前已經存在的 object 不會自動被同步，只有後續上傳的 object 會被同步</p>
<blockquote>
<p>如果上傳新版的 object，原來所有版本的記錄都會一併被同步</p>
</blockquote>
</li>
<li><p>任何與 object 相關的 metadata or ACL 被變更時，都會觸發 replication 的工作執行</p>
</li>
<li><p>必須設定 IAM policy，用以提供 S3 合適的權限進行 replication 工作</p>
</li>
<li><p>單一 bucket 無法同步到多個 region，但可透過 <code>region1_bucket -&gt; region2_bucket -&gt; region3_bucket</code> 的方式達成相同效果 (daisy chain 似乎也不行)</p>
</li>
<li><p>刪除 object 後，原本同步 region 上的 object 也會被刪除</p>
<ul>
<li>所從舊版的 console 刪除 delete maker 後可以恢復檔案，但刪除 delete marker 這動作不會被同步，因此同步的 destination bucket 上的檔案不會回復</li>
<li>若使用 <code>region1_bucket -&gt; region2_bucket -&gt; region3_bucket</code> 同步到多個 region，delete marker 只會被同步到 region2，region3 只會得到檔案被刪除的結果，看不到 delete marker</li>
</ul>
</li>
<li><p>Deleting individual versions or delete markers will not be replicated</p>
<blockquote>
<p>在 source bucket 中刪除 delete marker or 特定版本(在舊版的 console)的結果，不會被同步到 destination bucket</p>
</blockquote>
</li>
</ul>
<h2 id="Lifecycle-Management-1"><a href="#Lifecycle-Management-1" class="headerlink" title="Lifecycle Management"></a>Lifecycle Management</h2><ul>
<li><p>等同於傳統 IT storage infra 中的 <strong>automated storage tiering</strong> 功能，是一種 data 從 <code>hot</code>(frequently    accessed) -&gt; <code>warm</code>(less    frequently    accessed) -&gt; <code>cold</code>(long-term    backup    or    archive) 的概念</p>
</li>
<li><p>Can be used in conjuction with versioning.</p>
</li>
<li><p>Can be applied to current versions and previous versions</p>
</li>
<li><p>Following actions can now be done:</p>
<ul>
<li>Transition to the <strong>Standard - Infrequent Access</strong> storage class (128Kb and 30 days after the creation date)</li>
<li>Archive to the <strong>Glacier</strong> storage class (30 days after IA, if relevent)</li>
<li>Permanently Delete (若有移到 Glacier 要把刪除的日期設為 90 天以上，因為 Glacier 費用低消是 90 days)</li>
</ul>
</li>
</ul>
<h2 id="CloudFront"><a href="#CloudFront" class="headerlink" title="CloudFront"></a>CloudFront</h2><ul>
<li><p>Edge Location: This is the location where content will be cached. This is separate to an AWS Region/AZ.</p>
</li>
<li><p>Origin: This is the origin of all the files that the CDN will distribute. This can be either an S3 bucket, an EC2 instance, an Elastic Load Balancer or Route53.</p>
</li>
<li><p>Distribution: This is the name given the CDN which consists of a collection of Edge Locations.</p>
<ul>
<li><strong>Web Distribution</strong>: Typically used for websites.</li>
<li><strong>RTMP</strong>: Used for media streaming. (ex: Adobe Flash)</li>
</ul>
</li>
<li><p>Edge Locations are <strong>not just READ only</strong>, you can write to them too. (ie. put an object on to them).</p>
</li>
<li><p>Objects are cached for the life of the TTL (Time to Live)</p>
</li>
<li><p>You can clear cached objects, but you will be charged. (不需要等到 TTL 結束)</p>
</li>
</ul>
<h2 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h2><ul>
<li><p>By default, all newly created buckets are <strong>PRIVATE</strong></p>
</li>
<li><p>You can setup access control to your buckets using:</p>
<ul>
<li>Bucket Policies</li>
<li>Access Control Lists (可調整個別 object 的權限)</li>
</ul>
</li>
<li><p>S3 buckets can be configured to create access logs which log all requests made to the S3 buckets. This can be done to another bucket. (也可以將 log 放到另一個 AWS 帳號 S3 bucket 中，需要進行跨帳號連結的設定) </p>
</li>
</ul>
<h2 id="Encryption-1"><a href="#Encryption-1" class="headerlink" title="Encryption"></a>Encryption</h2><h3 id="1-In-Transit-SSL-TLS"><a href="#1-In-Transit-SSL-TLS" class="headerlink" title="1. In Transit (SSL/TLS)"></a>1. In Transit (SSL/TLS)</h3><h3 id="2-At-Rest-1"><a href="#2-At-Rest-1" class="headerlink" title="2. At Rest"></a>2. At Rest</h3><ul>
<li><p>Server Side Encryption</p>
<ul>
<li>S3 Managed Keys (<code>SSE-S3</code>)</li>
<li>AWS Key Management Service, Managed Keys (<code>SSE-KMS</code>)</li>
<li>Server Side Encryption with Customer Provided Keys (<code>SSE-C</code>)</li>
</ul>
</li>
<li><p>Client Side Encryption</p>
</li>
</ul>
<h2 id="Storage-Gateway"><a href="#Storage-Gateway" class="headerlink" title="Storage Gateway"></a>Storage Gateway</h2><ul>
<li><p><strong>File Gateway</strong>: For flat files, stored directly on S3</p>
</li>
<li><p><strong>Volume Gateway</strong></p>
<ul>
<li><strong>Stored Volumes</strong> - Entire Dataset is stored on site and is asynchronously backed up to S3.</li>
<li><strong>Cached Volumes</strong> - Entire Dataset is stored on S3 and the most frequently accessed data is cached on site.</li>
</ul>
</li>
<li><p><strong>Gateway Virtual Tape Library (VTL)</strong>: Used for backup and uses popular backup applications like NetBackup, Backup Exec, Veam etc</p>
</li>
</ul>
<h2 id="Snowball"><a href="#Snowball" class="headerlink" title="Snowball"></a>Snowball</h2><ul>
<li><p>Snowball</p>
</li>
<li><p>Snowball Edge</p>
</li>
<li><p>Snowmobile</p>
</li>
<li><p>Understand what Snowball is</p>
</li>
<li><p>Understand what Import Export is</p>
</li>
<li><p>Snowball can</p>
<ul>
<li>Import to S3</li>
<li>Export from S3</li>
</ul>
</li>
</ul>
<h2 id="S3-Transfer-Acceleration-1"><a href="#S3-Transfer-Acceleration-1" class="headerlink" title="S3 Transfer Acceleration"></a>S3 Transfer Acceleration</h2><p>You can speed up transfers to S3 using S3 transfer acceleration. This cost extra, and has the greatest impact on people who are in far away location.</p>
<h2 id="S3-Static-Websites"><a href="#S3-Static-Websites" class="headerlink" title="S3 Static Websites"></a>S3 Static Websites</h2><ul>
<li><p>You can use S3 to hsot static websites</p>
</li>
<li><p>Serverless</p>
</li>
<li><p>Very cheap, scales automatically</p>
</li>
<li><p><strong>STATIC</strong> only, canonot host dynamic sites</p>
</li>
</ul>
<h2 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h2><ul>
<li><p>Write to S3 - HTTP 200 code for a successful write.</p>
</li>
<li><p>You can load files to S3 much faster by enabling multipart upload</p>
</li>
<li><p>Read the S3 FAQ before taking the exam. It comes up A LOT!</p>
</li>
</ul>
<p>##　Best Practices, Patterns,    and    Performance</p>
<ul>
<li><p>S3 &amp; Glacier 非常適合在 hybrid cloud 的環境下作為異地備份的工具</p>
</li>
<li><p>另一個常見的應用是將 S3 作為大量 blob 檔案的儲存位置，而把這些 blob 的 index 存於其他的服務(例如：Amazon DynamoDB or Amazon RDS)，透過此方式可以針對 key name 提高搜尋的速度並支援複雜的查詢</p>
</li>
<li><p>S3 會自動 scale 來支援 high request rate，也會自動的根據需求針對 bucket 進行 repartition 的動作</p>
</li>
<li><p>若有每秒超過 100 個 reuqest 的需求，可參考 developer guide 中的資訊，讓 object key 可以隨機的分佈 (可透過像是使用 hash 值作為 key name prefix 的方式來達成)</p>
</li>
</ul>
<h1 id="應考前建議"><a href="#應考前建議" class="headerlink" title="應考前建議"></a>應考前建議</h1><p>詳細閱讀下列資料：</p>
<ul>
<li><a href="https://aws.amazon.com/s3/faqs/" target="_blank" rel="noopener">Amazon Simple Storage Service (S3) FAQs</a> <a href="https://aws.amazon.com/tw/s3/faqs/" target="_blank" rel="noopener">(中文)</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> AWS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AWS </tag>
            
            <tag> S3 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[AWS 學習筆記 - IAM(Identity and Access Management)]]></title>
      <url>/blog/2017/05/02/AWS/AWS-Learning-Notes-IAM/</url>
      <content type="html"><![CDATA[<h1 id="What-is-IAM"><a href="#What-is-IAM" class="headerlink" title="What is IAM?"></a>What is IAM?</h1><p>AWS Identity and Access Management (IAM) enables you to securely control access to AWS services and resources for your users. Using IAM, you can create and manage AWS users and groups, and use permissions to allow and deny their access to AWS resources. </p>
<p>IAM is a feature of your AWS account offered at no additional charge. You will be charged only for use of other AWS services by your users.</p>
<h1 id="What-does-IAM-give-you"><a href="#What-does-IAM-give-you" class="headerlink" title="What does IAM give you?"></a>What does IAM give you?</h1><ul>
<li><p>Centralized control of your AWS account</p>
</li>
<li><p>Shared Access to your AWS account</p>
<blockquote>
<p>可以分享權限到其他帳號去</p>
</blockquote>
</li>
<li><p>Granular Permissions</p>
<blockquote>
<p>可以針對每個帳號可存取的資源權限進行很細部的控制，例如<strong>限制某人只能對 DynamoDB 進行唯讀的存取</strong></p>
</blockquote>
</li>
<li><p>Identity Federation(including Active Directory, Facebook, Linkedin etc)</p>
<blockquote>
<p>可以透過其他服務(AD, Facebook, Linkedin etc)的帳號透過 SSO 登入 AWS</p>
</blockquote>
</li>
<li><p>Multifactor Authentication</p>
<blockquote>
<p>AWS 建議為每個帳號都設定 multifactor authentication</p>
</blockquote>
</li>
<li><p>Provide temporary access for users/devices and services where necessary</p>
</li>
<li><p>Allows you to set up your own password rotation policy</p>
</li>
<li><p>Integrates with many different AWS services</p>
</li>
<li><p>Supports PCI DSS(Payment Card Industry Data Security Standards) Compliance</p>
<blockquote>
<p>PCI DSS(支付卡產業資料安全標準)是在整合外部付費服務之用，為了提升線上支付的安全性</p>
</blockquote>
</li>
</ul>
<h1 id="Critical-Terms"><a href="#Critical-Terms" class="headerlink" title="Critical Terms"></a>Critical Terms</h1><ul>
<li><p><strong>Users</strong> - End Users(think people)</p>
</li>
<li><p><strong>Group</strong> - A collection of userss under one set of permissions.</p>
<blockquote>
<p>A way to group our users and apply policies to them collectively</p>
</blockquote>
</li>
<li><p><strong>Roles</strong> - You create roles and can then assign them to AWS resources</p>
</li>
<li><p><strong>Policies</strong> - A document that defined one(or more permission)</p>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"Version"</span>: <span class="string">"2012-10-17"</span>,</span><br><span class="line">  <span class="attr">"Statement"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"Effect"</span>: <span class="string">"Allow"</span>,</span><br><span class="line">      <span class="attr">"Action"</span>: <span class="string">"s3:*"</span>,</span><br><span class="line">      <span class="attr">"Resource"</span>: <span class="string">"*"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="學習筆記"><a href="#學習筆記" class="headerlink" title="學習筆記"></a>學習筆記</h1><h2 id="IAM-is-global-universal"><a href="#IAM-is-global-universal" class="headerlink" title="IAM is global(universal)"></a>IAM is global(universal)</h2><p>從 management console 進入 IAM 的功能頁面後，Region 的部份會變成 <code>global</code>，表示 IAM 只需要設定一次，這個設定就可以用來套用到使用者在全球所有 region 中的 resource</p>
<h3 id="IAM-users-sign-in-link"><a href="#IAM-users-sign-in-link" class="headerlink" title="IAM users sign-in link"></a>IAM users sign-in link</h3><p><img src="http://etutorialsworld.com/wp-content/uploads/2016/05/72.22BAWS2BIAM2BDashboard-1.png" alt="IAM users sign-in link"></p>
<ol>
<li><p>這是用來提供給其他使用者存取 AWS resource 之用，並非 root account，需要注意一下!</p>
</li>
<li><p>網址是動態產生的，可以透過 <strong>Customize</strong> 的 link 設定別名以方便記憶</p>
</li>
</ol>
<h2 id="Security-Status"><a href="#Security-Status" class="headerlink" title="Security Status"></a>Security Status</h2><h3 id="1-Delete-your-root-access-keys"><a href="#1-Delete-your-root-access-keys" class="headerlink" title="(1) Delete your root access keys"></a>(1) Delete your root access keys</h3><p>AWS 建議儘量不要用 root account 進行資源的存取；正確的作法應該新增使用者，並為使用者設定所需要的資源存取權限。</p>
<p>例如：一開始我在 root account 加了一把 access key，在這個部份就無法 pass 檢查了</p>
<h3 id="2-Activate-MFA-on-your-root-account"><a href="#2-Activate-MFA-on-your-root-account" class="headerlink" title="(2) Activate MFA on your root account"></a>(2) Activate MFA on your root account</h3><p>選擇 <code>A virtual MFA device</code> 作為 MFA device type(Hardware 是要花錢買的)，接著可以選用 <code>Google Authenticator</code> 作為接收驗證碼之用。</p>
<p>在 Google Authenticator 中可以設定很多個要用來作 MFA 的帳號，當然也就可以把 AWS IAM 設定進來。</p>
<p>透過掃描 barcode 的方式，手機上會一直出現 random 的啟用碼(要等一下)，輸入兩個就可以用來啟用 AWS IAM MFA 了。</p>
<h3 id="3-Create-individual-IAM-users"><a href="#3-Create-individual-IAM-users" class="headerlink" title="(3) Create individual IAM users"></a>(3) Create individual IAM users</h3><p>在建立 user 時，有幾點需要注意一下：</p>
<ul>
<li><p><strong>Access type</strong>：勾選 <code>Programmatic access</code> 才可以用這個帳號搭配 AWS API, CLI, SDK …. 等其他開發工具來存取 AWS 的資源；勾選 <code>AWS Management Console access</code> 才可以透過密碼登入的方式進入 AWS Management console</p>
</li>
<li><p>可在此時順便建立 or 指定特定的 group，也可以順便指定 policy 來設定權限</p>
<blockquote>
<p>policy 並非 group 專屬，也可以 attach 到單一 user</p>
</blockquote>
</li>
<li><p>建立完成的 user(若有勾選 <strong>Programmatic access</strong>) 會得到 <code>Access key ID</code> &amp; <code>Secret access key</code>，這是開發用來存取 AWS 資源的程式需要的資訊</p>
</li>
</ul>
<h3 id="4-Use-groups-to-assign-permissions"><a href="#4-Use-groups-to-assign-permissions" class="headerlink" title="(4) Use groups to assign permissions"></a>(4) Use groups to assign permissions</h3><p>目前 AWS 已經提供了很多內建的權限清單可以用，例如：S3 唯讀, Glacier 唯讀….等等，但目前還不確定能不能自訂權限的選項。。</p>
<h3 id="5-Apply-an-IAM-password-policy"><a href="#5-Apply-an-IAM-password-policy" class="headerlink" title="(5) Apply an IAM password policy"></a>(5) Apply an IAM password policy</h3><p>這沒什麼特別，就是設定密碼的規則….(長度, rotation period…等等)</p>
<h2 id="Add-Role"><a href="#Add-Role" class="headerlink" title="Add Role"></a>Add Role</h2><h3 id="1-Role-Type"><a href="#1-Role-Type" class="headerlink" title="(1) Role Type"></a>(1) Role Type</h3><ul>
<li><p><strong>AWS Service Role</strong>: 用來指定 AWS 上面的特定 service</p>
<blockquote>
<p>這可以設定的非常細，例如：只讓 EC2 對 S3 完全存取，無其他 service 的存取權限</p>
</blockquote>
</li>
<li><p><strong>Role for Cross-Account Access</strong>: 可以用來讓特定帳號去存取其他帳號的 management console</p>
</li>
<li><p><strong>Role for Identity Provider Access</strong>: 作 SSO, 整合 FB, Linkedin 帳號時才會用到的部份</p>
</li>
</ul>
<h3 id="2-Attach-Policy"><a href="#2-Attach-Policy" class="headerlink" title="(2) Attach Policy"></a>(2) Attach Policy</h3><h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><ul>
<li><p>IAM is universal. It does not apply to regions at this time.</p>
</li>
<li><p>The <strong>root account</strong> is simplely the account created when first setup your AWS account. It has complete Admin access.</p>
</li>
<li><p>New Users have <strong>NO</strong> permissions when first created.</p>
</li>
<li><p>New Users are assigned <strong>Access Key ID</strong> &amp; <strong>Secrect Access Keys</strong> when first created.</p>
</li>
<li><p>These are not the same as a password, and you cannot use the Access Key ID &amp; Secret Access Key to Login in to the console. You can use this to access AWS via the APIs, SDK and Command Line however.</p>
</li>
<li><p>You only get to view these once. If you lose them, you have to regenerate them. So save them in a secure location.</p>
</li>
<li><p>Always setup Multifactor Authentication on your root account.</p>
</li>
<li><p>You can create and customize your own password rotation policies.</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> AWS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AWS </tag>
            
            <tag> IAM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Linux KVM] Template & Snapshot 的運用]]></title>
      <url>/blog/2017/01/01/KVM/KVM-Template-And-Snapshot/</url>
      <content type="html"><![CDATA[<p>此篇文章介紹如何使用 KVM 中的 template &amp; snapshot 功能</p>
<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>虛擬化技術有些非常吸引人使用的特性，例如：</p>
<ul>
<li><p>Fast Provisioning</p>
</li>
<li><p>Snapshots</p>
</li>
<li><p>不複雜的 backup &amp; recovery 方式</p>
</li>
</ul>
<p>以上這些特性都不是在實體環境上容易實現的，但透過 KVM 中的 template，可以實現 fast provisioning，而透過 snapshot 則可簡單實現 backup &amp; recovery。</p>
<hr>
<h1 id="VM-Templates"><a href="#VM-Templates" class="headerlink" title="VM Templates"></a>VM Templates</h1><p>template 有別於一般的 VM clone，clone 只是從其他 VM 複製成另外一個完整的 VM；而 template 則是可以作為其他 VM 的 master copy，並用來產生很多個 clone</p>
<h2 id="建立-template"><a href="#建立-template" class="headerlink" title="建立 template"></a>建立 template</h2><p>template 是由以存在的 VM 所轉換過來的，因此在建立 template 之前，我們必須先完成以下步驟：</p>
<ol>
<li><p>安裝 &amp; 設定 VM，確認上面已經安裝所需要的所有軟體套件</p>
</li>
<li><p>移除所有系統特定的設定，確保只與此 VM 相關的設定(例如：固定 IP)不會被複製到其他 VM 上</p>
</li>
<li><p>修改 VM 名稱讓其容易辨識，例如以 <strong>template</strong> 作為開頭</p>
</li>
</ol>
<h3 id="1-建立-Centos-Template"><a href="#1-建立-Centos-Template" class="headerlink" title="(1) 建立 Centos Template"></a>(1) 建立 Centos Template</h3><p>要建立 Linux template，必須透過 <code>virt-sysprep</code> 工具的協助。</p>
<p>這工具由 <code>libguestfs-tools-s</code> 套件所提供，可以移除 VM 中系統特定的資訊，以便於轉換成 template 之用；此外也可以客製化 VM，例如加上 SSH Key、加入使用者、設定 Logo …. 等等。</p>
<p>輸入 <code>virt-prep --help</code> 可以知道 virt-sysprep 支援哪些調整選項：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@ocp-kvm-host ~]<span class="comment"># virt-sysprep -help</span></span><br><span class="line">virt-sysprep: reset or unconfigure a virtual machine so clones can be made</span><br><span class="line"></span><br><span class="line"> virt-sysprep [--options] -d domname</span><br><span class="line"></span><br><span class="line"> virt-sysprep [--options] -a disk.img [-a disk.img ...]</span><br><span class="line"></span><br><span class="line">A short summary of the options is given below.  For detailed <span class="built_in">help</span> please</span><br><span class="line"><span class="built_in">read</span> the man page virt-sysprep(1).</span><br><span class="line"></span><br><span class="line">  -a file                             Add disk image file</span><br><span class="line">  --add file                          Add disk image file</span><br><span class="line">  -c uri                              Set libvirt URI</span><br><span class="line">  --chmod PERMISSIONS:FILE            Change the permissions of a file</span><br><span class="line">  --connect uri                       Set libvirt URI</span><br><span class="line">  -d domain                           Set libvirt guest name</span><br><span class="line">  --debug-gc                          Debug GC and memory allocations (internal)</span><br><span class="line">  --delete PATH                       Delete a file or directory</span><br><span class="line">  --domain domain                     Set libvirt guest name</span><br><span class="line">  --dry-run                           Perform a dry run</span><br><span class="line">  --dryrun                            Perform a dry run</span><br><span class="line">  --dump-pod                          Dump POD (internal)</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>
<p>從 help 中的說明可以看出，virt-sysprep 有兩個參數分別是 <code>-d</code> &amp; <code>-a</code>，其中 <code>-d</code> 所處理的對象是 VM，而 <code>-a</code> 所處理的對象則是獨立的 virtual disk。</p>
<p>以下使用對 VM 為範例來操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@ocp-kvm-host ~]<span class="comment"># virsh list --all</span></span><br><span class="line"> Id    Name                           State</span><br><span class="line">----------------------------------------------------</span><br><span class="line"> -     centos7                        shut off</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">[root@ocp-kvm-host ~]<span class="comment"># virt-sysprep -d centos7</span></span><br><span class="line">[   0.0] Examining the guest ...</span><br><span class="line">[  43.0] Performing <span class="string">"abrt-data"</span> ...</span><br><span class="line">[  43.0] Performing <span class="string">"bash-history"</span> ...</span><br><span class="line">........</span><br><span class="line">[  43.0] Performing <span class="string">"udev-persistent-net"</span> ...</span><br><span class="line">[  43.0] Performing <span class="string">"utmp"</span> ...</span><br><span class="line">[  43.0] Performing <span class="string">"yum-uuid"</span> ...</span><br><span class="line">[  43.0] Performing <span class="string">"customize"</span> ...</span><br><span class="line">[  43.0] Setting a random seed</span><br><span class="line">[  43.0] Performing <span class="string">"lvm-uuids"</span> ...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>到此步驟時，VM template 已經準備完成；還有一點更重要的是，<strong>不要再啟動 template VM</strong>，否則將會失去之前 virt-sysprep 所完成的結果，甚至有可能會在使用 thin method(參考下方) 產生 VM 時發生問題 </p>
</blockquote>
<h3 id="2-建立-Windows-Template"><a href="#2-建立-Windows-Template" class="headerlink" title="(2) 建立 Windows Template"></a>(2) 建立 Windows Template</h3><p>要製作 template，可以透過 <code>virt-clone</code> + <code>virt-sysprep</code> 的方式</p>
<p>要透過 template 建立新的 VM，有以下兩種方式可以進行：</p>
<h2 id="透過-template-佈署-VM"><a href="#透過-template-佈署-VM" class="headerlink" title="透過 template 佈署 VM"></a>透過 template 佈署 VM</h2><ol>
<li><p><strong>thin method</strong></p>
<blockquote>
<p>此方式會以 template image 為 base image以 read-only(template VM image) 搭配 copy-on-write(新的 VM) 來處理，所需要的磁碟空間比較小，但需要確保 base image 可以被存取</p>
</blockquote>
</li>
<li><p><strong>clone method</strong></p>
<blockquote>
<p>此方式會完整複製一份 template image 作為 新 VM 的 image，會消耗較多的磁碟空間，但可以完全獨立不依賴原本的 base image</p>
</blockquote>
</li>
</ol>
<hr>
<h1 id="Snapshots"><a href="#Snapshots" class="headerlink" title="Snapshots"></a>Snapshots</h1><p>snapshot 是以檔案為基礎，用來表示 VM 在某個特定時間點的狀態，包含了相關設定檔 &amp; disk 資料；而透過 snapshot，管理者可以隨時將 VM 還原到當時建立 snapshot 時的狀態，而這功能在進行對於 VM 要進行重大變更前時特別好用。</p>
<p>此外，libvirt 還提供了 live snapshot 的功能，可以針對執行中的 VM 進行 snapshot，但這功能不建議使用在 I/O 工作頻繁的 VM 上，建議這類的 VM 還是 shutdown or suspend 之後再來做 snapshot 會較好。</p>
<p>libvirt 支援兩種 snapshop，分別如下：</p>
<h3 id="internal-snapshot"><a href="#internal-snapshot" class="headerlink" title="internal snapshot"></a>internal snapshot</h3><p>internal snapshot 的 snapshot 資訊會存在於同一個 qcow2 檔案中(before/after snapshot bit)，有以下的限制需要注意：</p>
<ul>
<li><p>僅支援 qcow2 format</p>
</li>
<li><p>當建立 snapshot 時，VM 會進入暫停狀態</p>
</li>
<li><p>無法使用在 LVM storage pool 上</p>
</li>
</ul>
<h3 id="external-snapshot"><a href="#external-snapshot" class="headerlink" title="external snapshot"></a>external snapshot</h3><p>external snapshot 是以 copy-on-write 的概念進行的，當 VM 進行 snapshot 後，system disk 就會進入 read-only 的模式，後續 VM guest 新增的資料就會放在 overlay disk image 上，以下有個圖示來說明：</p>
<p><img src="https://github.com/godleon/godleon.github.io/blob/master/_posts/images/2017/KVM-Template-And-Snapshot/copy-on-write_overlay-disk0-image.png?raw=true" alt="copy-on-write overlay disk image"></p>
<p>external snapshot 也有以下特點：</p>
<ol>
<li><p>overlay disk image 的起始大小為 0，最大可以到 original disk 的大小</p>
</li>
<li><p>base disk 可以是任何的格式(例如：raw, qcow2, 或是其他 libvirt 支援的格式)</p>
</li>
<li><p>overlay disk image 一定是 qcow2 格式</p>
</li>
</ol>
<h2 id="VM-Disk-Image-Format"><a href="#VM-Disk-Image-Format" class="headerlink" title="VM Disk Image Format"></a>VM Disk Image Format</h2><p>libvirt 支援很多種不同的 disk foramt，包含 iso, dmg, qcow2, raw, vmdk, vpc … 等等，但與 libvirt 搭配起來運作的最好的是 <strong>raw</strong> &amp; <strong>qcow2</strong> 兩種：</p>
<h3 id="1-raw"><a href="#1-raw" class="headerlink" title="(1) raw"></a>(1) <strong>raw</strong></h3><ul>
<li><p>效能最佳，performace overhead 最低，適合給有高度 I/O 需求的 VM 使用</p>
</li>
<li><p>完全佔據 disk 所指定的空間</p>
</li>
<li><p>沒有 snapshot &amp; compression 的功能</p>
</li>
</ul>
<h3 id="2-qcow2"><a href="#2-qcow2" class="headerlink" title="(2) qcow2"></a>(2) <strong>qcow2</strong></h3><ul>
<li><p>完全以 cloud 架構出發所設計的格式</p>
</li>
<li><p>支援 read-only backing、snapshot、compression、encryption、pre-allocation … 等功能</p>
</li>
</ul>
<h2 id="轉換-Disk-Image-Format"><a href="#轉換-Disk-Image-Format" class="headerlink" title="轉換 Disk Image Format"></a>轉換 Disk Image Format</h2><p>以下介紹如何透過 <code>qemu-img</code> 指令在 <strong>raw</strong> &amp; <strong>qcow2</strong> 之間進行轉換：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># raw -&gt; qcow2</span></span><br><span class="line">$ qemu-img convert -f raw -O qcow2 vm_disk.img vm_disk.qcow2</span><br><span class="line"></span><br><span class="line"><span class="comment"># qcow2 -&gt; raw</span></span><br><span class="line">$ qemu-img convert -f qcow2 -O ram vm_disk.qcow2 vm_disk.img</span><br></pre></td></tr></table></figure>
<h2 id="操作-Internal-Snapshot"><a href="#操作-Internal-Snapshot" class="headerlink" title="操作 Internal Snapshot"></a>操作 Internal Snapshot</h2><h3 id="1-建立-amp-檢視-snapshot"><a href="#1-建立-amp-檢視-snapshot" class="headerlink" title="(1) 建立 &amp; 檢視 snapshot"></a>(1) 建立 &amp; 檢視 snapshot</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">$ virsh snapshot-list rhel7.3</span><br><span class="line"> Name                 Creation Time             State</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 internal snapshot</span></span><br><span class="line">$ virsh snapshot-create rhel7.3</span><br><span class="line">Domain snapshot 1481514143 created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 internal snapshot (使用 snapshot-create-as 搭配 --name, --description 等參數)</span></span><br><span class="line"><span class="comment"># --atomic 可以確保 snapshot 是可以用的 (若是 snapshot 無法使用，建立時就會 fail)</span></span><br><span class="line">$ virsh snapshot-create-as rhel7.3 --name <span class="string">"rhel7.3_snapshot_1"</span> --description <span class="string">"First named snapshot"</span> --atomic</span><br><span class="line">Domain snapshot rhel7.3_snapshot_1 created</span><br><span class="line"></span><br><span class="line">$ virsh snapshot-list rhel7.3</span><br><span class="line"> Name                 Creation Time             State</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"> 1481514143           2016-12-12 11:42:23 +0800 shutoff</span><br><span class="line"> rhel7.3_snapshot_1   2016-12-14 08:32:23 +0800 shutoff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示 snapshot 資訊</span></span><br><span class="line">$ virsh snapshot-info rhel7.3 --snapshotname 1481514143</span><br><span class="line">Name:           1481514143</span><br><span class="line">Domain:         rhel7.3</span><br><span class="line">Current:        no</span><br><span class="line">State:          shutoff</span><br><span class="line">Location:       internal</span><br><span class="line">Parent:         -</span><br><span class="line">Children:       1</span><br><span class="line">Descendants:    1</span><br><span class="line">Metadata:       yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視指定 VM 的 current snapshot 資訊</span></span><br><span class="line">$ virsh snapshot-current rhel7.3</span><br><span class="line">&lt;domainsnapshot&gt;</span><br><span class="line">  &lt;name&gt;rhel7.3_snapshot_1&lt;/name&gt;</span><br><span class="line">  &lt;description&gt;First named snapshot&lt;/description&gt;</span><br><span class="line">  &lt;state&gt;shutoff&lt;/state&gt;</span><br><span class="line">  &lt;parent&gt;</span><br><span class="line">    &lt;name&gt;1481514143&lt;/name&gt;</span><br><span class="line">  &lt;/parent&gt;</span><br><span class="line">  &lt;creationTime&gt;1481675543&lt;/creationTime&gt;</span><br><span class="line">  &lt;memory snapshot=<span class="string">'no'</span>/&gt;</span><br><span class="line">  &lt;disks&gt;</span><br><span class="line">    &lt;disk name=<span class="string">'vda'</span> snapshot=<span class="string">'internal'</span>/&gt;</span><br><span class="line">  &lt;/disks&gt;</span><br><span class="line">  &lt;domain <span class="built_in">type</span>=<span class="string">'kvm'</span>&gt;</span><br><span class="line">    ....</span><br><span class="line">  &lt;/domain&gt;</span><br><span class="line">&lt;/domainsnapshot&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示 snapshot XML 資訊</span></span><br><span class="line">$ virsh snapshot-dumpxml rhel7.3 --snapshotname 1481514143</span><br><span class="line">&lt;domainsnapshot&gt;</span><br><span class="line">  .... 與上面類似</span><br><span class="line">&lt;/domainsnapshot&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示 snapshot 的 parent snapshot (第一個 snapshot 沒有 parent snapshot)</span></span><br><span class="line">$ virsh snapshot-parent rhel7.3 --snapshotname 1481514143</span><br><span class="line">error: snapshot <span class="string">'1481514143'</span> has no parent</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二個 snapshot 就有 parent snapshot 了</span></span><br><span class="line">$ virsh snapshot-parent rhel7.3 --snapshotname rhel7.3_snapshot_1</span><br><span class="line">1481514143</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示每個 snapshot 的 parent</span></span><br><span class="line">$ virsh snapshot-list rhel7.3 --parent</span><br><span class="line"> Name                 Creation Time             State           Parent</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"> 1481514143           2016-12-12 11:42:23 +0800 shutoff         (null)</span><br><span class="line"> rhel7.3_snapshot_1   2016-12-14 08:32:23 +0800 shutoff         1481514143</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以樹狀結構顯示每個 snapshot 的關係</span></span><br><span class="line">$ virsh snapshot-list rhel7.3 --tree</span><br><span class="line">1481514143</span><br><span class="line">  |</span><br><span class="line">  +- rhel7.3_snapshot_1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>若是在 VM 正在 running 的狀態下建立 snapshot，會需要多花一點時間，因為 VM 必須先進入到 <strong>pause</strong> 的狀態，當 snapshot 完成後才會回到 running 的狀態；而這一段時間的長短取決於 VM 當時耗用了多少記憶體，以及當時對記憶體存取的頻繁程度。</p>
</blockquote>
<p>另外還可以透過 <code>qemu-image</code> 工具來查詢 VM image 的狀態：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查詢 image 的狀態</span></span><br><span class="line">$ qemu-img info /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.qcow2 </span><br><span class="line">image: /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.qcow2</span><br><span class="line">file format: qcow2</span><br><span class="line">virtual size: 40G (42949672960 bytes)</span><br><span class="line">disk size: 572M</span><br><span class="line">cluster_size: 65536</span><br><span class="line">Snapshot list:</span><br><span class="line">ID        TAG                 VM SIZE                DATE       VM CLOCK</span><br><span class="line">1         1481514143                0 2016-12-12 11:42:23   00:00:00.000</span><br><span class="line">2         rhel7.3_snapshot_1        0 2016-12-14 08:32:23   00:00:00.000</span><br><span class="line">Format specific information:</span><br><span class="line">    compat: 0.10</span><br><span class="line">    refcount bits: 16</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢查 image 是否有錯誤</span></span><br><span class="line"><span class="comment"># 適合用在 running 過程中建立 snapshot 後，檢查有無錯誤發生</span></span><br><span class="line">$ qemu-img check /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.qcow2 </span><br><span class="line">No errors were found on the image.</span><br><span class="line">19467/655360 = 2.97% allocated, 93.71% fragmented, 90.63% compressed clusters</span><br><span class="line">Image end offset: 599916544</span><br></pre></td></tr></table></figure>
<h3 id="2-透過-snapshot-還原-VM"><a href="#2-透過-snapshot-還原-VM" class="headerlink" title="(2) 透過 snapshot 還原 VM"></a>(2) 透過 snapshot 還原 VM</h3><p>接著介紹如何透過 internal snapshot 還原 VM：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 從指定的 snapshot 還原 VM</span></span><br><span class="line">$ virsh snapshot-revert rhel7.3 --snapshotname rhel7.3_snapshot_1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 從指定的 snapshot 還原 &amp; 自動啟動 VM</span></span><br><span class="line">$ virsh snapshot-revert rhel7.3 --snapshotname rhel7.3_snapshot_1 --running</span><br></pre></td></tr></table></figure>
<h3 id="3-刪除-snapshot"><a href="#3-刪除-snapshot" class="headerlink" title="(3) 刪除 snapshot"></a>(3) 刪除 snapshot</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 刪除指定的 snapshot</span></span><br><span class="line">$ virsh snapshot-delete rhel7.3 1481514143</span><br><span class="line">Domain snapshot 1481514143 deleted</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示目前 snapshot 的狀態</span></span><br><span class="line">[root@ocp-kvm-host ~]<span class="comment"># virsh snapshot-list rhel7.3 --parent</span></span><br><span class="line"> Name                 Creation Time             State           Parent</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"> rhel7.3_snapshot_1   2016-12-14 08:32:23 +0800 shutoff         (null)</span><br></pre></td></tr></table></figure>
<h2 id="操作-External-Snapshot"><a href="#操作-External-Snapshot" class="headerlink" title="操作 External Snapshot"></a>操作 External Snapshot</h2><p>external snapshot 的原理是由 <code>overlay_image</code> &amp; <code>backing_file</code> 兩個所組成；其中 backing file 會變成 read-only，後續使用者針對 VM 的變更都會寫到 overlay_image 中。</p>
<p>而 external snapshot 比較有優勢的地方，在於支援各種不同的 disk image type(raw, qcow, vmdk … etc)，不僅有 qcow2 而已。</p>
<p>但由於目前 virsh 還不完全支援 external snapshot 的操作，這邊就先保留，等到 virsh 可以完整支援 external snapshot 之後再來補。</p>
<h3 id="1-建立-external-snapshot"><a href="#1-建立-external-snapshot" class="headerlink" title="(1) 建立 external snapshot"></a>(1) 建立 external snapshot</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ virsh list</span><br><span class="line"> Id    Name                           State</span><br><span class="line">----------------------------------------------------</span><br><span class="line"> 32    rhel7.3                        running</span><br><span class="line"></span><br><span class="line">$ virsh domblklist rhel7.3 --details</span><br><span class="line">Type       Device     Target     Source</span><br><span class="line">------------------------------------------------</span><br><span class="line">file       disk       vda        /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.qcow2</span><br><span class="line"></span><br><span class="line">$ virsh snapshot-create-as rhel7.3 ext_snapshot1 <span class="string">"first external snapshot"</span> --disk-only --atomic</span><br><span class="line">Domain snapshot ext_snapshot1 created</span><br><span class="line"></span><br><span class="line">$ virsh snapshot-list rhel7.3</span><br><span class="line">Name                 Creation Time             State</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">ext_snapshot1        2016-12-31 21:00:23 +0800 disk-snapshot</span><br><span class="line"></span><br><span class="line">$ virsh snapshot-info rhel7.3 ext_snapshot1</span><br><span class="line">Name:           ext_snapshot1</span><br><span class="line">Domain:         rhel7.3</span><br><span class="line">Current:        yes</span><br><span class="line">State:          disk-snapshot</span><br><span class="line">Location:       external</span><br><span class="line">Parent:         -</span><br><span class="line">Children:       0</span><br><span class="line">Descendants:    0</span><br><span class="line">Metadata:       yes</span><br></pre></td></tr></table></figure>
<p>利用上面的命令就可以建立 VM external snapshot；此外，還有幾點需要注意：</p>
<ol>
<li><p>external snapshot 可以在 VM running 的狀態下建立(若是 disk I/O 頻繁的 VM，建議還是 shutdown 之後再作)</p>
</li>
<li><p><code>--disk-only</code> 表示只針對 disk 作 snapshot</p>
</li>
<li><p><code>--atomic</code> 會確保 snapshot 建立的工作執行成功後會得到一個可用的 snapshot；若是中途發生任何問題，就不會有 snapshot 的產生，也不會對原有的 VM 產生任何異動，藉此確保建立 snapshot 不會損壞原有的 VM</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 檢視目前 VM disk 資訊</span></span><br><span class="line"><span class="comment"># 已經被 external disk 取代了!</span></span><br><span class="line">$ virsh domblklist rhel7.3 --details</span><br><span class="line">Type       Device     Target     Source</span><br><span class="line">------------------------------------------------</span><br><span class="line">file       disk       vda        /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot1</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 可看出原本的 disk 已經變成了 backing file</span></span><br><span class="line">$ qemu-img info /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot1</span><br><span class="line">image: /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot1</span><br><span class="line">file format: qcow2</span><br><span class="line">virtual size: 40G (42949672960 bytes)</span><br><span class="line">disk size: 2.0M</span><br><span class="line">cluster_size: 65536</span><br><span class="line">backing file: /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.qcow2</span><br><span class="line">backing file format: qcow2</span><br><span class="line">Format specific information:</span><br><span class="line">    compat: 1.1</span><br><span class="line">    lazy refcounts: <span class="literal">false</span></span><br><span class="line">    refcount bits: 16</span><br><span class="line">    corrupt: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>從上面可看出，從此刻開始對 VM 的變更將會直接寫入 external snapshot，而原本的 disk image 變成了 backing file。</p>
<p>接著再建立兩個 external snapshot 試試看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ virsh snapshot-create-as rhel7.3 ext_snapshot2 <span class="string">"second external snapshot"</span> --disk-only --atomic</span><br><span class="line">Domain snapshot ext_snapshot2 created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過 "--quiesce" 參數，確保連同記憶體內的資訊都一併進入到 snapshot 中</span></span><br><span class="line">$ virsh snapshot-create-as rhel7.3 ext_snapshot3 <span class="string">"third external snapshot"</span> --disk-only --quiesce</span><br><span class="line">Domain snapshot ext_snapshot3 created</span><br><span class="line"></span><br><span class="line">$ virsh snapshot-list rhel7.3</span><br><span class="line"> Name                 Creation Time             State</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"> ext_snapshot1        2016-12-31 21:00:23 +0800 disk-snapshot</span><br><span class="line"> ext_snapshot2        2016-12-31 22:16:42 +0800 disk-snapshot</span><br><span class="line"> ext_snapshot3        2016-12-31 22:17:53 +0800 disk-snapshot</span><br></pre></td></tr></table></figure>
<p>在第三個 snapshot 中使用了 <code>--quiesce</code> 參數，目的就是要讓尚未寫入 disk(記憶體中的資料) 一併進入到 snapshot 中，這樣就可以確保 snapshot 是最完整的狀態，但要使用這參數必須預先在 VM 上安裝 <code>qemu-guest agent</code> 才可以。</p>
<p>最後，每個 snapshot 的相依性可以使用下列命令觀察：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ qemu-img info --backing-chain /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot3 | grep backing</span><br><span class="line">backing file: /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot2</span><br><span class="line">backing file format: qcow2</span><br><span class="line">backing file: /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot1</span><br><span class="line">backing file format: qcow2</span><br><span class="line">backing file: /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.qcow2</span><br><span class="line">backing file format: qcow2</span><br></pre></td></tr></table></figure>
<h3 id="2-從-external-snapshot-還原"><a href="#2-從-external-snapshot-還原" class="headerlink" title="(2) 從 external snapshot 還原"></a>(2) 從 external snapshot 還原</h3><p>external snapshot 看似不錯，但其實無法透過 virsh 指令直接還原 VM：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ virsh snapshot-revert rhel7.3 --snapshotname <span class="string">"ext_snapshot3"</span></span><br><span class="line">error: unsupported configuration: revert to external snapshot not supported yet</span><br></pre></td></tr></table></figure>
<p>但這並不代表沒辦法從 external snapshot 還原，只是要透過以下步驟來完成：(假設要還原到 <code>ext_snapshot2</code>)</p>
<ol>
<li><p>關閉 VM (<strong>這是必須的!</strong>)</p>
</li>
<li><p>檢查要還原的 external snapshot overlay image 有無損毀</p>
</li>
<li><p>若 snapshot 完整無誤，編輯 VM XML 定義檔，將 boot disk 指向 <code>ext_snapshot2</code></p>
</li>
<li><p>確認 external snapshot image 格式</p>
</li>
<li><p>從 VM XML 定義中移除原本的 disk，改成指定要還原的 <code>ext_snapshot2</code></p>
</li>
<li><p>透過 <code>domblklist</code> 參數確認 VM 使用的 disk 已經指向 ext_snapshot2</p>
</li>
<li><p>重新啟動 VM</p>
</li>
</ol>
<p>以下是實際操作步驟：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 關閉 VM</span></span><br><span class="line">$ virsh shutdown rhel7.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取得 ext_snapshot2 的詳細路徑</span></span><br><span class="line">$ virsh snapshot-dumpxml rhel7.3 --snapshotname ext_snapshot2 | grep ext_snapshot2</span><br><span class="line">  &lt;name&gt;ext_snapshot2&lt;/name&gt;</span><br><span class="line">      &lt;<span class="built_in">source</span> file=<span class="string">'/var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot2'</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先使用 qemu-img 工具檢查 overlay image 有無損毀</span></span><br><span class="line">$ qemu-img check /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot2</span><br><span class="line">No errors were found on the image.</span><br><span class="line">11/655360 = 0.00% allocated, 36.36% fragmented, 0.00% compressed clusters</span><br><span class="line"></span><br><span class="line"><span class="comment"># 確認 overlay image 格式</span></span><br><span class="line">$ qemu-img info /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot2 | grep backing</span><br><span class="line">backing file: /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot1</span><br><span class="line">backing file format: qcow2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除原本的 disk</span></span><br><span class="line">$ virt-xml rhel7.3 --remove-device --disk target=vda</span><br><span class="line">Domain <span class="string">'rhel7.3'</span> defined successfully.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 換上要還原的 ext_snapshot2</span></span><br><span class="line">$ virt-xml rhel7.3 --add-device --disk /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot2,format=qcow2,bus=virtio</span><br><span class="line">Domain <span class="string">'rhel7.3'</span> defined successfully.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 確認目前 VM 所使用的 disk</span></span><br><span class="line">$ virsh domblklist rhel7.3</span><br><span class="line">Target     Source</span><br><span class="line">------------------------------------------------</span><br><span class="line">vda        /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新啟動 VM</span></span><br><span class="line">$ virsh start rhel7.3</span><br><span class="line">Domain rhel7.3 started</span><br></pre></td></tr></table></figure>
<h3 id="3-刪除-external-snapshot"><a href="#3-刪除-external-snapshot" class="headerlink" title="(3) 刪除 external snapshot"></a>(3) 刪除 external snapshot</h3><p>由於 virsh 不支援 external snapshot 的刪除，所以刪除 snapshot 就必須自己來了!</p>
<p>假設要移除所有的 snapshot，但又想要保留在 snapshot 上完整的變更，此時必須把 snapshot merge 到 base image 上，以下是操作步驟：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 目前 disk 所使用的 snapshot</span></span><br><span class="line">$ virsh domblklist rhel7.3</span><br><span class="line">Target     Source</span><br><span class="line">------------------------------------------------</span><br><span class="line">vda        /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢 snapshot overlay image 的相依關係</span></span><br><span class="line">$ qemu-img info --backing-chain /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot2 | grep backing</span><br><span class="line">backing file: /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot1</span><br><span class="line">backing file format: qcow2</span><br><span class="line">backing file: /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.qcow2</span><br><span class="line">backing file format: qcow2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將 base image &amp; snapshot overlay image 合併!</span></span><br><span class="line">$ virsh blockcommit rhel7.3 vda --verbose --pivot --active</span><br><span class="line">Block commit: [100 %]</span><br><span class="line">Successfully pivoted</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可看出 VM disk 已經變成 base image</span></span><br><span class="line">$ virsh domblklist rhel7.3</span><br><span class="line">Target     Source</span><br><span class="line">------------------------------------------------</span><br><span class="line">vda        /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.qcow2</span><br><span class="line"></span><br><span class="line">$ virsh snapshot-list rhel7.3</span><br><span class="line"> Name                 Creation Time             State</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"> ext_snapshot1        2016-12-31 21:00:23 +0800 disk-snapshot</span><br><span class="line"> ext_snapshot2        2016-12-31 22:16:42 +0800 disk-snapshot</span><br><span class="line"> ext_snapshot3        2016-12-31 22:17:53 +0800 disk-snapshot</span><br></pre></td></tr></table></figure>
<p>確認好 VM disk 已經不是指向 external snapshot 了，就可以開始進行刪除 snapshot 的動作，而刪除 external snapshot 必須從 metadata 下手，以下為操作範例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定刪除從 ext_snapshot1 開始的所有 children snapshot 的 metadata &amp; image</span></span><br><span class="line">$ virsh snapshot-delete rhel7.3 ext_snapshot1 --children --metadata</span><br><span class="line">Domain snapshot ext_snapshot1 deleted</span><br><span class="line"></span><br><span class="line"><span class="comment"># 確認所有 external snapshot 都已經被刪除</span></span><br><span class="line">$ virsh snapshot-list rhel7.3</span><br><span class="line"> Name                 Creation Time             State</span><br><span class="line">------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<h2 id="使用-snapshot-時所需的正確觀念"><a href="#使用-snapshot-時所需的正確觀念" class="headerlink" title="使用 snapshot 時所需的正確觀念"></a>使用 snapshot 時所需的正確觀念</h2><ol>
<li><p>不建議在 production 的環境中讓 VM 去 attach 之前做好的 snapshot 來使用</p>
</li>
<li><p>不要把 snapshot 當作是備份的方式，只是用來留下當時 VM 的狀態做後續使用而已</p>
</li>
<li><p>snapshot 不要保留太久，若確定不需要的就把 snapshot commit(for external snapshot) or 刪除</p>
</li>
<li><p>external snapshot 出現故障的機率比 internal snapshot 還低，因此建議優先使用 external snapshot</p>
</li>
<li><p>snapshot 數量要控制，太多的 snapshot 可能會倒置系統效能低落</p>
</li>
<li><p>建立 snapshot 前要先安裝 guest agent</p>
</li>
<li><p>建立 snapshot 確認都有帶上 <code>--quiesce</code> &amp;&amp; <code>--atomic</code> 兩個參數</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> KVM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> KVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Linux KVM] VM Life Cycle 管理]]></title>
      <url>/blog/2016/11/30/KVM/KVM-Lifecycle-Management/</url>
      <content type="html"><![CDATA[<p>此篇文章將會介紹 VM 生命周期管理、Qemu Guest Agent、Virtual Video Card、Graphic Server … 等主題。</p>
<h1 id="VM-Lifecycle"><a href="#VM-Lifecycle" class="headerlink" title="VM Lifecycle"></a>VM Lifecycle</h1><p>在 KVM 中的 virtual machine 共會有以下幾種狀態：</p>
<ul>
<li><p><strong>Undefined</strong>：未定義</p>
</li>
<li><p><strong>Defined / Shutoff</strong>：已定義，libvirtd 已經知道有此 VM 存在，但狀態為關機中(Stopped or Shutdown)</p>
</li>
<li><p><strong>Running</strong>：執行中</p>
</li>
<li><p><strong>Shutdown</strong>：關機中</p>
</li>
<li><p><strong>Paused</strong>：暫停中，VM 記憶體中的資料暫時被保留，並且可以在 guest OS 無法知悉的狀況下回復</p>
</li>
<li><p><strong>Saved</strong>：VM 處於完全暫停的狀態，記憶體中的資料被存到一般檔案中，並存在於 persistent storage (可回復到進行 save 時的狀態)</p>
</li>
<li><p><strong>Idle</strong>：等待 I/O，或是因為沒有工作需要進行而休眠中</p>
</li>
<li><p><strong>Crashed</strong>：可能因為 QEMU process 被強制移除 or core dump 所造成的 VM 損毀</p>
</li>
<li><p><strong>Dying</strong>：在 shutdown 的過程中失敗所產生的況狀</p>
</li>
<li><p><strong>Pmsuspended</strong>：透過 guest OS 中的電源管理功能進行 suspend 後進入的狀態</p>
</li>
</ul>
<p>有了上面概念後，可以透過 virsh 來檢視目前 domain(virtual machine) 的狀態：</p>
<hr>
<h1 id="檢視-VM"><a href="#檢視-VM" class="headerlink" title="檢視 VM"></a>檢視 VM</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 顯示所有 VM (包含關機中的)</span></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.3/system list --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示特定狀態的 VM</span></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.3/system list --state-[running|paused|shutoff|]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示(未)包含 snapshot 的 VM</span></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.3/system list --[with|without]-snapshot</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示(未)包含 managed save 狀態的 VM</span></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.3/system list --[with|without]-managed-save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 僅顯示 uuid or name</span></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.3/system list --[uuid|name]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>還有許多其他參數可用，使用者可透過 <code>virsh help</code> or <code>virsh help list</code> 來查詢更多使用方式</p>
</blockquote>
<hr>
<h1 id="操作-VM"><a href="#操作-VM" class="headerlink" title="操作 VM"></a>操作 VM</h1><p>了解 VM 有這麼多狀態之後，自然就會有相對應的操作了，virsh 提供以下幾項對 VM 的操作：</p>
<ul>
<li><p><strong>start</strong>：啟動 VM</p>
</li>
<li><p><strong>shutdown</strong>：關閉 VM (正常關機程序)</p>
</li>
<li><p><strong>reboot</strong>：重新啟動 VM</p>
</li>
<li><p><strong>reset</strong>：與 power cycle 相同效果</p>
</li>
<li><p><strong>save</strong>：將 VM 狀態儲存到檔案中，並關閉 VM</p>
</li>
<li><p><strong>restore</strong>：從指定的檔案將 VM 狀態回復為執行中</p>
</li>
<li><p><strong>suspend</strong>：暫停 VM 運作</p>
</li>
<li><p><strong>resume</strong>：回復 VM 運作</p>
</li>
<li><p><strong>destroy</strong>：直接刪除 QEMU process (類似直接拔掉電腦電源線的效果)</p>
</li>
<li><p><strong>create</strong>：使用指定的 XML 建立 VM，並啟動 VM</p>
</li>
<li><p><strong>define</strong>：使用指定的 XML 建立 VM，但不啟動 VM</p>
</li>
<li><p><strong>undefine</strong>：將 VM 從 libvird 的控制中移除</p>
</li>
</ul>
<hr>
<h1 id="QEMU-guest-agent"><a href="#QEMU-guest-agent" class="headerlink" title="QEMU guest agent"></a>QEMU guest agent</h1><p>在安裝 virtualbox or VMware 的 VM 時，安裝結束之後都會詢問要不要額外安裝 agent 在 guest VM 中，透過這個 agent，hypervisor 可以更有效率的管理每一個 VM；同樣的在 KVM 中，也是有相同的作法，稱為 <strong>QEMU guest agent</strong>。</p>
<p><strong>QEMU guest agent</strong> 是一個裝在 guest VM 中的套件，會以 service 的形式存在於背景，接著 service 就變成了 hypervisor &amp; guest OS 之間溝通的橋樑(channel)，hypervisor 會透過這個 channle 取得 VM 的資訊，以及對 VM 進行後續更多的操作；而兩者相互通訊的協定稱為 <strong>Qemu Machine Protocol(QMP)</strong>。</p>
<p>其中 Hypervisor 與 guest agent 是透過一個名稱為 <code>org.qemu.guest_agent.0</code> 的 virtio-serial channel 或是 isa-serial channel 來處理；而在 Hypervisor 這一端，相對應處理這些資訊交換的 socket file 則是存在於 <code>/var/lib/libvirt/qemu/channel/target</code> 目錄中，且同一個 socket file 可以同時被多個 VM 所共享，因此不會產生太多檔案。</p>
<p>若 guest VM 為 Linux，可安裝名稱為 <code>qemu-guest-agent</code> 的套件，若是 windows，則可以參考以下連結：</p>
<ul>
<li><p><a href="http://www.linux-kvm.org/page/WindowsGuestDrivers/Download_Drivers" target="_blank" rel="noopener">WindowsGuestDrivers/Download Drivers - KVM</a></p>
</li>
<li><p><a href="https://fedoraproject.org/wiki/Windows_Virtio_Drivers" target="_blank" rel="noopener">Windows Virtio Drivers - FedoraProject</a></p>
</li>
</ul>
<p>除了安裝 <code>qemu-guest-agent</code> 套件之外，還要確認 <code>qemu-guest-agent</code> service 是否有正確啟動：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl status qemu-guest-agent</span><br><span class="line">● qemu-guest-agent.service - QEMU Guest Agent</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/qemu-guest-agent.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Thu 2016-11-24 22:25:07 EST; 35min ago</span><br><span class="line">   ......</span><br></pre></td></tr></table></figure>
<p>確認服務沒有問題，我們就可以使用類似以下的命令在 KVM host 端取得 guest VM 的相關資訊：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ virsh qemu-agent-command &lt;GUEST_VM_NAME&gt; <span class="string">'&#123;"execute": "guest-info"&#125;'</span> --pretty</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"return"</span>: &#123;</span><br><span class="line">        <span class="string">"version"</span>: <span class="string">"2.3.0"</span>,</span><br><span class="line">        <span class="string">"supported_commands"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"enabled"</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">"name"</span>: <span class="string">"guest-get-memory-block-info"</span>,</span><br><span class="line">                <span class="string">"success-response"</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">.......</span><br></pre></td></tr></table></figure>
<blockquote>
<p>QMP 資料通訊使用 JSON format</p>
</blockquote>
<hr>
<h1 id="Virtual-Video-cards-amp-graphics"><a href="#Virtual-Video-cards-amp-graphics" class="headerlink" title="Virtual Video cards &amp; graphics"></a>Virtual Video cards &amp; graphics</h1><p>為了可以”看見” VM 的運作狀態，QEMU 需要提供兩個元素來達成這件任務：</p>
<ol>
<li><p><strong>virtual video card</strong>：讓每個 VM 都擁有一張虛擬的顯示卡</p>
</li>
<li><p>從遠端存取 VM 虛擬顯示卡的方式 or 協定</p>
</li>
</ol>
<h2 id="Virtual-Video-Card"><a href="#Virtual-Video-Card" class="headerlink" title="Virtual Video Card"></a>Virtual Video Card</h2><p>顯示卡的用途在於顯示圖形資料到顯示設備上，而虛擬顯示卡同樣也是為了這個目的而存在的。</p>
<p>然而在虛擬環境中當然沒有實體顯示卡，因此 QEMU 支援模擬以下幾種顯示卡：</p>
<ul>
<li><p><strong>Cirrus</strong>：libvirt 預設的顯示卡，可模擬 <strong>Cirrus Logic GD5446</strong> 顯示卡，Windows 95 之後的作業系統都支援這張顯示卡</p>
</li>
<li><p><strong>VGA</strong>：搭配 Bochs VBE extensions 的標準顯示卡，Windows XP 以後的作業系統可以支援(可設定 &gt;= 1280x1024x16 解析度 &amp; 大小的畫質)</p>
</li>
<li><p><strong>VMVGA</strong>：在 VGA 再更高階的虛擬顯示卡</p>
</li>
<li><p><strong>QXL</strong>：半虛擬化顯示卡，搭配在 VM 內安裝 QXL guest driver，可得到很不錯的顯示效果，而且是搭配 <strong>spice</strong> protocol 的最佳選擇</p>
</li>
</ul>
<p>在安裝 VM 時，libvirt 就會根據安裝的 OS，協助選擇一個最合適的顯示卡，通常安裝最近發佈的 OS，都會直接選配 QXL；若是 Windows 或是比較舊版的 Linux，可能就會使用 Cirrus。</p>
<h2 id="Graphics"><a href="#Graphics" class="headerlink" title="Graphics"></a>Graphics</h2><p>當 VM 有了顯示卡之後，接著需要一個可以存取圖形訊號的方法，在 KVM 中是透過 <strong>graphic server</strong> 的方式，目前提供了 <strong>VNC</strong> &amp; <em>*SPICE</em> 兩種 graphic server。</p>
<p>當 VM 確定好顯示卡之後，QEMU 就會啟動相對應的 Spice or VNC server，並與 VM 的顯示卡進行連接，以便讓外部的 client 可以使用圖形化的方式存取 VM。</p>
<h3 id="1-VNC"><a href="#1-VNC" class="headerlink" title="(1) VNC"></a>(1) VNC</h3><p>要為 VM 設定一個 VNC graphic server，可在 XML 定義檔中的 <code>&lt;device&gt;</code> section 內部加入類似以下的定義：(IP &amp; port 都可以自己定義)</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">graphics</span> <span class="attr">type</span>=<span class="string">'vnc'</span> <span class="attr">port</span>=<span class="string">'-1'</span> <span class="attr">autoport</span>=<span class="string">'yes'</span> <span class="attr">listen</span>=<span class="string">'192.168.122.1'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listen</span> <span class="attr">type</span>=<span class="string">'address'</span> <span class="attr">address</span>=<span class="string">'192.168.122.1'</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">graphics</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-SPICE"><a href="#2-SPICE" class="headerlink" title="(2) SPICE"></a>(2) SPICE</h3><p>SPICE(Simple Protocol for Independent Computing Environment) 僅有在 Linux 上支援，有以下特色：</p>
<ol>
<li><p>可以提供雙向的 audio</p>
</li>
<li><p>高效率的 2D 圖像繪製能力</p>
</li>
<li><p>可利用到 client 端的顯示卡的能力</p>
</li>
<li><p>支援加密、資料壓縮</p>
</li>
<li><p>支援透過網路的 USB passthrough</p>
</li>
</ol>
<p>因此若要規劃把 KVM 用在 VDI 的應用上，使用 <code>QXL</code> + <code>SPICE</code> 目前是最好的組合。</p>
<p>要為 VM 設定一個 SPICE graphic server，可在 XML 定義檔中的 <code>&lt;device&gt;</code> section 內部加入類似以下的定義：(IP &amp; port 都可以自己定義)</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">graphics</span> <span class="attr">type</span>=<span class="string">'spice'</span> <span class="attr">autoport</span>=<span class="string">'yes'</span> <span class="attr">listen</span>=<span class="string">'0.0.0.0'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listen</span> <span class="attr">type</span>=<span class="string">'address'</span> <span class="attr">address</span>=<span class="string">'0.0.0.0'</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">graphics</span>&gt;</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><p><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Virtualization_Administration_Guide/sect-QEMU_Guest_Agent-Running_the_QEMU_guest_agent_on_a_Windows_guest.html" target="_blank" rel="noopener">Virtualization Administration Guide &gt; Running the QEMU Guest Agent on a Windows Guest</a></p>
</li>
<li><p><a href="http://www.linux-kvm.org/page/WindowsGuestDrivers/Download_Drivers" target="_blank" rel="noopener">WindowsGuestDrivers/Download Drivers - KVM</a></p>
</li>
<li><p><a href="https://fedoraproject.org/wiki/Windows_Virtio_Drivers" target="_blank" rel="noopener">Windows Virtio Drivers - FedoraProject</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> KVM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> KVM </tag>
            
            <tag> SPICE </tag>
            
            <tag> VNC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Git] Cheat Sheet]]></title>
      <url>/blog/2016/11/08/Git/Git-Cheat-Sheets/</url>
      <content type="html"><![CDATA[<h1 id="The-Basics"><a href="#The-Basics" class="headerlink" title="The Basics"></a>The Basics</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a Git repository in the current folder.</span></span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># View the status of each file in a repository.</span></span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># Stage a file for the next commit.</span></span><br><span class="line">$ git add &lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Commit the staged files with a descriptive message.</span></span><br><span class="line">$ git commit</span><br><span class="line"></span><br><span class="line"><span class="comment"># View a repository’s commit history.</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以單行的方式顯示 git log (commit log)</span></span><br><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以單行的方式顯示與指定檔案相關的 git log</span></span><br><span class="line">$ git <span class="built_in">log</span> --oneline &lt;file_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 詳細列出所有 commit 的歷史紀錄</span></span><br><span class="line">$ git <span class="built_in">log</span> --graph --abbrev-commit --decorate --date=relative --all</span><br><span class="line">    </span><br><span class="line"><span class="comment"># Define the author name to be used in all repositories.</span></span><br><span class="line">$ git config --global user.name <span class="string">"&lt;name&gt;"</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># Define the author email to be used in all repositories. </span></span><br><span class="line">$ git config --global user.email &lt;email&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Undoing-Changes"><a href="#Undoing-Changes" class="headerlink" title="Undoing Changes"></a>Undoing Changes</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 將 HEAD 指標移到指定的 commit or tag(sha1_checksum_prefix 可由 "git log --oneline" 取得)</span></span><br><span class="line"><span class="comment"># 若 git log 沒有加上 "--all" 參數，就會看不到比 HEAD 更新的 commit snapshot</span></span><br><span class="line">$ git checkout &lt;commit-id | tag-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回到最新的 commit 紀錄("master" 會固定指向最新一筆 commit snapshot)</span></span><br><span class="line">$ git checkout master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 為目前最新的 commit 加上一個 annotated tag (通常 tag 用來作為正式 release 的標記用途)</span></span><br><span class="line">$ git tag -a &lt;tag-name&gt; -m <span class="string">"&lt;description&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出目前所有的 tag 紀錄</span></span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># undo 指定的 commit (重要! 這並非是回到特定 commit 的概念)</span></span><br><span class="line"><span class="comment"># 即使 commit 被 undo，其實歷史紀錄還是永遠保留著，這是 git 的特性</span></span><br><span class="line">$ git revert &lt;commit-id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消所有 tracked 的變更，回到最新的 commit (但不包含 untracked 的部分，例如：新增的檔案)</span></span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除 untracked files (與上一個指令搭配使用，此時應該回復到一個乾淨的 working directory，亦即為最新的 commit snapshot)</span></span><br><span class="line">$ git clean -f</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意 <code>git reset --hard</code> + <code>git clean -f</code> 的使用，是在 working directory 上生效，並不是在 commit snapshot 上，因此一旦 undo 之後，所有尚未 commit 的變更都會完全消失且無法追溯，請確定真的不要這些變更之後，再執行這兩個指令</p>
</blockquote>
<hr>
<h1 id="Branches"><a href="#Branches" class="headerlink" title="Branches"></a>Branches</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 顯示所有的 branch (星號的部分表示目前所在的 branch)</span></span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用目前的 working directory 作為基礎，新增 branch</span></span><br><span class="line">$ git branch &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將 HEAD 指標以及 working directory 移到指定的 branch</span></span><br><span class="line">$ git checkout &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將指定的 branch 與目前所在的 branch(checked-out) 做合併</span></span><br><span class="line">$ git merge &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刪除指定的 branch</span></span><br><span class="line">$ git branch -d &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 強制刪除尚未合併的 branch (將會永遠遺失所有的檔案變更)</span></span><br><span class="line">$ git branch -D &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 從 working directory 中移除 &amp; 停止追蹤指定的檔案</span></span><br><span class="line">$ git rm &lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改檔案名稱</span></span><br><span class="line">$ git mv &lt;old-filename&gt; &lt;new-filename&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用一行指令直接 commit 所有狀態為 tracked 的檔案，並指定 commit 內容</span></span><br><span class="line">$ git commit -a -m <span class="string">"&lt;message&gt;"</span></span><br></pre></td></tr></table></figure>
<p>以下 <strong>master</strong> branch 合併 <strong>css</strong> branch 的狀況稱為 <code>fast-forward merge</code>：</p>
<p><img src="http://rypress.com/tutorials/git/media/3-10.png" alt="fast-forward merge"></p>
<blockquote>
<p>因為 css branch 是從 master branch 中最新的 commit snapshot 所延伸出來，所以 master branch 合併 css branch 是不需要做什麼額外的判斷處理</p>
</blockquote>
<p>使用 branch 的基本原則：</p>
<ol>
<li><p>為每一個主要的新增功能，都使用 branch 的方式來完成</p>
</li>
<li><p>若無法為 branch 取一個實際的名稱(無法定義修改的內容為何)，就不要使用 branch</p>
</li>
</ol>
<p>!3-way merge](<a href="http://rypress.com/tutorials/git/media/4-1.png" target="_blank" rel="noopener">http://rypress.com/tutorials/git/media/4-1.png</a>)</p>
<blockquote>
<p>3-way merge 在當要合併兩個擁有不同 commit snapshot 時會發生，此時 Git 會額外建立一個 merge commit snapshot，並同時指向兩個不同的 branch(如上圖中的 <strong>After</strong>，紅色圈圈表示這個 commit snapshot 同時來自 crazy &amp; master 兩個 branch)</p>
<p>fast-forward merge 不會在 project history 中看到，這是與 3-way merge 不同的地方</p>
</blockquote>
<hr>
<h1 id="Rebasing"><a href="#Rebasing" class="headerlink" title="Rebasing"></a>Rebasing</h1><p>當整個 git 專案越來越多 branch 時，可以透過 rebase 的方式來整理 branch，避免過於凌亂；此外，rebase 也有在不進行 merge 的情況下，取得最新版 master 的效果。</p>
<p>透過 rebase 可以把 branch 指向指定 branch 的最新 commit snapshot；舉例來說，可將多餘的 branch 重新 rebase 後指向 master 最新的 commit snapshot，如此一來後續進行 merge 時就會變成 <strong>fast-forward merge</strong>，相關的 commit snapshot 都變成了 linear history，這樣在後續檢視上會更為直覺。</p>
<blockquote>
<p>rebase 雖然可以讓整體專案的 branch 更為簡潔易讀，但在某些 rebase 操作上會移除(or 修改)某些 commit snapshot，因此後續就會無法還原當初 commit snapshot 的全貌，這也是 rebase 功能有所爭議的地方</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 檢視 branch-feature 是否有落後 branch-dev，有顯示 commit snapshot 則表示落後，可考慮進行 rebase</span></span><br><span class="line">$ git <span class="built_in">log</span> &lt;branch-feature&gt;..&lt;branch-dev&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將目前的 branch 的 root commit snapshot 指向 new-base 最新的 commit snapshot</span></span><br><span class="line">$ git rebase &lt;new-base&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以互動的方式進行 rebse 的設定，並可選擇對每個 commit snapshot 所要執行的動作</span></span><br><span class="line">$ git rebase -i &lt;new-base&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改已經存在的 commit snapshot，不產生新的 (搭配上面 rebase 編輯 commit snapshop list 時使用 edit/squash 等關鍵是)</span></span><br><span class="line">$ git commit --amend</span><br><span class="line"></span><br><span class="line"><span class="comment"># 完成修改了特定的 commit snapshot 資訊後，繼續進行 rebase 工作</span></span><br><span class="line">$ git rebase --<span class="built_in">continue</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 放棄目前的 rebase 結果並回到原先的狀態</span></span><br><span class="line">git rebase --abort</span><br><span class="line"></span><br><span class="line"><span class="comment"># 強制 git 不以 fast-forward 的方式進行 merge，藉此保留 branch 的相關資訊</span></span><br><span class="line">git merge --no-ff &lt;branch-name&gt;</span><br></pre></td></tr></table></figure>
<p>以下用圖說明執行 <code>git merge</code> 指令時有無加上 <code>--no-ff</code> 參數所產生的效果：</p>
<p><img src="https://i0.wp.com/farm6.static.flickr.com/5054/5488984566_359f74ecc2.jpg?resize=463%2C414&amp;ssl=1" alt="git merge"></p>
<hr>
<h1 id="Rewriting-History"><a href="#Rewriting-History" class="headerlink" title="Rewriting History"></a>Rewriting History</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 顯示本地端所有的 commit snapshot (以時間排序，包含已經被 reset 的 commit snapshot)</span></span><br><span class="line">$ git reflog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將 HEAD 指標往前移到第 n 的 commit snapshot，但不變更 working directory 中的內容</span></span><br><span class="line"><span class="comment"># 比 HEAD~&lt;n&gt; 還新的 commit snapshot 中的變更會保留</span></span><br><span class="line">$ git reset --mixed HEAD~&lt;n&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將 HEAD 指標往前移到第 n 的 commit snapshot，但會變更 working directory 中的內容</span></span><br><span class="line"><span class="comment"># 比 HEAD~&lt;n&gt; 還新的 commit snapshot 中的變更會被移除</span></span><br><span class="line">$ git reset --hard HEAD~&lt;n&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示從 &lt;since&gt; &amp; &lt;until&gt; 兩個 branch 之間的 commit snapshot 紀錄</span></span><br><span class="line">$ git <span class="built_in">log</span> &lt;since&gt;..&lt;until&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 git log 顯示訊息中額外包含被修改的檔案資訊</span></span><br><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Remotes"><a href="#Remotes" class="headerlink" title="Remotes"></a>Remotes</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 從遠端複製指定的 Git repository 回來</span></span><br><span class="line">$ git <span class="built_in">clone</span> &lt;remote-path&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出 remote repository 列表(若加上 -v 參數會顯示每個 remote repository 的詳細位址)</span></span><br><span class="line">$ git remote</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增一筆 remote repository 記錄</span></span><br><span class="line">$ git remote add &lt;remote-name&gt; &lt;remote-path&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取得 remote repository 的指定 branch (不進行 merge)</span></span><br><span class="line">$ git fetch &lt;remote-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># merge 指定的 remote repository branch 到目前所在的 branch</span></span><br><span class="line">$ git merge &lt;remote-name&gt;/&lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出 remote repository branch</span></span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將 local repository branch 推送到 remote repository branch 進行更新</span></span><br><span class="line">$ git push &lt;remote-name&gt; &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 為 remote repository 加上一個 tag</span></span><br><span class="line">$ git push &lt;remote-name&gt; &lt;tag-name&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Centralized-Workflows"><a href="#Centralized-Workflows" class="headerlink" title="Centralized Workflows"></a>Centralized Workflows</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立 git repository，但沒有 working directory (只是用來存放檔案用)</span></span><br><span class="line">$ git init --bare &lt;repository-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除 remote connection</span></span><br><span class="line">$ git remote rm &lt;remote-name&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Patch-Workflows"><a href="#Patch-Workflows" class="headerlink" title="Patch Workflows"></a>Patch Workflows</h1><p><img src="http://rypress.com/tutorials/git/media/10-2.png" alt="patch workflows"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立 patch，包含了目前所在的 branch 有的，卻沒有在 &lt;branch-name&gt; branch 出現的 commit snapshot</span></span><br><span class="line">$ git format-patch &lt;branch-name&gt;</span><br><span class="line">    Create a patch <span class="keyword">for</span> each commit contained <span class="keyword">in</span> the current branch but not <span class="keyword">in</span> &lt;branch-name&gt;. You can also specify a commit ID instead of &lt;branch-name&gt;.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 套用  patch 到目前的 branch</span></span><br><span class="line">$ git am &lt; &lt;patch-file&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Tips-amp-Tricks"><a href="#Tips-amp-Tricks" class="headerlink" title="Tips &amp; Tricks"></a>Tips &amp; Tricks</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 備份目前的 branch，但只留下最新的一筆 commit snapshot</span></span><br><span class="line">$ git archive &lt;branch-name&gt; --format=zip --output=&lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 完整匯出指定的 branch 到指定檔案(會包含所有 commit snapshot 記錄)</span></span><br><span class="line">$ git bundle create &lt;file&gt; &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過 bundled repository 重新建立一個 repository 並 checkout 指定的 branch</span></span><br><span class="line">$ git <span class="built_in">clone</span> repo.bundle &lt;repo-dir&gt; -b &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暫時將變更隱藏，將目前的目錄變為乾淨的 working directory</span></span><br><span class="line">$ git stash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將隱藏的變更套用到 working directory</span></span><br><span class="line">$ git stash apply</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視兩個 commit snapshot 之間的差異</span></span><br><span class="line">$ git diff &lt;commit-id&gt;..&lt;commit-id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視目前 working directory 與 staging area 的差異</span></span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視目前 staging area 與最新一筆 commit snapshot 之間的差異</span></span><br><span class="line">$ git diff --cached</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將指令檔案從 commit snapshot 中移到 staged snapshot 中</span></span><br><span class="line">$ git reset HEAD &lt;file&gt;</span><br><span class="line">    Unstage a file, but don’t alter the working directory or move the current branch.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 從指定的 commit snapshot 中取得指定檔案</span></span><br><span class="line">$ git checkout &lt;commit-id&gt; &lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定 git command alias</span></span><br><span class="line">$ git config --global <span class="built_in">alias</span>.&lt;<span class="built_in">alias</span>-name&gt; &lt;git-command&gt;</span><br></pre></td></tr></table></figure>
<p><strong>git reset</strong>：<br><img src="http://rypress.com/tutorials/git/media/11-1.png" alt="git reset"></p>
<p><strong>git checkout</strong>：<br><img src="http://rypress.com/tutorials/git/media/11-2.png" alt="git checkout"></p>
<hr>
<h1 id="Plumbing"><a href="#Plumbing" class="headerlink" title="Plumbing"></a>Plumbing</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 顯示指定的 object 內容(其中 &lt;type&gt; 可以是 commit / tree / blob / tag)</span></span><br><span class="line">$ git cat-file &lt;<span class="built_in">type</span>&gt; &lt;object-id&gt;</span><br></pre></td></tr></table></figure>
<p><img src="http://rypress.com/tutorials/git/media/12-1.png" alt="commit and tree objects"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查詢指定的 object id 是屬於哪種 type</span></span><br><span class="line">$ git cat-file -t &lt;object-id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出指定 tree 物件的內容</span></span><br><span class="line">$ git ls-tree &lt;tree-id&gt;</span><br><span class="line">040000 tree 5aa02e7f90df11621262d7fe91a9357bb44494aa	about</span><br><span class="line">100644 blob 4838a99c7bb4cc75941ff0a5e3a05fe4889570f9	blue.html</span><br><span class="line">.......</span><br><span class="line">100644 blob c9d942d8aadb84617d78455f8e2da25866c079a2	style.css</span><br><span class="line">100644 blob e9d1781fd949fd41d2439ae3824a293531bc38a5	yellow.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示指定 object id(這裡指的是 blob 物件) 的內容</span></span><br><span class="line">$ git cat-file blob e9d178</span><br></pre></td></tr></table></figure>
<p><img src="http://rypress.com/tutorials/git/media/12-2.png" alt="commit, tree, and blob objects"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 對 git object database 進行 garbage collection </span></span><br><span class="line">$ git gc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將指定的檔案從 working directory 移到 staged area (新增的檔案要額外加上 --add 參數)</span></span><br><span class="line">$ git update-index [--add] &lt;file&gt;</span><br><span class="line">    Stage the specified file, using the optional --add flag to denote a new untracked file.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 從目前的 index 中產生一個 tree 物件，並存入 object database 中</span></span><br><span class="line">$ git write-tree</span><br><span class="line"></span><br><span class="line"><span class="comment"># 從指定的 tree object &amp; parent commit 中產生一個新的 commit 物件</span></span><br><span class="line">$ git commit-tree &lt;tree-id&gt; -p &lt;parent-id&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><p><a href="http://rypress.com/tutorials/git/index" target="_blank" rel="noopener">Ry’s Git Tutorial - RyPress</a></p>
</li>
<li><p><a href="https://blog.yorkxin.org/2011/07/29/git-rebase" target="_blank" rel="noopener">Git-rebase 小筆記 - Yu-Cheng Chuang’s Blog</a></p>
</li>
<li><p><a href="https://blog.wu-boy.com/2011/03/git-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6-branch-model-%E5%88%86%E6%94%AF%E6%A8%A1%E7%B5%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%B4%B9/" target="_blank" rel="noopener">Git 版本控制 branch model 分支模組基本介紹 | 小惡魔 - 電腦技術 - 工作筆記 - AppleBOY</a></p>
</li>
<li><p><a href="http://hungyuhei.github.io/2012/08/07/better-git-commit-graph-using-pull---rebase-and-merge---no-ff.html" target="_blank" rel="noopener">洁癖者用 Git：pull –rebase 和 merge –no-ff</a></p>
</li>
<li><p><a href="https://speakerdeck.com/mouson/laradebut-number-03-cong-git-ru-men-dao-tuan-dui-he-zuo-kai-fa" target="_blank" rel="noopener">Laradebut #03 從 git 入門到團隊合作開發 // Speaker Deck</a></p>
</li>
<li><p><a href="http://ithelp.ithome.com.tw/tags/articles/git?page=2" target="_blank" rel="noopener">Tag 列表頁(git) - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Git] Get Started with Git]]></title>
      <url>/blog/2016/10/29/Git/Get-Started-with-Git/</url>
      <content type="html"><![CDATA[<p>介紹開始使用 Git 前調教 config 的相關資訊</p>
<h1 id="初始化-Git-Repository"><a href="#初始化-Git-Repository" class="headerlink" title="初始化 Git Repository"></a>初始化 Git Repository</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化 git repository</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git init</span></span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /root/git/git-lab/.git/</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Git-config"><a href="#Git-config" class="headerlink" title="Git config"></a>Git config</h1><h2 id="常用-Git-config-gitconfig"><a href="#常用-Git-config-gitconfig" class="headerlink" title="常用 Git config (~/.gitconfig)"></a>常用 Git config (~/.gitconfig)</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[user]</span></span><br><span class="line">    email = godleon@gmail.com</span><br><span class="line">    name = godleon</span><br><span class="line"><span class="section">[core]</span></span><br><span class="line">    editor = vim</span><br><span class="line">    </span><br><span class="line">    repositoryformatversion = 0</span><br><span class="line">    filemode = true</span><br><span class="line">    bare = false</span><br><span class="line">    logallrefupdates = true</span><br><span class="line"><span class="section">[color]</span></span><br><span class="line">    ui = true</span><br><span class="line"><span class="section">[alias]</span></span><br><span class="line">    tree = log --all --graph --decorate=short --color --format=format:'%C(bold blue)%h%C(reset) %C(auto)%d%C(reset)\n         %C(black)[%cr]%C(reset)  %x09%C(black)%an: %s %C(reset)'</span><br><span class="line"></span><br><span class="line">    logs = log --all --graph --decorate=short --color --format=format:'%C(bold blue)%h%C(reset)+%C(dim black)(%cr)%C(reset)+%C(auto)%d%C(reset)++\n+++       %C(bold black)%an%C(reset)%C(black): %s%C(reset)'</span><br><span class="line"></span><br><span class="line">    stree = !bash -c '"                                                                             \</span><br><span class="line">    while IFS=+ read -r hash time branch message; do                                            \</span><br><span class="line">        timelength=$(echo \"$time\" | sed -r \"s:[^ ][[]([0-9]&#123;1,2&#125;(;[0-9]&#123;1,2&#125;)?)?m::g\");     \</span><br><span class="line">        timelength=$(echo \"16+$&#123;#time&#125;-$&#123;#timelength&#125;\" | bc);                                 \</span><br><span class="line">        printf \"%$&#123;timelength&#125;s    %s %s %s\n\" \"$time\" \"$hash\" \"$branch\" \"\";          \</span><br><span class="line">    done &lt; &lt;(git logs &amp;&amp; echo);"'</span><br><span class="line"></span><br><span class="line">    logv = log --all --graph --decorate=short --color --format=format:'%C(bold blue)%h%C(reset)+%C(dim black)(%cr)%C(reset)+%C(auto)%d%C(reset)++\n+++       %C(bold black)%an%C(reset)%C(black): %s%C(reset)'</span><br><span class="line"></span><br><span class="line">    vtree = !bash -c '"                                                                             \</span><br><span class="line">    while IFS=+ read -r hash time branch message; do                                            \</span><br><span class="line">        timelength=$(echo \"$time\" | sed -r \"s:[^ ][[]([0-9]&#123;1,2&#125;(;[0-9]&#123;1,2&#125;)?)?m::g\");     \</span><br><span class="line">        timelength=$(echo \"16+$&#123;#time&#125;-$&#123;#timelength&#125;\" | bc);                                 \</span><br><span class="line">        printf \"%$&#123;timelength&#125;s    %s %s %s\n\" \"$time\" \"$hash\" \"$branch\" \"$message\";  \</span><br><span class="line">    done &lt; &lt;(git logv &amp;&amp; echo);"'</span><br></pre></td></tr></table></figure>
<h2 id="Git-config-優先權"><a href="#Git-config-優先權" class="headerlink" title="Git config 優先權"></a>Git config 優先權</h2><p>Git config 的優先權如下：</p>
<ol>
<li><p><code>.git/config</code></p>
</li>
<li><p><code>~/.gitconfig</code></p>
</li>
<li><p><code>/etc/gitconfig</code></p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 檢視 ".git/config" 的內容</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># cat .git/config</span></span><br><span class="line">[core]</span><br><span class="line">        repositoryformatversion = 0</span><br><span class="line">        filemode = <span class="literal">true</span></span><br><span class="line">        bare = <span class="literal">false</span></span><br><span class="line">        logallrefupdates = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示目前有效的 git config</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git config -l</span></span><br><span class="line">core.repositoryformatversion=0</span><br><span class="line">core.filemode=<span class="literal">true</span></span><br><span class="line">core.bare=<span class="literal">false</span></span><br><span class="line">core.logallrefupdates=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 '/etc/gitconfig' 中的設定</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git config --system -l</span></span><br><span class="line">fatal: unable to <span class="built_in">read</span> config file <span class="string">'/etc/gitconfig'</span>: No such file or directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 ~/.gitconfig 中的設定</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git config --global -l</span></span><br><span class="line">fatal: unable to <span class="built_in">read</span> config file <span class="string">'/root/.gitconfig'</span>: No such file or directory</span><br></pre></td></tr></table></figure>
<h2 id="設定-amp-移除-git-config"><a href="#設定-amp-移除-git-config" class="headerlink" title="設定 &amp; 移除 git config"></a>設定 &amp; 移除 git config</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下的設定將會存在 ~/.gitconfig 中</span></span><br><span class="line"><span class="comment"># 若改成 "--system" 參數，則設定會存在 '/etc/gitconfig'</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git config --global user.name 'godleon'</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git config --global user.email 'godleon@gmail.com'</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git config --list</span></span><br><span class="line">user.name=godleon</span><br><span class="line">user.email=godleon@gmail.com</span><br><span class="line">core.repositoryformatversion=0</span><br><span class="line">core.filemode=<span class="literal">true</span></span><br><span class="line">core.bare=<span class="literal">false</span></span><br><span class="line">core.logallrefupdates=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除 git config 設定</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git config --global --unset user.name</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git config --list</span></span><br><span class="line">user.email=godleon@gmail.com</span><br><span class="line">core.repositoryformatversion=0</span><br><span class="line">core.filemode=<span class="literal">true</span></span><br><span class="line">core.bare=<span class="literal">false</span></span><br><span class="line">core.logallrefupdates=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="設定-Git-alias"><a href="#設定-Git-alias" class="headerlink" title="設定 Git alias"></a>設定 Git alias</h2><p>跟 Linux 的 alias 很像，可以自訂簡單的命令來替代複雜的指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 git-lab]<span class="comment"># git config alias.con 'config -l'</span></span><br><span class="line"><span class="comment"># 此命令等同於 "git config -l" 的效果</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git con</span></span><br><span class="line">user.email=godleon@gmail.com</span><br><span class="line">core.repositoryformatversion=0</span><br><span class="line">core.filemode=<span class="literal">true</span></span><br><span class="line">core.bare=<span class="literal">false</span></span><br><span class="line">core.logallrefupdates=<span class="literal">true</span></span><br><span class="line">alias.con=config -l</span><br></pre></td></tr></table></figure>
<h2 id="設定-editor-amp-diff-tool"><a href="#設定-editor-amp-diff-tool" class="headerlink" title="設定 editor &amp; diff tool"></a>設定 editor &amp; diff tool</h2><ul>
<li><p><code>git config --global color.ui true</code>：加上顏色</p>
</li>
<li><p><code>git config --global core.editor vim</code>：把預設的文字編輯器改為 vim</p>
</li>
<li><p><code>git config --global diff.tool meld</code>：把預設的 diff tool 改為 meld (要先安裝 meld，且這是 GUI tool，不適用 text mode)</p>
</li>
<li><p><code>git difftool</code>：查詢檔案差異</p>
</li>
</ul>
<hr>
<h1 id="將檔案存入-Git-Repository"><a href="#將檔案存入-Git-Repository" class="headerlink" title="將檔案存入 Git Repository"></a>將檔案存入 Git Repository</h1><h2 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h2><p>Git 追蹤檔案的方式，會將檔案 &amp; 資料夾分成三類：</p>
<ol>
<li><p>untracked</p>
<blockquote>
<p>一開始所有檔案都是 untracked，執行 <code>git status</code> 可以看到 untracked 的檔案清單</p>
</blockquote>
</li>
<li><p>tracked</p>
<blockquote>
<p>當透過 <code>git add</code> 處理之後的檔案，狀態會變成 tracked，等待使用者進一步的 commit or cancel</p>
</blockquote>
</li>
<li><p>ignored</p>
<blockquote>
<p>會被 git 忽略處理的檔案，需要新增 <code>.gitignore</code> 檔案，並逐行宣告要忽略的檔案 (被設定忽略的檔案狀態不會變成 untracked)</p>
</blockquote>
</li>
</ol>
<p>以下為 <code>.gitignore</code> 設定範例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可用萬用字元(# 開頭為註解)</span></span><br><span class="line">*.txt</span><br><span class="line"><span class="comment"># 不要忽略 note.txt 檔案</span></span><br><span class="line">!note.txt</span><br><span class="line"><span class="comment"># folder 資料夾 &amp; 資料夾內的檔案通通忽略</span></span><br><span class="line">folder</span><br></pre></td></tr></table></figure>
<h2 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h2><h3 id="1、從-tracked-復原到-untracked"><a href="#1、從-tracked-復原到-untracked" class="headerlink" title="1、從 tracked 復原到 untracked"></a>1、從 tracked 復原到 untracked</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加入 file1.txt，狀態變成 tracked</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git add file1.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 從 git index 中移除，狀態變回 untracked</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git rm --cache file1.txt</span></span><br></pre></td></tr></table></figure>
<h3 id="2、從已經-commit-後的狀態回復原狀"><a href="#2、從已經-commit-後的狀態回復原狀" class="headerlink" title="2、從已經 commit 後的狀態回復原狀"></a>2、從已經 commit 後的狀態回復原狀</h3><p>首先先來看看如何顯示目前 commit 的狀態</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此為自訂的 alias，請參考上方設定</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git tree</span></span><br><span class="line">* 72f32d4  (HEAD, master)</span><br><span class="line">|          [25 minutes ago]     root: commit of file1</span><br><span class="line">* fbaedbb</span><br><span class="line"></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git log --graph --oneline --decorate --date=relative --all</span></span><br><span class="line">* 72f32d4 (HEAD, master) commit of file1</span><br><span class="line">* fbaedbb First commit</span><br><span class="line"></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git log --graph --abbrev-commit --decorate --date=relative --all</span></span><br><span class="line">* commit 72f32d4 (HEAD, master)</span><br><span class="line">| Author: root &lt;godleon@gmail.com&gt;</span><br><span class="line">| Date:   23 minutes ago</span><br><span class="line">|</span><br><span class="line">|     commit of file1</span><br><span class="line">|</span><br><span class="line">* commit fbaedbb</span><br><span class="line">  Author: root &lt;godleon@gmail.com&gt;</span><br><span class="line">  Date:   9 hours ago</span><br><span class="line"></span><br><span class="line">      First commit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消剛剛 commit 的狀態，將 file1.txt 狀態回復到 untracked 的狀態</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git reset HEAD^</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git status</span></span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Untracked files:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to include in what will be committed)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       .gitignore</span></span><br><span class="line"><span class="comment">#       file1.txt</span></span><br><span class="line"><span class="comment">#       file2.txt</span></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">"git add"</span> to track)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目前 HEAD 已經回到第一次  commit 的地方</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git tree</span></span><br><span class="line">* fbaedbb  (HEAD, master)</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="比較檔案差異-amp-從-Git-Repository-取回檔案"><a href="#比較檔案差異-amp-從-Git-Repository-取回檔案" class="headerlink" title="比較檔案差異 &amp; 從 Git Repository 取回檔案"></a>比較檔案差異 &amp; 從 Git Repository 取回檔案</h1><h2 id="比較檔案差異"><a href="#比較檔案差異" class="headerlink" title="比較檔案差異"></a>比較檔案差異</h2><p>git 提供了很多方式來檢視不同版本間的檔案差異，主要就是使用 <code>git diff</code> &amp; <code>git difftool</code> 來完成此功能，以下用個簡單範例來說明：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出目前的 commit 紀錄</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git tree</span></span><br><span class="line">* 81618ad  (HEAD, master)</span><br><span class="line">|          [2 hours ago]        godleon: 2nd commit <span class="keyword">for</span> file1.txt</span><br><span class="line">* fbaedbb</span><br><span class="line">           [2 days ago]         root: First commit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目前 file1.txt 已經有修改</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git status</span></span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to update what will be committed)</span></span><br><span class="line"><span class="comment">#   (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       modified:   file1.txt</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Untracked files:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to include in what will be committed)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       .gitignore</span></span><br><span class="line"><span class="comment">#       file2.txt</span></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比較本地端檔案 &amp; git repository 的差異</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git diff</span></span><br><span class="line">diff --git a/file1.txt b/file1.txt</span><br><span class="line">index 7cca94a..3aff906 100644</span><br><span class="line">--- a/file1.txt</span><br><span class="line">+++ b/file1.txt</span><br><span class="line">@@ -1,2 +1,3 @@</span><br><span class="line"> file1, line 1</span><br><span class="line"> file1, line2</span><br><span class="line">+file1, line3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將檔案 file1.txt 移到 staging 中</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git add file1.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 比較 staging 與 HEAD 的版本差異</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git diff --cached file1.txt</span></span><br><span class="line">diff --git a/file1.txt b/file1.txt</span><br><span class="line">index 7cca94a..3aff906 100644</span><br><span class="line">--- a/file1.txt</span><br><span class="line">+++ b/file1.txt</span><br><span class="line">@@ -1,2 +1,3 @@</span><br><span class="line"> file1, line 1</span><br><span class="line"> file1, line2</span><br><span class="line">+file1, line3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比較不同 commit 之間指定檔案的差異</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git diff HEAD HEAD~1 file1.txt</span></span><br><span class="line">diff --git a/file1.txt b/file1.txt</span><br><span class="line">deleted file mode 100644</span><br><span class="line">index 7cca94a..0000000</span><br><span class="line">--- a/file1.txt</span><br><span class="line">+++ /dev/null</span><br><span class="line">@@ -1,2 +0,0 @@</span><br><span class="line">-file1, line 1</span><br><span class="line">-file1, line2</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><p><a href="https://github.com/geeeeeeeeek/git-recipes/wiki" target="_blank" rel="noopener">git-recipes</a></p>
</li>
<li><p><a href="http://www-cs-students.stanford.edu/%7Eblynn/gitmagic/intl/zh_tw/index.html" target="_blank" rel="noopener">Git Magic</a></p>
</li>
<li><p><a href="http://www.cnblogs.com/fanfan259/p/4810517.html" target="_blank" rel="noopener">我所记录的git命令（非常实用） - 糖糖果 - 博客园</a></p>
</li>
<li><p><a href="https://ihower.tw/blog/archives/2622" target="_blank" rel="noopener">Git 版本控制系統(3) 還沒 push 前可以做的事 | ihower { blogging }</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Linux KVM] libvirt & Storage]]></title>
      <url>/blog/2016/10/27/KVM/KVM-libvirt-storage/</url>
      <content type="html"><![CDATA[<h1 id="建立-amp-使用-unmanaged-storage"><a href="#建立-amp-使用-unmanaged-storage" class="headerlink" title="建立 &amp; 使用 unmanaged storage"></a>建立 &amp; 使用 unmanaged storage</h1><p>建立 unmanaged storage 是幫 VM 增加 virtual disk 最快的方式，其中有兩種作法：</p>
<ol>
<li><p><strong>preallocated</strong>：效能好，但完全佔據磁碟空間</p>
</li>
<li><p><strong>thin-provisioned</strong>：效能較差，但僅佔據實際使用到的磁碟空間</p>
</li>
</ol>
<p>以下是兩種不同 image 的建立示範：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 產生 preallocated image</span></span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/zero of=/tmp/dbvm_disk1.img bs=1G count=10</span><br><span class="line">10+0 records <span class="keyword">in</span></span><br><span class="line">10+0 records out</span><br><span class="line">10737418240 bytes (11 GB) copied, 8.32924 s, 1.3 GB/s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 產生 thin-provisioned image</span></span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/zero of=/tmp/dbvm_disk1_seek.img bs=1G seek=10 count=0</span><br><span class="line">0+0 records <span class="keyword">in</span></span><br><span class="line">0+0 records out</span><br><span class="line">0 bytes (0 B) copied, 0.000307303 s, 0.0 kB/s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢 image 資訊 (preallocated image 已經完全佔據磁碟空間)</span></span><br><span class="line">$ qemu-img info /tmp/dbvm_disk1.img </span><br><span class="line">image: /tmp/dbvm_disk1.img</span><br><span class="line">file format: raw</span><br><span class="line">virtual size: 10G (10737418240 bytes)</span><br><span class="line">disk size: 10G</span><br><span class="line"><span class="comment"># 查詢 image 資訊 (thin-provisioned image 並未預先佔據磁碟空間)</span></span><br><span class="line">$ qemu-img info /tmp/dbvm_disk1_seek.img </span><br><span class="line">image: /tmp/dbvm_disk1_seek.img</span><br><span class="line">file format: raw</span><br><span class="line">virtual size: 10G (10737418240 bytes)</span><br><span class="line">disk size: 0</span><br></pre></td></tr></table></figure>
<p>當 image 建立完成，可用以下指令直接掛載到執行中的 VM：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ virsh domblklist centos7</span><br><span class="line">Target     Source</span><br><span class="line">------------------------------------------------</span><br><span class="line">vda        /var/lib/libvirt/images/hdd/vmdisk/centos7.qcow2</span><br><span class="line"></span><br><span class="line"><span class="comment"># vdb =&gt; 指定 image 掛載為 vdb</span></span><br><span class="line"><span class="comment"># --live =&gt; 指定在執行中的 VM 掛載 image</span></span><br><span class="line"><span class="comment"># --config =&gt; 讓此掛載設定可以永久保留，不會因為 VM reboot 而消失</span></span><br><span class="line">$ virsh attach-disk centos7 /tmp/dbvm_disk1.img vdb --live --config</span><br><span class="line">Disk attached successfully</span><br><span class="line"></span><br><span class="line">$ virsh domblklist centos7</span><br><span class="line">Target     Source- [KVM XML 設定檔基本內容](http://www.tfcis.org/~lantw44/download/notes/cs/libvirt.domain(5))</span><br><span class="line">------------------------------------------------</span><br><span class="line">vda        /var/lib/libvirt/images/hdd/vmdisk/centos7.qcow2</span><br><span class="line">vdb        /tmp/dbvm_disk1.img</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="建立-amp-使用-managed-storage"><a href="#建立-amp-使用-managed-storage" class="headerlink" title="建立 &amp; 使用 managed storage"></a>建立 &amp; 使用 managed storage</h1><p>為了讓 storage 有個統一標準的管理，除非是很臨時的測試目的需求，不然上面 unmanage 的作法就盡量少作囉!</p>
<p>libvirt 支援了相當多種的 storage pool，以下一一列出：</p>
<ul>
<li><p><code>-dir</code>：使用<strong>標準的檔案系統目錄</strong>儲存 virtual disk</p>
</li>
<li><p><code>-disk</code>：使用<strong>實體磁碟機</strong>來建立 virtual disk</p>
</li>
<li><p><code>-fs</code>：使用<strong>預設格式化好的磁碟分割</strong>來儲存 virtual disk</p>
</li>
<li><p><code>-netfs</code>：使用 <strong>network-shared storage</strong>(例如：NFS) 來儲存 virtual disk</p>
</li>
<li><p><code>-gluster</code>：使用 <strong>glusterfs</strong> 儲存 virtual disk</p>
</li>
<li><p><code>-iscsi</code>：使用 <strong>iscsi storage</strong> 儲存 virtual disk</p>
</li>
<li><p><code>-scsi</code>：使用 <strong>本地端 scsi storage</strong> 儲存 virtual disk </p>
</li>
<li><p><code>-lvm</code>：使用 <strong>LVM volume group</strong> 儲存 virtual disk</p>
</li>
<li><p><code>-rbd</code>：使用 <strong>Ceph storage</strong> 儲存 virtual disk </p>
</li>
</ul>
<blockquote>
<p>在 libvirt 中，managed storage 是以 <code>pool</code> + <code>volume</code> 所組合而成</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查詢 pool 列表</span></span><br><span class="line">$ $ virsh -c qemu+ssh://root@10.20.190.2/system pool-list</span><br><span class="line"> Name                 State      Autostart </span><br><span class="line">-------------------------------------------</span><br><span class="line"> default              active     yes       </span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視 pool 的詳細資訊</span></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system pool-info default</span><br><span class="line">Name:           default</span><br><span class="line">UUID:           0896bbcd-a502-4ed8-b484-34d8baf05e84</span><br><span class="line">State:          running</span><br><span class="line">Persistent:     yes</span><br><span class="line">Autostart:      yes</span><br><span class="line">Capacity:       1007.80 GiB</span><br><span class="line">Allocation:     70.07 GiB</span><br><span class="line">Available:      937.73 GiB</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">這些資訊會以 XML 的形式存在於 KVM host 上，以 `default` 為例，其 XML 定義檔的位置為 `/etc/libvirt/storage/default.xml`。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">管理 Storage Pool</span><br><span class="line">=================</span><br><span class="line"></span><br><span class="line">以下使用 filesystem &amp; LVM 作為建立 storage pool 的範例：</span><br><span class="line"></span><br><span class="line"><span class="comment">## (1) 建立 fife system directory backed storage pool</span></span><br><span class="line"></span><br><span class="line">這是上述 `defautl` pool 的方式，使用的是 KVM host 上的 `/var/lib/libvirt/images` 資料夾作為儲存 volume 的位置</span><br><span class="line"></span><br><span class="line">以下是建立一個名稱為 **dedicated_storage** 的簡單方式：</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line"><span class="comment"># 定義 storage pool (會產生 XML 定義檔案在 /etc/libvirt/storage 目錄中)</span></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system pool-define-as dedicated_storage dir - - - - <span class="string">"/vms"</span></span><br><span class="line">Pool dedicated_storage defined</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 storage pool (建立指定目錄 &amp; 設定 SELinux 相關權限)</span></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system pool-build dedicated_storage</span><br><span class="line">Pool dedicated_storage built</span><br><span class="line"></span><br><span class="line"><span class="comment"># 啟動 storage pool</span></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system pool-start dedicated_storage</span><br><span class="line">Pool dedicated_storage started</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定 libvirtd 啟動時，同時啟動此 storage pool</span></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system pool-autostart dedicated_storage</span><br><span class="line">Pool dedicated_storage marked as autostarted</span><br></pre></td></tr></table></figure>
<h2 id="2-建立-LVM-volume-Group-backed-storage-pool"><a href="#2-建立-LVM-volume-Group-backed-storage-pool" class="headerlink" title="(2) 建立 LVM volume Group backed storage pool"></a>(2) 建立 LVM volume Group backed storage pool</h2><p>使用 LVM 的優點就會有以下優點啦：</p>
<ol>
<li><p>彈性伸縮磁碟容量</p>
</li>
<li><p>整合不同的磁碟</p>
</li>
<li><p>volume snapshots</p>
</li>
<li><p>自定義的裝置名稱</p>
</li>
<li><p>data striping 提昇 I/O throughput</p>
</li>
<li><p>Mirror volumes</p>
</li>
</ol>
<p>所以使用 LVM 作為 storage pool 也是個相當不錯的選項。</p>
<p>假設目前在 KVM host 中有 <strong>/dev/sdb</strong> &amp; <strong>/dev/sdc</strong> 兩個硬碟可拿來作為 LVM volume，可用以下指令建立 LVM storage pool：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ bash -c <span class="string">'cat &lt;&lt;EOF &gt; /tmp/storage-lvm.xml</span></span><br><span class="line"><span class="string">&lt;pool type="logical"&gt;</span></span><br><span class="line"><span class="string">  &lt;name&gt;HostVG&lt;/name&gt;</span></span><br><span class="line"><span class="string">  &lt;source&gt;</span></span><br><span class="line"><span class="string">    &lt;device path="/dev/sdb"/&gt;</span></span><br><span class="line"><span class="string">    &lt;device path="/dev/sdc"/&gt;</span></span><br><span class="line"><span class="string">  &lt;/source&gt;</span></span><br><span class="line"><span class="string">  &lt;target&gt;</span></span><br><span class="line"><span class="string">    &lt;path&gt;/dev/HostVG&lt;/path&gt;</span></span><br><span class="line"><span class="string">  &lt;/target&gt;</span></span><br><span class="line"><span class="string">&lt;/pool&gt;</span></span><br><span class="line"><span class="string">EOF'</span></span><br><span class="line"></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system pool-define /tmp/storage-lvm.xml </span><br><span class="line">Pool HostVG defined from /tmp/storage-lvm.xml</span><br><span class="line"></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system pool-build HostVG</span><br><span class="line">Pool HostVG built</span><br><span class="line"></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system pool-start HostVG</span><br><span class="line">Pool HostVG started</span><br><span class="line"></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system pool-autostart HostVG</span><br><span class="line">Pool HostVG marked as autostarted</span><br></pre></td></tr></table></figure>
<h2 id="3-刪除-storage-pool"><a href="#3-刪除-storage-pool" class="headerlink" title="(3) 刪除 storage pool"></a>(3) 刪除 storage pool</h2><p>刪除 storage pool 就相對簡單，假設要刪除上面的 <strong>HostVG</strong> pool，只要透過以下指令即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system pool-destroy HostVG</span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system pool-undefine HostVG</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Storage-Volume-的管理"><a href="#Storage-Volume-的管理" class="headerlink" title="Storage Volume 的管理"></a>Storage Volume 的管理</h1><p>透過 virsh 建立 storage volume 的語法類似如下：</p>
<blockquote>
<p>virsh vol-create-as –pool POOL_NAME VOL_NAME VOL_SIZE –format raw|qcow2|qed </p>
</blockquote>
<p>因此假設我們要在 pool <strong>dedicated_storage</strong> 中建立一個格式為 <strong>qcow2</strong>，大小為 <strong>10G</strong> 的 volume，可用下列語法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立一個名稱為 vm_vol1.qcow2 的 storage volume</span></span><br><span class="line">$ $ virsh -c qemu+ssh://root@10.20.190.2/system vol-create-as --pool dedicated_storage vm_vol1.qcow2 10G --format qcow2</span><br><span class="line">Vol vm_vol1.qcow2 created</span><br><span class="line"></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system vol-info --pool dedicated_storage vm_vol1.qcow2</span><br><span class="line">Name:           vm_vol1.qcow2</span><br><span class="line">Type:           file</span><br><span class="line">Capacity:       10.00 GiB</span><br><span class="line">Allocation:     196.00 KiB</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">若要刪除 storage volume，則可用以下指令</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system vol-delete --pool dedicated_storage vm_vol1.qcow2</span><br><span class="line">Vol vm_vol1.qcow2 deleted</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><p><a href="http://beakdoosan.blogspot.tw/2011/01/lvm.html" target="_blank" rel="noopener">Beakdoosan’s Weblog: LVM 筆記 - 觀念篇</a></p>
</li>
<li><p><a href="https://libvirt.org/storage.html" target="_blank" rel="noopener">libvirt: Storage Management</a></p>
</li>
<li><p><a href="https://www.suse.com/documentation/sles11/book_kvm/data/sec_libvirt_storage_virsh.html" target="_blank" rel="noopener">Suse Doc: Virtualization with KVM - Managing Storage with virsh</a></p>
</li>
<li><p><a href="http://docs.ceph.com/docs/hammer/rbd/libvirt/" target="_blank" rel="noopener">Using libvirt with Ceph RBD — Ceph Documentation</a></p>
</li>
<li><p><a href="http://www.tfcis.org/~lantw44/download/notes/cs/libvirt.domain(5" target="_blank" rel="noopener">KVM XML 設定檔基本內容</a>)</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> KVM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> KVM </tag>
            
            <tag> libvirt </tag>
            
            <tag> Storage </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Linux KVM] libvirt & network]]></title>
      <url>/blog/2016/10/21/KVM/KVM-libvirt-network/</url>
      <content type="html"><![CDATA[<p>介紹如何使用 libvirt 來管理 KVM virtual network</p>
<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>以下圖片來說明 libvirt 在整個虛擬化架構中所扮演的角色：</p>
<p><img src="http://smilejay.com/wp-content/uploads/2013/03/libvirt-manage-hypervisors.jpg" alt="libvirt 1"></p>
<blockquote>
<p>其中 other tools 的部份，甚至可以是 <strong>OpenStack</strong>、<strong>oVirt</strong> … 等工具</p>
</blockquote>
<p>libvirt 的管理功能一共包含五個部分：</p>
<ol>
<li><p>Virtual Machine</p>
<blockquote>
<p>包含 VM lifecycle(啟動/停止/暫停/保存/恢復/Live Migration …. 等等) 的管理，也支援對各種設備的熱插拔(不同的 hypervisor 對熱插拔的支援程度不一)</p>
</blockquote>
</li>
<li><p>Remote Node</p>
<blockquote>
<p>只要 remote node 上執行了 libvirtd 服務，libvirt 就可以用遠端的方式進行管理，支援 SSH / TCP socket … 等不同的連線方式，以 SSH 為例，可用像是 <code>virsh -c qemu+ssh://root@remotehost.com/system</code> 的命令進行連線</p>
</blockquote>
</li>
<li><p>Storage</p>
<blockquote>
<p>與上面相同，只要 remote node 上執行了 libvirtd 服務，就可以透過 libvirt 來管理不同類型的 storage，例如：建立不同格式的 virtual machine image(qcow2 / raw / vmdk … 等等)、掛載 remote NFS/iSCSI share、磁碟分割 …. 等等</p>
</blockquote>
</li>
<li><p>Network</p>
<blockquote>
<p>與上面相同，只要 remote node 上執行了 libvirtd 服務，就可以透過 libvirt 進行像是配置 tap device、建立 virtual network tap、bridge device 設定、VLAN/NAT 管理…等功能</p>
</blockquote>
</li>
<li><p>提供穩定、高效 API interface</p>
</li>
</ol>
<p>更清楚一點解釋 libvirt 在整個 QEMU/KVM 虛擬環境中所扮演的角色，可參考下圖：</p>
<p><img src="https://github.com/godleon/godleon.github.io/blob/master/_posts/images/2016/KVM-libvirt/libvirt.png?raw=true" alt="libvirt"></p>
<hr>
<h1 id="遠端操作-libvirtd"><a href="#遠端操作-libvirtd" class="headerlink" title="遠端操作 libvirtd"></a>遠端操作 libvirtd</h1><p>以下用個很簡單的範例，透過 virsh 命令連線到遠端主機的 libvirtd 並執行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 遠端主機為 10.20.190.3</span></span><br><span class="line"><span class="comment"># 執行命令 "list --all"</span></span><br><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system list --all</span><br><span class="line"> Id    Name                           State</span><br><span class="line">----------------------------------------------------</span><br><span class="line"> 3     centos7                        running</span><br></pre></td></tr></table></figure>
<p>用圖來表示的話，遠端操作 libvirtd 的流程如下：</p>
<p><img src="https://github.com/godleon/godleon.github.io/blob/master/_posts/images/2016/KVM-libvirt/remote_access_libvirtd.png?raw=true" alt="Remote Accrss libvirtd"></p>
<hr>
<h1 id="Linux-Virtual-Networking"><a href="#Linux-Virtual-Networking" class="headerlink" title="Linux Virtual Networking"></a>Linux Virtual Networking</h1><p>libvirt networking 的主要元件是 virtual network switch，也就是 Linux 中的 <strong><font color="red">bridge devices</font></strong>，而連接在 bridge 上的 interface，我們稱為 <strong><font color="red">TAP devices</font></strong>。</p>
<blockquote>
<p>TAP device 是由 Linux 的 TUN/TAP 模組所實作出來，其中 TUN(tunnel) 用來模擬 layer 3 的設備，而 TAP(network tap) 則是用來模擬 layer 2 設備</p>
</blockquote>
<p>以下示範如何建立 bridge device &amp; TAP device：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查詢是否已經掛載 bridge 模組</span></span><br><span class="line">$ lsmod | grep bridge</span><br><span class="line">bridge                119562  0</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增 bridge device</span></span><br><span class="line">$ brctl addbr tester</span><br><span class="line">$ brctl show</span><br><span class="line">bridge name	  bridge id		       STP enabled	interfaces</span><br><span class="line">.......</span><br><span class="line">tester		    8000.000000000000	 no		</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢查 TUN/TAP 模組是否已經載入到 kernel 中</span></span><br><span class="line">$ lsmod | grep tun</span><br><span class="line">tun                    27141  4 vhost_net</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 TAP device(vm-vnic)</span></span><br><span class="line">$ ip tuntap add dev vm-vnic mode tap</span><br><span class="line">$ ip addr show vm-vnic</span><br><span class="line">21: vm-vnic: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN qlen 500</span><br><span class="line">    link/ether 92:ee:17:b7:2b:c4 brd ff:ff:ff:ff:ff:ff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將 TAP device 與 bridge 相連</span></span><br><span class="line">$ brctl addif tester vm-vnic</span><br><span class="line">$ brctl show</span><br><span class="line">bridge name	bridge id		       STP enabled	 interfaces</span><br><span class="line">.......</span><br><span class="line">tester		  8000.92ee17b72bc4	 no		         vm-vnic</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視目前連接到 bridge 的 TAP devices</span></span><br><span class="line">$ brctl showmacs tester</span><br><span class="line">port no	mac addr		is <span class="built_in">local</span>?	ageing timer</span><br><span class="line">  1	92:ee:17:b7:2b:c4	yes		   0.00</span><br><span class="line">  1	92:ee:17:b7:2b:c4	yes		   0.00</span><br></pre></td></tr></table></figure>
<p>若以上的 vm-vnic 連接到 VM 後，整個 network topology 會變成類似如下圖：</p>
<p><img src="https://github.com/godleon/godleon.github.io/blob/master/_posts/images/2016/KVM-Virtual-Networking/Linux_bridge_taps.png?raw=true" alt="Linux Bridge &amp; TAP devices"></p>
<p>測試完畢後，我們可以用以下指令移除上面建立的 TAP device &amp; bridge：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ brctl delif tester vm-vnic</span><br><span class="line"></span><br><span class="line">$ brctl show</span><br><span class="line">bridge name	bridge id		       STP enabled	interfaces</span><br><span class="line">........</span><br><span class="line">tester		  8000.000000000000	 no		</span><br><span class="line"></span><br><span class="line">$ ip tuntap del dev vm-vnic mode tap</span><br><span class="line">$ brctl delbr tester</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Virtual-Network-Types"><a href="#Virtual-Network-Types" class="headerlink" title="Virtual Network Types"></a>Virtual Network Types</h1><p>在 KVM 中，virtual network 分為以下幾種類型：</p>
<ul>
<li><p><strong>NATed</strong>：以 host 作為 NAT server 的方式提供網路</p>
</li>
<li><p><strong>Routed</strong>：透過設定在 hypervisor 上的 routing rules，允許 VM 與實體網路卡相連進行資料傳輸</p>
</li>
<li><p><strong>Isolated</strong>：與外界完全區隔的內部私有網路，只有在裡面的 VM 可以互相通訊</p>
</li>
</ul>
<p>透過以下指令可以查詢 virtual network 相關的資訊：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$ virsh -c qemu+ssh://root@10.20.190.3/system net-list --all</span><br><span class="line"> Name                 State      Autostart     Persistent</span><br><span class="line">----------------------------------------------------------</span><br><span class="line"> default              active     yes           yes</span><br><span class="line"></span><br><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system net-info default</span><br><span class="line">Name:           default  <span class="comment"># virtual network 名稱</span></span><br><span class="line">UUID:           83bea138-4c65-4ca2-8199-db3400d87fa5</span><br><span class="line">Active:         yes      <span class="comment"># 目前的啟動狀態</span></span><br><span class="line">Persistent:     yes      </span><br><span class="line">Autostart:      yes      <span class="comment"># 是否隨著 libvird 一起啟動</span></span><br><span class="line">Bridge:         virbr0   <span class="comment"># 使用那個 device 進行對外通訊 </span></span><br><span class="line"></span><br><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system net-dumpxml default</span><br><span class="line">&lt;network&gt;</span><br><span class="line">  &lt;name&gt;default&lt;/name&gt;</span><br><span class="line">  &lt;uuid&gt;83bea138-4c65-4ca2-8199-db3400d87fa5&lt;/uuid&gt;</span><br><span class="line">  &lt;forward mode=<span class="string">'nat'</span>&gt;</span><br><span class="line">    &lt;nat&gt;</span><br><span class="line">      &lt;port start=<span class="string">'1024'</span> end=<span class="string">'65535'</span>/&gt;</span><br><span class="line">    &lt;/nat&gt;</span><br><span class="line">  &lt;/forward&gt;</span><br><span class="line">  &lt;bridge name=<span class="string">'virbr0'</span> stp=<span class="string">'on'</span> delay=<span class="string">'0'</span>/&gt;</span><br><span class="line">  &lt;mac address=<span class="string">'52:54:00:f8:50:f2'</span>/&gt;</span><br><span class="line">  &lt;ip address=<span class="string">'192.168.122.1'</span> netmask=<span class="string">'255.255.255.0'</span>&gt;</span><br><span class="line">    &lt;dhcp&gt;</span><br><span class="line">      &lt;range start=<span class="string">'192.168.122.2'</span> end=<span class="string">'192.168.122.254'</span>/&gt;</span><br><span class="line">    &lt;/dhcp&gt;</span><br><span class="line">  &lt;/ip&gt;</span><br><span class="line">&lt;/network&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 啟動 default virtual network</span></span><br><span class="line">$ virsh net-start default</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刪除 default virtual network</span></span><br><span class="line">$ virsh net-destroy default</span><br></pre></td></tr></table></figure>
<p>系統預設的 <strong><font color="red">default</font></strong> virtual network 屬於 NATed，host 會自動派發 IP 給此網路中 VM，並設定相關的 firewall rule 讓 VM 可以透過 host 對外通訊。</p>
<hr>
<h1 id="使用-libvirt-管理-virtual-network-Isolated"><a href="#使用-libvirt-管理-virtual-network-Isolated" class="headerlink" title="使用 libvirt 管理 virtual network - Isolated"></a>使用 libvirt 管理 virtual network - Isolated</h1><p>顧名思義，isolated network 表示外面是無法與在 isolated network 中的 VM 進行通訊的，只有加入到此 network 的 VM 才可以相互通訊，而在 isolated network 內部的 VM 也無法對外連線。</p>
<p><img src="https://github.com/godleon/godleon.github.io/blob/master/_posts/images/2016/KVM-libvirt/kvm_isolated-network.jpg?raw=true" alt="KVM isolated network"></p>
<p>建立 isolated network 的方式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ bash -c <span class="string">'cat &lt;&lt;EOF &gt; /tmp/isolated.xml</span></span><br><span class="line"><span class="string">&lt;network&gt; </span></span><br><span class="line"><span class="string">  &lt;name&gt;isolated&lt;/name&gt;</span></span><br><span class="line"><span class="string">&lt;/network&gt;</span></span><br><span class="line"><span class="string">EOF'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定義 virtual network </span></span><br><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system net-define /tmp/isolated.xml </span><br><span class="line">Network isolated defined from /tmp/isolated.xml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視目前的 virtual network 清單 (isolated 已經加入，但尚未啟動)</span></span><br><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system net-list --all</span><br><span class="line"> Name                 State      Autostart     Persistent</span><br><span class="line">----------------------------------------------------------</span><br><span class="line"> default              active     yes           yes</span><br><span class="line"> isolated             inactive   no            yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># libvirt 會自動指派 UUID, virtual bridge ...等資訊</span></span><br><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system net-dumpxml isolated</span><br><span class="line">&lt;network&gt;</span><br><span class="line">  &lt;name&gt;isolated&lt;/name&gt;</span><br><span class="line">  &lt;uuid&gt;765e746b-334d-4acf-8b9c-cb32be5b77f5&lt;/uuid&gt;</span><br><span class="line">  &lt;bridge name=<span class="string">'virbr1'</span> stp=<span class="string">'on'</span> delay=<span class="string">'0'</span>/&gt;</span><br><span class="line">  &lt;mac address=<span class="string">'52:54:00:70:8b:87'</span>/&gt;</span><br><span class="line">&lt;/network&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>定義一個新的 virtual network 後，會在 KVM host 上的 <code>/etc/libvirt/qemu/networks</code> 目錄產生對應的 XML 設定檔，以上面為例，XML 設定檔完整名稱是 <code>/etc/libvirt/qemu/networks/isolated.xml</code></p>
</blockquote>
<p>完成 virtual network define 之後，接著要啟動 virtual network：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system net-start isolated</span><br><span class="line">Network isolated started</span><br><span class="line"></span><br><span class="line"><span class="comment"># network isolated 已經啟動</span></span><br><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system net-list --all</span><br><span class="line"> Name                 State      Autostart     Persistent</span><br><span class="line">----------------------------------------------------------</span><br><span class="line"> default              active     yes           yes</span><br><span class="line"> isolated             active     no            yes</span><br></pre></td></tr></table></figure>
<p>完成了 isolated virtual network 的配置後，以下是動態產生 &amp; 刪除 NIC 並與 VM 相連的相關操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 檢視 domain interface list (目前只有連接 default network)</span></span><br><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system domiflist centos7</span><br><span class="line">Interface  Type       Source     Model       MAC</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">vnet0      network    default    virtio      52:54:00:7e:f8:5c</span><br><span class="line"></span><br><span class="line"><span class="comment"># attach-interface =&gt; 產生一個 interface 並連接到後續指定的 virtual network</span></span><br><span class="line"><span class="comment"># --domain =&gt; 指定要變更設定的 VM (稱為 domain)</span></span><br><span class="line"><span class="comment"># --source isolated --type network =&gt; 使用 virtual network isolated</span></span><br><span class="line"><span class="comment"># --model virtio =&gt; 使用 virtio (效能較好)</span></span><br><span class="line"><span class="comment"># --config =&gt; 變更設定 &amp; 儲存 (若沒使用此參數，NIC 僅會暫時出現)</span></span><br><span class="line"><span class="comment"># --live =&gt; 在 VM 執行狀態下動態新增 (若要針對停止中的 VM 新增 NIC 不需要使用此參數)</span></span><br><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system attach-interface --domain centos7 --<span class="built_in">source</span> isolated --<span class="built_in">type</span> network --model virtio --config --live</span><br><span class="line">Interface attached successfully</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新檢視 VM 的 interface list，發現新的 NIC 已經安裝上去了</span></span><br><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system domiflist centos7</span><br><span class="line">Interface  Type       Source     Model       MAC</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">vnet0      network    default    virtio      52:54:00:7e:f8:5c</span><br><span class="line">vnet1      network    isolated   virtio      52:54:00:07:b8:72</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除指定的 NIC</span></span><br><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system detach-interface --domain centos7 --<span class="built_in">type</span> network --mac 52:54:00:07:b8:72 --config --live</span><br><span class="line">Interface detached successfully</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可看出其中一的 NIC 已經被移除</span></span><br><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system domiflist centos7</span><br><span class="line">Interface  Type       Source     Model       MAC</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">vnet0      network    default    virtio      52:54:00:7e:f8:5c</span><br></pre></td></tr></table></figure>
<p>當透過 virsh 新增一個 NIC 與 VM 相連後，直接到 KVM host 上使用 <code>brctl show</code> 指令檢視目前與 bridge device 相連的 interface：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ brctl show</span><br><span class="line">bridge name	bridge id		      STP enabled	interfaces</span><br><span class="line">......</span><br><span class="line">virbr1		  8000.525400708b87	yes		      virbr1-nic</span><br><span class="line">							                            vnet1</span><br></pre></td></tr></table></figure>
<p>可以看出 interface 已經被 libvirt 自動建立且與 bridge 相連。(其中的 <strong>virbr1-nic</strong> 是在 isolated virtual network 建立時，libvirt 一併同時產生的)</p>
<hr>
<h1 id="virtual-network-NATed-amp-Routed"><a href="#virtual-network-NATed-amp-Routed" class="headerlink" title="virtual network - NATed &amp; Routed"></a>virtual network - NATed &amp; Routed</h1><h2 id="NATed-virtual-network"><a href="#NATed-virtual-network" class="headerlink" title="NATed virtual network"></a>NATed virtual network</h2><p>安裝好 KVM 後，預設就會附上一個名稱為 <code>default</code> 的 NATed virtual network，所有使用 default virtual network 的 VM，都可以透過 KVM host 中新增的 bridge device  <code>virbr0</code>，以 NAT 的方式連到外部網路。 </p>
<p>NATed virtual network 的設定步驟如下：</p>
<ol>
<li><p>建立 bridge device，並與特定的 nic 連結</p>
</li>
<li><p>設定防火牆規則 for NAT masquerade</p>
</li>
<li><p>virtual network 中 XML 定義的 <code>forward mode</code> 要設為 yes </p>
</li>
</ol>
<p>接著就是 <code>virsh net-{define,start,autostart}</code> 的工作了，這與上面雷同，就不再贅述</p>
<h2 id="Routed-virtual-network"><a href="#Routed-virtual-network" class="headerlink" title="Routed virtual network"></a>Routed virtual network</h2><p>這在實際應用中很少遇到，因此就略過先不測試，有機會試過之後再來補!</p>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><p><a href="">Networking - KVM</a><a href="http://www.linux-kvm.org/page/Networking" target="_blank" rel="noopener">http://www.linux-kvm.org/page/Networking</a></p>
</li>
<li><p><a href="https://libvirt.org/formatnetwork.html" target="_blank" rel="noopener">libvirt: Network XML format</a></p>
</li>
<li><p><a href="http://www.tfcis.org/~lantw44/download/notes/cs/libvirt.domain(5" target="_blank" rel="noopener">KVM XML 設定檔基本內容</a>)</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> KVM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> KVM </tag>
            
            <tag> libvirt </tag>
            
            <tag> Network </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Linux KVM] 半虛擬化驅動(Paravirtualization Driver)]]></title>
      <url>/blog/2016/08/20/KVM/KVM-Paravirtualization-Drivers/</url>
      <content type="html"><![CDATA[<p>介紹如何使用 QEMU/KVM 中的半虛擬化，並了解此技術如何帶來效能上的提升</p>
<h1 id="QEMU-I-O-Overview"><a href="#QEMU-I-O-Overview" class="headerlink" title="QEMU I/O Overview"></a>QEMU I/O Overview</h1><p>QEMU/KVM 是屬於全虛擬化的解決方案，若沒有硬體加速輔助的情況下，所有的工作都必須透過軟體模擬，其實效率是很不好的，特別是 device I/O 的部分。</p>
<p>以下的圖可以說明純 QEMU 模擬下的 device I/O 狀況：</p>
<p><img src="http://smilejay.b0.upaiyun.com/wp-content/uploads/2012/11/qemu-emulated-io.jpg" alt="KVM virtio"></p>
<p>一個 virtual machine 的 I/O request 會透過以下流程完成：</p>
<ol>
<li><p>被 KVM module 中的 I/O trap 捕捉到 &amp; 處理</p>
</li>
<li><p>將處理結果放到 I/O sharing page 中</p>
</li>
<li><p>通知 QEMU process 來取得 I/O 資訊，並交由 QEMU I/O Emulation Code 來模擬 I/O request</p>
</li>
<li><p>完成後將結果放回 I/O sharing page</p>
</li>
<li><p>通知 KVM module 中的 I/O trap 將處理結果取回並回傳給 virtual machine</p>
</li>
</ol>
<p>透過 QEMU 可以模擬出各式各樣的 I/O device，甚至很老舊的設備都沒有問題；但從上面複雜的步驟不難看出為何使用 QEMU 模擬 device I/O 會效率不彰，除了每次 I/O request 處理的流程繁複之外，過多的 VMEntry, VMExit, context switch，也都是拖垮 QEMU 效能的原因。</p>
<hr>
<h1 id="virtio-Overview"><a href="#virtio-Overview" class="headerlink" title="virtio Overview"></a>virtio Overview</h1><p>有鑑於此，<a href="http://www.linux-kvm.org/page/Virtio" target="_blank" rel="noopener">virtio</a> 被提出來，作為運行在 Hypervisor 上的一組 API interface，讓 virtual machine 知道自己運行在虛擬環境中，並根據 virtio 標準與 hypervisor 互動，藉此達到更好的運作效能(I/O 效能提升最為明顯)。</p>
<p>以下是純 QEMU 模擬 &amp; virtio 的架構比較，可以看出 virtio 省略了 I/O trap，讓 virtual machine 可以直接與 QEMU 的 I/O 模組通訊：</p>
<p><img src="http://images0.cnblogs.com/blog2015/697113/201506/011807259737673.jpg" alt="QEMU v.s. virtio"></p>
<p>更細部一點檢視 virtio 的架構：</p>
<p><img src="http://smilejay.b0.upaiyun.com/wp-content/uploads/2012/11/qemu-kvm-virtio.jpg" alt="virtio architecture"></p>
<ol>
<li><p>第一層 <strong>virtio_blk</strong>、<strong>virtio_net</strong>、<strong>virtio_scsi</strong> …. 等等屬於 <strong><font color="red">virtio Frontend，存在於</font></strong> virtual machine OS kernel module 中</p>
</li>
<li><p>最下面一層稱為 <strong><font color="red">virtio Backend</font></strong>，是在 QEMU 中實作，讓 I/O request 可以透過 QEMU 直接送給 host machine 中的 device driver，減少整體 I/O 的 overhead</p>
</li>
<li><p><strong><font color="red">virtio</font></strong> 屬於虛擬佇列，目的是將 Frontend 的驅動程序附加到 Backend 的處理程序 (一個 Frontend 的驅動程序可以根據需求使用 0 個或多個佇列，例如 virtio_net 同時需要傳送 &amp; 接收用的兩個虛擬佇列，virtio_blk 則僅需要一個)</p>
</li>
<li><p><strong><font color="red">virtio-ring</font></strong> 透過實作 ring buffer 的機制，讓 I/O request 得以批次處理，藉以提升 virtual machine 與 hypervisor 之間訊息交換的效率</p>
</li>
</ol>
<p>雖然 virtio 可以大幅的提升 I/O 性能，但不僅需要 host machine 的 OS kernel 有支援，連 virtual machine 也要同時有安裝 virtio driver，不過目前較新的 Linux 都已經支援 virtio 了! 所以若使用的是最近幾年的 Linux 版本，在 I/O 裝置的部分應該都可以選擇以 virtio 的方式運行。</p>
<blockquote>
<p>Windows 也都有對應的 virtio driver 可對應下載</p>
</blockquote>
<hr>
<h1 id="檢查-virtio-環境"><a href="#檢查-virtio-環境" class="headerlink" title="檢查 virtio 環境"></a>檢查 virtio 環境</h1><h2 id="1-1-virtio-Backend"><a href="#1-1-virtio-Backend" class="headerlink" title="1.1 virtio Backend"></a>1.1 virtio Backend</h2><p>由於 host machine 安裝的是 CentOS 7，因此都已經預設安裝 virtio driver 了! 可以用以下指令查詢：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ find / -name <span class="string">'virtio*.ko'</span> | grep $(uname -r)</span><br><span class="line">/usr/lib/modules/3.10.0-327.28.2.el7.x86_64/kernel/drivers/virtio/virtio_pci.ko</span><br><span class="line">/usr/lib/modules/3.10.0-327.28.2.el7.x86_64/kernel/drivers/virtio/virtio.ko</span><br><span class="line">/usr/lib/modules/3.10.0-327.28.2.el7.x86_64/kernel/drivers/virtio/virtio_ring.ko</span><br><span class="line">/usr/lib/modules/3.10.0-327.28.2.el7.x86_64/kernel/drivers/virtio/virtio_input.ko</span><br><span class="line">/usr/lib/modules/3.10.0-327.28.2.el7.x86_64/kernel/drivers/virtio/virtio_balloon.ko</span><br><span class="line">/usr/lib/modules/3.10.0-327.28.2.el7.x86_64/kernel/drivers/char/virtio_console.ko</span><br><span class="line">/usr/lib/modules/3.10.0-327.28.2.el7.x86_64/kernel/drivers/char/hw_random/virtio-rng.ko</span><br><span class="line">/usr/lib/modules/3.10.0-327.28.2.el7.x86_64/kernel/drivers/scsi/virtio_scsi.ko</span><br><span class="line">/usr/lib/modules/3.10.0-327.28.2.el7.x86_64/kernel/drivers/block/virtio_blk.ko</span><br><span class="line">/usr/lib/modules/3.10.0-327.28.2.el7.x86_64/kernel/drivers/net/virtio_net.ko</span><br></pre></td></tr></table></figure>
<h2 id="1-2-virtio-Frontend"><a href="#1-2-virtio-Frontend" class="headerlink" title="1.2 virtio Frontend"></a>1.2 virtio Frontend</h2><h3 id="1-2-1-Linux"><a href="#1-2-1-Linux" class="headerlink" title="1.2.1 Linux"></a>1.2.1 Linux</h3><p>目前新版本的 Linux(Ubuntu / CentOS / …. 等等)都已經內建 virtio driver 了，不需要再額外安裝囉!</p>
<h3 id="1-2-2-Windows"><a href="#1-2-2-Windows" class="headerlink" title="1.2.2 Windows"></a>1.2.2 Windows</h3><p>若是要安裝 Windows 的 virtio driver，可以使用以下指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://fedorapeople.org/groups/virt/virtio-win/virtio-win.repo -O /etc/yum.repos.d/virtio-win.repo</span><br><span class="line"></span><br><span class="line">$ yum info virtio-win</span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: ftp.yzu.edu.tw</span><br><span class="line"> * epel: mirror01.idc.hinet.net</span><br><span class="line"> * extras: ftp.yzu.edu.tw</span><br><span class="line"> * updates: ftp.yzu.edu.tw</span><br><span class="line">Available Packages</span><br><span class="line">Name        : virtio-win</span><br><span class="line">Arch        : noarch</span><br><span class="line">Version     : 0.1.102</span><br><span class="line">Release     : 1</span><br><span class="line">Size        : 75 M</span><br><span class="line">Repo        : virtio-win-stable</span><br><span class="line">Summary     : VirtIO para-virtualized drivers <span class="keyword">for</span> Windows(R)</span><br><span class="line">URL         : http://www.redhat.com/</span><br><span class="line">License     : GPLv2</span><br><span class="line">Description : VirtIO para-virtualized Windows(R) drivers <span class="keyword">for</span> 32-bit and 64-bit</span><br><span class="line">            : Windows(R) guests.</span><br><span class="line"></span><br><span class="line">$ yum -y install virtio-win</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢目前 virtio-win 的支援程度</span></span><br><span class="line">$ ls -R /usr/share/virtio-win</span><br><span class="line">/usr/share/virtio-win:</span><br><span class="line">drivers  guest-agent  virtio-win-0.1.102_amd64.vfd  virtio-win-0.1.102.iso  virtio-win-0.1.102_x86.vfd  virtio-win_amd64.vfd  virtio-win.iso  virtio-win_x86.vfd</span><br><span class="line"></span><br><span class="line">/usr/share/virtio-win/drivers:</span><br><span class="line">amd64  i386</span><br><span class="line"></span><br><span class="line">/usr/share/virtio-win/drivers/amd64:</span><br><span class="line">Win2003  Win2008  Win2008R2  Win2012  Win2012R2  Win7  Win8  Win8.1</span><br><span class="line">.......</span><br><span class="line">/usr/share/virtio-win/drivers/amd64/Win2012R2:</span><br><span class="line">netkvm.cat  netkvm.inf  netkvm.sys  vioscsi.cat  vioscsi.inf  vioscsi.sys  viostor.cat  viostor.inf  viostor.sys</span><br><span class="line">.......</span><br><span class="line">/usr/share/virtio-win/drivers/amd64/Win7:</span><br><span class="line">netkvm.cat  netkvm.inf  netkvm.sys  qxl.cat  qxldd.dll  qxl.inf  qxl.sys  vioscsi.cat  vioscsi.inf  vioscsi.sys  viostor.cat  viostor.inf  viostor.sys</span><br><span class="line">.......</span><br></pre></td></tr></table></figure>
<blockquote>
<p>從上面的檔案列表得知，目前 stable 的 virtio-win 支援到 Windows 2012R2 &amp; Windows 8.1，若要更新的 Windows OS 需求，可能要使用 latest 版本</p>
</blockquote>
<p>若希望可以在最新版的 Windows 上安裝 virtio driver，那就要升級到最新版的 virtio-win，可以透過以下的指令來啟用最新的 repository &amp; 升級：(目前最新版已經支援 Windows 10)</p>
<blockquote>
<p>yum –enablerepo=virtio-win-latest update virtio-win</p>
</blockquote>
<p>使用方式很容易，只要在啟動 windows virtual machine 時，指定 CDRom 裝置掛載 <font color="red"><strong>/usr/share/virtio-win/virtio-win-0.1.102.iso</strong></font> 後，進入 Windows 把相關的 virtio 裝置驅動即可，詳細的使用方式可以參考 =&gt; <a href="http://www.lijyyh.com/2015/12/linux-kvm-set-up-linux-kvm.html" target="_blank" rel="noopener">傲笑紅塵路: 架設 Linux KVM 虛擬化主機 (Set up Linux KVM virtualization host)</a></p>
<hr>
<h1 id="使用-virtio-balloon"><a href="#使用-virtio-balloon" class="headerlink" title="使用 virtio_balloon"></a>使用 virtio_balloon</h1><h2 id="balloonning-Overview"><a href="#balloonning-Overview" class="headerlink" title="balloonning Overview"></a>balloonning Overview</h2><p><img src="http://smilejay.com/wp-content/uploads/2012/11/linux-ballooning-demo.jpg" alt="KVM ballooning"></p>
<p>透過 balloon 的技術，可以如上圖所示，在 virtual machine 運行時動態調整記憶體的配置，而不需要 virtual machine 關機。</p>
<p>情境如下：</p>
<ol>
<li><p>當 host machine 記憶體空間不足時，在 virtual machine 中的記憶體 balloon 會膨脹(inflate)，讓 virtual machine 實際上無法使用到太多的記憶體，進而讓記憶體空間可以讓 host machine 暫時利用</p>
</li>
<li><p>當 virtual machine 記憶體空間不足時，在 virtual machine 中的記憶體 balloon 則會壓縮(deflate)，讓 host machine 可以分配閒置的記憶體給 virtual machine</p>
</li>
</ol>
<blockquote>
<p>以上功能必須透過 <code>virtio-balloon driver</code> 來達成</p>
</blockquote>
<h2 id="使用-balloonning-技術的優缺點"><a href="#使用-balloonning-技術的優缺點" class="headerlink" title="使用 balloonning 技術的優缺點"></a>使用 balloonning 技術的優缺點</h2><p>使用 balloon 的技術肯定也是有優缺點的，管理者可以根據實際需求評估使用：</p>
<p>優點如下：</p>
<ul>
<li><p>由於 balloonning 是能夠被監控 &amp; 控制的(不同於不可控制的 KSM 技術)，因此能夠有效率的節省記憶體的實際耗用</p>
</li>
<li><p>balloonning 對於記憶體的調度是很靈活的</p>
</li>
<li><p>hypervisor 透過 balloonning 從 virtual machine 中取得歸還的部分記憶體空間，不一定一定要用在其他地方，可自己保留住，端看管理者想要如何管理記憶體空間</p>
</li>
</ul>
<p>但 balloonning 同樣也是有些缺點存在的的：</p>
<ul>
<li><p>virtual machine 必須安裝 virtio_balloon driver 才可使用此功能(新版的 Linux 有內建，但 Windows 就必須要另外安裝了)</p>
</li>
<li><p>若透過 balloonning 從 virtual machine 中取回大量的記憶體空間，可能會提升 virtual machine 對於 swap 的 I/O 存取而導致效能降低；也有可能會造成 virtual machine 中的某些 process 運作時發生記憶體不足的況狀而失敗</p>
</li>
<li><p>雖然 balloonning 可被監控 &amp; 控制，但目前尚缺乏有效的自動化機制，對於大規模佈署使用上是不方便的</p>
</li>
<li><p>記憶體動態調整的過於頻繁，可能會使記憶體空間配置上過於零散而不連續，如此一來記憶體的使用效率就會降低</p>
</li>
</ul>
<h2 id="在-QEMU-KVM-中使用-balloonning"><a href="#在-QEMU-KVM-中使用-balloonning" class="headerlink" title="在 QEMU/KVM 中使用 balloonning"></a>在 QEMU/KVM 中使用 balloonning</h2><p>首先要先檢查 host machine 是否支援 balloonning：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cat /boot/config-`uname -r` | grep VIRTIO</span><br><span class="line">CONFIG_VIRTIO_BLK=m</span><br><span class="line">CONFIG_SCSI_VIRTIO=m</span><br><span class="line">CONFIG_VIRTIO_NET=m</span><br><span class="line">CONFIG_VIRTIO_CONSOLE=m</span><br><span class="line">CONFIG_HW_RANDOM_VIRTIO=m</span><br><span class="line">CONFIG_VIRTIO=m</span><br><span class="line">CONFIG_VIRTIO_PCI=m</span><br><span class="line">CONFIG_VIRTIO_PCI_LEGACY=y</span><br><span class="line">CONFIG_VIRTIO_BALLOON=m</span><br><span class="line">CONFIG_VIRTIO_INPUT=m</span><br><span class="line"><span class="comment"># CONFIG_VIRTIO_MMIO is not set</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>CONFIG_VIRTIO_BALLOON=m 表示已經支援(以 module 方式載入)</p>
</blockquote>
<p>接著要在 virtual machine 中啟用 balloonning，則必須在啟動 virtual machine 的指令中加上以下參數：(預設為 <code>-balloon none</code>)</p>
<blockquote>
<p>-balloon virtio[,addr=addr]</p>
</blockquote>
<p>參數中的 addr 是可用來指定 virtual machine 中 balloon device 的 PCI address</p>
<p>也可以使用 <font color="red"><strong>-device</strong></font> 參數來統一設定不同的 device，使用方法如下：</p>
<blockquote>
<p>-device driver[,prop[=value][,…]]</p>
</blockquote>
<p>了解啟用 balloon 的參數後，可以用以下指令啟動搭載 balloonning 功能的 virtual machine：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kvm -vnc 0.0.0.0:1 -m 2048 /kvm/storage/vm_disks/ubnutu1604.img \</span><br><span class="line">  -net nic -net tap,script=/etc/qemu-ifup \</span><br><span class="line">  -device virtio-balloon-pci --daemonize</span><br></pre></td></tr></table></figure>
<p>接著連線到 virtual machine 中，查詢 balloonning device 的狀態：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># balloon 功能已開啟</span></span><br><span class="line">ubuntu@vm-ubuntu1604:~$ cat /boot/config-`uname -r` | grep VIRTIO</span><br><span class="line">.....</span><br><span class="line">CONFIG_VIRTIO_BALLOON=y</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視目前 pci device 狀態</span></span><br><span class="line">ubuntu@vm-ubuntu1604:~$ lspci</span><br><span class="line">00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)</span><br><span class="line">00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]</span><br><span class="line">00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]</span><br><span class="line">00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03)</span><br><span class="line">00:02.0 VGA compatible controller: Cirrus Logic GD 5446</span><br><span class="line">00:03.0 Ethernet controller: Intel Corporation 82540EM Gigabit Ethernet Controller (rev 03)</span><br><span class="line">00:04.0 Unclassified device [00ff]: Red Hat, Inc Virtio memory balloon</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢 balloonning device 的詳細資訊</span></span><br><span class="line">ubuntu@vm-ubuntu1604:~$ lspci -s 00:04.0 -v</span><br><span class="line">00:04.0 Unclassified device [00ff]: Red Hat, Inc Virtio memory balloon</span><br><span class="line">        Subsystem: Red Hat, Inc Virtio memory balloon</span><br><span class="line">        Physical Slot: 4</span><br><span class="line">        Flags: bus master, fast devsel, latency 0, IRQ 11</span><br><span class="line">        I/O ports at c040 [size=32]</span><br><span class="line">        Kernel driver <span class="keyword">in</span> use: virtio-pci</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視 virtual machine 記憶體狀態</span></span><br><span class="line">ubuntu@vm-ubuntu1604:~$ free -m</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           2000          40        1851           3         108        1823</span><br><span class="line">Swap:          2045           0        2045</span><br></pre></td></tr></table></figure>
<p>接著在 QEMU monitor 中透過 <code>balloon 512</code> 把 virtual machine 的記憶體限縮到僅能使用 512 MB：</p>
<p><img src="https://github.com/godleon/godleon.github.io/blob/master/_posts/images/2016/KVM-Paravirtualization-Drivers/kvm_virtio_balloon.PNG?raw=true" alt="balloon"></p>
<p>以下是 virtual machine 中目前的記憶體狀況：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 經過 balloon 縮小可用記憶體空間後，檢視記憶體狀態</span></span><br><span class="line">ubuntu@vm-ubuntu1604:~$ free -m</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:            464          39         316           3         108         288</span><br><span class="line">Swap:          2045           0        2045</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看出 total memory 已經變少，可見 balloon 的確是起了作用</p>
</blockquote>
<p>另外一個比較需要注意的是，balloon 沒辦法用於增加 virtual machine 的記憶體配置；例如，啟用 virtual machine 時配置了 2048 MB 的記憶體，即使在 QEMU monitor 中使用 <code>ballon 4096</code>，也無法讓 virtual machine 的記憶體變成 4096 MB。</p>
<hr>
<h1 id="使用-virtio-net"><a href="#使用-virtio-net" class="headerlink" title="使用 virtio_net"></a>使用 virtio_net</h1><p>使用 virtio network device，有提高 throughput &amp; 降低 latency 的兩項優點，可以達到接近原生網卡的效能，因此通常是配置網路時的優先選擇。</p>
<p>以下指令可以查詢是否支援 virtio_net：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 有出現 virtio 表示支援 virtio network device</span></span><br><span class="line">$ kvm -net nic,model=?</span><br><span class="line">qemu: Supported NIC models: ne2k_pci,i82551,i82557b,i82559er,rtl8139,e1000,pcnet,virtio</span><br></pre></td></tr></table></figure>
<h2 id="1、啟用支援-virtio-net-的-vitual-machine"><a href="#1、啟用支援-virtio-net-的-vitual-machine" class="headerlink" title="1、啟用支援 virtio_net 的 vitual machine"></a>1、啟用支援 virtio_net 的 vitual machine</h2><p>接著可以用以下指令啟動一個使用 virtio_net 的 virtual machine：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kvm -vnc 0.0.0.0:1 -m 2048 --daemonize \</span><br><span class="line">  -drive format=raw,file=/kvm/storage/vm_disks/ubnutu1604.img \</span><br><span class="line">  -device virtio-balloon-pci \</span><br><span class="line">  -net nic,model=virtio -net tap</span><br></pre></td></tr></table></figure>
<p>當 virtual machine 啟動後，登入檢查 virtio_net 的狀態：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ubuntu 16.04 原生已經搭載 virtio driver</span></span><br><span class="line">ubuntu@vm-ubuntu1604:~$ cat /boot/config-`uname -r` | grep VIRTIO</span><br><span class="line">.....</span><br><span class="line">CONFIG_VIRTIO_NET=y</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可看出目前 virtual machine 的網卡已經以 virtio 模式運作</span></span><br><span class="line">ubuntu@vm-ubuntu1604:~$ lspci</span><br><span class="line">....</span><br><span class="line">00:03.0 Ethernet controller: Red Hat, Inc Virtio network device</span><br><span class="line">00:04.0 Unclassified device [00ff]: Red Hat, Inc Virtio memory balloon</span><br><span class="line"></span><br><span class="line"><span class="comment"># virtio_net 詳細資訊</span></span><br><span class="line">ubuntu@vm-ubuntu1604:~$ lspci -vv -s 00:03.0</span><br><span class="line">00:03.0 Ethernet controller: Red Hat, Inc Virtio network device</span><br><span class="line">        Subsystem: Red Hat, Inc Virtio network device</span><br><span class="line">        Physical Slot: 3</span><br><span class="line">        Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR+ FastB2B- DisINTx+</span><br><span class="line">        Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast &gt;TAbort- &lt;TAbort- &lt;MAbort- &gt;SERR- &lt;PERR- INTx-</span><br><span class="line">        Latency: 0</span><br><span class="line">        Interrupt: pin A routed to IRQ 11</span><br><span class="line">        Region 0: I/O ports at c000 [size=32]</span><br><span class="line">        Region 1: Memory at febd1000 (32-bit, non-prefetchable) [size=4K]</span><br><span class="line">        Expansion ROM at feb80000 [disabled] [size=256K]</span><br><span class="line">        Capabilities: &lt;access denied&gt;</span><br><span class="line">        Kernel driver <span class="keyword">in</span> use: virtio-pci</span><br></pre></td></tr></table></figure>
<h2 id="2、進一步提升半虛擬化網卡效能"><a href="#2、進一步提升半虛擬化網卡效能" class="headerlink" title="2、進一步提升半虛擬化網卡效能"></a>2、進一步提升半虛擬化網卡效能</h2><h3 id="1-關閉-TSO-amp-GSO-以提升-virtio-net-的效能"><a href="#1-關閉-TSO-amp-GSO-以提升-virtio-net-的效能" class="headerlink" title="(1) 關閉 TSO &amp; GSO 以提升 virtio_net 的效能"></a>(1) 關閉 TSO &amp; GSO 以提升 virtio_net 的效能</h3><p>為了提升 virtual machine 網卡的效能，除了使用 virtio 半虛擬化的技術外，還可以透過關閉 host machine 的 TSO &amp; GSO 功能來更進一步提升</p>
<p>以下可以檢查 host machine 的網卡是否支援 TSO &amp; GSO：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ethtool -k ens1f1</span><br><span class="line">Features <span class="keyword">for</span> ens1f1:</span><br><span class="line">.....</span><br><span class="line">tcp-segmentation-offload: on</span><br><span class="line">        tx-tcp-segmentation: on</span><br><span class="line">        tx-tcp-ecn-segmentation: off [fixed]</span><br><span class="line">        tx-tcp6-segmentation: on</span><br><span class="line">.....</span><br><span class="line">generic-segmentation-offload: on</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>
<p>從上面可以看出目前 TSO &amp; GSO 的功能都是開啟的，可以透過以下方式關閉：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ethtool -K ens1f1 tso off</span><br><span class="line">$ ethtool -K ens1f1 gso off</span><br></pre></td></tr></table></figure>
<p>如此一來 virtio_net 的效能就可以進一步的提升。</p>
<h3 id="2-使用-vhost-net-後端驅動"><a href="#2-使用-vhost-net-後端驅動" class="headerlink" title="(2) 使用 vhost-net 後端驅動"></a>(2) 使用 vhost-net 後端驅動</h3><p>一般來說，virtio 在 host machine 是由每個 user space 中的 QEMU 來進行後端處理的，但若是可以將 network I/O 的部分移到 kernel space 來處理，不僅可以提高 network throughput，還可以降低 latency，進而提升網路的效率。</p>
<p>目前比較新的 Linux kernel 中都有搭載稱為 <strong><font color="red">vhost-net</font></strong> 的 module，可用來將 virtio_net 的後端處理移到 Linux kernel 中進行來提升 network I/O 的效率。</p>
<p>首先先來檢查 host machine 是否支援 <strong>vhost-net</strong> 的功能：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat /boot/config-`uname -r` | grep VHOST</span><br><span class="line">CONFIG_VHOST_NET=m</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">$ lsmod | grep vhost</span><br><span class="line">vhost_net              18152  1</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>從上面可以看出 host machine 有支援 vhost-net，接著就可以使用以下指令啟動支援 vhost-net 的 virtual machine：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kvm -vnc 0.0.0.0:1 -m 2048 --daemonize \</span><br><span class="line">  -drive format=raw,file=/kvm/storage/vm_disks/ubnutu1604.img,<span class="keyword">if</span>=virtio \</span><br><span class="line">  -device virtio-balloon-pci \</span><br><span class="line">  -netdev tap,id=net0,vhost=on -device virtio-net-pci,netdev=net0</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="使用-virtio-blk"><a href="#使用-virtio-blk" class="headerlink" title="使用 virtio_blk"></a>使用 virtio_blk</h1><p>virtio_blk 提供了 virtual machine 可以透過 virtio API 進行 block device I/O 的相關驅動程式，藉以提升存取 block device 的效能。</p>
<p>同樣的，要使用 virtio_blk，host machine &amp; virtual machine 都必須要同時支援才行，目前新版的 Linux 都已經預設搭載 virtio driver 了，我們用以下的指令啟動支援 virtio_blk 的 virtual machine：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kvm -vnc 0.0.0.0:1 -m 2048 --daemonize \</span><br><span class="line">  -drive format=raw,file=/kvm/storage/vm_disks/ubnutu1604.img \</span><br><span class="line">  -device virtio-balloon-pci \</span><br><span class="line">  -netdev tap,id=net0,vhost=on -device virtio-net-pci,netdev=net0</span><br></pre></td></tr></table></figure>
<p>進入到 virtual machine 之後，可以透過以下指令確認 block device 的確是以 virtio driver 所驅動：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@vm-ubuntu1604:~$ cat /boot/config-`uname -r` | grep VIRTIO_BLK</span><br><span class="line">CONFIG_VIRTIO_BLK=y</span><br><span class="line"></span><br><span class="line">ubuntu@vm-ubuntu1604:~$ lspci | grep -i virtio</span><br><span class="line">00:03.0 Unclassified device [00ff]: Red Hat, Inc Virtio memory balloon</span><br><span class="line">00:04.0 Ethernet controller: Red Hat, Inc Virtio network device</span><br><span class="line">00:05.0 SCSI storage controller: Red Hat, Inc Virtio block devicei</span><br><span class="line"></span><br><span class="line">ubuntu@vm-ubuntu1604:~$ lspci -vv -s 00:05.0</span><br><span class="line">00:05.0 SCSI storage controller: Red Hat, Inc Virtio block device</span><br><span class="line">        Subsystem: Red Hat, Inc Virtio block device</span><br><span class="line">        Physical Slot: 5</span><br><span class="line">        Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR+ FastB2B- DisINTx+</span><br><span class="line">        Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast &gt;TAbort- &lt;TAbort- &lt;MAbort- &gt;SERR- &lt;PERR- INTx-</span><br><span class="line">        Latency: 0</span><br><span class="line">        Interrupt: pin A routed to IRQ 10</span><br><span class="line">        Region 0: I/O ports at c000 [size=64]</span><br><span class="line">        Region 1: Memory at febd2000 (32-bit, non-prefetchable) [size=4K]</span><br><span class="line">        Capabilities: &lt;access denied&gt;</span><br><span class="line">        Kernel driver <span class="keyword">in</span> use: virtio-pci</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><p><a href="https://read01.com/4aJdOL.html" target="_blank" rel="noopener">Virtio 基本概念和設備操作 - 壹讀</a></p>
</li>
<li><p><a href="http://www.cnblogs.com/sammyliu/p/4543657.html" target="_blank" rel="noopener">KVM 介绍（3）：I/O 全虚拟化和准虚拟化 [KVM I/O QEMU Full-Virtualizaiton Para-virtualization] - SammyLiu - 博客园</a></p>
</li>
<li><p><a href="http://www.lijyyh.com/2015/12/linux-kvm-set-up-linux-kvm.html" target="_blank" rel="noopener">傲笑紅塵路: 架設 Linux KVM 虛擬化主機 (Set up Linux KVM virtualization host)</a></p>
</li>
<li><p><a href="https://fedoraproject.org/wiki/Windows_Virtio_Drivers" target="_blank" rel="noopener">Windows Virtio Drivers - FedoraProject</a></p>
</li>
<li><p><a href="http://www.linux-kvm.org/page/Virtio" target="_blank" rel="noopener">Virtio - KVM</a></p>
</li>
<li><p><a href="http://seitran.com/2015/04/13/01-gso-gro-lro/" target="_blank" rel="noopener">网卡TSO/GSO/LRO/GRO简要介绍 | Chenny的部落格</a></p>
</li>
<li><p><a href="http://lirobo.blogspot.tw/2014/12/tso-gso-lro-gro.html" target="_blank" rel="noopener">小蘿蔔工作室 Little Robot Studio: TSO, GSO, LRO, GRO</a></p>
</li>
<li><p><a href="https://kris.io/2015/10/01/kvm-network-performance-tso-and-gso-turn-it-off/" target="_blank" rel="noopener">KVM Network Performance : TSO and GSO - Turn it off - kris.io : virtualization &amp; cloud</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> KVM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> KVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Linux KVM] Linux KVM concept - Networking]]></title>
      <url>/blog/2016/08/10/KVM/KVM-Basic-Concept-Networking/</url>
      <content type="html"><![CDATA[<p>此篇文章介紹學習 Linux KVM 時所需要了解的 Networking 相關知識</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>現今的虛擬化技術中，網路的部分永遠都是比重相當高的一部分，許多大型的 service provider 透過網路提供各種不同的服務給使用者，讓使用者在 IT 科技的幫助下，生活更加便利。</p>
<p>也因為這樣，當網路發生故障時，這些公司的損失常常難以估計，因此網路架構的設計上，保有彈性 &amp; 穩定性是相當重要的。</p>
<p>而現在 server 普遍都擁有多張網路卡，為了提高網路使用效率 &amp; 增加備援功能，建議 <strong><font color="red">透過 Linux bonding 的技術將所有的網路卡設定成為 single virtual channel</font></strong>。</p>
<blockquote>
<p>bonding mode 有分為 Mode 1(active-backup)、Mode 2(balance-xor)、Mode 4(802.3ad/LACP)、Mode 5(balance-tlb)，其中建議使用 <code>Mode 1(active-backup)</code> &amp; <code>Mode 5(balance-tlb)</code></p>
</blockquote>
<hr>
<h1 id="KVM-QEMU-支援的-Network-Type"><a href="#KVM-QEMU-支援的-Network-Type" class="headerlink" title="KVM/QEMU 支援的 Network Type"></a>KVM/QEMU 支援的 Network Type</h1><p>網路絕對是使用 vitual machine 時最不可或缺的一部分，而 QEMU 提供了 virtual machine 一共四種不同的 network type：</p>
<ol>
<li><p>bridge</p>
</li>
<li><p>NAT</p>
</li>
<li><p>user mode networking</p>
</li>
<li><p>VT-d &amp; SR-IOV (直接分配網路設備)</p>
</li>
</ol>
<p>要透過 QEMU 配置 virtual machine 的網路，必須使用 <code>-net</code> 參數，若是完全沒使用任何的網路相關參數，會系統自動帶上 <code>-net nic -net user</code> 做為網路預設值。</p>
<p>而 QEMU 可以模擬那些網路卡呢? 肯定必須是主流且被廣泛支援的，可以用以下指令查詢：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kvm -net nic,model=?</span><br><span class="line">qemu: Supported NIC models: ne2k_pci,i82551,i82557b,i82559er,rtl8139,e1000,pcnet,virtio</span><br></pre></td></tr></table></figure>
<blockquote>
<p>若沒指定任何網路相關參數，則預設會使用 RTL8139 網卡</p>
</blockquote>
<hr>
<h1 id="設定第一張虛擬網卡"><a href="#設定第一張虛擬網卡" class="headerlink" title="設定第一張虛擬網卡"></a>設定第一張虛擬網卡</h1><p>為了要設定虛擬網卡，必須先了解 <code>-net nic</code> 相關參數：</p>
<blockquote>
<p>-net nic[,vlan=n][,macaddr=mac][,model=type] [,name=name][,addr=addr][,vectors=v]</p>
</blockquote>
<ul>
<li><p><code>-net nic</code>：表示這是一個網卡的設定 (<strong><font color="red">必要!</font></strong>)</p>
</li>
<li><p><code>vlan=n</code>：將網卡連結到 ID 為 <strong><font color="red">n</font></strong> 的 VLAN</p>
</li>
<li><p><code>macaddr=mac</code>：指定網卡 MAC address</p>
</li>
<li><p><code>model=type</code>：設定網卡的種類，預設為 <strong><font color="red">rtl8139</font></strong></p>
</li>
<li><p><code>name=name</code>：為網卡命名(但僅有在 QEMU monitor 看的到)</p>
</li>
<li><p><code>addr=addr</code>：指定網卡在 virtual machine 中的 PCI device address</p>
</li>
<li><p><code>vectors=v</code>：設定網卡設備的 MSI-X 向量的數量，用於 virtio 驅動的網卡上</p>
</li>
</ul>
<p>簡單做個測試，我們透過以下指令指定網卡：</p>
<blockquote>
<p>kvm -vnc 0.0.0.0:1 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img -net nic,vlan=0,macaddr=52:53:00:11:12:13,model=e1000,addr=08 -net user</p>
</blockquote>
<p>於是在系統中可以得到以下訊息：</p>
<p><img src="https://lh3.googleusercontent.com/abxoQOVs8BrZGNtB7rvarf28_a0AomNu_UBJvLgblFG6uoAj2lWJnlMGMuujMu_V3ldlY2p2ZPYTQJa84180vlnBkGp4bkJmidQN29QBEO9zb9cWOOQOK5HTTOwglaXnEJ_WXdSnKO1xGFmKkdHZji1tulTDI_mihaOaghtA3YlT_I5ss4-OQbsdK2lIdLz_deaKnb5AcAQA9cmAt6rPaW0pocvL4THwvZY3d4QXOOMso96DPPTWntwl0qsHEd19BMg4B0uzuAbNlIVglYMX8k80YOTZxTQDsAFi16q5MDlgrTPDa0VY7UOoNFvI-7PWmktPf3RYSpXa1QQ6kmASVax3x3NCYC3pZW_HA27dxjwyA3GRM4IYtsjKA9EBjMkhpVZmHeoxAeCk9_gSXKMJUqEdg8u63JRm9xsJobEcOy_g_1YXmMPCc1v-8Mx1QFpwctMr5C7DXq8DI-C_Voz2Y8DGpz1p7prWgDb2j1v6daMfvJwJvtKAyw2p2HyulbsMuSZE3JNB6bsZLmJgi4WjvXT3rr32l1mJQcE64B4MK-ZLQMZjTA0g18g5w5wk5d83XtQiSahUc-5wGhudJ6l5sqqRwDQ1Nec=w771-h384-no" alt="System NIC Information"></p>
<p>在 QEMU monitor 則可以看到以下資訊：</p>
<p><img src="https://lh3.googleusercontent.com/RPzHnMisxvsHZx5xpTctONaavpAXkcjUxfqHdaiNfwYL-RyspfM2dGW4rffxz7Z-NyzLHH1ChC0zGwjNes5AclVYiW4-8Bb8YOgg61jHs58jmMchhv_ICNNvwhm-vkyHmkffIukmKxX7BqufthPly1VgVMNI1J2x17l66DD2LicTEbGPQB-414rpc8tTR1l3pBPnoNPZuaxTNCXNYlkfmvQUdx1ltYfWusoEUsxhLckpakEJ_F8qCEGrJ-dmLgh6BbLjDNlDfqBix-bMJaBdGlyngC8XvWR-f45eTKUyPCukFb-oSFVFH1VspTRqsBgccbSH06fKlq12CDu0pNhBNbte6zFPt7oJMAFn_Yf2ENBWXQbFjRs2H0x8eaCcQ0MiXY01wUmsNYoGJsgmZgKJZ2jQdhLDXu4bjtoH-0DuZw1NSfKPuIkDks9FdQR0j-adxK_rOg9oqpTdNOBOkU_QPfqQJUejhwlTr5OwjLjGkD5XIYHKbXU72D66eDCZNTMVUGxWo_EkhVluszNlN1PiCzOdqlRK4StC0LVWUFscHLHwyEjHuwTwg0BEIRs91_-nD0DrJT5mZF7emdCRPStDDdWGdP9ftVY=w541-h153-no" alt="Network Info in QEMU monitor"></p>
<hr>
<h1 id="設定-Bridge-Mode"><a href="#設定-Bridge-Mode" class="headerlink" title="設定 Bridge Mode"></a>設定 Bridge Mode</h1><h2 id="設定參數說明"><a href="#設定參數說明" class="headerlink" title="設定參數說明"></a>設定參數說明</h2><p>在 bridge mode 下，virtual machine 的網路可視為與 host machine 是相同的，可以有自己的獨立 ip，外部網路可以直接存取 virtual machine。</p>
<p>以下是建立 bridge mode NIC 的參數：</p>
<blockquote>
<p>-net tap[,vlan=n][,name=name][,fd=h][,ifname=name][,script=file][,downscript=dfile][,helper=helper]</p>
</blockquote>
<ul>
<li><p><code>tap</code>：表示使用 tap device(屬於 layer 2 的虛擬網路設備；附帶一提，<code>tun</code> 則是屬於 layer 3 的虛擬網路設備)</p>
</li>
<li><p><code>vlan=n</code>：指定使用的 VLAN ID</p>
</li>
<li><p><code>name=name</code>：設定網卡名稱(可從 QEMU monitor 中檢視，但大多數情況下可忽略)</p>
</li>
<li><p><code>fd=h</code>：連接到已經開啟 tap 的 file descriptor (<strong>一般交給 QEMU 自行建立</strong>)</p>
</li>
<li><p><code>ifname=name</code>：設定 tap device 名稱(未設定的話會由 QEMU 自行產生)</p>
</li>
<li><p><code>script=file</code>：指定啟動 virtual machine 時自動執行的 script</p>
</li>
<li><p><code>downscript=dfile</code>：指定關閉 virtual machine 時自動執行的 script</p>
</li>
<li><p><code>helper=helper</code>：指定啟動 virtual machine 時會在 host machine 上執行的 helper 程式(例如：建立 tap device)，一般可以忽略使用預設值即可</p>
</li>
</ul>
<h2 id="建立支援-bridge-mode-的環境"><a href="#建立支援-bridge-mode-的環境" class="headerlink" title="建立支援 bridge mode 的環境"></a>建立支援 bridge mode 的環境</h2><h3 id="1、檢查環境支援程度"><a href="#1、檢查環境支援程度" class="headerlink" title="1、檢查環境支援程度"></a>1、檢查環境支援程度</h3><p>在建立 bridge 模式的網路配置之前，我們必須先確定 host machine 已經掛載相關模組：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 檢查是否有掛載 tun 模組</span></span><br><span class="line">$ lsmod | grep tun</span><br><span class="line">tun                    27141  1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 確認目前的 user 有 /dev/net/tun 的讀寫權限</span></span><br><span class="line">$ ls -al /dev/net/tun</span><br><span class="line">crw-rw-rw-. 1 root root 10, 200 Aug  3 20:14 /dev/net/tun</span><br></pre></td></tr></table></figure>
<h3 id="2、在-host-machine-上可建立-bridge-device-的環境"><a href="#2、在-host-machine-上可建立-bridge-device-的環境" class="headerlink" title="2、在 host machine 上可建立 bridge device 的環境"></a>2、在 host machine 上可建立 bridge device 的環境</h3><p>環境說明：</p>
<ul>
<li><p>bridge device：<code>br0</code></p>
</li>
<li><p>physical device：<code>ens1f0</code></p>
</li>
<li><p>ip address：<code>10.20.190.2/24</code></p>
</li>
<li><p>gateway：<code>10.20.190.1</code></p>
</li>
</ul>
<p>以下要在 host machine 上建立一個 bridge device，並綁定到要連外的實體網卡，並讓 bridge device 成為連接 host machine 與外網的設備：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># nmcli connection add type bridge ifname br0</span></span><br><span class="line">[root@localhost ~]<span class="comment"># nmcli connection modify bridge-br0 bridge.stp yes</span></span><br><span class="line"><span class="comment"># 以下請根據自身的 lab 環境做調整</span></span><br><span class="line">[root@localhost ~]<span class="comment"># nmcli connection modify bridge-br0 ipv4.method manual ipv4.address "10.20.190.2/24" ipv4.gateway "10.20.190.1" ipv4.dns 8.8.8.8</span></span><br><span class="line">[root@localhost ~]<span class="comment"># nmcli connection add type bridge-slave ifname ens1f0 master br0</span></span><br><span class="line">[root@localhost ~]<span class="comment"># nmcli connection delete ens1f0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bridge device 設定完成後，可以檢查是否有與實體網卡連動</span></span><br><span class="line">$ brctl show</span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">br0             8000.2c600cb163d5       yes             ens1f0</span><br><span class="line">virbr0          8000.5254001001dc       yes             virbr0-nic</span><br></pre></td></tr></table></figure>
<p>設定完成後，實體網路卡會進入到 <strong><font color="red">promiscuous mode</font></strong>，而 bridge device 則會進入到 <strong><font color="red">forwarding state</font></strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ dmesg | grep ens1f0</span><br><span class="line">.....</span><br><span class="line">[807464.149861] device ens1f0 entered promiscuous mode</span><br><span class="line">.....</span><br><span class="line">[807494.252510] br0: port 1(ens1f0) entered forwarding state</span><br></pre></td></tr></table></figure>
<p>接著建立要進行 bridge 網路配置用的 script(<strong><font color="red">/etc/qemu-if{up,down}</font></strong>) 並設定可執行權限：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立 script (/etc/qemu-ifup)</span></span><br><span class="line">$ cat &lt;&lt;\EOF &gt;/etc/qemu-ifup</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#This is a qemu-ifup script for bridging.</span></span><br><span class="line"><span class="comment">#You can use it when starting a KVM guest with bridge mode network.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#set your bridge name</span></span><br><span class="line">switch=br0</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$1</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="comment">#start up the TAP interface</span></span><br><span class="line">  ip link <span class="built_in">set</span> <span class="variable">$1</span> up</span><br><span class="line">  sleep 1</span><br><span class="line">  <span class="comment">#add TAP interface to the bridge</span></span><br><span class="line">  brctl addif <span class="variable">$&#123;switch&#125;</span> <span class="variable">$1</span></span><br><span class="line">  <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> “Error: no interface specified”</span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">$ cat &lt;&lt;\EOF &gt;/etc/qemu-ifdown</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#This is a qemu-ifdown script for bridging.</span></span><br><span class="line"><span class="comment">#You can use it when starting a KVM guest with bridge mode network.</span></span><br><span class="line"><span class="comment">#Don’t use this script in most cases; QEMU will handle it automatically.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#set your bridge name</span></span><br><span class="line">switch=br0</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$1</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="comment"># Delete the specified interfacename</span></span><br><span class="line">  tunctl -d <span class="variable">$1</span></span><br><span class="line">  <span class="comment">#release TAP interface from bridge</span></span><br><span class="line">  brctl delif <span class="variable">$&#123;switch&#125;</span> <span class="variable">$1</span></span><br><span class="line">  <span class="comment">#shutdown the TAP interface</span></span><br><span class="line">  ip link <span class="built_in">set</span> <span class="variable">$1</span> down</span><br><span class="line">  <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> “Error: no interface specified”</span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定執行權限</span></span><br><span class="line">$ chmod +x /etc/qemu-if&#123;up,down&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>若是目前使用者沒有 script 的 execute 權限，就無法新增 tap interface for bridge mode 喔!</p>
</blockquote>
<h3 id="3、啟動-bridge-mode-virtual-machine"><a href="#3、啟動-bridge-mode-virtual-machine" class="headerlink" title="3、啟動 bridge-mode virtual machine"></a>3、啟動 bridge-mode virtual machine</h3><p>當上述環境都準備好後，可使用以下指令啟動 virtual machine：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -net nic -net tap =&gt; 指定 virtual machine 網卡為 bridge mode，建立 tap interface</span></span><br><span class="line"><span class="comment"># script=/etc/qemu-ifup =&gt; 指定 script 配置網卡</span></span><br><span class="line"><span class="comment"># downscript=/etc/qemu-ifdown =&gt; 指定 script 移除網卡 (若設定為 no 則 QEMU 會自動協助處理)</span></span><br><span class="line"><span class="comment"># --daemonize =&gt; QEMU 程序背景執行</span></span><br><span class="line">$ kvm -vnc 0.0.0.0:1 -m 2048 /kvm/storage/vm_disks/ubnutu1604.img -net nic -net tap,script=/etc/qemu-ifup,downscript=/etc/qemu-ifdown --daemonize</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢是否有啟動 tap interface 並與 bridge device 相連</span></span><br><span class="line">$ brctl show</span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">br0             8000.26503b3a5e74       yes             ens1f0</span><br><span class="line">                                                        tap0</span><br><span class="line">virbr0          8000.5254001001dc       yes             virbr0-nic</span><br></pre></td></tr></table></figure>
<p>當 virtual machine 啟動後(會在 DHCP 的地方卡一段時間)，在 virtual machine 中可以透過以下指令設定 IP：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假設新增的 network interface 為 ens3</span></span><br><span class="line">$ sudo ip addr add 10.20.190.3/24 dev ens3</span><br><span class="line">$ sudo ip route add 0.0.0.0/0 via 10.20.190.1 dev ens3</span><br></pre></td></tr></table></figure>
<p>如此一來在網路的部分就可以等同 host machine 一樣，正常存取 Internet &amp; 提供網路服務了</p>
<p>詳細的設定操作可以參考下圖：</p>
<p><img src="https://github.com/godleon/godleon.github.io/blob/master/_posts/images/2016/KVM-Basic-Concept-Networking/kvm_network-bridge-mode-configure-ip.PNG?raw=true" alt="Configure static IP by using ip command"></p>
<hr>
<h1 id="設定-NAT-mode"><a href="#設定-NAT-mode" class="headerlink" title="設定 NAT mode"></a>設定 NAT mode</h1><h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p>NAT 是為了解決 public ip address 不足而產生的，其詳細的原理這邊就不贅述了，可參考下列網址：</p>
<ul>
<li><a href="http://linux.vbird.org/linux_server/0250simple_firewall/0320nat.php" target="_blank" rel="noopener">鳥哥的 Linux 私房菜 – Network Address Transfer ( NAT ) 架設</a></li>
</ul>
<h2 id="檢查-host-machine-環境"><a href="#檢查-host-machine-環境" class="headerlink" title="檢查 host machine 環境"></a>檢查 host machine 環境</h2><h3 id="1、檢查-bridge-device"><a href="#1、檢查-bridge-device" class="headerlink" title="1、檢查 bridge device"></a>1、檢查 bridge device</h3><p>在 QEMU/KVM 中，使用 NAT mode 的 virtual machine 其實是透過 host machine 中的 <strong><font color="red">virbr0</font></strong> 這個 bridge device 連外的，可以來檢視一下相關資訊：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ ip addr show</span><br><span class="line">1: lo: .......</span><br><span class="line">2: eno1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP qlen 1000</span><br><span class="line">    link/ether 2c:60:0c:c1:b9:2d brd ff:ff:ff:ff:ff:ff</span><br><span class="line">3: ens1f0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq master br0 state UP qlen 1000</span><br><span class="line">    link/ether 2c:60:0c:b1:63:d5 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">4: ens1f1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP qlen 1000</span><br><span class="line">    link/ether 2c:60:0c:b1:63:d6 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">5: virbr0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN</span><br><span class="line">    link/ether 52:54:00:10:01:dc brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.122.1/24 brd 192.168.122.255 scope global virbr0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">6: virbr0-nic: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc pfifo_fast master virbr0 state DOWN qlen 500</span><br><span class="line">    link/ether 52:54:00:10:01:dc brd ff:ff:ff:ff:ff:ff</span><br><span class="line">7: br0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP</span><br><span class="line">    link/ether 2c:60:0c:b1:63:d5 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.20.190.2/24 brd 10.20.190.255 scope global br0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::2e60:cff:feb1:63d5/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<p>從上面可以看出，QEMU/KVM 已經幫我們把 virbr0 設定完成，使用的是 <code>192.168.122.1/24</code> 的網段。</p>
<h3 id="2、檢查-DHCP-服務"><a href="#2、檢查-DHCP-服務" class="headerlink" title="2、檢查 DHCP 服務"></a>2、檢查 DHCP 服務</h3><p>但關於 DHCP 的部分呢? QEMU/KVM 同樣也設定好 <strong><font color="red">dnsmasq</font></strong> 幫我們處理好 ip 的分配 &amp; traffic forwarding 的相關問題，若是要進一步的了解詳細的設定細節，可使用下面方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ ps -aux | grep dns</span><br><span class="line">nobody    4322  0.0  0.0  15552   888 ?        S    Jul27   0:01 /sbin/dnsmasq --conf-file=/var/lib/libvirt/dnsmasq/default.conf --leasefile-ro --dhcp-script=/usr/libexec/libvirt_leaseshelper</span><br><span class="line">root      4323  0.0  0.0  15524   176 ?        S    Jul27   0:00 /sbin/dnsmasq --conf-file=/var/lib/libvirt/dnsmasq/default.conf --leasefile-ro --dhcp-script=/usr/libexec/libvirt_leaseshelper</span><br><span class="line">root     16414  0.0  0.0 112652   976 pts/2    S+   06:02   0:00 grep --color=auto dns</span><br><span class="line"></span><br><span class="line">[root@ocp-kvm-host ~]<span class="comment"># cat /var/lib/libvirt/dnsmasq/default.conf</span></span><br><span class="line"><span class="comment">##WARNING:  THIS IS AN AUTO-GENERATED FILE. CHANGES TO IT ARE LIKELY TO BE</span></span><br><span class="line"><span class="comment">##OVERWRITTEN AND LOST.  Changes to this configuration should be made using:</span></span><br><span class="line"><span class="comment">##    virsh net-edit default</span></span><br><span class="line"><span class="comment">## or other application using the libvirt API.</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">## dnsmasq conf file created by libvirt</span></span><br><span class="line">strict-order</span><br><span class="line">pid-file=/var/run/libvirt/network/default.pid</span><br><span class="line">except-interface=lo</span><br><span class="line"><span class="built_in">bind</span>-dynamic</span><br><span class="line">interface=virbr0</span><br><span class="line">dhcp-range=192.168.122.2,192.168.122.254</span><br><span class="line">dhcp-no-override</span><br><span class="line">dhcp-lease-max=253</span><br><span class="line">dhcp-hostsfile=/var/lib/libvirt/dnsmasq/default.hostsfile</span><br><span class="line">addn-hosts=/var/lib/libvirt/dnsmasq/default.addnhosts</span><br></pre></td></tr></table></figure>
<h3 id="3、檢查-traffic-forward-設定"><a href="#3、檢查-traffic-forward-設定" class="headerlink" title="3、檢查 traffic forward 設定"></a>3、檢查 traffic forward 設定</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/sys/net/ipv4/ip_forward</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>‵<code>1</code> 表示 traffic forward 的功能是開啟的</p>
</blockquote>
<h3 id="3、檢查-firewall-設定"><a href="#3、檢查-firewall-設定" class="headerlink" title="3、檢查 firewall 設定"></a>3、檢查 firewall 設定</h3><p>最後要確認 host machine 可以將 virtual machine 對外的流量透過 virbr0 送出，因此要確認防火牆的設定：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iptables -t nat -L -vn</span></span><br><span class="line">Chain PREROUTING (policy ACCEPT 29 packets, 4041 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line"></span><br><span class="line">Chain INPUT (policy ACCEPT 5 packets, 1044 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 39 packets, 2906 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line"></span><br><span class="line">Chain POSTROUTING (policy ACCEPT 39 packets, 2906 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">    0     0 RETURN     all  --  *      *       192.168.122.0/24     224.0.0.0/24</span><br><span class="line">    0     0 RETURN     all  --  *      *       192.168.122.0/24     255.255.255.255</span><br><span class="line">    0     0 MASQUERADE  tcp  --  *      *       192.168.122.0/24    !192.168.122.0/24     masq ports: 1024-65535</span><br><span class="line">    0     0 MASQUERADE  udp  --  *      *       192.168.122.0/24    !192.168.122.0/24     masq ports: 1024-65535</span><br><span class="line">    0     0 MASQUERADE  all  --  *      *       192.168.122.0/24    !192.168.122.0/24</span><br></pre></td></tr></table></figure>
<blockquote>
<p>從上面可看出，來自於 192.168.122.0/24 網段且對外的流量，會以 NAT 的形式連外</p>
</blockquote>
<h2 id="建立可運行-NAT-mode-的環境"><a href="#建立可運行-NAT-mode-的環境" class="headerlink" title="建立可運行 NAT mode 的環境"></a>建立可運行 NAT mode 的環境</h2><p>確認好目前的環境後，我們便根據環境設定了兩支 script，分別用來產生 &amp; 移除 tap interface for NAT mode：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置 tap interface for NAT mode 的 script</span></span><br><span class="line">$ cat &lt;&lt;\EOF &gt;/etc/qemu-ifup-NAT</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># network information</span></span><br><span class="line">BRIDGE=virbr0</span><br><span class="line">NETWORK=192.168.122.0</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=192.168.122.1</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$1</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="comment"># 啟用 bridge device for NAT mode</span></span><br><span class="line">  brctl stp <span class="variable">$&#123;BRIDGE&#125;</span> on</span><br><span class="line">  ifconfig <span class="variable">$&#123;BRIDGE&#125;</span> <span class="variable">$&#123;GATEWAY&#125;</span> netmask <span class="variable">$&#123;NETMASK&#125;</span> up</span><br><span class="line"></span><br><span class="line">  ifconfig <span class="string">"<span class="variable">$1</span>"</span> 0.0.0.0 up</span><br><span class="line">  brctl addif <span class="variable">$&#123;BRIDGE&#125;</span> <span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line">  <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Error: no interface specified."</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除 tap interface for NAT mode 的 script</span></span><br><span class="line">$ cat &lt;&lt;\EOF &gt;/etc/qemu-ifdown-NAT</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># network information</span></span><br><span class="line">BRIDGE=virbr0</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$1</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Tearing down network bridge for <span class="variable">$1</span>"</span></span><br><span class="line">  ip link <span class="built_in">set</span> <span class="string">"<span class="variable">$1</span>"</span> down</span><br><span class="line">  brctl delif <span class="variable">$&#123;BRIDGE&#125;</span> <span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line">  <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Error: no interface specified."</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 為目前的使用者加入</span></span><br><span class="line">$ chmod +x /etc/qemu-if&#123;up,down&#125;-NAT</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上的 script 可能會因為自身的環境不同而有增減，需要特別注意一下</p>
</blockquote>
<h2 id="啟動-NAT-mode-virtual-machine"><a href="#啟動-NAT-mode-virtual-machine" class="headerlink" title="啟動 NAT-mode virtual machine"></a>啟動 NAT-mode virtual machine</h2><p>當環境都準備好後，可以使用以下指令啟動 virtual machine：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -net nic -net tap =&gt; 設定 tap interface</span></span><br><span class="line"><span class="comment"># script=/etc/qemu-ifup-NAT,downscript=/etc/qemu-ifdown-NAT =&gt; 使用指定的 script 配置網路</span></span><br><span class="line">$ kvm -vnc 0.0.0.0:1 -m 2048 /kvm/storage/vm_disks/ubnutu1604.img -net nic -net tap,script=/etc/qemu-ifup-NAT,downscript=/etc/qemu-ifdown-NAT --daemonize</span><br><span class="line"></span><br><span class="line"><span class="comment"># 從下面結果可看出 tap0 是與 virbr0 這個 bridge device 相連</span></span><br><span class="line">$ brctl show</span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">br0             8000.2c600cb163d5       yes             ens1f0</span><br><span class="line">virbr0          8000.1a507abb7dff       yes             tap0</span><br><span class="line">                                                        virbr0-nic</span><br></pre></td></tr></table></figure>
<p>最後確認一下 virtual machine 的狀況：</p>
<p><img src="https://github.com/godleon/godleon.github.io/blob/master/_posts/images/2016/KVM-Basic-Concept-Networking/kvm_network-NAT-mode-VM.PNG?raw=true" alt="NAT mode - virtual machine"></p>
<p>從上圖可看出 virtual machine 的確拿到了 192.168.122.0/24 網段中的 ip address，表示 host machine 中的 dnsmasq 運作正常；此外連外也正常，表示防火牆的設定部分也沒有問題</p>
<hr>
<h1 id="設定用戶模式-user-mode-網路-內部網路"><a href="#設定用戶模式-user-mode-網路-內部網路" class="headerlink" title="設定用戶模式(user-mode)網路(內部網路)"></a>設定用戶模式(user-mode)網路(內部網路)</h1><p>若在啟動 virtual machine 沒加上 <code>-net</code> 參數，預設 QEMU 就會使用 <code>-net nic -net user</code> 把 virtual machine 設定為 user mode。</p>
<p>user mode network 完全是由 QEMU 透過 <a href="http://wiki.qemu.org/Documentation/Networking" target="_blank" rel="noopener">SLiRP</a> 所實現的一個虛擬 NAT 網路，不用依賴先前所安裝的 <strong>bridge-utils</strong>、<strong>dnsmaq</strong>、<strong>iptables</strong> 等工具，也不需要 root 的權限就可執行。</p>
<p>以下是 user mode network 的架構圖：</p>
<p><img src="http://wiki.qemu.org/images/9/93/Slirp_concept.png" alt="SLiRP concept"></p>
<p>使用參數：<code>-net user[,option][,option][,...]</code></p>
<p>以下列出比較常用的 option：</p>
<ul>
<li><p><code>vlan=n</code>：將 user mode network 連接到 VLAN ID=n 的 VLAN</p>
</li>
<li><p><code>net=addr[/mask]</code>：設定 virtual machine 的 ip address (預設為 <strong><font color="red">10.0.2.0/24</font></strong>)</p>
</li>
<li><p><code>host=addr</code>：設定 host machine 的 ip address (預設為 <strong><font color="red">10.0.2.2</font></strong>)</p>
</li>
<li><p><code>dns=addr</code>：設定 virtual DNS 的 ip address (預設為 <strong><font color="red">10.0.2.3</font></strong>)</p>
</li>
<li><p><code>dhcpstart=addr</code>：設定 DHCP 的第一個 ip address (預設為 <strong><font color="red">10.0.2.15</font></strong>)</p>
</li>
<li><p><code>restrict=y|yes|n|no</code>：若設定 yes，virtual machine 將無法與 host machine 通訊，但不會影響 hostfwd 的設定</p>
</li>
<li><p><code>hostfwd=[tcp|udp]:[hostaddr]:hostport-[guestaddr]:guestport</code>：將 host machine 中的 hostport 導向 virtual machine 的 guestport (可一次定義多個 hostfwd 設定)</p>
</li>
</ul>
<p>以下是簡單的應用範例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -net nic -net user =&gt; user mode network</span></span><br><span class="line"><span class="comment"># hostfwd=tcp::5022-:22 =&gt; 將 host machine 的 tcp port 5022 導向 virtual machine 的 tcp port 22</span></span><br><span class="line">$ kvm -vnc 0.0.0.0:1 -m 2048 /kvm/storage/vm_disks/ubnutu1604.img -net nic -net user,hostfwd=tcp::5022-:22 --daemonize</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 tcp port 5022 連線到 virtual machine</span></span><br><span class="line">$ ssh -p 5022 ubuntu@10.20.190.2</span><br><span class="line">ubuntu@10.20.190.2\<span class="string">'s password:</span></span><br><span class="line"><span class="string">.......</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 查詢 ip address</span></span><br><span class="line"><span class="string">ubuntu@vm-ubuntu1604:~$ ip addr show</span></span><br><span class="line"><span class="string">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1</span></span><br><span class="line"><span class="string">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span></span><br><span class="line"><span class="string">    inet 127.0.0.1/8 scope host lo</span></span><br><span class="line"><span class="string">       valid_lft forever preferred_lft forever</span></span><br><span class="line"><span class="string">    inet6 ::1/128 scope host</span></span><br><span class="line"><span class="string">       valid_lft forever preferred_lft forever</span></span><br><span class="line"><span class="string">2: ens3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span></span><br><span class="line"><span class="string">    link/ether 52:54:00:12:34:56 brd ff:ff:ff:ff:ff:ff</span></span><br><span class="line"><span class="string">    inet 10.0.2.15/24 brd 10.0.2.255 scope global ens3</span></span><br><span class="line"><span class="string">       valid_lft forever preferred_lft forever</span></span><br><span class="line"><span class="string">    inet6 fe80::5054:ff:fe12:3456/64 scope link</span></span><br><span class="line"><span class="string">       valid_lft forever preferred_lft forever</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 實際上是可以上網的</span></span><br><span class="line"><span class="string">ubuntu@vm-ubuntu1604:~$ curl www.google.com.tw</span></span><br><span class="line"><span class="string">..........(省略一大堆內容)</span></span><br></pre></td></tr></table></figure>
<p>必須一提的是，使用 user mode network 也是有些缺點在的，像是：</p>
<ol>
<li><p>由於網路都是由 QEMU 虛擬出來的，因此效能比起其他模式相對差一些</p>
</li>
<li><p>不支援部分網路功能(例如：ICMP)，所以也就無法使用 ping command</p>
</li>
<li><p>無法從 host machine or 外部直接存取 virtual machine</p>
</li>
</ol>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><p><a href="http://linux.die.net/man/1/qemu-kvm" target="_blank" rel="noopener">qemu-kvm(1): QEMU Emulator User Documentation - Linux man page</a></p>
</li>
<li><p><a href="http://wiki.qemu.org/download/qemu-doc.html" target="_blank" rel="noopener">QEMU Emulator User Documentation</a></p>
</li>
<li><p><a href="http://www.it610.com/article/4332744.htm" target="_blank" rel="noopener">桥网络配置 - info5 - IT610.com</a></p>
</li>
<li><p><a href="http://smilejay.com/2012/03/kvm_qemu_network_error/" target="_blank" rel="noopener">KVM “qemu-ifup: could not configure /dev/net/tun: Operation not permitted”解决方案 – 笑遍世界</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> KVM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> KVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Linux KVM] Linux KVM concept - Storage]]></title>
      <url>/blog/2016/08/03/KVM/KVM-Basic-Concept-Storage/</url>
      <content type="html"><![CDATA[<p>此篇文章介紹學習 Linux KVM 時所需要了解的 Storage 相關知識</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 Linux KVM 中，是由 QEMU 來提供 storage device 的模擬，可以模擬的 storage 類型很多，包含 IDE device / SCSI device / Floopy disk / USB disk / virtio disk …. 等等，可根據使用者需求的不同來提供不同組合以及不同的開機順序。</p>
<hr>
<h1 id="Host-Machine-Swap-空間應該要設定多大"><a href="#Host-Machine-Swap-空間應該要設定多大" class="headerlink" title="Host Machine Swap 空間應該要設定多大?"></a>Host Machine Swap 空間應該要設定多大?</h1><p>以前學 Linux 時知道，swap 是用來作為當記憶體不足時的 buffer 用，而現在虛擬化環境中，每台 host machine 的記憶體容量都很大，那 swap 應該如何規劃配置呢? 以下有幾個原則：</p>
<h3 id="不使用-memory-overcommit"><a href="#不使用-memory-overcommit" class="headerlink" title="不使用 memory overcommit"></a>不使用 memory overcommit</h3><ol>
<li><p>若實體記憶體 &lt;= 4GB，則 swap space 設定為 2GB</p>
</li>
<li><p>若 4GB &lt; 實體記憶體 &lt;= 16GB，則 swap space 設定為 4GB</p>
</li>
<li><p>若 16GB &lt; 實體記憶體 &lt;= 64GB，則 swap space 設定為 8GB</p>
</li>
<li><p>若 64GB &lt; 實體記憶體 &lt;= 526GB，則 swap space 設定為 16GB</p>
</li>
</ol>
<h3 id="使用-memory-overcommit"><a href="#使用-memory-overcommit" class="headerlink" title="使用 memory overcommit"></a>使用 memory overcommit</h3><p>假設配置 memory overcommit rate 為 0.5 (例如：128 GB 的記憶體卻配置 <code>128 * (1 + 0.5) = 192 GB</code>)，那 swap space 除了上面的大小外，還要額外在加上記憶體容量 x 0.5 的空間。</p>
<p>亦即設定 memory overcommit，還要多增加 <strong><font color="red">physical memory x memory overcommit rate</font></strong> 的容量大小給 swap space。</p>
<p>舉個實際例子，假設 host machine 有 32GB 記憶體，memory overcommit ratio 設定為 0.5，則 swap space 的容量計算如下：</p>
<blockquote>
<p>(32 * 0.5) + 8 = 24 GB</p>
</blockquote>
<hr>
<h1 id="Storage-Device-amp-開機順序的配置"><a href="#Storage-Device-amp-開機順序的配置" class="headerlink" title="Storage Device &amp; 開機順序的配置"></a>Storage Device &amp; 開機順序的配置</h1><p>在 <strong>qemu-kvm</strong> 可以直接在命令行中進行 storage device &amp; 開機順序的配置，以下是常用的參數：</p>
<h2 id="Storage-Devices"><a href="#Storage-Devices" class="headerlink" title="Storage Devices"></a>Storage Devices</h2><ul>
<li><code>-hd[a:d] file_path</code>：以 file_path 指定的 image 檔案作為系統的 IDE HDD，在 virtual machine 中會以 <strong>/dev/hd[a:d]</strong> or <strong>/dev/sd[a:d]</strong> 呈現</li>
</ul>
<blockquote>
<p>若在 qemu-kvm 中直接指定檔案而沒有設定 -hd[a:d]，則預設為 <strong>-hda</strong></p>
</blockquote>
<ul>
<li><p><code>-fd[a:b] file_path</code>：以 file_path 指定的 image 檔案作為系統的軟碟機，在 virtual machine 中會以 <strong>/dev/fd[a:b]</strong> 呈現</p>
</li>
<li><p><code>-cdrom file_path</code>：用來指定 iso 檔案作為 virtual machine 的 <strong>/dev/cdrom</strong> 時使用：不可與 <strong>-hdc</strong> 參數同時使用，會衝突</p>
</li>
<li><p><code>-driver option[, option[, option[, option[,....]]]]</code>：透過 <strong>-driver</strong> 參數指定 storage device 的設定細節</p>
</li>
</ul>
<p>由於以上的設定參數太多，所以這邊直接貼 man page 的內容來看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">-drive option[,option[,option[,...]]]</span><br><span class="line">    Define a new drive. Valid options are:</span><br><span class="line">    file=file</span><br><span class="line">      This option defines <span class="built_in">which</span> disk image to use with this drive. If the filename contains comma, you must double it (<span class="keyword">for</span> instance, <span class="string">"file=my,,file"</span> to use file <span class="string">"my,file"</span>).</span><br><span class="line">    <span class="keyword">if</span>=interface</span><br><span class="line">      This option defines on <span class="built_in">which</span> <span class="built_in">type</span> on interface the drive is connected. Available types are: ide, scsi, sd, mtd, floppy, pflash, virtio.</span><br><span class="line">    bus=bus,unit=unit</span><br><span class="line">      These options define <span class="built_in">where</span> is connected the drive by defining the bus number and the unit id.</span><br><span class="line">    index=index</span><br><span class="line">      This option defines <span class="built_in">where</span> is connected the drive by using an index <span class="keyword">in</span> the list of available connectors of a given interface <span class="built_in">type</span>.</span><br><span class="line">    media=media</span><br><span class="line">      This option defines the <span class="built_in">type</span> of the media: disk or cdrom.</span><br><span class="line">    cyls=c,heads=h,secs=s[,trans=t]</span><br><span class="line">      These options have the same definition as they have <span class="keyword">in</span> -hdachs.</span><br><span class="line">    snapshot=snapshot</span><br><span class="line">      snapshot is <span class="string">"on"</span> or <span class="string">"off"</span> and allows to <span class="built_in">enable</span> snapshot <span class="keyword">for</span> given drive (see -snapshot).</span><br><span class="line">    cache=cache</span><br><span class="line">      cache is <span class="string">"none"</span>, <span class="string">"writeback"</span>, <span class="string">"unsafe"</span>, or <span class="string">"writethrough"</span> and controls how the host cache is used to access block data.</span><br><span class="line">    aio=aio</span><br><span class="line">      aio is <span class="string">"threads"</span>, or <span class="string">"native"</span> and selects between pthread based disk I/O and native Linux AIO .</span><br><span class="line">    format=format</span><br><span class="line">      Specify <span class="built_in">which</span> disk format will be used rather than detecting the format. Can be used to specifiy format=raw to avoid interpreting an untrusted format header.</span><br><span class="line">    serial=serial</span><br><span class="line">      This option specifies the serial number to assign to the device.</span><br><span class="line">    addr=addr</span><br><span class="line">      Specify the controller\<span class="string">'s PCI address (if=virtio only).</span></span><br><span class="line"><span class="string">    copy-on-read=copy-on-read</span></span><br><span class="line"><span class="string">      copy-on-read is "on" or "off" and enables whether to copy read backing file sectors into the image file.</span></span><br></pre></td></tr></table></figure>
<p>在預設情況下，QEMU 會為所有的 block device 自動帶上 writethrough caching 的功能，這功能是利用 host page cache 所達成的，效率較差，但安全性高。</p>
<p>而另外一個 Writeback caching 可以提供更好的效率，但安全性較低，因為若是 host machine 突然掛點或發生電力中斷的情況，cache 中的資料很有可能會遺失；若是加上 <code>snapshot</code> 參數，則會預設使用 Writeback caching。</p>
<p>若是要完全關閉 cache 功能，可以加上參數 <code>cache=none</code>。</p>
<p>此外，其實每一個 storage device 都可以用 <code>-drive</code> 來設定，舉例來說：</p>
<ul>
<li><p><code>-cdrom file_path</code> = <code>-drive file=file,index=2,media=cdrom</code></p>
</li>
<li><p><code>-hda file_path</code> = <code>-drive file=file,index=0,media=disk</code></p>
</li>
<li><p><code>-fda file_path</code> = <code>-drive file=file,index=0,if=floppy</code></p>
</li>
</ul>
<h2 id="開機順率"><a href="#開機順率" class="headerlink" title="開機順率"></a>開機順率</h2><p>開機順序的參數設定如下：</p>
<blockquote>
<p>-boot [order=drives][,once=drives][,menu=on|off][,splash=sp_name][,splash-time=sp_time][,reboot-timeout=rb_timeout][,strict=on|off]</p>
</blockquote>
<p>QEMU 的開機順序，是以英文字母表示：</p>
<ul>
<li><p><code>a</code>：第一台軟碟機</p>
</li>
<li><p><code>b</code>：第二台軟碟機</p>
</li>
<li><p><code>c</code>：第一顆硬碟</p>
</li>
<li><p><code>d</code>：光碟機</p>
</li>
<li><p><code>n</code>：網路啟動</p>
</li>
</ul>
<p>以下是幾個簡單的範例：</p>
<ul>
<li><p><code>-boot order=d</code>：光碟開機</p>
</li>
<li><p><code>-boot once=d</code>：第一次以光碟開機，系統重開後以第一顆硬碟開機</p>
</li>
</ul>
<p>此外其他參數的說明：</p>
<ul>
<li><p><code>menu=on|off</code>：是否顯示開機選單</p>
</li>
<li><p><code>splash=sp_name</code> &amp; <code>splash-time=sp_time</code>：在 <code>menu=on</code> 時才有效，<code>splash</code> 設定開機 logo，<code>splash-time</code> 設定開機 logo 時間</p>
</li>
<li><p><code>-boot order=dc,menu=on</code>：開機順序為光碟機 &gt;&gt; 硬碟，顯示開機選單</p>
</li>
</ul>
<hr>
<h1 id="qemu-img"><a href="#qemu-img" class="headerlink" title="qemu-img"></a>qemu-img</h1><p><strong><a href="http://wiki.qemu.org/download/qemu-doc.html#qemu_005fimg_005finvocation" target="_blank" rel="noopener">qemu-img</a></strong> 是 QEMU 的磁碟管理工具，安裝好 QEMU 相關套件時就會存在於系統中，基本使用語法如下：</p>
<blockquote>
<p>qemu-img command [command options]</p>
</blockquote>
<p>以下就常用的相關命令 &amp; 參數進行介紹：</p>
<ul>
<li><code>create [-f fmt] [-o options] filename [size]</code>：建立 disk image；其中 <code>options</code> 的部分可以使用 <code>-o ?</code> 來查詢特定格式所支援的選項；<code>size</code> 則是支援 <code>k</code>(KB) / <code>M</code>(MB) / <code>G</code>(GB) / <code>T</code>(TB) 等大小。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 顯示目前 qcow2 格式支援的 options</span></span><br><span class="line">$ qemu-img create -f qcow2 -o ?</span><br><span class="line">Supported options:</span><br><span class="line">size             Virtual disk size</span><br><span class="line">compat           Compatibility level (0.10 or 1.1)</span><br><span class="line">backing_file     File name of a base image</span><br><span class="line">backing_fmt      Image format of the base image</span><br><span class="line">encryption       Encrypt the image</span><br><span class="line">cluster_size     qcow2 cluster size</span><br><span class="line">preallocation    Preallocation mode (allowed values: off, metadata, falloc, full)</span><br><span class="line">lazy_refcounts   Postpone refcount updates</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增檔名為 ubuntu1604.qcow2，格式為 qcow2，大小為 10GB 的 disk image</span></span><br><span class="line">$ qemu-img create -f qcow2 ubuntu1604.qcow2 10G</span><br><span class="line">Formatting <span class="string">'ubuntu1604.qcow2'</span>, fmt=qcow2 size=10737418240 encryption=off cluster_size=65536 lazy_refcounts=off</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增有 backing file(centos7.img，原生大小為 10GB) 的 disk image</span></span><br><span class="line"><span class="comment"># disk image 檔名為 centos7.qcow2，格式為 qcow2，大小為 20GB</span></span><br><span class="line">$ qemu-img create -f qcow2 centos7.img 10G</span><br><span class="line">Formatting <span class="string">'centos7.img'</span>, fmt=qcow2 size=10737418240 encryption=off cluster_size=65536 lazy_refcounts=off</span><br><span class="line">$ qemu-img create -f qcow2 -o backing_file=centos7.img,size=20G centos7.qcow2</span><br><span class="line">Formatting <span class="string">'centos7.qcow2'</span>, fmt=qcow2 size=21474836480 backing_file=<span class="string">'centos7.img'</span> encryption=off cluster_size=65536 lazy_refcounts=off</span><br></pre></td></tr></table></figure>
<ul>
<li><code>check [-f fmt] filename</code>：對 disk image 進行一致性 &amp; 錯誤的檢查，但目前只有支援 qcow2 / qed / vdi 等格式；若不加上 <code>[-f fmt]</code> 參數則會自動偵測格式</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ qemu-img check centos7.qcow2</span><br><span class="line">No errors were found on the image.</span><br><span class="line">Image end offset: 262144</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>commit [-f fmt] filename</code>：將指定 disk image 的修改 commit 到 backing file 中(例如上面範例中，把 centos7.qcow2 的修改 commit 回 centos7.img 中)</p>
</li>
<li><p><code>convert [-c] [-f fmt] [-O output_fmt] [-o options] filename [filename2 [...]] output_filename</code>：轉換 disk image 的格式；input file 的格式可自動偵測，但 output file 則需要指定，不指定則預設為 <code>raw</code>；<code>-c</code> 則是指定對 output file 進行壓縮，但只支援 qcow &amp; qcow2 格式的檔案；<code>-o options</code> 用來指定各種選項，例如 backing file，檔案大小、是否加密…等，附帶一提，使用 backing file 可以使產生的檔案變成 copy-on-write 的增量檔案</p>
</li>
</ul>
<blockquote>
<p>若是由 raw 轉成 qcow2，一般來說檔案還會有瘦身的效果</p>
</blockquote>
<ul>
<li><code>info [-f fmt] filename</code>：顯示 disk image 的詳細資訊</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ qemu-img info /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">image: /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">file format: raw</span><br><span class="line">virtual size: 8.0G (8589934592 bytes)</span><br><span class="line">disk size: 8.0G</span><br><span class="line"></span><br><span class="line">$  qemu-img info centos7.qcow2</span><br><span class="line">image: centos7.qcow2</span><br><span class="line">file format: qcow2</span><br><span class="line">virtual size: 20G (21474836480 bytes)</span><br><span class="line">disk size: 196K</span><br><span class="line">cluster_size: 65536</span><br><span class="line">backing file: centos7.img</span><br><span class="line">Format specific information:</span><br><span class="line">    compat: 1.1</span><br><span class="line">    lazy refcounts: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>snapshot [-l | -a snapshot | -c snapshot | -d snapshot] filename</code>：snapshot 的管理，包含查詢 snapshot 列表資訊(<code>-l</code>) / 使用快照作為 disk image(<code>-a snapshot</code>) / 建立 snapshot(<code>-c snapshot</code>) / 刪除 snapshot(<code>-d snapshot</code>)</p>
</li>
<li><p><code>resize filename [+ | -]size</code>：改變 disk image 的大小；縮小空間要確保 disk image 有足夠的空間，否則會有資料損毀的風險；qcow2 格式不支援縮小；增加空間後，在 virtual machine 中需要使用 fdisk or parted 才可以使用到增加的空間</p>
</li>
</ul>
<blockquote>
<p>強烈建議在 resize 之前要做好備份</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@ocp-kvm-host ~]<span class="comment"># qemu-img resize ubuntu1604.qcow2 +1G</span></span><br><span class="line">Image resized.</span><br><span class="line"></span><br><span class="line">[root@ocp-kvm-host ~]<span class="comment"># qemu-img info ubuntu1604.qcow2</span></span><br><span class="line">image: ubuntu1604.qcow2</span><br><span class="line">file format: qcow2</span><br><span class="line">virtual size: 11G (11811160064 bytes)</span><br><span class="line">disk size: 200K</span><br><span class="line">cluster_size: 65536</span><br><span class="line">Format specific information:</span><br><span class="line">    compat: 1.1</span><br><span class="line">    lazy refcounts: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Storage-Types"><a href="#Storage-Types" class="headerlink" title="Storage Types"></a>Storage Types</h1><p>在 QEMU/KVM 中，virual machine 的 disk image 其實可以用很多種不同方式來儲存，例如：</p>
<ol>
<li><p>Local storage (最常用的方式)</p>
</li>
<li><p>physical disk/partition</p>
</li>
<li><p>LVM</p>
</li>
<li><p>NFS</p>
</li>
<li><p>iSCSI</p>
</li>
<li><p>在 Local 端 or 透過 Fiber 連接的 LUN</p>
</li>
<li><p>GFS2</p>
</li>
</ol>
<blockquote>
<p>上面的幾個選項中，phtsical partition &amp; LVM 由於無法存放 MBR，因此無法作為 virtual machine 的開機磁碟，只能用來存放資料用。</p>
</blockquote>
<p>基本上，以 file-based 的方式管理 disk images 是比較有彈性的，可放在 Local / NFS / iSCSI / LUN / GFS2 … 等，若是 virtual machine 對於 I/O 效能不是非常要求時，選擇 qcow2 則是較為建議的 disk image 格式，其優點如下：</p>
<ul>
<li><p>儲存方便 (file-baed)</p>
</li>
<li><p>比起其他方式相對容易使用</p>
</li>
<li><p>可移動性佳</p>
</li>
<li><p>容易複製</p>
</li>
<li><p>可透過 sparse 的機制節省硬碟空間(類似 thin provision)</p>
</li>
<li><p>可放在透過網路連結的檔案系統中(例如：NFS，可把 backing file 放在 NFS，差異部分放在 local)，因此可以輕鬆達到 live migration 的效果</p>
</li>
</ul>
<p>最後，若需要高效能的 I/O，則可以使用半虛擬化的 <strong><font color="red">virtio</font></strong> 作為 disk image 的 driver。</p>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><p><a href="http://linux.die.net/man/1/qemu-kvm" target="_blank" rel="noopener">qemu-kvm(1): QEMU Emulator User Documentation - Linux man page</a></p>
</li>
<li><p><a href="http://wiki.qemu.org/download/qemu-doc.html" target="_blank" rel="noopener">QEMU Emulator User Documentation</a></p>
</li>
<li><p><a href="http://benjr.tw/20361" target="_blank" rel="noopener">Cache 的 write back 和 write through – Benjr.tw</a></p>
</li>
<li><p><a href="http://www.pcdvd.com.tw/showthread.php?t=285217" target="_blank" rel="noopener">請教Cache運作方式的Write Back與Write Through之分別 - PCDVD數位科技討論區</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> KVM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> KVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Linux KVM] Linux KVM concept - Memory]]></title>
      <url>/blog/2016/08/01/KVM/KVM-Basic-Concept-Memory/</url>
      <content type="html"><![CDATA[<p>此篇文章介紹學習 Linux KVM 時所需要了解的 Memory 相關知識</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Memory 在作業系統是用來暫時存放 cpu 要執行的指令以及資料，所有 process 都必須先載入到 memory 中才能正確執行。</p>
<p>而在虛擬化的環境中，virtual machine 中 memory 的使用是需要額外的 mapping 機制對應到 host machine，在這個部分的效率的高低，當然也就會決定 virtual machine 整體的系統性能。</p>
<hr>
<h1 id="VM-可以使用多少記憶體"><a href="#VM-可以使用多少記憶體" class="headerlink" title="VM 可以使用多少記憶體?"></a>VM 可以使用多少記憶體?</h1><p>也許這是很多人想要了解的，在 host machine 上安裝了一大堆實體記憶體，究竟可以分配給 VM 的可以有多少呢? 以下有兩個簡單公式可以計算：</p>
<ol>
<li><p>實體記憶體 &lt;= 64 GB</p>
<blockquote>
<p>RAM - 2 GB = Amount of RAM available to VMs in GBs</p>
</blockquote>
</li>
<li><p>實體記憶體 &gt; 64GB</p>
<blockquote>
<p>RAM - (2 GiB + .5* (RAM/64)) = Amount of RAM available to VMs in GBs</p>
</blockquote>
</li>
</ol>
<p>假設 host machine 記憶體有 32GB，則一共可以配置 <code>32 - 2 = 10</code>GB 的記憶體給 VM。</p>
<p>假設 host machine 記憶體有 256GB，則一共可以配置 <code>256 - (2 + 0.5 * (256 / 64)) = 252</code>GB 的記憶體給 VM</p>
<hr>
<h1 id="配置-VM-記憶體"><a href="#配置-VM-記憶體" class="headerlink" title="配置 VM 記憶體"></a>配置 VM 記憶體</h1><p>幫 virtual machine 配置記憶體是很容易的，只要使用 <strong><font color="red">-m</font></strong> 參數即可，預設的格式是：</p>
<blockquote>
<p>-m megs</p>
</blockquote>
<p>預設是以 <strong><font color="red">MB</font></strong> 作為預設的單位，也可以使用 <strong><font color="red">G</font></strong> 表示要使用 GB 為單位，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 記憶體大小為 2048 MB</span></span><br><span class="line">$ kvm -vnc 0.0.0.0:1 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line"></span><br><span class="line"><span class="comment"># 記憶體大小為 4 GB</span></span><br><span class="line">$ kvm -vnc 0.0.0.0:1 -m 4G -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="EPT"><a href="#EPT" class="headerlink" title="EPT"></a>EPT</h1><p>傳統要把 virtual machine 中運行的應用程式所使用的 memory 對應到 host machine 的 memory，一共是有三層關係的，下圖可做個簡單說明：</p>
<p><img src="http://m.eet.com/media/1200411/CloudFig4a.jpg" alt="VM memory mapping"></p>
<blockquote>
<p>Guest Virtual Address(GVA) &lt;–&gt; Guest Physical Address(GPA) &lt;–&gt; Host Physical Address(HPA)</p>
</blockquote>
<p>但由於上面三層的轉換效率是很差的，因此後來透過軟體實作了稱為 <strong><font color="red">Shadow Page Tables</font></strong> 的機制，將三層中的第二層拿掉，直接讓 Guest Virtual Address 與 Host Physical Address 可以有直接對應的機制：</p>
<p><img src="http://image.slidesharecdn.com/windays-virtualization-090428034228-phpapp01/95/windows-server-virtualization-hyperv-2008-r2-30-728.jpg?cb=1240890219" alt="Shadow Page Tables"></p>
<p>此時 hypervisor 就可以把 shadow page tables 載入到 MMU(Memory Management Unit) 中進行 address translation 的工作。</p>
<p>但 shadow page tables 實作起來不僅複雜，也會 memory 的額外消耗(每一個 virtual machine 都需要一個 shadow page table)；因此 Intel 提出了 EPT(Extended Page Tables)，AMD 提出了 NPT(Nested Page Tables)，在硬體層直接提供了 <code>GVA &lt;--&gt; GPA &lt;--&gt; HPA</code> 的轉換，不僅提升了 memory 虛擬化的效能，也降低了 memory 虛擬化的複雜度。</p>
<p>以下是 Intel EPT 技術的概觀：</p>
<p><img src="http://virtualization.info/images/EPT-716833.png" alt="Intel EPT"></p>
<p>其中可以看到 Intel 在硬體中增加了 CR3(Control Registor 3) 來處理 GVA &lt;–&gt; GPA 的轉換，以及 EPT 來處理 GPA &lt;–&gt; HPA 的轉換。</p>
<p>由於所有的轉換都在硬體層級完成，因此速度很快；而且由於整個轉換過程只需要一個 EPT Page Table，因此在 memory 的消耗上也相對的低。</p>
<hr>
<h1 id="VPID"><a href="#VPID" class="headerlink" title="VPID"></a>VPID</h1><p>要了解 VPID，首先要知道 TLB(Translation Lookaside Buffer) 是什麼? 可以參考以下連結：</p>
<ul>
<li><a href="http://www.wikiwand.com/zh-hk/%E8%BD%89%E8%AD%AF%E5%BE%8C%E5%82%99%E7%B7%A9%E8%A1%9D%E5%8D%80" target="_blank" rel="noopener">TLB 轉譯後備緩衝區 - Wikiwand</a></li>
</ul>
<blockquote>
<p>分配給 virtual machine 的每一個 vCPU 都會有一個 TLB</p>
</blockquote>
<p>而 VPID 則是在硬體層級對 TLB 資源管理的優化，在 virtual machine 進行 migration / VM Entry / VM Exit 時，避免對 TLB 進行轉存 &amp; 清除，進而降低 memory 的額外消耗，對於 live migration 有顯著的效能提升。</p>
<hr>
<h1 id="查詢-EPT-amp-VPID-的支援度"><a href="#查詢-EPT-amp-VPID-的支援度" class="headerlink" title="查詢 EPT &amp; VPID 的支援度"></a>查詢 EPT &amp; VPID 的支援度</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查詢 CPU 是否支援 EPT &amp; VPID</span></span><br><span class="line">$  grep -E <span class="string">"\sept\s|\svpid\s"</span> /proc/cpuinfo | uniq</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢 kvm_intel 模組是否有開啟 EPT &amp; VPID 的功能</span></span><br><span class="line">$ cat /sys/module/kvm_intel/parameters/ept</span><br><span class="line">Y</span><br><span class="line">$ cat /sys/module/kvm_intel/parameters/vpid</span><br><span class="line">Y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 開啟 kvm_intel 模組 EPT &amp; VPID 的功能</span></span><br><span class="line">$ modprobe kvm_intel ept=1,vpid=1</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Huge-Page"><a href="#Huge-Page" class="headerlink" title="Huge Page"></a>Huge Page</h1><p>x86 架構的 CPU 預設的 memory page table 大小為 4KB，而 x86-64 則可以支援到 2MB 大小的 memory page table(亦稱為 <strong><font color="red">Huge Page</font></strong>)，在 Linux 2.6 以上的 kernel 都支援這個特性。</p>
<p>而使用 Huge Page 有何優缺點呢?</p>
<h3 id="優點："><a href="#優點：" class="headerlink" title="優點："></a>優點：</h3><ul>
<li><p>page table 數量減少，更節省 memory</p>
</li>
<li><p>由於 memory address translation 的工作減少了，因此 page fault 機率降低為 <strong><font color="red">Huge Page Size / 4KB</font></strong> 分之一</p>
</li>
<li><p>提升了 memory 存取的效能</p>
</li>
<li><p>提高 TLB 命中率，因而減少 CPU cache 的使用，最後提升了系統整體效能</p>
</li>
<li><p>適合用在 memory 存取密集的 virtual machine 上</p>
</li>
</ul>
<h3 id="缺點："><a href="#缺點：" class="headerlink" title="缺點："></a>缺點：</h3><ul>
<li><p>Huge Page 無法被 swap out 到硬碟上</p>
</li>
<li><p>無法使用 Ballooning 的方式自動增長</p>
</li>
<li><p>並非適合所有不同工作類型的 virtual machine</p>
</li>
</ul>
<h2 id="在-KVM-中使用-Huge-Page"><a href="#在-KVM-中使用-Huge-Page" class="headerlink" title="在 KVM 中使用 Huge Page"></a>在 KVM 中使用 Huge Page</h2><h3 id="1、檢查-host-machine-中-Huge-Page-的設定資訊："><a href="#1、檢查-host-machine-中-Huge-Page-的設定資訊：" class="headerlink" title="1、檢查 host machine 中 Huge Page 的設定資訊："></a>1、檢查 host machine 中 Huge Page 的設定資訊：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 目前預設的 page size</span></span><br><span class="line">$ getconf PAGESIZE</span><br><span class="line">4096</span><br><span class="line"></span><br><span class="line"><span class="comment"># 記憶體資訊中 Huge Page 的相關資訊 (size = 2048 KB)</span></span><br><span class="line">$ cat /proc/meminfo | grep Huge</span><br><span class="line">AnonHugePages:     14336 kB</span><br><span class="line">HugePages_Total:       0</span><br><span class="line">HugePages_Free:        0</span><br><span class="line">HugePages_Rsvd:        0</span><br><span class="line">HugePages_Surp:        0</span><br><span class="line">Hugepagesize:       2048 kB</span><br></pre></td></tr></table></figure>
<h3 id="2、掛載-hugetlbfs-檔案系統"><a href="#2、掛載-hugetlbfs-檔案系統" class="headerlink" title="2、掛載 hugetlbfs 檔案系統"></a>2、掛載 hugetlbfs 檔案系統</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 掛載 hugetlbfs 檔案系統</span></span><br><span class="line">$ mount -t hugetlbfs hugetlbfs /dev/hugepages</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢檔案系統資訊</span></span><br><span class="line">$ mount | grep huge</span><br><span class="line">cgroup on /sys/fs/cgroup/hugetlb <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)</span><br><span class="line">hugetlbfs on /dev/hugepages <span class="built_in">type</span> hugetlbfs (rw,relatime,seclabel)</span><br><span class="line">hugetlbfs on /dev/hugepages <span class="built_in">type</span> hugetlbfs (rw,relatime,seclabel)</span><br></pre></td></tr></table></figure>
<h3 id="3、設定-Huge-Page-的數量"><a href="#3、設定-Huge-Page-的數量" class="headerlink" title="3、設定 Huge Page 的數量"></a>3、設定 Huge Page 的數量</h3><p>假設要啟動一個 memory 為 2048 MB 的 virtual machine，可以算出 Huge Page(2048 KB) 的數量為：</p>
<blockquote>
<p>2048 * 1024 / 2048 = 1024</p>
</blockquote>
<p>因此這邊設定 Huge Page 的數量為 1024 個：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 設定 Huge Page 的數量為 1024 個</span></span><br><span class="line">$ sysctl vm.nr_hugepages=1024</span><br><span class="line">vm.nr_hugepages = 1024</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此時 host machine 中的記憶體資訊已經有 Huge Page 的數量資訊</span></span><br><span class="line">$ cat /proc/meminfo | grep Huge</span><br><span class="line">AnonHugePages:     14336 kB</span><br><span class="line">HugePages_Total:    1024</span><br><span class="line">HugePages_Free:     1024</span><br><span class="line">HugePages_Rsvd:        0</span><br><span class="line">HugePages_Surp:        0</span><br><span class="line">Hugepagesize:       2048 kB</span><br></pre></td></tr></table></figure>
<h3 id="4、啟動-virtual-machine-使用-Huge-Page"><a href="#4、啟動-virtual-machine-使用-Huge-Page" class="headerlink" title="4、啟動 virtual machine 使用 Huge Page"></a>4、啟動 virtual machine 使用 Huge Page</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ kvm -vnc 0.0.0.0:1 -smp 4 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img -mem-path /dev/hugepages</span><br><span class="line"></span><br><span class="line">$ cat /proc/meminfo | grep Huge</span><br><span class="line">AnonHugePages:     26624 kB</span><br><span class="line">HugePages_Total:    1024</span><br><span class="line">HugePages_Free:      738</span><br><span class="line">HugePages_Rsvd:      738</span><br><span class="line">HugePages_Surp:        0</span><br><span class="line">Hugepagesize:       2048 kB</span><br></pre></td></tr></table></figure>
<p>可以看出 virtual machine 的確消耗了一些 huge page，但其實並不是全部，因為 virtual machine 實際上並沒有完整分配到 2048 MB 的 memory；若要完整分配指定的 memory，則需要加上 <code>-mem-prealloc</code> 參數。</p>
<hr>
<h1 id="Memory-Overcommit"><a href="#Memory-Overcommit" class="headerlink" title="Memory Overcommit"></a>Memory Overcommit</h1><p>除了之前介紹 CPU 可以 overcommit 之外，memory 也可以設定一定程度的 overcommit，原因是因為每台電腦在運作時一般都不會耗盡記憶體。對 host machine 來說，virtual machine 也只是一個 QEMU process，在啟動的當下是不會分配完整記憶體的，而是隨著 virtual machine 的更多要求下逐步分配到位，因此可以在此行為的前提下設定 memory overcommit。</p>
<p>在 KVM 中有三種方式可以達到 memory overcommit：</p>
<ol>
<li><p><strong><font color="red">Swapping</font></strong>：透過 system swap(一般為硬碟空間) 來彌補 memory 不足的問題</p>
</li>
<li><p><strong><font color="red">Ballooning</font></strong>：透過 <code>virtio_balloon</code> driver 來達成</p>
</li>
<li><p><strong><font color="red">Page Sharing</font></strong>：使用 <code>KSM(Kernel Samepage Merging)</code> 合併多台 virtual machine 中相同的 memory page</p>
</li>
</ol>
<p>關於第一個方式的 swap，根據 <a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Storage_Administration_Guide/ch-swapspace.html#tb-recommended-system-swap-space" target="_blank" rel="noopener">RedHat RHEL 7 官方文件</a>所提供的建議，swap 大小的設定建議如下：</p>
<table>
<thead>
<tr>
<th>系統記憶體</th>
<th>建議 swap 大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>⩽ 2 GB</td>
<td>2 x memory size</td>
</tr>
<tr>
<td>&gt; 2 GB – 8 GB</td>
<td>等同 memory size</td>
</tr>
<tr>
<td>&gt; 8 GB – 64 GB</td>
<td>至少 4 GB</td>
</tr>
<tr>
<td>&gt; 64 GB</td>
<td>至少 4 GB</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><p><a href="http://linux.die.net/man/1/qemu-kvm" target="_blank" rel="noopener">qemu-kvm(1): QEMU Emulator User Documentation - Linux man page</a></p>
</li>
<li><p><a href="http://www.gegugu.com/2016/03/22/9088.html" target="_blank" rel="noopener">精品：KVM學習筆記 : 歌穀穀</a></p>
</li>
<li><p><a href="http://tc.wangchao.net.cn/it/detail_128378.html" target="_blank" rel="noopener">Huge Page 是否是拯救性能的萬能良藥？ - 王朝網路 - wangchao.net.cn</a></p>
</li>
<li><p><a href="http://brandon-hy-lin.blogspot.tw/2016/04/compound-page-huge-page-transparent.html" target="_blank" rel="noopener">隨意寫寫: Compound Page, Huge Page, 和Transparent Huge Page(THP)</a></p>
</li>
<li><p><a href="http://jaychu649.blogspot.tw/2014/09/linux-huge-memory-greater-then-hundred.html" target="_blank" rel="noopener">IT 研究室 ( 前IT DBA’s 資訊站): 如何在Linux 使用大記憶體(huge memory greater then hundred of GB)</a></p>
</li>
<li><p><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Storage_Administration_Guide/ch-swapspace.html#tb-recommended-system-swap-space" target="_blank" rel="noopener">RedHat RHEL 7 Support &gt; Product Documentation &gt; Storage &gt; Administration Guide</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> KVM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> KVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Linux KVM] Linux KVM concept - CPU]]></title>
      <url>/blog/2016/07/30/KVM/KVM-Basic-Concept-CPU/</url>
      <content type="html"><![CDATA[<p>此篇文章介紹學習 Linux KVM 時所需要了解的 CPU 相關知識</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>KVM 在 Linux x86 硬體平台上提供了全虛擬化(Full Virtualization)的 solution，透過 QEMU 的模擬，顯示特定數量的 CPU &amp; 相關 feature 給使用者，而在支援 KVM 的前提下，virtual machine 的 CPU 指令則是直接由 CPU 來輔助執行，藉此大幅提升運作效率。</p>
<hr>
<h1 id="vCPU"><a href="#vCPU" class="headerlink" title="vCPU"></a>vCPU</h1><p>QEMU/KVM 提供每一台 virtual machine 有一個模擬的完整硬體環境，在 virual machine 中所看到的 CPU，即是 host machine 上的 vCPU。</p>
<p>在 KVM 環境中，每一台 virtual machine 都是一個的 QEMU userspace process，而 vCPU 則是 QEMU process 中的 thread。</p>
<p><img src="http://image.slidesharecdn.com/els305-100323102407-phpapp02/95/virtualization-with-kvm-kernelbased-virtual-machine-4-728.jpg" alt="KVM environment"></p>
<p>vCPU 一共有以下三種執行模式：</p>
<ol>
<li><p>User Mode</p>
</li>
<li><p>Kernel Mode</p>
</li>
<li><p>Guest Mode</p>
</li>
</ol>
<p>其中前兩個執行模式(<strong>User Mode</strong> &amp; <strong>Kernel Mode</strong>)是一般的 process 所擁有的執行模式，詳細的說明可以參考下面連結：</p>
<ul>
<li><p><a href="https://www.ptt.cc/bbs/b97902HW/M.1267018497.A.3B1.html" target="_blank" rel="noopener">[系程] 教學: 簡介 Kernel/User Mode 的概念 - 看板 b97902HW - 批踢踢實業坊</a></p>
</li>
<li><p><a href="http://peachwaneversay.blogspot.tw/2007/05/user-mode-vs-kernel-mode.html" target="_blank" rel="noopener">企鵝幫魚，魚幫兔: User mode vs. Kernel mode</a></p>
</li>
</ul>
<p>而 KVM 多了一個 <strong>Guest Mode</strong>，功能是用來<strong>執行關於 virtual machine 中的相關 I/O request</strong>，無法直接；所有 Memory &amp; CPU 的 I/O request，會透過 <strong>/dev/kvm(QUME)</strong> 來模擬完成，並可透過 QEMU 執行一些特權指令來存取 host machine 的資源。</p>
<p><img src="http://benjr.tw/wp-content/uploads/2013/11/kvm_qemu01.png" alt="KVM Guest Mode"></p>
<hr>
<h1 id="SMP-Symmetric-Multi-Processor"><a href="#SMP-Symmetric-Multi-Processor" class="headerlink" title="SMP(Symmetric Multi-Processor)"></a>SMP(Symmetric Multi-Processor)</h1><p>由於現在 multiple core、hyper threading 等相關技術已經很普遍，這讓作業系統可以進行真正的平行處理；而現在較新的作業系統都已經有對 SMP 的支援(Linux kernel 2.6 以上)，這對虛擬化的推展有相當大的助益。</p>
<p>透過以下指令，可以用來檢查目前 host machine 對 SMP 的支援程度：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查詢 logic cpu 數量</span></span><br><span class="line">$ cat /proc/cpuinfo | grep <span class="string">"processor"</span> | wc -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 實體 CPU 數量</span></span><br><span class="line">$ cat /proc/cpuinfo | grep <span class="string">"physical id"</span> | sort | uniq | wc -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每個 CPU 上的 core 數量</span></span><br><span class="line">$ cat /proc/cpuinfo | grep <span class="string">"core id"</span> | sort | uniq | wc -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每個 physical cpu 上分配的 logic cpu 的數量</span></span><br><span class="line">$ cat /proc/cpuinfo | grep <span class="string">"siblings"</span> | sort | uniq | awk -F: <span class="string">'&#123;print $2&#125;'</span></span><br></pre></td></tr></table></figure>
<p>以上一篇文章中的範例來說明：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kvm -smp 4 -m 2048 \</span><br><span class="line">  -vnc 0.0.0.0:5 -boot order=<span class="built_in">cd</span> \</span><br><span class="line">  -hda /kvm/storage/vm_disks/ubnutu1604.img \</span><br><span class="line">  -cdrom /kvm/os_images/ubuntu-16.04.1-server-amd64.iso</span><br></pre></td></tr></table></figure>
<p>其中 <code>-smp</code> 參數就是指定要使用多少的 vCPU 支援，完整的使用設定如下：(上例為使用 4 個 vCPU)</p>
<blockquote>
<p>-smp n[,<strong>cores=</strong>cores][,<strong>threads=</strong>threads][,<strong>sockets=</strong>sockets][,<strong>maxcpus=</strong>maxcpus]</p>
</blockquote>
<h2 id="範例-1-僅使用-smp"><a href="#範例-1-僅使用-smp" class="headerlink" title="範例 1 (僅使用 -smp)"></a>範例 1 (僅使用 -smp)</h2><p>而在 Linux 系統中，每一個 vCPU 的分配都會成為一個 process 運行在 host machine 中，以下開啟一個 vCPU=8 的 virtual machine：</p>
<blockquote>
<p>kvm -vnc 0.0.0.0:1 -smp 8 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</p>
</blockquote>
<p>可以從 QEMU monitor 中觀察 vCPU 對應到 kvm 的 process：</p>
<p><img src="https://lh3.googleusercontent.com/hHP9T9hWydFXixyMUCuCVFDkl7hlZ6Yv_lbljFDdv_azyt_rh01M6X8bHI1fRMV82a2UObBH6wQgAElavdVxByZ99u0cDBToT-t9OIqgWpSY6ZGreqooEuin8WvQqXpQ9g84uwed3-qO2akJatJTCJqpY0Xt_xU9J1ak4702nyJicXQ7h6HqppYXz0G_86NhyQMd6tv2w5venHGgaBoOF46L8UcYYTskX5rPptWqlmhJtNQSkFGj8F6t3DVVGpOJQfgErjdrfFm162spjhQGwZJ6OWiKTsdBAuXbeUscC-NUTPtGbVjSvAHXa-MVo3-h6jjWZ-TlNkjSmQYCICiRiTGIcFsLAkbIVMGw7-PXkPdqXhJyaC9bEWplxhPzhgGptGUeJCAOrdIhvF_l8lXzaSqeWGL-BSnBbA5qCuV-9UUZVGrcHgiQo2p5_Q_iUBBazlkqnRuM69ULxGEeM-q82gIztEmQiqqOrynKeAf9w5MZnJeb_w29u6qu6B-6d81hRGXwc68A1YHKH256EWxgtrd7_aVfsu08fLEIsPwo5qEuDnkef9G_hGNUHccLcWMSIOIr4J1ViP1vOrDsLpAA_qW-08QfZ4Q=w463-h210-no" alt="QEMU monitor - cpu infos"></p>
<p>以下則可以看出在 host machine 有相對應的 process 存在：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ps -efL | grep kvm</span><br><span class="line">root      1122     2  1122  0    1 Jul27 ?        00:00:00 [kvm-irqfd-clean]</span><br><span class="line">root     14606 11601 14606  3   11 17:46 pts/0    00:00:02 kvm -vnc 0.0.0.0:1 -smp 8 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">root     14606 11601 14610 10   11 17:46 pts/0    00:00:06 kvm -vnc 0.0.0.0:1 -smp 8 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">root     14606 11601 14611  2   11 17:46 pts/0    00:00:01 kvm -vnc 0.0.0.0:1 -smp 8 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">root     14606 11601 14612  1   11 17:46 pts/0    00:00:01 kvm -vnc 0.0.0.0:1 -smp 8 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">root     14606 11601 14613  1   11 17:46 pts/0    00:00:00 kvm -vnc 0.0.0.0:1 -smp 8 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">root     14606 11601 14614  1   11 17:46 pts/0    00:00:00 kvm -vnc 0.0.0.0:1 -smp 8 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">root     14606 11601 14615  1   11 17:46 pts/0    00:00:00 kvm -vnc 0.0.0.0:1 -smp 8 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">root     14606 11601 14616  1   11 17:46 pts/0    00:00:00 kvm -vnc 0.0.0.0:1 -smp 8 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">root     14606 11601 14617  1   11 17:46 pts/0    00:00:01 kvm -vnc 0.0.0.0:1 -smp 8 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">root     14606 11601 14619  1   11 17:46 pts/0    00:00:00 kvm -vnc 0.0.0.0:1 -smp 8 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">root     14606 11601 14631  0   11 17:46 pts/0    00:00:00 kvm -vnc 0.0.0.0:1 -smp 8 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">root     14618     2 14618  0    1 17:46 ?        00:00:00 [kvm-pit/14606]</span><br><span class="line">root     14633 12908 14633  0    1 17:47 pts/1    00:00:00 grep --color=auto kvm</span><br></pre></td></tr></table></figure>
<p>最後可以用上面的 grep 查詢 physical / cores / threads 等資訊：</p>
<p><img src="https://lh3.googleusercontent.com/mD_mnwyxWHinCr-2GSCfaMs-kyhi7p5c9cspDW5go_wM_76oHUj0Phj4n5dAahx39fazYXbMYa5xknxe1oRcoErP0cG84fMRu0WRwm9A1-_p4_bH0XediFmabBPzQQ6omUqJeBgJkwuyj0YRQ8-5kQ6zrE6elocc5sAt4q4tVKOXISDO0CZzSiYU9jHr6HeQVWO4xyLcBBkEUTZEeCfeR_tIrJzZF23nMGWDLI9CSu84ADbuL6KilIp4zDwQPNGrZmxNEwi2kUWyKcxC9-iZBm1W3wNdDYdIESmnVkTQuMe19XnTYsGdPiyRiOtMYv01WQ_KmBoCdRRZ1vfn0syyYdkt9PagLY3TjJ75dt57p918PI4z04YUZomaZ0lZ6Pqb8bt1Iaz1oljrslZpyveJ2AtAGWIdO9hFvE_9r3uvzK-ND77ZL1nAMbvuBPcD3rxuAGGr9ZqZTH_RACGOKtUN44cffI9VMvDp261xOj2NvYUDAVKxLogUNUj_ltOSyLGZ3uSffQtBkybY8OBAR3o3ycSsVy6Riwk8x2n6buCDR05dA4oTlaUqmR_o39TyTKsF6c1hzgoiJN9d_tc4cLS2c1PINXUh7W8=w785-h194-no" alt="SMP only"></p>
<ul>
<li>logic cpu = 8</li>
<li>physical cpu = 8</li>
<li>每個 CPU 上的 core 數量 = 1</li>
<li>每個 physical cpu 上分配的 logic cpu 的數量 = 1</li>
</ul>
<h2 id="範例-2-使用-smp，搭配-sockets-2-cores-2-threads-2"><a href="#範例-2-使用-smp，搭配-sockets-2-cores-2-threads-2" class="headerlink" title="範例 2 (使用 -smp，搭配 sockets=2,cores=2,threads=2)"></a>範例 2 (使用 -smp，搭配 sockets=2,cores=2,threads=2)</h2><p>此範例搭配 socket, cores, threads 等 smp 相關參數</p>
<blockquote>
<p> kvm -vnc 0.0.0.0:1 -smp 8,sockets=2,cores=2,threads=2 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</p>
</blockquote>
<p>用 grep 查詢 physical / cores / threads 等資訊：</p>
<p><img src="https://lh3.googleusercontent.com/JmmR_lsIlsIsr66SlLZXaBJfVKdo6gim3rLxj7oMrVrTbDEYnluhtz-uj5FdlYwUAN4_W-FZDL2a6ykDgFBdwIlYNVrorpLPc7olTSl7oOsHlEoUVT1U9o9yDroSYZFNEGoJVJaMcKoIrtRr9HKB7R9uKrz5VNLR6iX_n2OZs5gL_UxPrxL5UOeYeqyyuZwswNDTyqh61qmqlJ2i0KBAHkSauTcUbASZScuk1rCL_wlp0B0VguRIhd2WZtq2oEe_G9nL6zRMclrXsOqhWsVBy0DyBibyGtqsUPIG7-7rYHcSGs1ao8j_fuTELJVA0P4nWoPpAX5sRI9p84M32vGuppudVSkFDdzACIo43FdB6ZkFftc4sPfRLk-qLXldYJ5ss_waqmqcIA2Qr-be1M443d0QiqYV6BF4XkIn6cKud7gCzy15I30CdM31gVZwK7rkQ6O_eWSCLYhiQoBR1y-B9jXV5qnN7axQfTC8hL46gRlQSyozEG4HXp-X2UmU12rfMWv8rZop2alI6pLa29CE5oywHl40BYI8qKgok52V0znrX1klcmgiCn5iYYdEFPYELqHwDW_EQv0-Z8oAXxmyIpk8tKnSR0E=w777-h190-no" alt="SMP with sockets, cores, and threads"></p>
<ul>
<li>logic cpu = 8</li>
<li>physical cpu = 2</li>
<li>每個 CPU 上的 core 數量 = 2</li>
<li>每個 physical cpu 上分配的 logic cpu 的數量 = 4</li>
</ul>
<hr>
<h1 id="Over-Commit"><a href="#Over-Commit" class="headerlink" title="Over-Commit"></a>Over-Commit</h1><p>一般正常使用情況下，每一台 virtual machine 不會總是在高負載狀況，很多時間會是閒置的；此時透過 over-commit 的方式，可以分配比 host machine 中所有的 vCPU 給 virtual machine。</p>
<p>但不建議分配給單一 virtual machine 超過 host machine 所有 vCPU 的數量，因為這會大大降低 virtual machine 的效能，例如：host machine 總共有 4 個 vCPU，但分配 8 個 vCPU 給 virtual machine。</p>
<p>若是 4 個 vCPU，分配 1 個 vCPU 給 virtual machine，但分配到 8 台 virtual machine，這樣的效能會比上面的配置更有效率。</p>
<blockquote>
<p>若是在 production 的環境，建議還是不要 over-commit</p>
</blockquote>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><p><a href="http://linux.die.net/man/1/qemu-kvm" target="_blank" rel="noopener">qemu-kvm(1): QEMU Emulator User Documentation - Linux man page</a></p>
</li>
<li><p><a href="https://ncucsie.hackpad.com/ep/pad/static/QrwxkWD88gd" target="_blank" rel="noopener">虛擬化技術與應用</a></p>
</li>
<li><p><a href="https://www.ptt.cc/bbs/b97902HW/M.1267018497.A.3B1.html" target="_blank" rel="noopener">[系程] 教學: 簡介 Kernel/User Mode 的概念 - 看板 b97902HW - 批踢踢實業坊</a></p>
</li>
<li><p><a href="http://peachwaneversay.blogspot.tw/2007/05/user-mode-vs-kernel-mode.html" target="_blank" rel="noopener">企鵝幫魚，魚幫兔: User mode vs. Kernel mode</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> KVM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> KVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Linux KVM] 使用 Linux KVM 啟用第一個 virtual machine]]></title>
      <url>/blog/2016/07/26/KVM/QEMU-KVM-In-CentOS7-GettingStart/</url>
      <content type="html"><![CDATA[<p>介紹如何使用 QEMU/KVM 在 Linux 上啟用第一個 virtual machine</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="KVM"><a href="#KVM" class="headerlink" title="KVM"></a>KVM</h2><p>KVM 屬於全虛擬化(Full Virtualization) 的技術，因此在上面運行的 OS 不需要經過任何修改。</p>
<p>原本因為 Full Virtualization 效能應該是很差的，但因為硬體虛擬化的支援(例如：<a href="http://stenlyho.blogspot.tw/2009/01/vt-xvt-d-intel.html" target="_blank" rel="noopener">Intel VT-d</a>，因此大幅提升了 KVM 的效能；此外 KVM 與 QEMU(負責周邊設備的模擬) 的搭配，提供了使用者在 CPU、Memory、Storage、Network、Display 上都有完全相同的虛擬化體驗。</p>
<h2 id="Linux-kernel"><a href="#Linux-kernel" class="headerlink" title="Linux kernel"></a>Linux kernel</h2><p>關於 Linux kernel 上，建議使用目前較新的 kernel，在以下的環境中，會選用安裝 CentOS 7 作為 host machine，搭配 3.10 版的 Linux kernel 做為測試環境之用。</p>
<h2 id="環境說明"><a href="#環境說明" class="headerlink" title="環境說明"></a>環境說明</h2><h3 id="硬體"><a href="#硬體" class="headerlink" title="硬體"></a>硬體</h3><p>CPU：Intel(R) Xeon(R) CPU E5-2660 v3 @ 2.60GHz</p>
<h3 id="軟體"><a href="#軟體" class="headerlink" title="軟體"></a>軟體</h3><ul>
<li><p>OS: CentOS 7</p>
</li>
<li><p>Linux Kernel: 3.10</p>
</li>
<li><p>qemu-kvm: 1.5.3 (預設開啟 KVM 加速)</p>
</li>
<li><p>qemu-img: 1.5.3</p>
</li>
</ul>
<hr>
<h1 id="前置環境設定"><a href="#前置環境設定" class="headerlink" title="前置環境設定"></a>前置環境設定</h1><h2 id="安裝套件"><a href="#安裝套件" class="headerlink" title="安裝套件"></a>安裝套件</h2><p>首先要安裝 KVM、QEMU、libvirtd 相關套件 &amp; 啟動 libvirtd service：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># KVM v2.3 需要使用此 repository</span></span><br><span class="line">$ bash -c <span class="string">"echo '[kvm-common]</span></span><br><span class="line"><span class="string">name=Latest KVM rpms</span></span><br><span class="line"><span class="string">baseurl=http://mirror.centos.org/centos-7/7/virt/x86_64/kvm-common/</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=0' &gt; /etc/yum.repos.d/kvm.repo"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安裝 KVM 1.5</span></span><br><span class="line">$ yum install -y qemu-kvm \</span><br><span class="line">    qemu-img \</span><br><span class="line">    qemu-system-x86 \</span><br><span class="line">    libvirt \</span><br><span class="line">    virt-install \</span><br><span class="line">    libvirt-python \</span><br><span class="line">    virt-manager \</span><br><span class="line">    python-virtinst \</span><br><span class="line">    libvirt-client \</span><br><span class="line">    bridge-utils \</span><br><span class="line">    net-tools \</span><br><span class="line">    libguestfs-tools-c \</span><br><span class="line">    iptables-services</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可使用 groupinstall 來批次安裝</span></span><br><span class="line">$ yum groupinstall <span class="string">"virtualization"</span> -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若要安裝 KVM 2.3 可使用下面指令</span></span><br><span class="line">$ yum install -y qemu-kvm-ev \</span><br><span class="line">    qemu-img-ev \</span><br><span class="line">    qemu-system-x86 \</span><br><span class="line">    libvirt \</span><br><span class="line">    virt-install \</span><br><span class="line">    libvirt-python \</span><br><span class="line">    virt-manager \</span><br><span class="line">    python-virtinst \</span><br><span class="line">    libvirt-client \</span><br><span class="line">    bridge-utils \</span><br><span class="line">    net-tools \</span><br><span class="line">    libguestfs-tools-c \</span><br><span class="line">    iptables-services</span><br></pre></td></tr></table></figure>
<p>也可以順便設定 <a href="http://www.linux-kvm.org/images/3/33/02x03-NestedVirtualization.pdf" target="_blank" rel="noopener">nested virtualization</a>，可以在虛擬環境中再虛擬一層而不會有太多的 performance lose：(此步驟可以略過)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 目前 nested virtualization 是關閉的 </span></span><br><span class="line">$ cat /sys/module/kvm_intel/parameters/nested</span><br><span class="line">N</span><br><span class="line"></span><br><span class="line"><span class="comment"># 開啟 nested virtualization</span></span><br><span class="line">$ sudo rmmod kvm-intel</span><br><span class="line">$ sudo sh -c <span class="string">"echo 'options kvm-intel nested=y' &gt;&gt; /etc/modprobe.d/dist.conf"</span></span><br><span class="line">$ sudo modprobe kvm-intel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 開啟 nested virtualization 成功</span></span><br><span class="line">$ cat /sys/module/kvm_intel/parameters/nested</span><br><span class="line">Y</span><br></pre></td></tr></table></figure>
<h2 id="防火牆設定"><a href="#防火牆設定" class="headerlink" title="防火牆設定"></a>防火牆設定</h2><p>停用預設的 <strong>firewalld.service</strong>，並啟用 <strong>iptables.service</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 關閉 firewalld</span></span><br><span class="line">$ systemctl stop firewalld.service</span><br><span class="line">$ systemctl <span class="built_in">disable</span> firewalld.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 啟用 iptables</span></span><br><span class="line">$ systemctl stop iptables.service</span><br><span class="line">$ systemctl <span class="built_in">disable</span> iptables.service</span><br></pre></td></tr></table></figure>
<p>改用傳統的 itpables 來進行防火牆設定，並使用以下 script 建立防火牆：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># global variables</span></span><br><span class="line">IIF=<span class="string">"ens1f0"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 防止 sync flooding 攻擊(開啟 tcp sync cookie)</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/tcp_syncookies</span><br><span class="line"></span><br><span class="line">iptables -t filter -F</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定 connection track</span></span><br><span class="line">iptables -t filter -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br><span class="line"><span class="comment"># 避免 INVALID 封包被其他服務所接收</span></span><br><span class="line">iptables -t filter -A INPUT -m state --state INVALID -j DROP</span><br><span class="line"></span><br><span class="line">iptables -t filter -A INPUT -p tcp --dport 22 -j ACCEPT</span><br><span class="line"><span class="comment"># 提供 vnc access</span></span><br><span class="line">iptables -t filter -A INPUT -p tcp --dport 5900:5910 -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用來取代 chain default policy</span></span><br><span class="line">iptables -t filter -A INPUT -i <span class="variable">$&#123;IIF&#125;</span> -j DROP</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的套件安裝 &amp; 防火牆設定完成後，要將 KVM host 重新開啟，並啟動 <strong><font color="red">libvirtd.service</font></strong></p>
</blockquote>
<hr>
<h1 id="驗證環境"><a href="#驗證環境" class="headerlink" title="驗證環境"></a>驗證環境</h1><p>安裝好 QEMU/KVM 相關套件後，我們可以來檢查目前的環境是否可以正確的運行虛擬化功能：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ virt-host-validate</span><br><span class="line">  QEMU: Checking <span class="keyword">for</span> hardware virtualization                                 : PASS</span><br><span class="line">  QEMU: Checking <span class="keyword">for</span> device /dev/kvm                                         : PASS</span><br><span class="line">  QEMU: Checking <span class="keyword">for</span> device /dev/vhost-net                                   : PASS</span><br><span class="line">  QEMU: Checking <span class="keyword">for</span> device /dev/net/tun                                     : PASS</span><br><span class="line">   LXC: Checking <span class="keyword">for</span> Linux &gt;= 2.6.26                                         : PASS</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">$ virsh nodeinfo</span><br><span class="line">CPU model:           x86_64</span><br><span class="line">CPU(s):              48</span><br><span class="line">CPU frequency:       1200 MHz</span><br><span class="line">CPU socket(s):       1</span><br><span class="line">Core(s) per socket:  12</span><br><span class="line">Thread(s) per core:  2</span><br><span class="line">NUMA cell(s):        2</span><br><span class="line">Memory size:         263930636 KiB</span><br><span class="line"></span><br><span class="line">$ virsh domcapabilities</span><br><span class="line">&lt;domainCapabilities&gt;</span><br><span class="line">  &lt;path&gt;/usr/bin/qemu-system-x86_64&lt;/path&gt;</span><br><span class="line">  &lt;domain&gt;qemu&lt;/domain&gt;</span><br><span class="line">  &lt;machine&gt;pc-i440fx-2.0&lt;/machine&gt;</span><br><span class="line">  &lt;arch&gt;x86_64&lt;/arch&gt;</span><br><span class="line">  &lt;vcpu max=<span class="string">'255'</span>/&gt;</span><br><span class="line">  &lt;os supported=<span class="string">'yes'</span>&gt;</span><br><span class="line">    &lt;loader supported=<span class="string">'yes'</span>&gt;</span><br><span class="line">      &lt;enum name=<span class="string">'type'</span>&gt;</span><br><span class="line">        &lt;value&gt;rom&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;pflash&lt;/value&gt;</span><br><span class="line">      &lt;/enum&gt;</span><br><span class="line">      &lt;enum name=<span class="string">'readonly'</span>&gt;</span><br><span class="line">        &lt;value&gt;yes&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;no&lt;/value&gt;</span><br><span class="line">      &lt;/enum&gt;</span><br><span class="line">    &lt;/loader&gt;</span><br><span class="line">  &lt;/os&gt;</span><br><span class="line">  &lt;devices&gt;</span><br><span class="line">    &lt;disk supported=<span class="string">'yes'</span>&gt;</span><br><span class="line">      &lt;enum name=<span class="string">'diskDevice'</span>&gt;</span><br><span class="line">        &lt;value&gt;disk&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;cdrom&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;floppy&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;lun&lt;/value&gt;</span><br><span class="line">      &lt;/enum&gt;</span><br><span class="line">      &lt;enum name=<span class="string">'bus'</span>&gt;</span><br><span class="line">        &lt;value&gt;ide&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;fdc&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;scsi&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;virtio&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;usb&lt;/value&gt;</span><br><span class="line">      &lt;/enum&gt;</span><br><span class="line">    &lt;/disk&gt;</span><br><span class="line">    &lt;hostdev supported=<span class="string">'yes'</span>&gt;</span><br><span class="line">      &lt;enum name=<span class="string">'mode'</span>&gt;</span><br><span class="line">        &lt;value&gt;subsystem&lt;/value&gt;</span><br><span class="line">      &lt;/enum&gt;</span><br><span class="line">      &lt;enum name=<span class="string">'startupPolicy'</span>&gt;</span><br><span class="line">        &lt;value&gt;default&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;mandatory&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;requisite&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;optional&lt;/value&gt;</span><br><span class="line">      &lt;/enum&gt;</span><br><span class="line">      &lt;enum name=<span class="string">'subsysType'</span>&gt;</span><br><span class="line">        &lt;value&gt;usb&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;pci&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;scsi&lt;/value&gt;</span><br><span class="line">      &lt;/enum&gt;</span><br><span class="line">      &lt;enum name=<span class="string">'capsType'</span>/&gt;</span><br><span class="line">      &lt;enum name=<span class="string">'pciBackend'</span>&gt;</span><br><span class="line">        &lt;value&gt;default&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;vfio&lt;/value&gt;</span><br><span class="line">      &lt;/enum&gt;</span><br><span class="line">    &lt;/hostdev&gt;</span><br><span class="line">  &lt;/devices&gt;</span><br><span class="line">&lt;/domainCapabilities&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="啟動第一個-virtual-machine"><a href="#啟動第一個-virtual-machine" class="headerlink" title="啟動第一個 virtual machine"></a>啟動第一個 virtual machine</h1><p>由於 RedHat 建議使用 virsh，因此 <strong><font color="red">qemu-kvm</font></strong> 就不存在於預設路徑中，用以下指令把它找出來：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 將 qemu-kvm 以 symlink 的形式複製到 $PATH</span></span><br><span class="line"><span class="comment"># qemu-kvm 指令已經預設啟用 KVM 支援</span></span><br><span class="line">$ ln -sf /usr/libexec/qemu-kvm /usr/bin/kvm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 製作一個 size = 8GB 的 raw image 作為 virtual machine disk</span></span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/zero of=/kvm/storage/vm_disks/ubnutu1604.img bs=1M count=8192</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目前系統中存在的 iso</span></span><br><span class="line">$ ls /kvm/os_images</span><br><span class="line">ubuntu-16.04.1-server-amd64.iso</span><br><span class="line"></span><br><span class="line"><span class="comment"># 啟動 VM (以光碟開機，安裝作業系統)</span></span><br><span class="line"><span class="comment"># -smp 4 =&gt; vCPU=4</span></span><br><span class="line"><span class="comment"># -m 2048 =&gt; RAM=2048MB</span></span><br><span class="line"><span class="comment"># -vnc 0.0.0.0:5 =&gt; 將 vnc 開在第五個 console，因此透過 vnc viewer 連線要使用 "ip:5" 來進行連線</span></span><br><span class="line"><span class="comment"># -boot order=cd =&gt; 開機順序為 cdrom &gt; hdd</span></span><br><span class="line"><span class="comment"># -hda /kvm/storage/vm_disks/ubnutu1604.img =&gt; 指定 hdd raw image</span></span><br><span class="line"><span class="comment"># -cdrom /kvm/os_images/ubuntu-16.04.1-server-amd64.iso =&gt; 指定開機光碟 iso</span></span><br><span class="line">$ kvm -smp 4 -m 2048 \</span><br><span class="line">  -vnc 0.0.0.0:5 -boot order=<span class="built_in">cd</span> \</span><br><span class="line">  -hda /kvm/storage/vm_disks/ubnutu1604.img \</span><br><span class="line">  -cdrom /kvm/os_images/ubuntu-16.04.1-server-amd64.iso</span><br></pre></td></tr></table></figure>
<p>接著可以使用 <a href="http://tigervnc.org/" target="_blank" rel="noopener">TigerVNC</a> or <a href="https://chrome.google.com/webstore/detail/vnc%C2%AE-viewer-for-google-ch/iabmpiboiopbgfabjmgeedhcmjenhbla" target="_blank" rel="noopener">VNC® Viewer for Google Chrome</a> 來進行連線，使用的的連線位置為 <code>server_ip:5</code>；連線進入後，就可以按照一般程序進行 OS 的安裝。</p>
<p>安裝完成後，<code>/kvm/storage/vm_disks/ubnutu1604.img</code> 將會是一個已經安裝好 OS 的硬碟 image 檔案，我們可以透過以下指令使用此 image 檔案來啟動系統：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -smp 4 =&gt; vCPU=4</span></span><br><span class="line"><span class="comment"># -m 2048 =&gt; RAM=2048MB</span></span><br><span class="line"><span class="comment"># -vnc 0.0.0.0:5 =&gt; 將 vnc 開在第五個 console，因此透過 vnc viewer 連線要使用 "ip:5" 來進行連線</span></span><br><span class="line">$ kvm -smp 4 -m 2048 -vnc 0.0.0.0:5 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br></pre></td></tr></table></figure>
<p>使用 VNC viewer 連到 virtual machine 之後，可使用 <code>Ctrl + Alt + 2</code> 切到 QEMU monitor，輸入 <code>kvm info</code> 就可以檢視目前 KVM 是否被使用，或是完全在 QEMU 模擬下產生：</p>
<p><img src="https://lh3.googleusercontent.com/Or8AH3hxAJbdXsIMADxmVkvUKlFYe_-DwTpSuw878fpP3bDAqyLv_ql_7W_HIrLYGHqc1hha7aecKMM6lytj2Wkv-NEyoXsZPuHE5RKa9mp_6apKEoPn7h-tp2DSjLcHaj72ByMefPKXRFKFYCLmYdbhsax0Ro8A-UCjSweOuB03zEL44VM7YbkxNE85vTmFv-JMUUERlX3CAdDotSWpvzl-ztgHzoU2E0iqwgLawhHAhn1JOX19Mn0ib3J0vxqZyLI6CNqaXEIc-7v5QNhAmAysEdWd3AMVKqkPVI41v8FDiUam2G_MDUkWOsAW4aQjnwrAbiw3-Ljpi72gjsM_iJWnsLF5nCuREGQxWC_LOrhRo7-AKLgU_XmzJuobqLRi6LoMzy_BKva5jI7nSgmgAfXDDTWpsXyGoKSgexpg_J7SRuLVZR1iZZ8HCZ9FZpre9qNIdr6xsvnH1NoUobJ73IKMbKn4YmGD0Z9Odi51bpWSh9eV1kOyCMFnF7Q5KZoPk-9lZwChK0gVUj6eObbJDKhlrFTpSvO7vYGJOmIBtfgCfKB9tAZ1-fpDSWxv8tGP38OQmKirl5oh0ozkGGQ-Z9QAr0mC31U=w642-h143-no" alt="QEMU Monitor"></p>
<blockquote>
<p>從上圖來看，可看出關鍵字 <code>kvm support: enabled</code>，表示 KVM 加速是開啟的</p>
<p>由於我們在上面所產生的 kvm 指令是來自於 qemu-kvm，因此已經預設啟用 KVM 加速 (若單純使用 QEMU，可搭配 <code>--enable-kvm</code> 參數來啟用 KVM 加速)</p>
</blockquote>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><ul>
<li><p><a href="http://newtoypia.blogspot.tw/2015/02/qemu-kvm.html" target="_blank" rel="noopener">玩具烏托邦: 五分鐘開始玩 qemu-kvm 虛擬機</a></p>
</li>
<li><p><a href="http://www.vpsee.com/2012/04/install-kvm-on-centos-6-2/" target="_blank" rel="noopener">在 CentOS 6.2 上安装和配置 KVM @vpsee.com</a></p>
</li>
<li><p><a href="http://ot-note.logdown.com/posts/64644/launch-a-vm-with-qemu-kvm" target="_blank" rel="noopener">使用 libvirt 與 qemu-kvm 開啓 VM (內含 libvirt sample XML for KVM ) « OT Coding Note</a></p>
</li>
</ul>
<h2 id="VNC"><a href="#VNC" class="headerlink" title="VNC"></a>VNC</h2><ul>
<li><a href="http://jamyy.us.to/blog/2011/10/3365.html" target="_blank" rel="noopener">KVM/QEMU 設置 VNC 連線密碼 « Jamyy’s Weblog</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> KVM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> KVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Linux] PXE Booting]]></title>
      <url>/blog/2016/07/01/Linux/Linux-PXE-Booting/</url>
      <content type="html"><![CDATA[<p>此篇文章介紹 PXE &amp; iPXE 的開機流程</p>
<h1 id="PXE"><a href="#PXE" class="headerlink" title="PXE"></a>PXE</h1><p>首先以下圖說明一下傳統 PXE 的流程：</p>
<p><img src="https://github.com/coreos/coreos-baremetal/raw/master/Documentation/img/pxelinux.png" alt="PXE"></p>
<p>PXE 的開機流程，簡單來說就是幾個步驟：</p>
<ol>
<li><p>network client 從 DHCP service 取得 IP &amp; 其他 metadata(例如：TFTP 資訊 &amp; NBP 檔名)</p>
</li>
<li><p>network client 從 TFTP 取得 NBP(Network Boot Program，上面中的 <code>pxelinux.0</code>)，並啟動</p>
</li>
<li><p>network client 使用 NBP 載入 configs, scripts, 以及執行 OS 需要的 kernel(範例中的 <code>kernel.vmlinuz</code>) &amp; ramfs image(上圖中的 <code>initrd.cpio.gz</code>)</p>
</li>
</ol>
<hr>
<h1 id="Network-Boot-Program-NBP-也稱為-bootloader"><a href="#Network-Boot-Program-NBP-也稱為-bootloader" class="headerlink" title="Network Boot Program (NBP, 也稱為 bootloader)"></a>Network Boot Program (NBP, 也稱為 bootloader)</h1><p>CoreOS 可用多種不同的 bootloader 開機 &amp; 設定，如果是一個全新的設定環境，<a href="http://ipxe.org/" target="_blank" rel="noopener">iPXE</a> 是個不錯的選擇。</p>
<h2 id="PXELINUX"><a href="#PXELINUX" class="headerlink" title="PXELINUX"></a>PXELINUX</h2><p><a href="http://www.syslinux.org/wiki/index.php?title=PXELINUX" target="_blank" rel="noopener">PXELINUX</a> 是個相當普遍被使用的 bootloader(檔名為 <code>pxelinux.0</code>)，會自動從 <code>/tftp_bootdir/pxelinux.cfg</code> 目錄中載入設定檔。</p>
<p>若要控制特定機器使用特定的設定檔，可以利用 network client 的 UUID、MAC address、IP or default 來進行設定，因此設定檔就會變成如下面的範例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/tftp_bootdir/pxelinux.cfg/b8945908-d6a6-41a9-611d-74a6ab80b83d</span><br><span class="line">/tftp_bootdir/pxelinux.cfg/01-88-99-aa-bb-cc-dd</span><br><span class="line">/tftp_bootdir/pxelinux.cfg/default</span><br></pre></td></tr></table></figure>
<p>按照上圖的流程，可以很清楚知道，設定檔的內容肯定就是會包含了像是 config / script / kernel / ramfs image …. 等檔案的位置資訊(可能還會包含<strong>開機選單</strong>)，以下是個簡單範例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">default coreos</span><br><span class="line">prompt 1</span><br><span class="line">timeout 15</span><br><span class="line"></span><br><span class="line">display boot.msg</span><br><span class="line"></span><br><span class="line">label coreos</span><br><span class="line">  menu default</span><br><span class="line">  kernel coreos_production_pxe.vmlinuz</span><br><span class="line">  append initrd=coreos_production_pxe_image.cpio.gz cloud-config-url=http://example.com/pxe-cloud-config.yml</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面範例中的檔案若沒有指定目錄，就表示應該將其放在 <code>/tftp_bootdir</code> 目錄中<br>其中設定了一個簡單的 menu、顯示訊息、kernel(coreos_production_pxe.vmlinuz)、ramfs(coreos_production_pxe_image.cpio.gz) &amp; 設定 CoreOS 用的 cloud-config.yaml</p>
</blockquote>
<p>PXE 雖然普遍使用，但的確是有些缺點存在的，例如：</p>
<ol>
<li><p>TFTP 速度慢</p>
</li>
<li><p>若有許多針對不同機器的客製化設定檔需求，會需要撰寫很多份 pxelinux config</p>
</li>
</ol>
<h2 id="iPXE"><a href="#iPXE" class="headerlink" title="iPXE"></a>iPXE</h2><p><a href="http://ipxe.org/" target="_blank" rel="noopener">iPXE</a> 可是視為加強版的 PXE bootloader，使用的並非是設定檔，而是 <strong>iPXE script</strong>，而且 iPXE script &amp; image 都可以透過 HTTP 下載</p>
<p>以下是 iPXE 開機流程示意圖：</p>
<p><img src="https://github.com/coreos/coreos-baremetal/raw/master/Documentation/img/ipxe.png" alt="iPXE"></p>
<p>從上圖可以看出，為了可以運作在原有的環境中，使用了一個名稱為 <a href="http://boot.ipxe.org/undionly.kpxe" target="_blank" rel="noopener">undionly.kpxe</a> 的 bootloader 來協助開機，接著會發生以下的事情：</p>
<ol>
<li><p>bootloader undionly.kpxe 會提供給 machine 上網 &amp; 處理後續 iPXE script 的能力</p>
</li>
<li><p>透過網路取得 iPXE script <code>boot.ipxes</code></p>
</li>
<li><p>並會使用檔名為 <code>boot.ipxe</code>(來源可以是 HTTP) 的 iPXE script 來繼續執行後續的開機流程</p>
</li>
</ol>
<p>以下是個簡單的 iPXE script 範例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!ipxe</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> base-url http://stable.release.core-os.net/amd64-usr/current</span><br><span class="line">kernel <span class="variable">$&#123;base-url&#125;</span>/coreos_production_pxe.vmlinuz cloud-config-url=http://provisioner.example.net/cloud-config.yml</span><br><span class="line">initrd <span class="variable">$&#123;base-url&#125;</span>/coreos_production_pxe_image.cpio.gz</span><br><span class="line">boot</span><br></pre></td></tr></table></figure>
<blockquote>
<p>透過 iPXE script，可以用程式化的方式進行更多動態的開機設定</p>
</blockquote>
<p>在 iPXE 開機環境 for CoreOS 的架構中，有一些事情是值得注意一下的：</p>
<ol>
<li><p>TFTP 只用來提供 <a href="http://boot.ipxe.org/undionly.kpxe" target="_blank" rel="noopener">undionly.kpxe</a> bootloader，目的是為了讓老舊的 PXE firmware client 也可以使用 iPXE</p>
</li>
<li><p>CoreOS 提供了 <a href="coreos-baremetal/bootcfg.md at master · coreos/coreos-baremetal">bootcfg</a> 工具，可根據硬體的屬性，用來產生相對應的 iPXE script (把 iPXE script 的來源指向 bootcfg iPXE endpoint)</p>
</li>
</ol>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><p><a href="http://www.syslinux.org/wiki/index.php?title=PXELINUX" target="_blank" rel="noopener">PXELINUX - Syslinux Wiki</a></p>
</li>
<li><p><a href="http://ipxe.org/howto/chainloading" target="_blank" rel="noopener">iPXE - open source boot firmware [howto:chainloading]</a></p>
</li>
<li><p><a href="https://github.com/coreos/coreos-baremetal/blob/master/Documentation/network-booting.md" target="_blank" rel="noopener">coreos-baremetal/network-booting.md at master · coreos/coreos-baremetal</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Linux] 解決使用帶有密碼的 SSH keypair 時需要重複輸入密碼的問題]]></title>
      <url>/blog/2016/07/01/Linux/Auto-Authenticate-with-Password-Protected-SSHKeypair/</url>
      <content type="html"><![CDATA[<blockquote>
<p>use ssh agent and keychain to input the secret of password-protected ssh key</p>
</blockquote>
<p>最近被 GitHub 騙了去產生個帶有密碼的 SSH keypair 來用</p>
<p>發現怎麼每次使用都要我輸入密碼呢….? 於是上網找了一下答案……</p>
<p>要解決這方式，需要 <strong>ssh agent</strong> 搭配 <strong>keychain</strong> 來將密碼安全的儲存起來</p>
<p>假設以下情況已經完成：</p>
<ol>
<li><p>SSK keypair 已經存在於 <code>~/.ssh/id_rsa*</code></p>
</li>
<li><p>keychain 套件已經安裝</p>
</li>
</ol>
<p>接著只要執行以下指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ tee --append ~/.bash_profile &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line"><span class="comment">### START-Keychain ###</span></span><br><span class="line"><span class="comment"># Let  re-use ssh-agent and/or gpg-agent between logins</span></span><br><span class="line">/usr/bin/keychain <span class="variable">$HOME</span>/.ssh/id_rsa</span><br><span class="line"><span class="built_in">source</span> <span class="variable">$HOME</span>/.keychain/<span class="variable">$HOSTNAME</span>-sh</span><br><span class="line"><span class="comment">### End-Keychain ###</span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>接著再重新登入，輸入一次密碼後，後續使用到 SSH keypair 時，就不用一直重複輸入了!</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><p><a href="https://help.github.com/articles/generating-an-ssh-key/" target="_blank" rel="noopener">Generating an SSH key - User Documentation</a></p>
</li>
<li><p><a href="http://unix.stackexchange.com/questions/83608/ssh-agent-how-to-set-it-up-so-my-centos-server-will-only-ask-for-passphrase-onc" target="_blank" rel="noopener">ssh-agent: How to set it up so my CentOS server will only ask for passphrase once? - Unix &amp; Linux Stack Exchange</a></p>
</li>
<li><p><a href="http://www.cyberciti.biz/faq/ssh-passwordless-login-with-keychain-for-scripts/" target="_blank" rel="noopener">keychain: Set Up Secure Passwordless SSH Access For Backup Scripts</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[VMware] 免費的 vSphere ESXi VM 備份方案 - XSIBACKUP]]></title>
      <url>/blog/2014/11/14/VMware/free-vsphere-esxi-vm-backup-solution-xsibackup/</url>
      <content type="html"><![CDATA[<p>最近公司在找給 VMware vSphere ESXi 用的 shared storage，想當然爾也會考慮到備份的問題</p>
<p>後來學長提供了 <a href="http://sourceforge.net/projects/xsibackup/" target="_blank" rel="noopener">xsibackup</a> 這個 opensource 的免費軟體，雖然是免費，可是備份功能也不差呢。</p>
<h2 id="環境設定"><a href="#環境設定" class="headerlink" title="環境設定"></a>環境設定</h2><ul>
<li>vSphere ESXi <strong>5.5 Update 2</strong></li>
<li>esxibackup <strong>4.1.6</strong></li>
</ul>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>1、 首先必須先開啟 ESXi Host 的 SSH servive，並透過 ssh client 登入到 esxi 中</p>
<p>2、 下載 xsibackup 程式並解壓縮，將 xsibackup 程式設定為可執行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要將檔案放到 ESXi 重開機後不會回復初始設定的路徑(可以是任何 DataStore 的目錄下，只要是 persistent folder 即可)</span></span><br><span class="line"><span class="comment"># 切換到 datastore1 folder，避免 ESXi 重開機之後將檔案刪除</span></span><br><span class="line">$ <span class="built_in">cd</span> /vmfs/volumes/datastore1</span><br><span class="line">$ wget http://sourceforge.net/projects/xsibackup/files/xsibackup_4.1.6.zip/download -O xsibackup.zip</span><br><span class="line">$ unzip xsibackup.zip</span><br><span class="line">$ chmod 0700 xsibackup*</span><br></pre></td></tr></table></figure>
<p>3、執行備份工作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 備份檔存放路徑：/vmfs/volumes/backup</span></span><br><span class="line"><span class="comment"># 備份類型：目前運行中的 VM (running)</span></span><br><span class="line"><span class="comment"># mail &amp; smpt 的相關設定都是與寄信相關</span></span><br><span class="line">$ ./xsibackup --backup-point=/vmfs/volumes/backup --backup-type=running </span><br><span class="line">--mail-from=email.sender@yourdomain.com --mail-to=email.recipient@anotherdomain.com </span><br><span class="line">--smtp-srv=smtp.yourdomain.com --smtp-port=25 --smtp-usr=username </span><br><span class="line">--smtp-pwd=password</span><br></pre></td></tr></table></figure>
<p><code>/vmfs/volumes/backup 目錄也可以是 remote host 所提供的 NFS share folder</code></p>
<p>其中 <code>--backup-type</code> 有以下三種：</p>
<ul>
<li><strong>all</strong> (所有 vm)</li>
<li><strong>running</strong> (執行中的 vm)</li>
<li><strong>custom</strong> (指定 vm，需搭配 –backup-vms 參數指令要備份的 vm，多個 vm 可用逗號隔開)</li>
</ul>
<p>custom 應用如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定備份 WINDOWSVM1 &amp; LINUXVM2 兩台 vm</span></span><br><span class="line">$ ./xsibackup --backup-point=/vmfs/volumes/backup --backup-type=custom --backup-vms=WINDOWSVM1,LINUXVM2</span><br></pre></td></tr></table></figure>
<h2 id="其他參數"><a href="#其他參數" class="headerlink" title="其他參數"></a>其他參數</h2><ul>
<li><code>--test-mode=true</code> (測試模式，不實際進行備份；但若有設定 EMail 相關參數則會發信)</li>
<li><code>--backup-how (hot | cold)</code> (hot 會在 vm 開機情況下備份，cold 則會將 vm 關機後再備份)`</li>
</ul>
<h2 id="寄送-Mail-的問題"><a href="#寄送-Mail-的問題" class="headerlink" title="寄送 Mail 的問題"></a>寄送 Mail 的問題</h2><p>設定了 EMail 發送相關參數後，實際執行會發現竟然不行，排除方法如下：</p>
<p>xsibackup 程式會在 <strong>/etc/vmware/firewall/service.xml</strong> 這個檔案補上這一段內容：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">id</span>=<span class="string">'9999'</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span>&gt;</span>SMTPout<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">rule</span> <span class="attr">id</span>=<span class="string">'0000'</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">direction</span>&gt;</span>outbound<span class="tag">&lt;/<span class="name">direction</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">protocol</span>&gt;</span>tcp<span class="tag">&lt;/<span class="name">protocol</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">porttype</span>&gt;</span>dst<span class="tag">&lt;/<span class="name">porttype</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">port</span>&gt;</span><span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">required</span>&gt;</span>false<span class="tag">&lt;/<span class="name">required</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但其實這是錯誤的，要把 <code>&lt;port&gt;&lt;/port&gt;</code>這個部分改成 <code>&lt;port&gt;25&lt;/port&gt;</code>，並執行以下指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ esxcli network firewall refresh</span><br></pre></td></tr></table></figure>
<p>如此一來 EMail 的功能就會正常啟動了!</p>
<h2 id="排程備份"><a href="#排程備份" class="headerlink" title="排程備份"></a>排程備份</h2><p>xsibackup 也支援排程喔! 設定方式如下：</p>
<ol>
<li>在 ESXi 主機上執行 <code>xsibackup --install-cron</code> 指令，此時會在 <strong>/vmfs/volumes/datastore1</strong> 目錄中產生 <code>xsibackup-cron</code>這個檔案，可以直接進入編輯：(若是星期一、五晚上 20:00 要備份)</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加入 --time 參數，格式為 --time="Day HH:mm"(注意這邊要用 UTC 時間)</span></span><br><span class="line"><span class="comment"># 星期一 20:00 備份</span></span><br><span class="line">/vmfs/volumes/datastore1/xsibackup --time=<span class="string">"Mon 12:00"</span> --backup-point=/vmfs/volumes/backup --backup-type=running --mail-from=email.sender@yourdomain.com --mail-to=email.recipient@anotherdomain.com --smtp-srv=smtp.yourdomain.com --smtp-port=25 --smtp-usr=username --smtp-pwd=password</span><br><span class="line"><span class="comment"># 星期五 20:00 備份</span></span><br><span class="line">/vmfs/volumes/datastore1/xsibackup --time=<span class="string">"Fri 12:00"</span> --backup-point=/vmfs/volumes/backup --backup-type=running --mail-from=email.sender@yourdomain.com --mail-to=email.recipient@anotherdomain.com --smtp-srv=smtp.yourdomain.com --smtp-port=25 --smtp-usr=username --smtp-pwd=password</span><br></pre></td></tr></table></figure>
<ol>
<li>重新啟動 ESXi Host 讓 cron 的功能啟用</li>
</ol>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>因此總結一下，優缺點大致如下：</p>
<h3 id="優點"><a href="#優點" class="headerlink" title="優點"></a>優點</h3><ol>
<li><p>免費、開放</p>
</li>
<li><p>可進行完整備份，非特殊格式，不需要透過其他軟體還原</p>
</li>
<li><p>在單純的環境下使用簡單</p>
</li>
</ol>
<h3 id="缺點"><a href="#缺點" class="headerlink" title="缺點"></a>缺點</h3><ol>
<li><p>無法執行差異備份，自然也就沒有 dedupication 的功能。</p>
</li>
<li><p>目前沒有 exclude 的參數，若是有不想備份的 VM(例如：VDP)，只能透過 custom or running(搭配將 vm 關機)的方式來完成 (也可以透過改 source code 的方式來做….)</p>
</li>
<li><p>若是 vSphere 授權版本有 DRS(Dynamic Resource Scheduler) 的話，VM 可能會隨著資源耗損不同而跑來跑去，備份工作就很難透過 custom 方式來達成。</p>
</li>
</ol>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><p><a href="http://sourceforge.net/projects/xsibackup/" target="_blank" rel="noopener">Free Backup Software for VMware ESXi VMs | SourceForge.net</a></p>
</li>
<li><p><a href="http://blog.depicus.com/add-outbound-port-25-for-smtp-in-vmware-esxi-v5/" target="_blank" rel="noopener">Add outbound port 25 for SMTP in VMware ESXi v5 – depicus</a></p>
</li>
<li><p><a href="http://kb.vmware.com/selfservice/microsites/search.do?language=en_US&amp;cmd=displayKC&amp;externalId=2008226" target="_blank" rel="noopener">VMware KB: Creating custom firewall rules in VMware ESXi 5.x</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> VMware </category>
            
        </categories>
        
        
        <tags>
            
            <tag> VMware </tag>
            
            <tag> Backup </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
