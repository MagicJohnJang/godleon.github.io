<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Docker 網路簡介</title>
      <link href="/blog/2018/07/09/Docker/docker-network-overview/"/>
      <url>/blog/2018/07/09/Docker/docker-network-overview/</url>
      <content type="html"><![CDATA[<p>剛開始使用 docker 的人可能不會對於 docker network 的細節有過多的研究，但若是要將 docker 的功能發揮的淋漓盡致，docker network 相關的知識可是必須要必備的。</p><p>以下將會介紹目前 docker 預設支援的網路類型，包含：</p><ul><li><p>bridge</p></li><li><p>host</p></li><li><p>overlay</p></li><li><p>macvlan</p></li><li><p>none</p></li></ul><p>讓使用者可以知道在何種情況下，啟用 container 時應該要選擇哪一種網路類型。</p><h1 id="Network-Drivers"><a href="#Network-Drivers" class="headerlink" title="Network Drivers"></a>Network Drivers</h1><p>為了讓 docker 支援多種網路類型，docker networking subsystem 被設計成是以可抽換 driver 的形式來運作，可根據使用者需求置換不同的 driver 來達到不同的網路設定目的；其中有以下5個 driver 已經是預設存在的，用來提供核心的網路功能：</p><ul><li><p>bridge</p></li><li><p>host</p></li><li><p>overlay</p></li><li><p>macvlan</p></li><li><p>none </p></li></ul><h1 id="Bridge-Network"><a href="#Bridge-Network" class="headerlink" title="Bridge Network"></a>Bridge Network</h1><p>此為預設的 network driver(沒特別指定就是這個)，通常會用在當 container 都是以 standalone 的方式運作並與其他的 container 相互溝通時，架構圖如下：</p><p><img src="https://cdn-images-1.medium.com/max/1060/0*cMUND9w1bO1o5sPe.png" alt="docker network - bridge"></p><ul><li><p>docker 會新增一個 software bridge 作為 container 網路對外的出口，預設名稱為 <code>docker0</code></p></li><li><p>docker0 會與 host 中的對外網卡(上圖為 <code>eth0</code>)相連，藉此取得對外連線的能力</p></li><li><p>每個 container 會使用一個 veth device 與 docker0 相連，因此具備連外能力</p></li></ul><h1 id="Host-Network"><a href="#Host-Network" class="headerlink" title="Host Network"></a>Host Network</h1><p>此模式的網路有以下特點：</p><ul><li><p>不使用獨立的網路(並非獨立的 network stack)，而是與 Docker Host 使用相同的網路</p></li><li><p>目前這個模式僅在 Linux 上有效，無法在 Mac or Windows 上使用</p></li><li><p>在 Docker 17.06 版以後可以在 swarm service 上使用此模式，但同一個 port 只能被用一次</p></li><li><p>container 如果沒有對外開 port 提供服務，其實設定為 host mode 並沒有意義</p></li></ul><p>網路架構如下圖：</p><p><img src="https://success.docker.com/api/images/.%2Frefarch%2Fnetworking%2Fimages%2Fhost-driver.png" alt="docker network - host"></p><h1 id="Overlay-Network"><a href="#Overlay-Network" class="headerlink" title="Overlay Network"></a>Overlay Network</h1><p>overlay network 是藉由將多個 docker daemon 連結起來，並啟用 swarm service 來讓多個 container 可以相互溝通，有以下特點：</p><ul><li><p>需要 Docker Swarm</p></li><li><p>可讓在不同 host 上的 standalone container 互相溝通</p></li><li><p>可讓 standalone container 與 swarm service 互相溝通</p></li></ul><p>由於 overlay mode 需要 Docker Swarm，因此會先忽略不深入討論，因為未來的學習方向會以 Kubernetes 為主。</p><p>Overlay network 的網路架構如下圖：</p><p><img src="http://img.scoop.it/1nNoIXGkJiDax7l5g5GxH7nTzqrqzN7Y9aBZTaXoQ8Q=" alt="docker network - overlay"></p><h1 id="MACVLAN-Network"><a href="#MACVLAN-Network" class="headerlink" title="MACVLAN Network"></a>MACVLAN Network</h1><p>macvlan network 可以讓使用者直接分配實體網卡的 MAC address 給特定的 container，讓 container 可以透過實體的網卡使用網路；有些需要獨立使用實體網卡的老舊應用程式，可能會用到 macvlan 來設定網路。</p><p>換個角度思考，若是要將上述老舊應用程式的網路與 Host 網路隔開，多加一張實體網卡並設定 macvlan 是個不錯的方式。</p><p>此外，若是實體網路接的是 switch 上的 trunk port，也可以透過 MACVLAN driver 將不同的 VLAN 分配給不同的 container 使用，而 MACVLAN 的網路架構如下：</p><p><img src="http://img.scoop.it/zD6OR5JZu3qF9dxWL79Gc7nTzqrqzN7Y9aBZTaXoQ8Q=" alt="docker network - macvlan"></p><h1 id="None"><a href="#None" class="headerlink" title="None"></a>None</h1><p>不設定 container 的網路，因此 container 無法對外通訊</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><p><a href="https://docs.docker.com/network" target="_blank" rel="noopener">Configure Network | Docker Documentation</a></p></li><li><p><a href="https://docs.docker.com/engine/swarm/" target="_blank" rel="noopener">Swarm mode overview | Docker Documentation</a></p></li><li><p><a href="https://blog.docker.com/2016/12/understanding-docker-networking-drivers-use-cases/" target="_blank" rel="noopener">Understanding Docker Networking Drivers and their use cases - Docker Blog</a></p></li><li><p><a href="http://blog.daocloud.io/docker-source-code-analysis-part7-first/" target="_blank" rel="noopener">Docker源码分析（七）：Docker Container网络 （上） - DaoCloud</a></p></li></ul>]]></content>
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Kubernetes] 設定 Ingress Controller (以 Traefik 為例)</title>
      <link href="/blog/2018/07/04/Kubernetes/k8s-Install-traefik-as-Ingress-Controller/"/>
      <url>/blog/2018/07/04/Kubernetes/k8s-Install-traefik-as-Ingress-Controller/</url>
      <content type="html"><![CDATA[<p>此篇文章介紹 Kubernetes Ingress 的基本概念 &amp; 使用方式 (以 Traefik 為例)</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前提到的 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/" target="_blank" rel="noopener">Pod</a> &amp; <a href="https://kubernetes.io/docs/concepts/services-networking/service/" target="_blank" rel="noopener">Service</a> 都會各自擁有一個 IP address 供存取，但這些 IP 僅有在 K8s cluster 內部才有辦法存取的到，但若要在 K8s cluster 上提供對外服務呢?</p><p>而目前可讓外部存取 K8s 上服務的方式主要有三種：</p><ol><li><p><strong>Service NodePort</strong>: 這方法會在每個 master &amp; worker node 上都開啟指定的 port number (這樣其實造成不少資源浪費)</p></li><li><p><strong>Service LoadBalancer</strong>: 只有在 GCP or AWS 這類的 public cloud 平台才有用的功能</p></li><li><p><strong><a href="https://kubernetes.io/docs/concepts/services-networking/ingress/" title="Kubernetes Ingress" target="_blank" rel="noopener">Ingress</a> 就是被設計來處理這類的問題</strong>：即為此篇文章要談的主角</p></li></ol><p>首先，在沒有 Ingress 之前，從外面到 K8s cluster 的流量會如下圖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  internet</span><br><span class="line">      |</span><br><span class="line">------------</span><br><span class="line">[ Services ]</span><br></pre></td></tr></table></figure><blockquote><p>但在原有的模式下，如果是在 GCP or AWS 使用 K8s 的話，還可以搭配 LoadBalancer 的 service type 動態取得 LB 對外提供服務；但如果是自己架設 K8s，那就只能透過 Service NodePort 的方式讓使用者從外部存取運行在 K8s 上的服務。</p></blockquote><p>所以 Ingress 在 K8s v1.1 之後就應運而生了，而 Ingress 其實就是一堆 rule 的集合，讓外面進來的網路流量可以正確的被導到後方的 Service，架構變成如下圖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> internet</span><br><span class="line">     |</span><br><span class="line">[ Ingress ]</span><br><span class="line">--|-----|--</span><br><span class="line">[ Services ]</span><br></pre></td></tr></table></figure><p>在官網文件中提到 Ingress 可以負責以下工作：</p><ul><li><p>give services externally-reachable urls</p></li><li><p>load balance traffic</p></li><li><p>SSL Termination</p></li><li><p>offer name based virtual hosting</p></li></ul><p>看的出來可以做到的功能實在很多，非常值得好好研究一下。</p><h1 id="在使用-Ingress-之前"><a href="#在使用-Ingress-之前" class="headerlink" title="在使用 Ingress 之前"></a>在使用 Ingress 之前</h1><p>看起來 Ingress 就是處理 inbound traffic 的銀彈，但直接在 YAML 中宣告 Ingress resource 並建立並不會有任何效果，必須搭配 <a href="https://kubernetes.io/docs/concepts/services-networking/ingress/#ingress-controllers" title="Kubernetes Ingress Controller" target="_blank" rel="noopener">Ingress controller</a> 才有辦法讓設定真正的生效。</p><blockquote><p>目前 <a href="https://git.k8s.io/ingress-nginx/README.md" target="_blank" rel="noopener">K8s 官方 GitHub repository</a> 中提供的則是以 nginx 來作為 Ingress controller。</p></blockquote><p>但我找到另外一個也開發的相當不錯的 HTTP reverse proxy 作為 Ingress Controller，名稱為 <a href="https://docs.traefik.io/" title="Træfik" target="_blank" rel="noopener">Træfik</a>，它可以與相當多的平台或軟體進行整合，例如：Docker, Docker Swarm, Marathon, Consul, etcd, Rancher, Amazon …. 等等，當然 Kubernetes 也是其中之一。</p><p>而為什麼要選擇 <a href="https://docs.traefik.io/" title="Træfik" target="_blank" rel="noopener">Træfik</a> 呢? 來看看[官網][<a href="https://docs.traefik.io/" title="Træfik" target="_blank" rel="noopener">traefik</a>]提供的 feature 列表:</p><ul><li><p>Continuously updates its configuration (No restarts!)</p></li><li><p>Supports multiple load balancing algorithms</p></li><li><p>Provides HTTPS to your microservices by leveraging Let’s Encrypt (wildcard certificates support)</p></li><li><p>Circuit breakers, retry</p></li><li><p>High Availability with cluster mode (beta)</p></li><li><p>See the magic through its clean web UI</p></li><li><p>Websocket, HTTP/2, GRPC ready</p></li><li><p>Provides metrics (Rest, Prometheus, Datadog, Statsd, InfluxDB)</p></li><li><p>Keeps access logs (JSON, CLF)</p></li><li><p>Fast</p></li><li><p>Exposes a Rest API</p></li><li><p>Packaged as a single binary file (made with :heart: with go) and available as a tiny official docker image</p></li></ul><p><a href="https://docs.traefik.io/" title="Træfik" target="_blank" rel="noopener">Træfik</a> 功能真的是相當強大阿! 當然要給它試試看….</p><p>因此接下來將會以 <a href="https://docs.traefik.io/" title="Træfik" target="_blank" rel="noopener">Træfik</a> 作為 Kubernetes Ingress Controller 作示範。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get nodes</span><br><span class="line">NAME            STATUS    ROLES          AGE       VERSION</span><br><span class="line">kube-ingress0   Ready     ingress,node   6d        v1.10.4</span><br><span class="line">kube-ingress1   Ready     ingress,node   6d        v1.10.4</span><br><span class="line">kube-master0    Ready     master         6d        v1.10.4</span><br><span class="line">kube-master1    Ready     master         6d        v1.10.4</span><br><span class="line">kube-master2    Ready     master         6d        v1.10.4</span><br><span class="line">kube-worker0    Ready     node           6d        v1.10.4</span><br><span class="line">kube-worker1    Ready     node           6d        v1.10.4</span><br><span class="line">kube-worker2    Ready     node           6d        v1.10.4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將 Ingress Node 加上 lable</span></span><br><span class="line">$ kubectl label node kube-ingress0 k8s-app=traefik-ingress-lb</span><br><span class="line">$ kubectl label node kube-ingress1 k8s-app=traefik-ingress-lb</span><br></pre></td></tr></table></figure><p>若要檢視目前每個 node 所帶的 label 可使用以下指令：</p><blockquote><p>kubectl get nodes –show-labels</p></blockquote><h1 id="佈署-Traefik-Ingress-Controller"><a href="#佈署-Traefik-Ingress-Controller" class="headerlink" title="佈署 Træfik Ingress Controller"></a>佈署 Træfik Ingress Controller</h1><h2 id="設定-RBAC"><a href="#設定-RBAC" class="headerlink" title="設定 RBAC"></a>設定 RBAC</h2><p>首先要讓 Træfik 有相對應的權限，將會進行以下設定：</p><ol><li><p>為 Træfik 建立一個 cluster role(<code>traefik-ingress-controller</code>)，並給定足夠的權限</p></li><li><p>為 Træfik 建立一個 service account(<code>traefik-ingress-controller</code>)，並繫結(透過 cluster role binding <code>traefik-ingress-controller</code>)到上述的 cluster role 以取得權限</p></li></ol><p>準備檔案 <code>traefik-rbac.yaml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">traefik-ingress-controller</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="attr">  - apiGroups:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">""</span></span><br><span class="line"><span class="attr">    resources:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">services</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">endpoints</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">secrets</span></span><br><span class="line"><span class="attr">    verbs:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">get</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">list</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">watch</span></span><br><span class="line"><span class="attr">  - apiGroups:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">extensions</span></span><br><span class="line"><span class="attr">    resources:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">ingresses</span></span><br><span class="line"><span class="attr">    verbs:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">get</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">list</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">watch</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">traefik-ingress-controller</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line"><span class="attr">  apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">  kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">traefik-ingress-controller</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="attr">- kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">traefik-ingress-controller</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br></pre></td></tr></table></figure><blockquote><p>kubectl apply -f traefik-rbac.yaml</p></blockquote><p>或是也可以直接套用 traefik 最新的程式碼：</p><blockquote><p>kubectl apply -f <a href="https://raw.githubusercontent.com/containous/traefik/master/examples/k8s/traefik-rbac.yaml" target="_blank" rel="noopener">https://raw.githubusercontent.com/containous/traefik/master/examples/k8s/traefik-rbac.yaml</a></p></blockquote><h2 id="設定以-DaemonSet-的方式執行"><a href="#設定以-DaemonSet-的方式執行" class="headerlink" title="設定以 DaemonSet 的方式執行"></a>設定以 DaemonSet 的方式執行</h2><p>traefik 可以用 Deployment or DaemonSet 的方式進行佈署，兩者的差異比較可以參考<a href="https://docs.traefik.io/user-guide/kubernetes/#deploy-trfik-using-a-deployment-or-daemonset" target="_blank" rel="noopener">官網說明</a>，以下是使用 DaemonSet 安裝所需要的 YAML 設定(<code>traefik-ds.yaml</code>)：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">traefik-ingress-controller</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">traefik-ingress-controller</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    k8s-app:</span> <span class="string">traefik-ingress-lb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        k8s-app:</span> <span class="string">traefik-ingress-lb</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">traefik-ingress-lb</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      serviceAccountName:</span> <span class="string">traefik-ingress-controller</span></span><br><span class="line"><span class="attr">      terminationGracePeriodSeconds:</span> <span class="number">60</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - image:</span> <span class="string">traefik</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">traefik-ingress-lb</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">          containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">          hostPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">          containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">        securityContext:</span></span><br><span class="line"><span class="attr">          capabilities:</span></span><br><span class="line"><span class="attr">            drop:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">ALL</span></span><br><span class="line"><span class="attr">            add:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">NET_BIND_SERVICE</span></span><br><span class="line"><span class="attr">        args:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="bullet">--api</span></span><br><span class="line"><span class="bullet">        -</span> <span class="bullet">--kubernetes</span></span><br><span class="line"><span class="bullet">        -</span> <span class="bullet">--logLevel=INFO</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">traefik-ingress-service</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    k8s-app:</span> <span class="string">traefik-ingress-lb</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">    - protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">    - protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">admin</span></span><br></pre></td></tr></table></figure><p>套用上述設定：</p><blockquote><p>kubectl apply -f traefik-ds.yaml</p></blockquote><p>或是也可以直接套用 traefik 最新的程式碼：</p><blockquote><p>kubectl apply -f <a href="https://raw.githubusercontent.com/containous/traefik/master/examples/k8s/traefik-ds.yaml" target="_blank" rel="noopener">https://raw.githubusercontent.com/containous/traefik/master/examples/k8s/traefik-ds.yaml</a></p></blockquote><p>到此階段，traefik ingress controller 已經佈署完成，接著就是定義 ingress 並與其繫結。</p><h2 id="佈署-Traefik-Dashboard"><a href="#佈署-Traefik-Dashboard" class="headerlink" title="佈署 Traefik Dashboard"></a>佈署 Traefik Dashboard</h2><p>traefik 有個不錯的優點就是提供了一個還蠻不錯看的 Dashboard，當然也是需要透過設定 ingress 才有辦法連到，因此準備以下檔案(<code>traefik-ui.yaml</code>)：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">traefik-web-ui</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">kubernetes.io/ingress.class:</span> <span class="string">traefik</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">  - host:</span> <span class="string">traefik-ui.k8s.example.com</span></span><br><span class="line"><span class="attr">    http:</span></span><br><span class="line"><span class="attr">      paths:</span></span><br><span class="line"><span class="attr">      - backend:</span></span><br><span class="line"><span class="attr">          serviceName:</span> <span class="string">traefik-web-ui</span></span><br><span class="line"><span class="attr">          servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><blockquote><p>kubectl apply -f traefik-ui.yaml</p></blockquote><p>除此之外，還有 DNS 的部份需要設定；在上面的 ingress host 設定是 <code>traefik-ui.k8s.example.com</code>，由於這個 domain name 是虛擬的，因此我們必須修改 client 端的 DNS 設定(<code>/etc/hosts</code>)，將 worker node 的 IP 指到這個 domain name。</p><p>在我的實驗環境中，worker node 一共有三台，分別是 <strong>10.103.10.[61-63]</strong>，因此在 client 的 <code>/etc/hosts</code> 中加入以下設定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10.103.10.61  traefik-ui.k8s.example.com</span><br><span class="line">10.103.10.62  traefik-ui.k8s.example.com</span><br><span class="line">10.103.10.63  traefik-ui.k8s.example.com</span><br></pre></td></tr></table></figure><p>完成之後就可以透過 <a href="http://traefik-ui.k8s.example.com" target="_blank" rel="noopener">http://traefik-ui.k8s.example.com</a> 連到 Traefik Dashboard 了!</p><h1 id="佈署網站-amp-設定-Ingress"><a href="#佈署網站-amp-設定-Ingress" class="headerlink" title="佈署網站 &amp; 設定 Ingress"></a>佈署網站 &amp; 設定 Ingress</h1><p>在這邊會另外建立一個 <code>ingress-test</code> 作為測試用的 namespace，並設定為 kubectl 的 default namespace：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立新的 namespace 並改為預設值</span></span><br><span class="line">$ kubectl create ns ingress-test</span><br><span class="line">$ kubectl config <span class="built_in">set</span>-context $(kubectl config current-context) --namespace=ingress-test</span><br></pre></td></tr></table></figure><h2 id="設定-DNS"><a href="#設定-DNS" class="headerlink" title="設定 DNS"></a>設定 DNS</h2><p>接下來的範例會需要有相對應的 DNS 設定，首先必須確認兩件事情：</p><ol><li><p>traefik DaemonSet 所存在的機器 IP (一般就是 worker node)</p></li><li><p>可控制的 domain name</p></li></ol><p>在本環境中，worker node 一共有三台，分別是 <strong>10.103.10.[61-63]</strong>，將會用到的 domain name 為：</p><ul><li><p>stilton.k8s.example.com</p></li><li><p>cheddar.k8s.example.com</p></li><li><p>wensleydale.k8s.example.com</p></li></ul><p>由於上述的並非真的由我控制的 domain，因此我們必須修改 client 端的 DNS 設定(<code>/etc/hosts</code>) 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10.103.10.61  stilton.k8s.example.com cheddar.k8s.example.com wensleydale.k8s.example.com</span><br><span class="line">10.103.10.62  stilton.k8s.example.com cheddar.k8s.example.com wensleydale.k8s.example.com</span><br><span class="line">10.103.10.63  stilton.k8s.example.com cheddar.k8s.example.com wensleydale.k8s.example.com</span><br></pre></td></tr></table></figure><p>接著以下會分為 <strong>Name-based Routing</strong> &amp; <strong>Path-bsaed Routing</strong> 進行示範：</p><h2 id="Name-based-Routing"><a href="#Name-based-Routing" class="headerlink" title="Name-based Routing"></a>Name-based Routing</h2><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><p>準備 Deployment 檔案(<code>cheese-deployments.yaml</code>)：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">stilton</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">cheese</span></span><br><span class="line"><span class="attr">    cheese:</span> <span class="string">stilton</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">cheese</span></span><br><span class="line"><span class="attr">      task:</span> <span class="string">stilton</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">cheese</span></span><br><span class="line"><span class="attr">        task:</span> <span class="string">stilton</span></span><br><span class="line"><span class="attr">        version:</span> <span class="string">v0.0.1</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">cheese</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">errm/cheese:stilton</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">cheddar</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">cheese</span></span><br><span class="line"><span class="attr">    cheese:</span> <span class="string">cheddar</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">cheese</span></span><br><span class="line"><span class="attr">      task:</span> <span class="string">cheddar</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">cheese</span></span><br><span class="line"><span class="attr">        task:</span> <span class="string">cheddar</span></span><br><span class="line"><span class="attr">        version:</span> <span class="string">v0.0.1</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">cheese</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">errm/cheese:cheddar</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">wensleydale</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">cheese</span></span><br><span class="line"><span class="attr">    cheese:</span> <span class="string">wensleydale</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">cheese</span></span><br><span class="line"><span class="attr">      task:</span> <span class="string">wensleydale</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">cheese</span></span><br><span class="line"><span class="attr">        task:</span> <span class="string">wensleydale</span></span><br><span class="line"><span class="attr">        version:</span> <span class="string">v0.0.1</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">cheese</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">errm/cheese:wensleydale</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><blockquote><p>kubectl apply -f cheese-deployments.yaml</p></blockquote><p>或是可以直接套用官網提供的 Deployment 範例：</p><blockquote><p>kubectl apply -f <a href="https://raw.githubusercontent.com/containous/traefik/master/examples/k8s/cheese-deployments.yaml" target="_blank" rel="noopener">https://raw.githubusercontent.com/containous/traefik/master/examples/k8s/cheese-deployments.yaml</a></p></blockquote><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>接著準備 Service 檔案(<code>cheese-services.yaml</code>)：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">stilton</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">cheese</span></span><br><span class="line"><span class="attr">    task:</span> <span class="string">stilton</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">cheddar</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">cheese</span></span><br><span class="line"><span class="attr">    task:</span> <span class="string">cheddar</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">wensleydale</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">traefik.backend.circuitbreaker:</span> <span class="string">"NetworkErrorRatio() &gt; 0.5"</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">cheese</span></span><br><span class="line"><span class="attr">    task:</span> <span class="string">wensleydale</span></span><br></pre></td></tr></table></figure><blockquote><p>kubectl apply -f cheese-services.yaml</p></blockquote><p>或是可以直接套用官網提供的 Deployment 範例：</p><blockquote><p>kubectl apply -f <a href="https://raw.githubusercontent.com/containous/traefik/master/examples/k8s/cheese-services.yaml" target="_blank" rel="noopener">https://raw.githubusercontent.com/containous/traefik/master/examples/k8s/cheese-services.yaml</a></p></blockquote><h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><p>最後則是 Ingress 的設定(<code>name-based-routing_cheese-ingress.yaml</code>)：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">cheese</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">kubernetes.io/ingress.class:</span> <span class="string">traefik</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">  - host:</span> <span class="string">stilton.k8s.example.com</span></span><br><span class="line"><span class="attr">    http:</span></span><br><span class="line"><span class="attr">      paths:</span></span><br><span class="line"><span class="attr">      - path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">        backend:</span></span><br><span class="line"><span class="attr">          serviceName:</span> <span class="string">stilton</span></span><br><span class="line"><span class="attr">          servicePort:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">  - host:</span> <span class="string">cheddar.k8s.example.com</span></span><br><span class="line"><span class="attr">    http:</span></span><br><span class="line"><span class="attr">      paths:</span></span><br><span class="line"><span class="attr">      - path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">        backend:</span></span><br><span class="line"><span class="attr">          serviceName:</span> <span class="string">cheddar</span></span><br><span class="line"><span class="attr">          servicePort:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">  - host:</span> <span class="string">wensleydale.k8s.example.com</span></span><br><span class="line"><span class="attr">    http:</span></span><br><span class="line"><span class="attr">      paths:</span></span><br><span class="line"><span class="attr">      - path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">        backend:</span></span><br><span class="line"><span class="attr">          serviceName:</span> <span class="string">wensleydale</span></span><br><span class="line"><span class="attr">          servicePort:</span> <span class="string">http</span></span><br></pre></td></tr></table></figure><blockquote><p>kubectl apply -f name-based-routing_cheese-ingress.yaml</p></blockquote><p>最後就可以透過以下3個連結連到不同的 Ingress -&gt; Service -&gt; Deployment：</p><ul><li><p><a href="http://stilton.k8s.example.com" target="_blank" rel="noopener">http://stilton.k8s.example.com</a></p></li><li><p><a href="http://cheddar.k8s.example.com" target="_blank" rel="noopener">http://cheddar.k8s.example.com</a></p></li><li><p><a href="http://wensleydale.k8s.example.com" target="_blank" rel="noopener">http://wensleydale.k8s.example.com</a></p></li></ul><h2 id="Path-bsaed-Routing"><a href="#Path-bsaed-Routing" class="headerlink" title="Path-bsaed Routing"></a>Path-bsaed Routing</h2><p>這個在 DNS 設定部份就簡單多了，在以下範例中，只要設定一個 DNS record(<code>cheese.k8s.example.com</code>) 即可，因此 DNS 設定(<code>/etc/hosts</code>)必須加入以下資訊：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10.103.10.61  cheese.k8s.example.com</span><br><span class="line">10.103.10.62  cheese.k8s.example.com</span><br><span class="line">10.103.10.63  cheese.k8s.example.com</span><br></pre></td></tr></table></figure><p>而在 <strong>Deployment</strong> &amp; <strong>Service</strong> 的部份跟 Name-based Routing 是相同的，而這裡的 ingress 設定(<code>path-based-routing_cheese-ingress.yaml</code>)則是跟上面不同：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">cheeses</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">kubernetes.io/ingress.class:</span> <span class="string">traefik</span></span><br><span class="line">    <span class="string">traefik.frontend.rule.type:</span> <span class="string">PathPrefixStrip</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">  - host:</span> <span class="string">cheeses.k8s.example.com</span></span><br><span class="line"><span class="attr">    http:</span></span><br><span class="line"><span class="attr">      paths:</span></span><br><span class="line"><span class="attr">      - path:</span> <span class="string">/stilton</span></span><br><span class="line"><span class="attr">        backend:</span></span><br><span class="line"><span class="attr">          serviceName:</span> <span class="string">stilton</span></span><br><span class="line"><span class="attr">          servicePort:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      - path:</span> <span class="string">/cheddar</span></span><br><span class="line"><span class="attr">        backend:</span></span><br><span class="line"><span class="attr">          serviceName:</span> <span class="string">cheddar</span></span><br><span class="line"><span class="attr">          servicePort:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      - path:</span> <span class="string">/wensleydale</span></span><br><span class="line"><span class="attr">        backend:</span></span><br><span class="line"><span class="attr">          serviceName:</span> <span class="string">wensleydale</span></span><br><span class="line"><span class="attr">          servicePort:</span> <span class="string">http</span></span><br></pre></td></tr></table></figure><blockquote><p>kubectl apply -f path-based-routing_cheese-ingress.yaml</p></blockquote><p>最後就可以透過以下3個連結連到不同的 Ingress -&gt; Service -&gt; Deployment：</p><ul><li><p><a href="http://cheeses.k8s.example.com/stilton" target="_blank" rel="noopener">http://cheeses.k8s.example.com/stilton</a></p></li><li><p><a href="http://cheeses.k8s.example.com/cheddar" target="_blank" rel="noopener">http://cheeses.k8s.example.com/cheddar</a></p></li><li><p><a href="http://cheeses.k8s.example.com/wensleydale" target="_blank" rel="noopener">http://cheeses.k8s.example.com/wensleydale</a></p></li></ul><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><p><a href="https://kubernetes.io/docs/concepts/services-networking/ingress" target="_blank" rel="noopener">Ingress - Kubernetes</a></p></li><li><p><a href="https://docs.traefik.io/" target="_blank" rel="noopener">Træfik</a></p></li><li><p><a href="https://ithelp.ithome.com.tw/articles/10196261" target="_blank" rel="noopener">[Day 19] 在 Kubernetes 中實現負載平衡 - Ingress Controller - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天</a></p></li></ul>]]></content>
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Kubernetes] 設定 StorageClass (以 Ceph RBD 為例)</title>
      <link href="/blog/2018/06/27/Kubernetes/k8s-Config-StorageClass-with-Ceph-RBD/"/>
      <url>/blog/2018/06/27/Kubernetes/k8s-Config-StorageClass-with-Ceph-RBD/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>安裝完 k8s cluster 後，接著緊接下來要解決的問題就是 “資料儲存” 的問題。</p><p>由於 container 的生命周期跟 VM 不同，而且在 k8s cluster 上，container 可能會因為某些原因在不同的機器之間遷移，因此”<strong>資料儲存</strong>“這件事情就變得要謹慎考慮。</p><p>此篇文章將會介紹如何使用 Ceph RBD 為 k8s cluster 提供 block device 的 persistent volume。此外由於本文是著重在 k8s 與 Ceph 的整合，因此就不會再 k8s &amp; Ceph 的安裝著墨，而是直接切入整合時的設定。</p><h1 id="環境說明"><a href="#環境說明" class="headerlink" title="環境說明"></a>環境說明</h1><p>Ceph: <code>Luminous</code></p><p>Kubernetes：<code>1.10.4</code></p><h1 id="設定-Ceph-cluster"><a href="#設定-Ceph-cluster" class="headerlink" title="設定 Ceph cluster"></a>設定 Ceph cluster</h1><p>首先要在 Ceph cluster 完成以下幾件事情：</p><ol><li><p>建立一個給 k8s cluster 用的 pool (例如： <code>kube</code>)</p></li><li><p>設定 pool 相關參數 (replica 數量，Quota …. etc)</p></li><li><p>新增使用該 pool 的使用者帳號(例如： <code>kube</code>)，並指定該 pool 的存取權限</p></li></ol><p>接著我們透過以下指令完成上面的工作：(必須以 Ceph 管理者的權限進行設定)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立名稱為 "kube" 的 pool</span></span><br><span class="line">$ ceph osd pool create kube 128</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定停用 replication 功能</span></span><br><span class="line">$ ceph osd pool <span class="built_in">set</span> kube size 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定 pool 最大容量為 10GB</span></span><br><span class="line">$ ceph osd pool <span class="built_in">set</span>-quota kube max_bytes $((10 * 1024 * 1024 * 1024))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立使用該 pool 的使用者帳號</span></span><br><span class="line">$ ceph auth get-or-create client.kube mon <span class="string">'allow r'</span> osd <span class="string">'allow class-read object_prefix rbd_children, allow rwx pool=kube'</span></span><br><span class="line">[client.kube]</span><br><span class="line">key = [YOUR_KEY]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取得 Ceph admin keyring</span></span><br><span class="line">$ ceph auth get-key client.admin | base64</span><br><span class="line">QVFEcytKaGF6UVlmRmhBQWJOZTNaZjYvaFVFdkhpRVVQejJOWFE9PQ==</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取得 Ceph user keyring</span></span><br><span class="line">$ ceph auth get-key client.kube | base64</span><br><span class="line">QVFDTmp6RmJONy9wRkJBQUZxN3QzQnVLaTJpb2YwR0dDZEJ2dEE9PQ==</span><br></pre></td></tr></table></figure><p>為了測試接下來要示範的 persistent volume，再多建立一個名稱為 <code>ceph-image</code> 的 RBD image：</p><blockquote><p>rbd create kube/ceph-image –size 4096 –image-format 2 –image-feature layering</p></blockquote><p><strong>Ceph 預設的 Crush Map 設定會讓 k8s 與 Ceph 的整合發生問題，因此要先調整 Crush Map，詳情可以參考下方的<a href="#障礙排除">障礙排除</a>。</strong></p><h1 id="設定-Kubernetes"><a href="#設定-Kubernetes" class="headerlink" title="設定 Kubernetes"></a>設定 Kubernetes</h1><h2 id="Prerequisite"><a href="#Prerequisite" class="headerlink" title="Prerequisite"></a>Prerequisite</h2><p>由於在 mount Ceph RBD image 之前，kubelet 會檢查 image 的狀態，因此在 k8s worker node 都需要額外進行以下調整：</p><ol><li><p>安裝 <code>ceph-common</code> 套件</p></li><li><p>將 ceph admin keyring 放到 <code>/etc/ceph/ceph.keyring</code></p></li></ol><h2 id="獨立的-namespace"><a href="#獨立的-namespace" class="headerlink" title="獨立的 namespace"></a>獨立的 namespace</h2><p>為了讓系統環境維持乾淨，接著建立一個獨立的 namespace(名稱為 <code>ceph-rbd-pv-lab</code>) 來進行以下測試：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立 namespace</span></span><br><span class="line">$ kubectl create namespace ceph-rbd-pv-lab</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定預設的 namespace</span></span><br><span class="line">$ kubectl config <span class="built_in">set</span>-context $(kubectl config current-context) --namespace==ceph-rbd-pv-lab</span><br></pre></td></tr></table></figure><h1 id="使用-Ceph-RBD-作為-Persistent-Volume"><a href="#使用-Ceph-RBD-作為-Persistent-Volume" class="headerlink" title="使用 Ceph RBD 作為 Persistent Volume"></a>使用 Ceph RBD 作為 Persistent Volume</h1><p>準備檔案 <code>ceph-pv.yaml</code>，內容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定義 secret，儲存 Ceph admin keyring</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">ceph-secret-admin</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  key:</span> <span class="string">QVFEcytKaGF6UVlmRmhBQWJOZTNaZjYvaFVFdkhpRVVQejJOWFE9PQ==</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定義 PV，指定到上面建立的 ceph rbd image</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">ceph-pv</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  capacity:</span></span><br><span class="line"><span class="attr">    storage:</span> <span class="number">2</span><span class="string">Gi</span></span><br><span class="line"><span class="attr">  accessModes:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">ReadWriteOnce</span></span><br><span class="line"><span class="attr">  rbd:</span></span><br><span class="line"><span class="attr">    monitors:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">10.103</span><span class="number">.2</span><span class="number">.24</span><span class="string">:6789</span></span><br><span class="line"><span class="attr">    pool:</span> <span class="string">kube</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">ceph-image</span></span><br><span class="line"><span class="attr">    user:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">    secretRef:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">ceph-secret-admin</span></span><br><span class="line"><span class="attr">    fsType:</span> <span class="string">ext4</span></span><br><span class="line"><span class="attr">    readOnly:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  persistentVolumeReclaimPolicy:</span> <span class="string">Recycle</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定義 PVC，與上面的 PV 進行繫結</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">ceph-claim</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  accessModes:</span>     </span><br><span class="line"><span class="bullet">    -</span> <span class="string">ReadWriteOnce</span></span><br><span class="line"><span class="attr">  resources:</span></span><br><span class="line"><span class="attr">    requests:</span></span><br><span class="line"><span class="attr">      storage:</span> <span class="number">2</span><span class="string">Gi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定義使用 PVC 的 pod</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">ceph-pod1</span>           </span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">ceph-busybox</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">busybox</span>          </span><br><span class="line"><span class="attr">    command:</span> <span class="string">["sleep",</span> <span class="string">"60000"</span><span class="string">]</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">ceph-vol1</span>       </span><br><span class="line"><span class="attr">      mountPath:</span> <span class="string">/usr/share/busybox</span> </span><br><span class="line"><span class="attr">      readOnly:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">ceph-vol1</span>         </span><br><span class="line"><span class="attr">    persistentVolumeClaim:</span></span><br><span class="line"><span class="attr">      claimName:</span> <span class="string">ceph-claim</span></span><br></pre></td></tr></table></figure><p>套用以上設定：</p><blockquote><p>kubectl create -f ceph-pv.yaml</p></blockquote><p>過一陣子檢查 pod 狀態：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pod 已經處於正常運作的狀態</span></span><br><span class="line">$ kubectl get pod</span><br><span class="line">NAME        READY     STATUS    RESTARTS   AGE</span><br><span class="line">ceph-pod1   1/1       Running   0          2m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 成功掛載在 /usr/share/busybox 目錄下</span></span><br><span class="line">$ kubectl <span class="built_in">exec</span> -it ceph-pod1 -- df -h | grep <span class="string">'/usr/share/busybox'</span></span><br><span class="line">/dev/rbd0                 3.8G      8.0M      3.6G   0% /usr/share/busybox</span><br></pre></td></tr></table></figure><h1 id="使用-StorageClass-動態生成-Persistent-Volume"><a href="#使用-StorageClass-動態生成-Persistent-Volume" class="headerlink" title="使用 StorageClass 動態生成 Persistent Volume"></a>使用 StorageClass 動態生成 Persistent Volume</h1><h2 id="What’s-StorageClass"><a href="#What’s-StorageClass" class="headerlink" title="What’s StorageClass?"></a>What’s StorageClass?</h2><p>不曉得有沒有人想過以下問題：</p><ul><li><p>如果我常常需要產生 PV，又要刪除它呢 ?</p></li><li><p>可以不要一直去煩 storage manager 嗎? 每次產生新的 PV 都需要請他建立對應的 RBD image</p></li><li><p>產生 PV 的動作可以自動完成嗎 ?</p></li><li><p>每次都要手動建立 RBD image 哪有 cloud native ?</p></li></ul><p>而 <a href="https://kubernetes.io/docs/concepts/storage/storage-classes" title="Kubernetes Storage Class" target="_blank" rel="noopener">Kubernetes StorageClass</a> 就是以上問題的解答，其流程如下圖：</p><p><img src="/blog/images/kubernetes/dynamic-volume-provision.jpg" alt="Kubernetes Persistent Volume Provisioning"></p><ol><li><p>設定 persistent volume provisioner (Ceph RBD 已經被 k8s 支援)</p></li><li><p>k8s ckuster 管理者建立 Storage Class，並指定要使用的 PV provisioner(這裡使用 <code>kubernetes.io/rbd</code>)</p></li><li><p>使用者建立 PVC，指定要使用的 <a href="https://kubernetes.io/docs/concepts/storage/storage-classes" title="Kubernetes Storage Class" target="_blank" rel="noopener">StorageClass</a></p></li><li><p><a href="https://kubernetes.io/docs/concepts/storage/storage-classes" title="Kubernetes Storage Class" target="_blank" rel="noopener">StorageClass</a> 使用 provisioner 在實際的 storage 上產生 volume，並建立 PV 與其繫結</p></li><li><p>將 PV 與 使用者 PVC 進行繫結</p></li><li><p>使用者建立 pod，並使用 PVC 取得外部的儲存空間</p></li></ol><blockquote><p><strong>以上的重點在於，管理者再也不用辛苦的手動建立儲存空間，並設定 PV 與其繫結了，這個部份都交給 StorageClass 自動處理</strong></p></blockquote><h2 id="在-Kubernetes-上設定-StorageClass"><a href="#在-Kubernetes-上設定-StorageClass" class="headerlink" title="在 Kubernetes 上設定 StorageClass"></a>在 Kubernetes 上設定 StorageClass</h2><p>準備以下設定檔，名稱為 <code>ceph-storageclass.yml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># admin secret 要定義在 cluster level (對應 PV 的生成)</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">ceph-secret-admin</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  key:</span> <span class="string">QVFEcytKaGF6UVlmRmhBQWJOZTNaZjYvaFVFdkhpRVVQejJOWFE9PQ==</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">kubernetes.io/rbd</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># user secret 要定義在 namespace level (對應 PVC 的生成 &amp; 繫結)</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">ceph-secret-user</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  key:</span> <span class="string">QVFDTmp6RmJONy9wRkJBQUZxN3QzQnVLaTJpb2YwR0dDZEJ2dEE9PQ==</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">kubernetes.io/rbd</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># user secret 要定義在 namespace level (對應 PVC 的生成 &amp; 繫結)</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StorageClass</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">ceph-dynamic</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">     <span class="string">storageclass.beta.kubernetes.io/is-default-class:</span> <span class="string">"true"</span></span><br><span class="line"><span class="attr">provisioner:</span> <span class="string">kubernetes.io/rbd</span></span><br><span class="line"><span class="attr">parameters:</span></span><br><span class="line"><span class="attr">  monitors:</span> <span class="number">10.103</span><span class="number">.2</span><span class="number">.24</span><span class="string">:6789</span></span><br><span class="line"><span class="attr">  adminId:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">  adminSecretName:</span> <span class="string">ceph-secret-admin</span></span><br><span class="line"><span class="attr">  adminSecretNamespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">  pool:</span> <span class="string">kube</span></span><br><span class="line"><span class="attr">  userId:</span> <span class="string">kube</span></span><br><span class="line"><span class="attr">  userSecretName:</span> <span class="string">ceph-secret-user</span></span><br><span class="line"><span class="attr">  fsType:</span> <span class="string">ext4</span></span><br><span class="line"><span class="attr">  imageFormat:</span> <span class="string">"2"</span></span><br><span class="line"><span class="attr">  imageFeatures:</span> <span class="string">"layering"</span></span><br></pre></td></tr></table></figure><p>套用上述設定檔即可完成：</p><blockquote><p>kubectl create -f ceph-storageclass.yml</p></blockquote><p>從以上可以看出，其實 <a href="https://kubernetes.io/docs/concepts/storage/storage-classes" title="Kubernetes Storage Class" target="_blank" rel="noopener">StorageClass</a> 的內容就是在實際的 storage 進行操作所必要的資訊(包含 IP，帳號、密碼…..等等)，敏感資訊的部份就透過 <strong>secret</strong> 放進去。</p><p>此外，在建立 <a href="https://kubernetes.io/docs/concepts/storage/storage-classes" title="Kubernetes Storage Class" target="_blank" rel="noopener">StorageClass</a> 的時候，就可以額外帶上建立 RBD 時的部份參數，以上面的設定為例，包含了：</p><ul><li><p>fsType: ext4</p></li><li><p>imageFormat: “2”</p></li><li><p>imageFeatures: “layering”</p></li></ul><p>如此一來當 RBD image 被建立時，就會是以在 <a href="https://kubernetes.io/docs/concepts/storage/storage-classes" title="Kubernetes Storage Class" target="_blank" rel="noopener">StorageClass</a> 中所定義的規格去產生。</p><h2 id="驗證動態-Persistent-Volume-的生成"><a href="#驗證動態-Persistent-Volume-的生成" class="headerlink" title="驗證動態 Persistent Volume 的生成"></a>驗證動態 Persistent Volume 的生成</h2><p>接著來驗證 persistent volume 的自動生成，透過以下的設定(名稱為 <code>storageclass-test.yml</code>)來完成：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">ceph-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  accessModes:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">ReadWriteOnce</span></span><br><span class="line"><span class="attr">  storageClassName:</span> <span class="string">ceph-dynamic</span></span><br><span class="line"><span class="attr">  resources:</span></span><br><span class="line"><span class="attr">    requests:</span></span><br><span class="line"><span class="attr">      storage:</span> <span class="number">2</span><span class="string">Gi</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">ceph-pod1</span>           </span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">ceph-busybox</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">busybox</span>          </span><br><span class="line"><span class="attr">    command:</span> <span class="string">["sleep",</span> <span class="string">"60000"</span><span class="string">]</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">ceph-vol1</span>       </span><br><span class="line"><span class="attr">      mountPath:</span> <span class="string">/usr/share/busybox</span> </span><br><span class="line"><span class="attr">      readOnly:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">ceph-vol1</span>         </span><br><span class="line"><span class="attr">    persistentVolumeClaim:</span></span><br><span class="line"><span class="attr">      claimName:</span> <span class="string">ceph-pvc</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 套用上面的設定</span></span><br><span class="line">$ kubectl create -f storageclass-test.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視 PVC 設定</span></span><br><span class="line">$ kubectl get pvc</span><br><span class="line">NAME       STATUS    VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">ceph-pvc   Bound     pvc-426e7cc8-79b1-11e8-81d0-56277529c641   2Gi        RWO            ceph-dynamic   6s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 確認 pod 已經正常的執行中</span></span><br><span class="line">$ kubectl get pods</span><br><span class="line">NAME        READY     STATUS    RESTARTS   AGE</span><br><span class="line">ceph-pod1   1/1       Running   0          20m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視與上面的 PVC 繫結的 PV 內容</span></span><br><span class="line">$ kubectl describe pv/pvc-426e7cc8-79b1-11e8-81d0-56277529c641</span><br><span class="line">Name:            pvc-426e7cc8-79b1-11e8-81d0-56277529c641</span><br><span class="line">....(略)</span><br><span class="line">StorageClass:    ceph-dynamic</span><br><span class="line">Status:          Bound</span><br><span class="line">Claim:           ceph-rbd-pv-lab/ceph-pvc</span><br><span class="line">....(略)</span><br><span class="line">Source:</span><br><span class="line">    Type:          RBD (a Rados Block Device mount on the host that shares a pod<span class="string">'s lifetime)</span></span><br><span class="line"><span class="string">    CephMonitors:  [10.103.2.24:6789]</span></span><br><span class="line"><span class="string">    RBDImage:      kubernetes-dynamic-pvc-4273f5b9-79b1-11e8-9115-3a01c1a41f09</span></span><br><span class="line"><span class="string">    FSType:        ext4</span></span><br><span class="line"><span class="string">    RBDPool:       kube</span></span><br><span class="line"><span class="string">    RadosUser:     kube</span></span><br><span class="line"><span class="string">    Keyring:       /etc/ceph/keyring</span></span><br><span class="line"><span class="string">    SecretRef:     &amp;&#123;ceph-secret-user &#125;</span></span><br><span class="line"><span class="string">    ReadOnly:      false</span></span><br><span class="line"><span class="string">Events:            &lt;none&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到有一個 RBD image <code>kubernetes-dynamic-pvc-4273f5b9-79b1-11e8-9115-3a01c1a41f09</code> 被產生出來。</p><p>接著回到 Ceph cluster 上查詢一下是不是有相對應的 object 被產生出來：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 的確有個 "kubernetes-dynamic-pvc" 開頭的 object 被產生出來了!</span></span><br><span class="line">$ rbd -p kube ls</span><br><span class="line">ceph-image</span><br><span class="line">kubernetes-dynamic-pvc-4273f5b9-79b1-11e8-9115-3a01c1a41f09</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視 RBD image 的細節</span></span><br><span class="line">$ rbd info kube/kubernetes-dynamic-pvc-4273f5b9-79b1-11e8-9115-3a01c1a41f09</span><br><span class="line">rbd image <span class="string">'kubernetes-dynamic-pvc-4273f5b9-79b1-11e8-9115-3a01c1a41f09'</span>:</span><br><span class="line">size 2048 MB <span class="keyword">in</span> 512 objects</span><br><span class="line">order 22 (4096 kB objects)</span><br><span class="line">block_name_prefix: rbd_data.bdce80238e1f29</span><br><span class="line">format: 2</span><br><span class="line">features: layering</span><br><span class="line">flags: </span><br><span class="line">create_timestamp: Wed Jun 27 10:24:46 2018</span><br></pre></td></tr></table></figure><p>從上面 RBD image 的內容可以看出，<a href="https://kubernetes.io/docs/concepts/storage/storage-classes" title="Kubernetes Storage Class" target="_blank" rel="noopener">StorageClass</a> 的確是有幫我們根據上面的規格產生出一個 RBD image 與 PV，並相互繫結後，最後再與 PVC 繫結。</p><h1 id="障礙排除"><a href="#障礙排除" class="headerlink" title="障礙排除"></a>障礙排除</h1><h2 id="feature-set-mismatch-1"><a href="#feature-set-mismatch-1" class="headerlink" title="feature set mismatch (1)"></a>feature set mismatch (1)</h2><p>在 pod event 中看到以下的訊息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MountVolume.WaitForAttach failed for volume &quot;ceph-pv&quot; : rbd: map failed exit status 110, rbd output: 2018-06-26 05:44:18.264219 7f50a90e4100 -1 did not load config file, using default settings.</span><br><span class="line"></span><br><span class="line">rbd: sysfs write failed</span><br><span class="line"></span><br><span class="line">In some cases useful info is found in syslog - try &quot;dmesg | tail&quot; or so.</span><br><span class="line">rbd: map failed: (110) Connection timed out</span><br></pre></td></tr></table></figure><p>於是到 worker node 上執行 <code>dmesg</code>，看到了很多類似以下的訊息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">........ (略)</span><br><span class="line">libceph: mon0 10.103.2.24:6789 feature set mismatch, my 106b84a842a42 &lt; server&apos;s 40106b84a842a42, missing 400000000000000</span><br><span class="line">libceph: mon0 10.103.2.24:6789 missing required protocol features</span><br><span class="line">........ (略)</span><br></pre></td></tr></table></figure><h3 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h3><p>這個問題只要修改 Ceph 的 crush map 即可，修改的方式到 Ceph 的 admin node 上執行以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ceph osd crush tunables legacy</span><br><span class="line"></span><br><span class="line">$ ceph osd crush reweight-all</span><br></pre></td></tr></table></figure><blockquote><p>其實也可以將 kernel 升級到 4.5 以上解決此問題</p></blockquote><h2 id="feature-set-mismatch-2"><a href="#feature-set-mismatch-2" class="headerlink" title="feature set mismatch (2)"></a>feature set mismatch (2)</h2><p>這個問題同樣是 <strong>feature set mismatch</strong>，會出現以下訊息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rbd: sysfs write failed</span><br><span class="line">RBD image feature set mismatch. You can disable features unsupported by the kernel with &quot;rbd feature disable&quot;.</span><br></pre></td></tr></table></figure><p>這個問題需要在建立 RBD image 時就要設定好特定的 feature，因此回到 Ceph admin node 上，先以正常的方式建立 RBD image</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以正常的方式建立 rbd image</span></span><br><span class="line">$ rbd create kube/ceph-image --size 1024</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示 image feature</span></span><br><span class="line">$ rbd info kube/ceph-image</span><br><span class="line">rbd image <span class="string">'ceph-image'</span>:</span><br><span class="line">size 1024 MB <span class="keyword">in</span> 256 objects</span><br><span class="line">order 22 (4096 kB objects)</span><br><span class="line">block_name_prefix: rbd_data.ba3aa02ae8944a</span><br><span class="line">format: 2</span><br><span class="line">features: layering, exclusive-lock, object-map, fast-diff, deep-flatten</span><br><span class="line">flags: </span><br><span class="line">create_timestamp: Tue Jun 26 14:08:35 2018</span><br></pre></td></tr></table></figure><p>其中 <code>exclusive-lock</code>, <code>object-map</code>, <code>fast-diff</code>, <code>deep-flatten</code> 這些 feature 都要拿掉才行….</p><p>因此我們改成以下指令建立 RBD image：</p><blockquote><p>rbd create kube/ceph-image –size 1024 –image-format 2 –image-feature layering</p></blockquote><p>上面的問題就解決了!</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><p><a href="kubernetes持久化存儲Ceph RBD - 掃文資訊">https://hk.saowen.com/a/edc90fdb04b4cc267bcbcbae056e2a8b0e9d73ac05c81d05c1f72bf295112a13</a></p></li><li><p><a href="https://tw.saowen.com/a/aa7346a600499cbde6551ef13c685b37b4148c6d5b3d03dcff6b48d431c7a10a" target="_blank" rel="noopener">Kubernetes儲存之Persistent Volumes簡介 - 掃文資訊</a></p></li><li><p><a href="https://kubernetes.io/docs/concepts/storage/storage-classes/#ceph-rbd" target="_blank" rel="noopener">Storage Classes - Kubernetes</a></p></li><li><p><a href="http://int32bit.me/2016/05/19/Ceph-Pool%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">Ceph Pool操作总结 - int32bit的博客 | int32bit Blog</a></p></li><li><p><a href="http://docs.ceph.com/docs/mimic/rados/operations/user-management/" target="_blank" rel="noopener">User Management — Ceph Documentation</a></p></li><li><p><a href="http://docs.ceph.com/docs/argonaut/man/8/rados/" target="_blank" rel="noopener">rados – rados object storage utility — Ceph documentation</a></p></li><li><p><a href="https://bugs.launchpad.net/charm-ceph-mon/+bug/1716735" target="_blank" rel="noopener">Bug #1716735 “ceph with luminous can’t be used with KRBD with Xe…” : Bugs : OpenStack ceph-mon charm</a></p></li><li><p><a href="http://cephnotes.ksperis.com/blog/2014/01/21/feature-set-mismatch-error-on-ceph-kernel-client/" target="_blank" rel="noopener">Feature Set Mismatch Error on Ceph Kernel Client - CephNotes</a></p></li><li><p><a href="https://kairen.github.io/2018/02/11/ceph/luminous-crush-issue/" target="_blank" rel="noopener">Ceph Luminous CRUSH map 400000000000000 問題 | KaiRen’s Blog</a></p></li></ul>]]></content>
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> Ceph </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>佈署 &amp; 存取 Kubernetes Dashboard</title>
      <link href="/blog/2018/06/20/Kubernetes/k8s-Deploy-and-Access-Dashboard/"/>
      <url>/blog/2018/06/20/Kubernetes/k8s-Deploy-and-Access-Dashboard/</url>
      <content type="html"><![CDATA[<p>剛安裝完 Kubernetes，第一個會想到的大概就是 “<strong>入口網站在哪裡</strong>“?</p><p>k8s 無疑是個非常強大的 container orchestration platform，但它預設並沒有附上一個精美的 UI(因為不是每個人都需要 UI，畢竟多少還是會消耗掉一些資源)，設計者提供給使用者 &amp; 開發者完全自由的使用方式。</p><p><strong>有需要就自己設計 &amp; 安裝吧!</strong></p><h1 id="安裝-Dashboard"><a href="#安裝-Dashboard" class="headerlink" title="安裝 Dashboard"></a>安裝 Dashboard</h1><p>自己設計 dashboard 當然是無法，但找個現成的就挺簡單了。</p><p>若是使用 [Kubespray][Kubespray] 安裝的 k8s cluster，dashboard 是預設會安裝好的；若要確認 dashboard 是否會被安裝，可以在 <code>group_vars/k8s-cluster.yml</code> 這個檔案中，加入以下設定：</p><blockquote><p>dashboard_enabled: true</p></blockquote><p>當 k8s cluster 安裝好後，dashboard 也會被一併安裝完成。</p><p>若是沒有呢? 那其實也很簡單，進入 master node 中，透過 [kubectl][kubectl] 執行以下指令安裝：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 安裝最新版的 k8s dasdboard (namespace = kube-system)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">root@kube-master0:~<span class="comment"># kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/master/src/deploy/recommended/kubernetes-dashboard.yaml</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 檢查 dashboard 是否安裝完成</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">root@kube-master0:~<span class="comment"># kubectl get deployment -n kube-system | grep dashboard</span></span><br><span class="line">kubernetes-dashboard   1         1         1            1           5d</span><br></pre></td></tr></table></figure><p>當系統出現 <code>kubernetes-dashboard</code> 這個 deployment resource 時，就表示安裝完成了。</p><h1 id="存取-Dashboard"><a href="#存取-Dashboard" class="headerlink" title="存取 Dashboard"></a>存取 Dashboard</h1><p>由於 [kubectl][kubectl] 並不在本地端，因此使用 <code>kubectl proxy</code> 也沒太大意義，因此這邊直接就直接使用 master node 上的入口進入，使用以下的連結:</p><blockquote><p><a href="https://first_master:6443/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/#!/login" target="_blank" rel="noopener">https://first_master:6443/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/#!/login</a></p></blockquote><p>進入後會出現以下畫面：</p><p><img src="/blog/images//kubernetes/dashboard-login-page.png" alt="Kubernetes Dashboard Login Page"></p><p>登入方式有兩種，分別是：</p><ul><li><p>Kubeconfig</p></li><li><p>Token</p></li></ul><p>以下介紹如何使用 Token 來登入 Dashboard。</p><h1 id="建立可登入-Dashboard-的使用者"><a href="#建立可登入-Dashboard-的使用者" class="headerlink" title="建立可登入 Dashboard 的使用者"></a>建立可登入 Dashboard 的使用者</h1><p>剛安裝好的 k8s cluster，上面已經存在有很多 Service Account，但這些都是 k8s cluster 中的各種服務，<strong>並非真實的使用者</strong>。</p><p>但由於目前 k8s cluster 中並沒有與任何的帳號系統(OpenLDAP / Windows AD / OpenID …. etc) 進行連結，因此以下還是會以建立 Service Account 的方式來模擬建立一個新的使用者進行示範:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 建立一個名稱為 "admin-user" 的 Service Account，用來模擬管理者</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">root@kube-master0:~<span class="comment"># cat &lt;&lt;EOF | kubectl create -f -</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kube-system</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 為了取得最大權限，預計會將 "admin-user" 與 role "cluster-admin" 進行繫結</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">root@kube-master0:~<span class="comment"># kubectl describe clusterrole/cluster-admin</span></span><br><span class="line">Name:         cluster-admin</span><br><span class="line">Labels:       kubernetes.io/bootstrapping=rbac-defaults</span><br><span class="line">Annotations:  rbac.authorization.kubernetes.io/autoupdate=<span class="literal">true</span></span><br><span class="line">PolicyRule:</span><br><span class="line">  Resources  Non-Resource URLs  Resource Names  Verbs</span><br><span class="line">  ---------  -----------------  --------------  -----</span><br><span class="line">  *.*        []                 []              [*]</span><br><span class="line">             [*]                []              [*]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 將 "admin-user" 與 role "cluster-admin" 進行繫結，建立名稱為 "admin-user" 的 ClusterRoleBinding</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">root@kube-master0:~<span class="comment"># cat &lt;&lt;EOF | kubectl create -f -</span></span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1beta1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kube-system</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 檢視 ClusterRoleBinding "admin-user" 的內容</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">root@kube-master0:~<span class="comment"># kubectl describe ClusterRoleBinding/admin-user</span></span><br><span class="line">Name:         admin-user</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Role:</span><br><span class="line">  Kind:  ClusterRole</span><br><span class="line">  Name:  cluster-admin</span><br><span class="line">Subjects:</span><br><span class="line">  Kind            Name        Namespace</span><br><span class="line">  ----            ----        ---------</span><br><span class="line">  ServiceAccount  admin-user  kube-system</span><br></pre></td></tr></table></figure><p>當 Service Account 被建立完成時，Kubernetes Token Controller 就會自動的為其產生一個 <strong>secret</strong> resource(名稱為 <code>[SERVICE_ACCOUNT_NAME]-token-[RANDOM_STRING]</code>)，並使用裡面的 token 作為與 API server 認證用，可以用以下指令察看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 檢視建立 service account 時產生的 secret</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">root@kube-master0:~<span class="comment"># kubectl get secret -n kube-system | grep admin-user</span></span><br><span class="line">admin-user-token-572j8                           kubernetes.io/service-account-token   3         11m</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 檢視 secret 細節，並取得 token 內容</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">root@kube-master0:~<span class="comment"># kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-user | awk '&#123;print $1&#125;')</span></span><br><span class="line">Name:         admin-user-token-572j8</span><br><span class="line">Namespace:    kube-system</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  kubernetes.io/service-account.name=admin-user</span><br><span class="line">              kubernetes.io/service-account.uid=ad79cce8-7453-11e8-b6b3-065296fdbf18</span><br><span class="line"></span><br><span class="line">Type:  kubernetes.io/service-account-token</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">ca.crt:     1090 bytes</span><br><span class="line">namespace:  11 bytes</span><br><span class="line">token:      [TOKEN_CONTENT]</span><br></pre></td></tr></table></figure><h1 id="登入-Dashboard"><a href="#登入-Dashboard" class="headerlink" title="登入 Dashboard"></a>登入 Dashboard</h1><p>透過上面的 secret 取得 token 後，就可以選擇 login page 上的 <code>Token</code> 選項登入，進入後可以看到以下畫面：</p><p><img src="/blog/images/kubernetes/dashboard-overview-page.png" alt="Kubernetes Dashboard Overview Page"></p><p>接著就可以以 Cluster Admin 的身份進行操作了。</p><h1 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h1><p>由於 k8s 內部是不儲存使用者帳號的，它設計可以外接不同的帳號認證系統。因此若是要真的執行嚴格的權限管理，並不是像上面的建立一個擁有 cluster admin 權限的 Service Account(因為 Service Account 顧名思義是給 service 用的)，而是要與外部的認證系統串接(例如：OpenID, LDAP … etc)。</p><p>因此之後將會找時間補上與外部認證系統串接這個部份，將使用者帳號獨立在 k8s cluster 外部。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><p><a href="https://github.com/kubernetes/dashboard" target="_blank" rel="noopener">kubernetes/dashboard: General-purpose web UI for Kubernetes clusters</a></p></li><li><p><a href="https://github.com/kubernetes/dashboard/wiki/Creating-sample-user" target="_blank" rel="noopener">Creating sample user · kubernetes/dashboard Wiki</a></p></li></ul>]]></content>
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>了解 Kubernetes 中的授權機制</title>
      <link href="/blog/2018/06/19/Kubernetes/k8s-API-Authorization/"/>
      <url>/blog/2018/06/19/Kubernetes/k8s-API-Authorization/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在進行授權(Authorization) 之前，一定要先完成認證(Authentication) 的過程，而認證的說明可以參考<a href="https://godleon.github.io/blog/2018/06/19/Kubernetes/k8s-API-Authentication/">上一篇文章</a>。</p><p>k8s 對於 REST API request 的屬性要求是通用的，因此可以與企業中 or 公有雲平台中現存的管理控制系統進行整合。</p><p>而在 k8s 中，負責對 API request 進行授權的是 API server，藉由檢查所有的 <strong>request attribute</strong> 並查詢所有的 policy 來決定是否允許或拒絕 API request 的存取。</p><blockquote><p>預設情況下所有權限都是預設關閉的</p></blockquote><p>k8s 支援同時多個授權機制，並且為循序式的進行檢查，若有任何一個授權機制通過檢查，就會馬上允許存取，若是沒有通過任何的授權機制檢查，此 API request 就會被拒絕存取；而被拒絕存取的 API request 都會收到 HTTP 403 error。</p><h1 id="名詞釋疑"><a href="#名詞釋疑" class="headerlink" title="名詞釋疑"></a>名詞釋疑</h1><h2 id="NameSpace"><a href="#NameSpace" class="headerlink" title="NameSpace"></a>NameSpace</h2><p>用來進行資源的虛擬隔離之用，在 k8s 剛建立好的初期會有預設的 <code>default</code> &amp; <code>kube-system</code> 兩個 namespace</p><h2 id="User-Account-amp-Service-Account"><a href="#User-Account-amp-Service-Account" class="headerlink" title="User Account &amp; Service Account"></a>User Account &amp; Service Account</h2><p>User Account &amp; Service Account 是用來區別作用的範圍，但會有以下的差別：</p><ol><li><p>User Account 是用來辨識使用者，而 Service Account 則是用來辨識 k8s 中的各種服務</p></li><li><p>User Account 對應人的身份，因此是跨 namespace；而 Service Account 對應的是 service 的身份，因此是與 namespace 有相關</p></li></ol><h1 id="Request-Attributes"><a href="#Request-Attributes" class="headerlink" title="Request Attributes"></a>Request Attributes</h1><p>上面有提到，API server 會檢查 <strong>API request attribute</strong> 來決定是否進行授權存取，在 k8s 有以下 API request attributes：</p><ul><li><p>user, group, extra(額外的 key/value 資訊)</p></li><li><p>API、Request Path(/api, /healthz), API request verb(get, list, create, update, patch, watch … etc)</p></li><li><p>HTTP request verb(get, post, put, delete)</p></li><li><p>Resource, Subresource (存取 resource 時需要的資訊)</p></li><li><p>Namespace</p></li><li><p><a href="https://kubernetes.io/docs/concepts/overview/kubernetes-api/#api-groups" target="_blank" rel="noopener">API group</a> (存取 resource 時需要的資訊)</p></li></ul><h1 id="Authorization-Modules"><a href="#Authorization-Modules" class="headerlink" title="Authorization Modules"></a>Authorization Modules</h1><p>目前 k8s 支援以下幾種 Authorization Modules：</p><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a><a href="https://kubernetes.io/docs/reference/access-authn-authz/node/" target="_blank" rel="noopener">Node</a></h2><p>此模組是為了授權在每一個 node 上的 kubelet 所發出的 API request 所設計出來的，讓 kubelet 的 API request 可進行特定的權限控制；例如對於以下的 resource 的讀取的權限：</p><ul><li><p>services</p></li><li><p>endpoints</p></li><li><p>nodes</p></li><li><p>pods</p></li><li><p>secrets / configmaps / presistent volume (claim)</p></li></ul><p>另外透過 NodeRestriction 的 plugin，可以針對以下 resource 進行寫入：</p><ul><li><p>node (status)</p></li><li><p>pod (status)</p></li><li><p>event</p></li></ul><blockquote><p>未來可能還會繼續透過 Node Authorization 來對於 kubelet 進行更細膩的權限控管</p></blockquote><h2 id="ABAC-Attribute-based-access-control"><a href="#ABAC-Attribute-based-access-control" class="headerlink" title="ABAC (Attribute-based access control)"></a><a href="https://kubernetes.io/docs/reference/access-authn-authz/abac/" target="_blank" rel="noopener">ABAC (Attribute-based access control)</a></h2><p>此種方式就是在 master node 上保留一份 policy 文件，指定不同的使用者對於 resource 的存取權限，不彈性也不容易擴充，修改了 policy 文件之後還需要重新啟動 master node。</p><h2 id="RBAC-Role-based-access-control"><a href="#RBAC-Role-based-access-control" class="headerlink" title="RBAC (Role-based access control)"></a><a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/" target="_blank" rel="noopener">RBAC (Role-based access control)</a></h2><p>RBAC 是目前 k8s 預設會啟動的 authorization module。</p><p>在 RBAC API 中定義了 resource target，用來描述使用者以及 resource 之間的權限關係：</p><ul><li><p>Role：定義在特定 namespace 下的 resource 的存取權限</p></li><li><p>RoleBinding： 設定哪些使用者(or service account)與 role 綁定而擁有存取權限</p></li><li><p>ClusterRole：定義在整個 k8s cluster 下的 resource 的存取權限</p></li><li><p>ClusterRoleBinding：設定哪些使用者(or service account)與 role 綁定而擁有存取權限</p></li></ul><p>接著以下以 role <strong>kubernetes-dashboard-minimal</strong> 做個簡單的示範：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">root@kube-master0:~<span class="comment"># kubectl get role --all-namespaces</span></span><br><span class="line">NAMESPACE     NAME                                             AGE</span><br><span class="line">default       pod-reader                                       4d</span><br><span class="line">kube-public   system:controller:bootstrap-signer               5d</span><br><span class="line">kube-system   extension-apiserver-authentication-reader        5d</span><br><span class="line">kube-system   kubernetes-dashboard-minimal                     5d</span><br><span class="line">..... (略)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root@kube-master0:~<span class="comment"># kubectl get rolebinding --all-namespaces</span></span><br><span class="line">NAMESPACE     NAME                                             AGE</span><br><span class="line">kube-public   system:controller:bootstrap-signer               5d</span><br><span class="line">kube-system   kubernetes-dashboard-minimal                     5d</span><br><span class="line">..... (略)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 檢視 role "kubernetes-dashboard-minimal" 中有那些 resource 的存取權限</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">root@kube-master0:~<span class="comment"># kubectl describe role/kubernetes-dashboard-minimal -n kube-system</span></span><br><span class="line">Name:         kubernetes-dashboard-minimal</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  kubectl.kubernetes.io/last-applied-configuration=&#123;<span class="string">"apiVersion"</span>:<span class="string">"rbac.authorization.k8s.io/v1"</span>,<span class="string">"kind"</span>:<span class="string">"Role"</span>,<span class="string">"metadata"</span>:&#123;<span class="string">"annotations"</span>:&#123;&#125;,<span class="string">"name"</span>:<span class="string">"kubernetes-dashboard-minimal"</span>,<span class="string">"namespace"</span>:<span class="string">"kube-system"</span>...</span><br><span class="line">PolicyRule:</span><br><span class="line">  Resources       Non-Resource URLs  Resource Names                     Verbs</span><br><span class="line">  ---------       -----------------  --------------                     -----</span><br><span class="line">  configmaps      []                 [kubernetes-dashboard-settings]    [get update]</span><br><span class="line">  configmaps      []                 []                                 [create]</span><br><span class="line">  secrets         []                 [kubernetes-dashboard-certs]       [get update delete]</span><br><span class="line">  secrets         []                 [kubernetes-dashboard-key-holder]  [get update delete]</span><br><span class="line">  secrets         []                 []                                 [create]</span><br><span class="line">  services        []                 [heapster]                         [proxy]</span><br><span class="line">  services/proxy  []                 [heapster]                         [get]</span><br><span class="line">  services/proxy  []                 [http:heapster:]                   [get]</span><br><span class="line">  services/proxy  []                 [https:heapster:]                  [get]</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 檢視目前與 role "kubernetes-dashboard-minimal" 相關連的使用者(名稱為 "kubernetes-dashboard" 的 service account)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">root@kube-master0:~<span class="comment"># kubectl describe rolebinding/kubernetes-dashboard-minimal -n kube-system</span></span><br><span class="line">Name:         kubernetes-dashboard-minimal</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  kubectl.kubernetes.io/last-applied-configuration=&#123;<span class="string">"apiVersion"</span>:<span class="string">"rbac.authorization.k8s.io/v1"</span>,<span class="string">"kind"</span>:<span class="string">"RoleBinding"</span>,<span class="string">"metadata"</span>:&#123;<span class="string">"annotations"</span>:&#123;&#125;,<span class="string">"name"</span>:<span class="string">"kubernetes-dashboard-minimal"</span>,<span class="string">"namespace"</span>:<span class="string">"kube-...</span></span><br><span class="line"><span class="string">Role:</span></span><br><span class="line"><span class="string">  Kind:  Role</span></span><br><span class="line"><span class="string">  Name:  kubernetes-dashboard-minimal</span></span><br><span class="line"><span class="string">Subjects:</span></span><br><span class="line"><span class="string">  Kind            Name                  Namespace</span></span><br><span class="line"><span class="string">  ----            ----                  ---------</span></span><br><span class="line"><span class="string">  ServiceAccount  kubernetes-dashboard  kube-system</span></span><br></pre></td></tr></table></figure><p>接著以 clusterole <strong>system:controller:deployment-controller</strong> 做示範：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 檢視目前 k8s cluster 中的 ClusteRole 資訊</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">root@kube-master0:~<span class="comment"># kubectl get clusterrole</span></span><br><span class="line">NAME                                                                   AGE</span><br><span class="line">admin                                                                  5d</span><br><span class="line">calico-node                                                            5d</span><br><span class="line">cluster-admin                                                          5d</span><br><span class="line">..... (略)</span><br><span class="line">system:controller:deployment-controller                                5d</span><br><span class="line">..... (略)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 檢視 "system:controller:deployment-controller" ClusteRole 的 resource 存取權限</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">root@kube-master0:~<span class="comment"># kubectl describe clusterrole/system:controller:deployment-controller</span></span><br><span class="line">Name:         system:controller:deployment-controller</span><br><span class="line">Labels:       kubernetes.io/bootstrapping=rbac-defaults</span><br><span class="line">Annotations:  rbac.authorization.kubernetes.io/autoupdate=<span class="literal">true</span></span><br><span class="line">PolicyRule:</span><br><span class="line">  Resources                          Non-Resource URLs  Resource Names  Verbs</span><br><span class="line">  ---------                          -----------------  --------------  -----</span><br><span class="line">  events                             []                 []              [create patch update]</span><br><span class="line">  pods                               []                 []              [get list update watch]</span><br><span class="line">  deployments.apps                   []                 []              [get list update watch]</span><br><span class="line">  deployments.apps/finalizers        []                 []              [update]</span><br><span class="line">  deployments.apps/status            []                 []              [update]</span><br><span class="line">  replicasets.apps                   []                 []              [create delete get list patch update watch]</span><br><span class="line">  deployments.extensions             []                 []              [get list update watch]</span><br><span class="line">  deployments.extensions/finalizers  []                 []              [update]</span><br><span class="line">  deployments.extensions/status      []                 []              [update]</span><br><span class="line">  replicasets.extensions             []                 []              [create delete get list patch update watch]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 檢視目前 k8s cluster 中的 ClusteRoleBinding 資訊</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">root@kube-master0:~<span class="comment"># kubectl get clusterrolebinding</span></span><br><span class="line">NAME                                                   AGE</span><br><span class="line">..... (略)</span><br><span class="line">system:controller:deployment-controller                5d</span><br><span class="line">..... (略)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 檢視目前 k8s cluster 中與 "system:controller:deployment-controller" ClusteRoleBinding 連結的使用者(or service account)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">root@kube-master0:~<span class="comment"># kubectl describe clusterrolebinding/system:controller:deployment-controller</span></span><br><span class="line">Name:         system:controller:deployment-controller</span><br><span class="line">Labels:       kubernetes.io/bootstrapping=rbac-defaults</span><br><span class="line">Annotations:  rbac.authorization.kubernetes.io/autoupdate=<span class="literal">true</span></span><br><span class="line">Role:</span><br><span class="line">  Kind:  ClusterRole</span><br><span class="line">  Name:  system:controller:deployment-controller</span><br><span class="line">Subjects:</span><br><span class="line">  Kind            Name                   Namespace</span><br><span class="line">  ----            ----                   ---------</span><br><span class="line">  ServiceAccount  deployment-controller  kube-system</span><br></pre></td></tr></table></figure><p>API server 已經預先建立了一系列的 ClusterRole &amp; ClusteRoleBinding，名稱都以 <strong>system</strong> 開頭，並涵蓋了維持系統正常服務所需要的所有權限，因此整個 k8s cluster 都可以在 RBAC 的基礎下進行權限的管理與授權。</p><blockquote><p>這也代表著隨意對 system 開頭的 ClusteRole 修改，可能會造成系統無法正常運作。</p></blockquote><h2 id="Webhook"><a href="#Webhook" class="headerlink" title="Webhook"></a><a href="https://kubernetes.io/docs/reference/access-authn-authz/webhook/" target="_blank" rel="noopener">Webhook</a></h2><p>此模式是管理者在外部提供 HTTPS 授權服務，並設定 API server 透過與外部服務互動的方式進行授權。</p><h1 id="檢查-API-存取權限"><a href="#檢查-API-存取權限" class="headerlink" title="檢查 API 存取權限"></a>檢查 API 存取權限</h1><p>kubectl 提供了 <code>auth can-i</code> 命令，可用來查詢當前的使用者有沒有特定 resource 的存取權限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 檢查有無在 "dev" namespace 中建立 deployment 的權限</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">root@kube-master0:~<span class="comment"># kubectl auth can-i create deployments --namespace dev</span></span><br><span class="line">yes</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 檢查有無在 "prod" namespace 中建立 deployment 的權限</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">root@kube-master0:~<span class="comment"># kubectl auth can-i create deployments --namespace prod</span></span><br><span class="line">yes</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 檢查有無在 "dev" namespace 中以 dave 的身份來列出 secret 的權限</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">root@kube-master0:~<span class="comment"># kubectl auth can-i list secrets --namespace dev --as dave</span></span><br><span class="line">yes</span><br></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><p><a href="https://kubernetes.io/docs/reference/access-authn-authz/authorization/" target="_blank" rel="noopener">Authorization Overview - Kubernetes</a></p></li><li><p><a href="https://zhangchenchen.github.io/2017/08/17/kubernetes-authentication-authorization-admission-control/" target="_blank" rel="noopener">Kubernetes– 漫谈kubernetes 中的认证 &amp; 授权 &amp; 准入机制 | Solar</a></p></li><li><p><a href="http://cizixs.com/2017/06/16/kubernetes-authentication-and-authorization" target="_blank" rel="noopener">kubernetes 權限管理 – Cizixs Writes Here</a></p></li><li><p><a href="https://k8smeetup.github.io/docs/admin/authorization/rbac/" target="_blank" rel="noopener">https://k8smeetup.github.io/docs/admin/authorization/rbac/</a></p></li></ul>]]></content>
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>了解 Kubernetes 中的認證機制</title>
      <link href="/blog/2018/06/19/Kubernetes/k8s-API-Authentication/"/>
      <url>/blog/2018/06/19/Kubernetes/k8s-API-Authentication/</url>
      <content type="html"><![CDATA[<p>由於 Kubernetes 整體就是以 API 為基礎來設計的，因此要了解認證機制也就等同於要了解 k8s API server 的認證機制。</p><h1 id="了解-Kubernetes-API-認證機制"><a href="#了解-Kubernetes-API-認證機制" class="headerlink" title="了解 Kubernetes API 認證機制"></a>了解 Kubernetes API 認證機制</h1><p>k8s 提供了多種的認證方式，管理者可以設定多種認證機制共存,只要任何一種通過就算通過。</p><p>以 k8s 中各服務之間的認證為例，是以 x509 的認證，同時也是最嚴格的認證方式。透過 Kubespray 安裝好 k8s 後，我們可以在 master node 上檢視一下 api server 的啟動設定：(<code>/etc/kubernetes/manifests/kube-apiserver.manifest</code>)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kube-apiserver</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="string">........(略)</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  hostNetwork:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  dnsPolicy:</span> <span class="string">ClusterFirst</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kube-apiserver</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">gcr.io/google-containers/hyperkube:v1.10.4</span></span><br><span class="line"><span class="attr">    imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line"><span class="attr">    resources:</span></span><br><span class="line"><span class="attr">      limits:</span></span><br><span class="line"><span class="attr">        cpu:</span> <span class="number">800</span><span class="string">m</span></span><br><span class="line"><span class="attr">        memory:</span> <span class="number">2000</span><span class="string">M</span></span><br><span class="line"><span class="attr">      requests:</span></span><br><span class="line"><span class="attr">        cpu:</span> <span class="number">100</span><span class="string">m</span></span><br><span class="line"><span class="attr">        memory:</span> <span class="number">256</span><span class="string">M</span></span><br><span class="line"><span class="attr">    command:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">/hyperkube</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">apiserver</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">--advertise-address=10.103.10.51</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">--etcd-servers=https://10.103.10.51:2379,https://10.103.10.52:2379,https://10.103.10.53:2379</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">--etcd-cafile=/etc/ssl/etcd/ssl/ca.pem</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">--etcd-certfile=/etc/ssl/etcd/ssl/node-kube-master0.pem</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">--etcd-keyfile=/etc/ssl/etcd/ssl/node-kube-master0-key.pem</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">--insecure-bind-address=127.0.0.1</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">--bind-address=0.0.0.0</span></span><br><span class="line">    <span class="string">........(略)</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">--client-ca-file=/etc/kubernetes/ssl/ca.pem</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">--kubelet-client-certificate=/etc/kubernetes/ssl/node-kube-master0.pem</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">--kubelet-client-key=/etc/kubernetes/ssl/node-kube-master0-key.pem</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">--tls-cert-file=/etc/kubernetes/ssl/apiserver.pem</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">--tls-private-key-file=/etc/kubernetes/ssl/apiserver-key.pem</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">--service-account-key-file=/etc/kubernetes/ssl/service-account-key.pem</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">--secure-port=6443</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">--insecure-port=8080</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">--storage-backend=etcd3</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">--authorization-mode=Node,RBAC</span></span><br><span class="line">    <span class="string">........(略)</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">--requestheader-client-ca-file=/etc/kubernetes/ssl/front-proxy-ca.pem</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">--proxy-client-cert-file=/etc/kubernetes/ssl/front-proxy-client.pem</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">--proxy-client-key-file=/etc/kubernetes/ssl/front-proxy-client-key.pem</span></span><br><span class="line"><span class="attr">    livenessProbe:</span></span><br><span class="line">    <span class="string">........(略)</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line">    <span class="string">........(略)</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">  - hostPath:</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/etc/kubernetes</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">kubernetes-config</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">ssl-certs-host</span></span><br><span class="line"><span class="attr">    hostPath:</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/etc/ssl</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">usr-share-ca-certificates</span></span><br><span class="line"><span class="attr">    hostPath:</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/usr/share/ca-certificates</span></span><br><span class="line"><span class="attr">  - hostPath:</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/etc/ssl/etcd/ssl</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">etcd-certs</span></span><br></pre></td></tr></table></figure><p>從上面可以看出：</p><ol><li><p>與各個服務相互認證所使用的憑證 (<code>*.pem</code>)</p></li><li><p>與本地端的其他服務則是透過 <code>--insecure-bind-address=127.0.0.1</code> &amp; <code>--insecure-port=8080</code> 來溝通</p></li><li><p>憑證存放的位置其實就是在各個 node 的本機上 (<code>hostPath</code> 定義)</p></li><li><p>目前此 k8s cluster 支援的認證方式為 <strong><a href="https://kubernetes.io/docs/reference/access-authn-authz/node/" target="_blank" rel="noopener">Node</a></strong> &amp; <strong><a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/" target="_blank" rel="noopener">RBAC</a></strong></p></li><li><p>pod 內部服務需要與 api server 互動時的認證方式，使用 <strong><a href="https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/" target="_blank" rel="noopener">Service Account Token</a></strong> 的方式，此處對應的設定是 <code>--service-account-key-file=/etc/kubernetes/ssl/service-account-key.pem</code></p></li></ol><p>Kubespray 預設設置了 <code>X509</code>, <code>Node</code> &amp; <code>RBAC</code> 三種認證方式，但 Kubernetes 還支援了相當多其他的認證方式，例如：</p><ul><li><p><code>Static Token File</code></p></li><li><p><code>Bootstrap Tokens</code></p></li><li><p><code>Static Password File</code></p></li><li><p><code>OpenID Connect Tokens</code></p></li><li><p><code>Webhook Token Authentication</code></p></li><li><p><code>Keystone Password</code></p></li></ul><p>以下會針對比較重要的認證機制詳細說明。 </p><h1 id="X509-Client-Certs"><a href="#X509-Client-Certs" class="headerlink" title="X509 Client Certs"></a>X509 Client Certs</h1><p>從 Kubespray 預設的安裝設定中的 API server 啟動參數中，可以看到與 X509 相關設定參數有：</p><ul><li><p><code>client-ca-file</code></p></li><li><p><code>tls-private-key-file</code></p></li><li><p><code>tls-cert-file</code></p></li></ul><p>由於只有在 k8s cluster 內的 node 才會有這些憑證檔案，因此這樣的認證方式是在 cluster 內部不同 node 之間的服務相互存取時使用。</p><p>但若是與 API server 同在本地端(localhost)的服務要存取 API 呢? 就直接 pass 了…..(像是 <code>kube-scheduler</code> &amp; <code>kube-controller-manager</code> 都屬於這一類的服務)</p><p>可看到 <code>--insecure-bind-address=127.0.0.1</code> &amp; <code>--insecure-port=8080</code> 兩個設定，就可以看出在本地端內部服務存取 API server 時，使用的是 <strong><a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></strong></p><h1 id="Service-Account"><a href="#Service-Account" class="headerlink" title="Service Account"></a>Service Account</h1><p>Service Account 本身在 k8s 中是屬於 resource 的一種。我們可以透過以下指令取得 Service Account 清單：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 每一個 namespace 都有一個名稱為 "default" 的 service account</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">root@kube-master0:~<span class="comment"># kubectl get serviceaccount --all-namespaces</span></span><br><span class="line">NAMESPACE     NAME                                 SECRETS   AGE</span><br><span class="line">default       default                              1         4d</span><br><span class="line">kube-public   default                              1         4d</span><br><span class="line">kube-system   attachdetach-controller              1         4d</span><br><span class="line">kube-system   cronjob-controller                   1         4d</span><br><span class="line">kube-system   daemon-set-controller                1         4d</span><br><span class="line">kube-system   default                              1         4d</span><br><span class="line">kube-system   deployment-controller                1         4d</span><br><span class="line">.....(略)</span><br></pre></td></tr></table></figure><p>從上面清單可看出，每個 namespace 中都會有一個名稱為 <code>default</code> 的 service account，接著可以來拆解這個 <code>default</code> service account 有什麼內容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 名稱為 "default" 的 service account 其實就是帶著用來存取 API server 時認證用的 token</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">root@kube-master0:~<span class="comment"># kubectl describe serviceaccount/default -n kube-system</span></span><br><span class="line">Name:                default</span><br><span class="line">Namespace:           kube-system</span><br><span class="line">Labels:              &lt;none&gt;</span><br><span class="line">Annotations:         &lt;none&gt;</span><br><span class="line">Image pull secrets:  &lt;none&gt;</span><br><span class="line">Mountable secrets:   default-token-nkl69</span><br><span class="line">Tokens:              default-token-nkl69</span><br><span class="line">Events:              &lt;none&gt;</span><br></pre></td></tr></table></figure><p>最後來看看上面 service account token 所帶的內容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 此 token 內容載明了 token 本身之外，還有 namespace, type ... 等資訊</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">root@kube-master0:~<span class="comment"># kubectl describe secret/default-token-nkl69 -n kube-system</span></span><br><span class="line">Name:         default-token-nkl69</span><br><span class="line">Namespace:    kube-system</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  kubernetes.io/service-account.name=default</span><br><span class="line">              kubernetes.io/service-account.uid=fd2e5d64-6f9c-11e8-b6b3-065296fdbf18</span><br><span class="line"></span><br><span class="line">Type:  kubernetes.io/service-account-token</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">namespace:  11 bytes</span><br><span class="line">token:      eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJkZWZhdWx0LXRva2VuLW5rbDY5Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6ImRlZmF1bHQiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiJmZDJlNWQ2NC02ZjljLTExZTgtYjZiMy0wNjUyOTZmZGJmMTgiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6a3ViZS1zeXN0ZW06ZGVmYXVsdCJ9.cMC6jKcj1vmDhQnxlsHzop1t6W3qeG-xhEAZyBuzagUgb-2f06ZxI0UvIQ-qb3mkXyjtCdhw-Hn4PpvJ56HtvCBMYwfaP-ii4ord0aZfhqIRynlFuj-cc2qvhewaGwC84Yj7awMj6rv9yQGMgFBEL0roaLgoVAyYqpbJ6B2ig4cBlQQnTbiewYXdGoWGzb3wtl2Ii6E9nZ6ANPxLI4dhwbAxVNVAR4tojRiukQldSnI0ItX-Iwx1Djd5FK3FCgxY1soo682sLE-_NJeF8KfVPAWtg1049dSXe1iNQ3k-AO3pfEGDBaAq4WACuYhMtfL2iYlZRxS5SEt8Mwz3aVW1ng</span><br><span class="line">ca.crt:     1090 bytes</span><br></pre></td></tr></table></figure><blockquote><p>Service Account 的認證方式主要是由 k8s 自行管理，當我們建立一個 namespace 時，就自動會產生一個名稱為 <code>default</code> 的 service account 並帶有新建立的 token；而未來在此 namespace 中所產生的 pod，都會自動使用此 token 與 API server 進行認證。</p></blockquote><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><p><a href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/" target="_blank" rel="noopener">Authenticating - Kubernetes</a></p></li><li><p><a href="https://zhangchenchen.github.io/2017/08/17/kubernetes-authentication-authorization-admission-control/" target="_blank" rel="noopener">Kubernetes– 漫谈kubernetes 中的认证 &amp; 授权 &amp; 准入机制 | Solar</a></p></li><li><p><a href="整合 OpenLDAP 進行 Kubernetes 身份認證 | KaiRen&#39;s Blog">https://kairen.github.io/2018/04/15/kubernetes/k8s-integration-ldap/</a></p></li></ul>]]></content>
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用 Kubespray 安裝 Kubernetes 1.10.4</title>
      <link href="/blog/2018/06/14/Kubernetes/Install-k8s-via-kubespray/"/>
      <url>/blog/2018/06/14/Kubernetes/Install-k8s-via-kubespray/</url>
      <content type="html"><![CDATA[<p>此篇文章介紹如何使用 <a href="https://github.com/kubernetes-incubator/kubespray" target="_blank" rel="noopener">Kubespray</a> 安裝 Kubernetes</p><h1 id="環境介紹"><a href="#環境介紹" class="headerlink" title="環境介紹"></a>環境介紹</h1><p>在這個安裝過程中，共有 8 個 VM，皆為透過 Ubuntu 16.04 cloud image 所產生，分別有以下幾個 node：</p><ul><li><p>Master Node x 3 (<strong>同時兼任 etcd node</strong>)</p></li><li><p>Worker Node x 3</p></li><li><p>Ingress Node x 2 (<strong>同時兼任 worker node</strong>)</p></li></ul><h1 id="準備安裝環境"><a href="#準備安裝環境" class="headerlink" title="準備安裝環境"></a>準備安裝環境</h1><h2 id="準備安裝環境-1"><a href="#準備安裝環境-1" class="headerlink" title="準備安裝環境"></a>準備安裝環境</h2><p>確認了環境之後，另外還要準備一台用來執行 Ansible 程式的機器(or VM)，以下以 docker container 的方式來執行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name kubespray -td ubuntu:xenial /bin/bash</span><br><span class="line"></span><br><span class="line">$ docker <span class="built_in">exec</span> -it kubespray bash</span><br></pre></td></tr></table></figure><p>接著在 ubuntu container 中執行以下 script：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bib/bash</span></span><br><span class="line"></span><br><span class="line">apt-get update</span><br><span class="line">apt-get -y install git python3-pip python</span><br><span class="line">pip3 install --upgrade pip</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/kubernetes-incubator/kubespray.git</span><br><span class="line"><span class="built_in">cd</span> -</span><br><span class="line">pip install -r /tmp/kubespray/requirements.txt</span><br></pre></td></tr></table></figure><p>如此一來 Kubespray 的安裝環境就準備好了</p><h2 id="準備環境設定檔"><a href="#準備環境設定檔" class="headerlink" title="準備環境設定檔"></a>準備環境設定檔</h2><p>接著要針對我們自己的環境來進行 Ansible inventory &amp; variables 的相關設定：(以下內容皆在 container 中)</p><h3 id="tmp-kubespray-inventory-mycluster-hosts-ini"><a href="#tmp-kubespray-inventory-mycluster-hosts-ini" class="headerlink" title="/tmp/kubespray/inventory/mycluster/hosts.ini"></a>/tmp/kubespray/inventory/mycluster/hosts.ini</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">kube-ingress0   ansible_host=[YOUR_SERVER_IP]   ip=[YOUR_SERVER_IP]</span><br><span class="line">kube-ingress1   ansible_host=[YOUR_SERVER_IP]   ip=[YOUR_SERVER_IP]</span><br><span class="line"></span><br><span class="line">kube-master0    ansible_host=[YOUR_SERVER_IP]   ip=[YOUR_SERVER_IP]</span><br><span class="line">kube-master1    ansible_host=[YOUR_SERVER_IP]   ip=[YOUR_SERVER_IP]</span><br><span class="line">kube-master2    ansible_host=[YOUR_SERVER_IP]   ip=[YOUR_SERVER_IP]</span><br><span class="line"></span><br><span class="line">kube-worker0    ansible_host=[YOUR_SERVER_IP]   ip=[YOUR_SERVER_IP]</span><br><span class="line">kube-worker1    ansible_host=[YOUR_SERVER_IP]   ip=[YOUR_SERVER_IP]</span><br><span class="line">kube-worker2    ansible_host=[YOUR_SERVER_IP]   ip=[YOUR_SERVER_IP]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">[kube-master]</span></span><br><span class="line">kube-master[0:2]</span><br><span class="line"></span><br><span class="line"><span class="section">[etcd]</span></span><br><span class="line">kube-master[0:2]</span><br><span class="line"></span><br><span class="line"><span class="section">[kube-node]</span></span><br><span class="line">kube-worker[0:2]</span><br><span class="line">kube-ingress[0:1]</span><br><span class="line"></span><br><span class="line"><span class="section">[kube-ingress]</span></span><br><span class="line">kube-ingress[0:1]</span><br><span class="line"></span><br><span class="line"><span class="section">[k8s-cluster:children]</span></span><br><span class="line">kube-master</span><br><span class="line">kube-node</span><br><span class="line">kube-ingress</span><br></pre></td></tr></table></figure><h3 id="tmp-kubespray-inventory-mycluster-group-vars-all-yml"><a href="#tmp-kubespray-inventory-mycluster-group-vars-all-yml" class="headerlink" title="/tmp/kubespray/inventory/mycluster/group_vars/all.yml"></a>/tmp/kubespray/inventory/mycluster/group_vars/all.yml</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#### ....預設值忽略.... ####</span></span><br><span class="line"></span><br><span class="line"><span class="attr">bootstrap_os:</span> <span class="string">ubuntu</span></span><br><span class="line"><span class="attr">ansible_user:</span> <span class="string">ubuntu</span></span><br><span class="line"><span class="attr">ansible_become_user:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">ansible_ssh_private_key_file:</span> <span class="string">/ansible/ssh-privkey/id_rsa</span></span><br></pre></td></tr></table></figure><h3 id="tmp-kubespray-inventory-mycluster-group-vars-k8s-cluster-yml"><a href="#tmp-kubespray-inventory-mycluster-group-vars-k8s-cluster-yml" class="headerlink" title="/tmp/kubespray/inventory/mycluster/group_vars/k8s-cluster.yml"></a>/tmp/kubespray/inventory/mycluster/group_vars/k8s-cluster.yml</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#### ....預設值忽略.... ####</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 ansible host 上存放 kubeconfig</span></span><br><span class="line"><span class="attr">kubeconfig_localhost:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h1 id="安裝-Kubernetes"><a href="#安裝-Kubernetes" class="headerlink" title="安裝 Kubernetes"></a>安裝 Kubernetes</h1><p>最後執行以下指令即可安裝：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /tmp/kubespray</span><br><span class="line">$ ansible-playbook -b -i inventory/mycluster/hosts.ini cluster.yml</span><br></pre></td></tr></table></figure><p>安裝完之後可以在執行 ansible 指令的機器上找到 kubeconfig，位置在 <code>/tmp/kubespray/inventory/mycluster/artifacts/admin.conf</code></p><h1 id="操作-Kubernetes"><a href="#操作-Kubernetes" class="headerlink" title="操作 Kubernetes"></a>操作 Kubernetes</h1><p>要操作 k8s 可以直接連到 master node 上直接使用 kubectl 進行操作，也可以使用其他機器進行操作。</p><p>但若要使用非 master node 的機器對 k8s 進行操作，必須先準備好以下環境：</p><ol><li><p>安裝 <a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/" target="_blank" rel="noopener">kubectl</a></p></li><li><p>準備好 kubeconfig (以上例來說，位於 <code>/tmp/kubespray/inventory/mycluster/artifacts/admin.conf</code>)，檔案路徑為 <code>~/.kube/config</code></p></li></ol><p>完成後執行簡單的指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get nodes</span><br><span class="line">NAME            STATUS    ROLES          AGE       VERSION</span><br><span class="line">kube-ingress0   Ready     ingress,node   1h        v1.10.4</span><br><span class="line">kube-ingress1   Ready     ingress,node   1h        v1.10.4</span><br><span class="line">kube-master0    Ready     master         1h        v1.10.4</span><br><span class="line">kube-master1    Ready     master         1h        v1.10.4</span><br><span class="line">kube-master2    Ready     master         1h        v1.10.4</span><br><span class="line">kube-worker0    Ready     node           1h        v1.10.4</span><br><span class="line">kube-worker1    Ready     node           1h        v1.10.4</span><br><span class="line">kube-worker2    Ready     node           1h        v1.10.4</span><br></pre></td></tr></table></figure><p>這樣大致上基本的 Kubernetes 就安裝完成了!</p><blockquote><p>若是要取得安裝時所產生的相關憑證檔案，可以到 master node 上的 <code>/etc/kubernetes/ssl</code> 目錄中尋找</p></blockquote><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://github.com/kubernetes-incubator/kubespray" target="_blank" rel="noopener">kubernetes-incubator/kubespray: Setup a kubernetes cluster</a></li></ul>]]></content>
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> Kubespray </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Proxmox] 使用 cloud-init 快速產生 VM</title>
      <link href="/blog/2018/06/07/Proxmox/Proxmox-use-cloud-init-to-provision-vm/"/>
      <url>/blog/2018/06/07/Proxmox/Proxmox-use-cloud-init-to-provision-vm/</url>
      <content type="html"><![CDATA[<p>本文將會介紹如何在 Proxmox 上使用 cloud-init 產生 VM</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用 <a href="https://www.proxmox.com/en/proxmox-ve" target="_blank" rel="noopener">Proxmox</a> 也有一段時間了，這套免費的 KVM virtualization platform 真是佛心來的，好用穩定又有 Web GUI，但唯一的缺憾就是要作 Infrastructure as code 真的有點困難，因為他本身並不具備 cloud-init 的功能。</p><p>還好這個功能終於在 5.2 的時候被支援了，不過看起來還是很陽春，但基本使用上應該還算足夠。</p><blockquote><p>希望未來會有 scheduler 也被開發出來，不然我都要自己指定 host 來擺 VM….</p></blockquote><h1 id="準備-Template-VM"><a href="#準備-Template-VM" class="headerlink" title="準備 Template VM"></a>準備 Template VM</h1><p>以下將以 <a href="https://cloud-images.ubuntu.com/xenial/current" target="_blank" rel="noopener">ubuntu 16.04 cloud image</a> 做示範來準備 template VM</p><p>在準備 template VM 前必須有以下資訊：</p><ol><li><p>VM ID：這個不要跟其他 VM 重複到即可，下面使用 <code>9999</code></p></li><li><p>CPU / Memory / Network 相關設定：這個部份就根據自己的環境 &amp; 需求調整</p></li><li><p>Storage：要選擇一個 Template VM disk 存放的 storage，以下以 <code>rbd_vm</code> 做示範 (官網的文章是直接放到 <code>local-lvm</code>)</p></li><li><p>SSH login key：cloud image 預設無法使用密碼登入，因此必須準備好登入用的 SSH Key(public)</p></li></ol><p>接著執行以下 script 即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line"></span><br><span class="line">wget https://cloud-images.ubuntu.com/xenial/current/xenial-server-cloudimg-amd64-disk1.img</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定 CPU type 為 host, 共 8(2x4) vcpu, 8GB memory, 網路使用 vmbr1(tag 1310, 此為我自己設定的 trunk bridge)</span></span><br><span class="line">qm create 9999 --cpu cputype=host --sockets 2 --cores 4 --memory 8192 --net0 virtio,bridge=vmbr1,tag=1310</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將 cloud image 匯入到指定的 storage 作為 template VM 的第一個 disk</span></span><br><span class="line">qm importdisk 9999 xenial-server-cloudimg-amd64-disk1.img rbd_vm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定 VM 細節</span></span><br><span class="line"><span class="comment"># 設定 storage type</span></span><br><span class="line"><span class="comment"># 設定 cloud-init 的功能以 cd-rom 的形式掛載</span></span><br><span class="line"><span class="comment"># serial 一定要加，否則 cloud image 會無法正常開機</span></span><br><span class="line">qm <span class="built_in">set</span> 9999 --virtio0 rbd_vm:vm-9999-disk-1 --ide2 rbd_vm:cloudinit --boot c --bootdisk virtio0 --serial0 socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定 SSH key (cloud image 預設是無法使用密碼登入，必須設定 SSH key)</span></span><br><span class="line">qm <span class="built_in">set</span> 9999 --sshkey &lt;your public ssk key path&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 轉換成 template VM</span></span><br><span class="line">qm template 9999</span><br></pre></td></tr></table></figure><p>執行完成後就會有一個 VM ID=9999 的 template VM 產生，從系統上可以看到類似以下資訊：</p><p><img src="/blog/images/proxmox/vm_hw_info.png" alt="Template VM Hardware Information"></p><p><img src="/blog/images//proxmox/vm_cloud-init_info.png" alt="Template VM cloud-init Information"></p><h1 id="產生-VM"><a href="#產生-VM" class="headerlink" title="產生 VM"></a>產生 VM</h1><p>接著就可以使用這個 template VM 來快速產生 VM 了，以下用個簡單的 script 來完成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 複製 VM</span></span><br><span class="line">qm <span class="built_in">clone</span> 9999 1001 --name ubuntu1604-1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將 storage size 擴大到 64GB</span></span><br><span class="line">qm resize 1001 virtio0 64G; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 網路設定 (以下是對應到上面的 tag 1310，請自行修改以對應自己的環境)</span></span><br><span class="line">qm <span class="built_in">set</span> 1001 --ipconfig0 ip=10.103.10.51/24,gw=10.103.10.1 --nameserver <span class="string">'8.8.8.8 1.1.1.1'</span></span><br><span class="line"></span><br><span class="line">qm start 1001</span><br></pre></td></tr></table></figure><p>以上的 script 修改一下，放到 loop 中，一下子要產生多個 VM 其實就是一件很簡單的事情了!</p><h1 id="其他限制"><a href="#其他限制" class="headerlink" title="其他限制"></a>其他限制</h1><p>目前 cloud-init 這個功能無法在 CentOS cloud image 上使用</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><p><a href="https://pve.proxmox.com/wiki/Cloud-Init_Support" target="_blank" rel="noopener">Cloud-Init Support - Proxmox VE</a></p></li><li><p><a href="https://pve.proxmox.com/pve-docs/qm.1.html" target="_blank" rel="noopener">qm(1)</a></p></li></ul>]]></content>
      
      <categories>
          
          <category> Proxmox </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Proxmox </tag>
            
            <tag> cloud-init </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[OpenShift] 如何計算在 Jenkins pipeline 中工作所花費的時間</title>
      <link href="/blog/2017/11/29/OpenShift/OpenShift-Howto-Calculate-Time-Duration-in-Jenkins/"/>
      <url>/blog/2017/11/29/OpenShift/OpenShift-Howto-Calculate-Time-Duration-in-Jenkins/</url>
      <content type="html"><![CDATA[<p>最近的工作都是使用 OpenShift + Jenkins 在進行 CI/CD 的相關工作，在時間的顯示上遇到了兩個問題：</p><ol><li><p>Jenkins 系統上使用的是 UTC 時間，希望改成 Taiwan 時間(+8:00)</p></li><li><p>想要知道整個 pipeline 的工作完成後一共花了多少時間</p></li></ol><p>上網找了很多資料，拼拼湊湊寫出了以下的 groovy script 來完成這件事情：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat</span><br><span class="line"><span class="keyword">import</span> java.util.Calendar</span><br><span class="line"><span class="keyword">import</span> groovy.time.*</span><br><span class="line"></span><br><span class="line"><span class="comment">// human-readable format</span></span><br><span class="line"><span class="keyword">def</span> dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// convert time from UTC to Taiwan Time(+8:00)</span></span><br><span class="line"><span class="keyword">def</span> startTime = <span class="keyword">new</span> Date((Calendar.getInstance()).getTimeInMillis() + (<span class="number">480</span> * <span class="number">60000</span>))</span><br><span class="line"><span class="keyword">def</span> strStartTime = dateFormat.format(startTime)</span><br><span class="line"></span><br><span class="line">sleep <span class="number">5</span></span><br><span class="line"></span><br><span class="line">openshift.withCluster() &#123;</span><br><span class="line">    stage(<span class="string">'Calculate Time Duration'</span>) &#123;</span><br><span class="line">        node &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">def</span> endTime = <span class="keyword">new</span> Date((Calendar.getInstance()).getTimeInMillis() + (<span class="number">480</span> * <span class="number">60000</span>))</span><br><span class="line">            strEndTime = dateFormat.format(endTime)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// calculate time duration</span></span><br><span class="line">            TimeDuration duration = TimeCategory.minus(endTime, startTime)</span><br><span class="line">            <span class="keyword">def</span> strDuration = String.format(<span class="string">"%02d"</span>, duration.getHours()) + <span class="string">":"</span> + String.format(<span class="string">"%02d"</span>, duration.getMinutes()) + <span class="string">":"</span> + String.format(<span class="string">"%02d"</span>, duration.getSeconds())</span><br><span class="line">            <span class="comment">// it's necessary to set it to null for avoiding "not serializable exception"</span></span><br><span class="line">            duration = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">            echo <span class="string">"Start Time = $&#123;strStartTime&#125;"</span></span><br><span class="line">            echo <span class="string">"End Time = $&#123;strEndTime&#125;"</span></span><br><span class="line">            echo <span class="string">"Time Duration = $&#123;strDuration&#125;"</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="comment">// ---------- End of stage('Configure IAAS')</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>透過以下步驟，可以直接使用我放在 GitHub 上面的範例，直接建立一個 build job 來測試：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/godleon/openshift-jenkins-customization.git</span><br><span class="line"></span><br><span class="line">$ oc create -f openshift-objects/</span><br><span class="line"></span><br><span class="line">$ oc start-build calculate-time-duration</span><br></pre></td></tr></table></figure><p>接著到 Jenkins 系統內部就可以看到執行結果囉!</p><hr><h1 id="關於-Script-Approval-的處理"><a href="#關於-Script-Approval-的處理" class="headerlink" title="關於 Script Approval 的處理"></a>關於 Script Approval 的處理</h1><p>預設 Jenkins pipeline 會在 sandbox 的環境中執行，因此很多 grovvy or java method 都會無法使用，因此在 OpenShift 中需要對 Jenkins 進行客製化，預先設定 script whitelist，讓某些 method 可以在 pipeline 中使用，如何客製化 Jenkins 詳情可以參考之前寫過的文章。</p>]]></content>
      
      <categories>
          
          <category> OpenShift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenShift </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[OpenShift] 如何客製化 Jenkins Image</title>
      <link href="/blog/2017/11/07/OpenShift/OpenShift-Howto-Customize-builtin-Jenkins-Image/"/>
      <url>/blog/2017/11/07/OpenShift/OpenShift-Howto-Customize-builtin-Jenkins-Image/</url>
      <content type="html"><![CDATA[<p>本文章的主題在於如何將客製化 OpenShift 原生提供的 Jenkins image</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Openshift 在 DevOps 的方面的確是下了不少功夫，使用 OpenShift 的確可以讓 DevOps engineer 省下不少工，但相對的也有蠻多新東西要學的! XD</p><p>在 OpenShift 建立第一個 BuildConfig(pipeline) 時，它會自動幫使用者佈署一個用來驅動 build pipeline 的 Jenkins server(此 container 會由 OpenShift 本身納管，因此掛了會自己再起一個新的)，佈署的行為如下：</p><ol><li><p>使用 <code>openshift</code> namespace 中的 template <code>jenkins-ephemeral</code> 為範本產生 Jenkins server</p></li><li><p>此 tempate 使用的 image stream 為 <code>jenkins:latest</code></p></li><li><p>Image Stream <code>jenkins:latest</code> 則是指到 Red Hat 官方所提供的 Jenkins image(<strong>registry.access.redhat.com/openshift3/jenkins-2-rhel7</strong>)</p></li></ol><p>當 Jenkins server 佈署好之後，就會自動的與 OpenShift 本身的認証機制進行整合，完全不用使用者進行額外的設定，相關的 credential 也都會設定在 Jenkins server 內部，使用者需要做的就是開始設計 pipeline 就對了!</p><hr><h1 id="Jenkins-image-for-OpenShift"><a href="#Jenkins-image-for-OpenShift" class="headerlink" title="Jenkins image for OpenShift"></a>Jenkins image for OpenShift</h1><p>由於 Jenkins 並不是一個很容易入門上手的系統，因此為了提供使用者能更方便的使用 Jenkins，OpenShift 將 Jenkins 系統打包成 docker image，並加入了許多常用的 plugin 以及與 OpenShift 整合所需要的 plugin，還很貼心的做好相關整合的設定，讓使用者在建立 pipeline 時就會同時產生相對應的 Jenkins server 來使用，省略許多繁複且容易造成錯誤的設定過程。</p><p>目前使用者可能比較容易用到的 Jenkins image for OpenShift 可能會有以下兩種：</p><ul><li>Red Hat 版本：<code>registry.access.redhat.com/openshift3/jenkins-2-rhel7</code><br>本文章的主題在於如何將客製化 OpenShift 原生提供的 Jenkins image</li></ul><h1 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h1><p>Openshift 在 DevOps 的方面的確是下了不少功夫，使用 OpenShift 的確可以讓 DevOps engineer 省下不少工，但相對的也有蠻多新東西要學的! XD</p><p>在 OpenShift 建立第一個 BuildConfig(pipeline) 時，它會自動幫使用者佈署一個用來驅動 build pipeline 的 Jenkins server(此 container 會由 OpenShift 本身納管，因此掛了會自己再起一個新的)，佈署的行為如下：</p><ol><li><p>使用 <code>openshift</code> namespace 中的 template <code>jenkins-ephemeral</code> 為範本產生 Jenkins server</p></li><li><p>此 tempate 使用的 image stream 為 <code>jenkins:latest</code></p></li><li><p>Image Stream <code>jenkins:latest</code> 則是指到 Red Hat 官方所提供的 Jenkins image(<strong>registry.access.redhat.com/openshift3/jenkins-2-rhel7</strong>)</p></li></ol><p>當 Jenkins server 佈署好之後，就會自動的與 OpenShift 本身的認証機制進行整合，完全不用使用者進行額外的設定，相關的 credential 也都會設定在 Jenkins server 內部，使用者需要做的就是開始設計 pipeline 就對了!</p><hr><h1 id="Jenkins-image-for-OpenShift-1"><a href="#Jenkins-image-for-OpenShift-1" class="headerlink" title="Jenkins image for OpenShift"></a>Jenkins image for OpenShift</h1><p>由於 Jenkins 並不是一個很容易入門上手的系統，因此為了提供使用者能更方便的使用 Jenkins，OpenShift 將 Jenkins 系統打包成 docker image，並加入了許多常用的 plugin 以及與 OpenShift 整合所需要的 plugin，還很貼心的做好相關整合的設定，讓使用者在建立 pipeline 時就會同時產生相對應的 Jenkins server 來使用，省略許多繁複且容易造成錯誤的設定過程。</p><p>目前使用者可能比較容易用到的 Jenkins image for OpenShift 可能會有以下兩種：</p><ul><li><p>Red Hat 版本：<code>registry.access.redhat.com/openshift3/jenkins-2-rhel7</code></p></li><li><p>CentOS 版本：<code>openshift/jenkins-2-centos7</code> (位於 DockerHub 上)</p></li></ul><p>由於新版的 OpenShift pipeline plugin for Jenkins 目前僅在 CentOS 版本的 Jenkins image 支援，因此後面的範例將會以 CentOS 版本為主，並提供將原有的 Jenkins image 從 Red Hat 版本改成 CentOS 版本的方法。</p><hr><h1 id="安裝額外的-Jenkins-plugin"><a href="#安裝額外的-Jenkins-plugin" class="headerlink" title="安裝額外的 Jenkins plugin"></a>安裝額外的 Jenkins plugin</h1><p>由於 OpenShift 提供的 Jenkins image 本身就是一個具有 s2i 功能的 docker image，因此我們可以透過 s2i 的流程，將所需要安裝的 plugin 以 source code injection 的方式指定進來並安裝。</p><p>以下的範例將會進行以下的客製化：</p><ol><li><p>安裝 <strong>redmine</strong>, <strong>gitlab-plugin</strong>, <strong>testlink</strong> 三個 plugin (詳細版本可參考<a href="https://github.com/godleon/learning_openshift/blob/master/jenkins_customization/plugins.txt" target="_blank" rel="noopener">原始碼</a>)</p></li><li><p>預先加入 <strong>scriptApproval.xml</strong> 檔案，讓某些 method 可在 sandbox 的環境中執行 (詳細清單可參考<a href="https://github.com/godleon/learning_openshift/blob/master/jenkins_customization/configuration/scriptApproval.xml" target="_blank" rel="noopener">原始碼</a>)</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取得原始碼</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/godleon/openshift-jenkins-customization.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 ImageStream(custom-jenkins-2-centos7) BuildConfig(custom-jenkins-build)</span></span><br><span class="line">$ oc create -f openshift-jenkins-customization/openshift-objects/</span><br><span class="line"></span><br><span class="line">$ oc -n openshift start-build custom-jenkins-build</span><br><span class="line"></span><br><span class="line">$ oc -n openshift get pods</span><br><span class="line">NAME                           READY     STATUS      RESTARTS   AGE</span><br><span class="line">custom-jenkins-build-1-build   0/1       Completed   0          22m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視 build log</span></span><br><span class="line">$ oc -n openshift logs -f custom-jenkins-build-1-build</span><br></pre></td></tr></table></figure><blockquote><p>使用者必須先安裝 <a href="https://github.com/openshift/origin/releases" target="_blank" rel="noopener">OpenShift CLI tool</a> 才可以執行上述的 oc 指令</p></blockquote><p>在最後一行指令中檢視 build log 時，就可以看見 OpenShift 透過 s2i 流程將我們在程式碼中所指定的 plugin 都已經安裝完成，此時我們就可以透過 ImageStream <code>custom-jenkins-2-centos7</code>(定義於 <strong>Jenkins_Customization/bc_custom-jenkins-build.yml</strong> 中) 來作為啟動 Jenkins server 的 default image。</p><hr><h1 id="更換原有的-Jenkins-Image"><a href="#更換原有的-Jenkins-Image" class="headerlink" title="更換原有的 Jenkins Image"></a>更換原有的 Jenkins Image</h1><p>今天在測試設計較為複雜的 Jenkins pipeline 時，發現 <a href="https://github.com/openshift/origin/tree/master/examples/jenkins/pipeline" target="_blank" rel="noopener">OpenShift 在 GitHub 提供的範例</a> 無法正常的使用，會出現 openshift class 不存在的錯誤，後來仔細的查了一下，發現原來裡面的範例需要搭配 <a href="https://github.com/openshift/jenkins-client-plugin" target="_blank" rel="noopener">OpenShift Jenkins Pipeline (DSL) Plugin</a> 一起使用。</p><p><strong>問題是，Red Hat 版本的 Jenkins image 並沒有內建這一個 plugin，此 plugin 目前僅有內建在 Centos 版本的 Jenkins image 中。</strong></p><p>而在上一個步驟中，我們使用了 CentOS 版本的 Jenkins image，並安裝了額外的 plugin 作為後續使用，因此以下便使用已經客製化完成的 Jenkins image 來作為啟動 Jenkins server 的 image。</p><p>為了更改自動佈署的 Jenkins server 所使用的 docker image，需要調整 <code>jenkins-ephemeral</code> 的內容，將 image 從 Red Hat 版本改到在上一個步驟完成的客製化 CentOS 版本，執行以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ oc edit template/jenkins-ephemeral -n openshift</span><br></pre></td></tr></table></figure><p>找到 <code>parameters</code> –&gt; <code>JENKINS_IMAGE_STREAM_TAG</code>，將 <strong>value</strong> 從 <code>jenkins:latest</code> 改為 <code>custom-jenkins-2-centos7:latest</code>，存檔即可。</p><p>經過了以上的設定，後面自動佈署出來的 Jenkins server 都會是 CentOS7 的版本，也會同時預載好 <a href="https://github.com/openshift/jenkins-client-plugin" target="_blank" rel="noopener">OpenShift Jenkins Pipeline (DSL) Plugin</a> 以及在上一個步驟額外安裝好的 plugin。</p><hr><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><p><a href="https://github.com/jenkinsci/openshift-pipeline-plugin" target="_blank" rel="noopener">OpenShift V3 Plugin for Jenkins (based on Kubernetes plugin)</a></p></li><li><p><a href="https://github.com/openshift/jenkins-client-plugin" target="_blank" rel="noopener">OpenShift Jenkins Pipeline (DSL) Plugin (newly design)</a></p></li><li><p><a href="https://github.com/openshift/origin/tree/master/examples/jenkins/pipeline" target="_blank" rel="noopener">Using Jenkins Pipelines with OpenShift @GitbHub</a></p></li><li><p><a href="https://docs.openshift.com/container-platform/3.6/using_images/other_images/jenkins.html" target="_blank" rel="noopener">Jenkins - Other Images | Using Images | OpenShift Container Platform 3.6</a></p></li><li><p><a href="https://github.com/openshift/jenkins-sync-plugin/issues/57" target="_blank" rel="noopener">Script approvals needed for changes to build config Jenkinsfile · Issue #57 · openshift/jenkins-sync-plugin</a></p></li><li><p><a href="https://github.com/fabric8io/jenkins-docker" target="_blank" rel="noopener">fabric8io/jenkins-docker: docker file for a jenkins docker image</a></p></li></ul>]]></content>
      
      <categories>
          
          <category> OpenShift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenShift </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[OpenShift] Concept - Image Stream</title>
      <link href="/blog/2017/11/06/OpenShift/OpenShift-Concept-ImageStream/"/>
      <url>/blog/2017/11/06/OpenShift/OpenShift-Concept-ImageStream/</url>
      <content type="html"><![CDATA[<h1 id="What-is-Image-Stream"><a href="#What-is-Image-Stream" class="headerlink" title="What is Image Stream?"></a>What is Image Stream?</h1><p>每一個 image stream 代表著一個 Docker-formatted container image；它其實只是一個在 OpenShift 中內部對於 docker image 的命名方式，讓系統可以使用指定的名稱找到正確的 docker image 來使用。(類似 Docker 中對每個 image 使用 tag 來命名)</p><p>也因為有自己內部的命名方式，因此 Image Stream 就可以包含以下來源的 image：</p><ul><li><p>OpenShift 內部的 container registry</p></li><li><p>其他的 image stream</p></li><li><p>外部的 image repository (例如：DockerHub, CoreOS Quay)</p></li></ul><p>在 OpenShift 中，image stream 可與 Build &amp; Deployment 搭配完成特定的自動化功能；由於 Build &amp; Deployment 都可以監控特定 image stream，當 image stream 指向的 image 有新版產生時，可自動的進行特定的 build or deploy 的工作。</p><hr><h1 id="建立第一個-Image-Stream"><a href="#建立第一個-Image-Stream" class="headerlink" title="建立第一個 Image Stream"></a>建立第一個 Image Stream</h1><p>以下是一個 ImageStream 的定義範例：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ImageStream</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">"myubuntu:xenial"</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  tags:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">'16.04'</span></span><br><span class="line"><span class="attr">    from:</span></span><br><span class="line"><span class="attr">      kind:</span> <span class="string">DockerImage</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">ubuntu</span></span><br></pre></td></tr></table></figure><p>透過以上的 image stream 定義，在 OpenShift Build or Deployment 中，就可以使用 <code>myubuntu:xenial</code> 指定外部 DockerHub 中的 <code>ubuntu:16.04</code> image。</p><p>當以上 ImageStream 被建立後，我們可以查詢到以下資訊：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ oc get is</span><br><span class="line">NAME       DOCKER REPO                                           TAGS      UPDATED</span><br><span class="line">myubuntu   docker-registry.default.svc:5000/leon-test/myubuntu   16.04     2 seconds ago</span><br></pre></td></tr></table></figure><p>若使用 <code>oc get is/myubuntu -o=yaml</code> 指令檢視 YAML 輸出，得到以下內容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ImageStream</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">openshift.io/image.dockerRepositoryCheck:</span> <span class="number">2017</span><span class="bullet">-11</span><span class="bullet">-06</span><span class="attr">T04:12:59Z</span></span><br><span class="line"><span class="attr">  creationTimestamp:</span> <span class="number">2017</span><span class="bullet">-11</span><span class="bullet">-06</span><span class="attr">T04:12:58Z</span></span><br><span class="line"><span class="attr">  generation:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">myubuntu</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">leon-test</span></span><br><span class="line"><span class="attr">  resourceVersion:</span> <span class="string">"9145705"</span></span><br><span class="line"><span class="attr">  selfLink:</span> <span class="string">/oapi/v1/namespaces/leon-test/imagestreams/myubuntu</span></span><br><span class="line"><span class="attr">  uid:</span> <span class="string">c59725ce-c2a8-11e7-a13b-faf564e56811</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  lookupPolicy:</span></span><br><span class="line"><span class="attr">    local:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  tags:</span></span><br><span class="line"><span class="attr">  - annotations:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">    from:</span></span><br><span class="line"><span class="attr">      kind:</span> <span class="string">DockerImage</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">ubuntu</span></span><br><span class="line"><span class="attr">    generation:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">    importPolicy:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">"16.04"</span></span><br><span class="line"><span class="attr">    referencePolicy:</span></span><br><span class="line"><span class="attr">      type:</span> <span class="string">Source</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line"><span class="attr">  dockerImageRepository:</span> <span class="string">docker-registry.default.svc:5000/leon-test/myubuntu</span></span><br><span class="line"><span class="attr">  tags:</span></span><br><span class="line"><span class="attr">  - items:</span></span><br><span class="line"><span class="attr">    - created:</span> <span class="number">2017</span><span class="bullet">-11</span><span class="bullet">-06</span><span class="attr">T04:12:59Z</span></span><br><span class="line"><span class="attr">      dockerImageReference:</span> <span class="string">ubuntu@sha256:152b4ccc429f6f28533aff625d8345baf1ba3808e9a99446e86b2bf3efa18571</span></span><br><span class="line"><span class="attr">      generation:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">sha256:152b4ccc429f6f28533aff625d8345baf1ba3808e9a99446e86b2bf3efa18571</span></span><br><span class="line"><span class="attr">    tag:</span> <span class="string">"16.04"</span></span><br></pre></td></tr></table></figure><hr><h1 id="Image-Stream-Image"><a href="#Image-Stream-Image" class="headerlink" title="Image Stream Image"></a>Image Stream Image</h1><p>image stream image(簡稱 <strong>isimage</strong>) 是一種 virtual resource，讓使用者可以透過 isimage 從特定的 image stream 取得 image，isimage 以 <code>&lt;image stream name&gt;@&lt;image name&gt;</code> 的方式呈現，因此以上面的範例來看，image steam image 就會是：</p><blockquote><p>myubuntu@sha256:152b4ccc429f6f28533aff625d8345baf1ba3808e9a99446e86b2bf3efa18571</p></blockquote><hr><h1 id="Image-Stream-Tag"><a href="#Image-Stream-Tag" class="headerlink" title="Image Stream Tag"></a>Image Stream Tag</h1><p>image stream tag(簡稱 <strong>istag</strong>) 是一個指到上面 image stream image 的 name pointer，可指向 local or 外部的 image，此外 isiage 還包含了 image 內容變動的歷史紀錄，這樣的設計讓使用者可以在有需要的時候方便的進行 rollback。</p><p>istag 以 <code>&lt;image stream name&gt;:&lt;tag&gt;</code> 的方式呈現，因此以上面的範例來看， istag 就會是：</p><blockquote><p>　myubuntu:16.04</p></blockquote><hr><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>有了 Image Stream(is), Image Stream Image (isimage), 以及 Image Stream Tag(istag) 的觀念之後，下一個階段將會介紹如何在 OpenShift 中管理 Image。</p><hr><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><p><a href="https://docs.openshift.com/container-platform/3.6/architecture/core_concepts/builds_and_image_streams.html" target="_blank" rel="noopener">Builds and Image Streams - Core Concepts | Architecture | OpenShift Container Platform 3.6</a></p></li><li><p><a href="https://docs.openshift.com/enterprise/3.0/architecture/core_concepts/builds_and_image_streams.html" target="_blank" rel="noopener">Builds and Image Streams - Core Concepts | Architecture | OpenShift Enterprise 3.0</a></p></li><li><p><a href="https://github.com/openshift/origin/tree/master/examples/image-streams" target="_blank" rel="noopener">OpenShift ImageStream Examples @GitHub</a></p></li><li><p><a href="https://docs.openshift.com/container-platform/3.6/dev_guide/managing_images.html" target="_blank" rel="noopener">Managing Images | Developer Guide | OpenShift Container Platform 3.6</a></p></li></ul>]]></content>
      
      <categories>
          
          <category> OpenShift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenShift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kubernetes 學習筆記</title>
      <link href="/blog/2017/06/29/Kubernetes/Learning-Kubernetes/"/>
      <url>/blog/2017/06/29/Kubernetes/Learning-Kubernetes/</url>
      <content type="html"><![CDATA[<p>此篇文章為研究 Kubernetes 時所留下的學習筆記索引</p><h1 id="Concepts"><a href="#Concepts" class="headerlink" title="Concepts"></a>Concepts</h1><h2 id="kubeconfig"><a href="#kubeconfig" class="headerlink" title="kubeconfig"></a>kubeconfig</h2><ul><li><a href="https://github.com/godleon/learning_kubernetes/blob/master/concept/howto_configure_kubeconfig.md" target="_blank" rel="noopener">如何設定 kubeconfig 與 Kubernetes cluster 互動</a></li></ul><h2 id="Overview-amp-Components"><a href="#Overview-amp-Components" class="headerlink" title="Overview &amp; Components"></a>Overview &amp; Components</h2><ul><li><p><a href="https://github.com/godleon/learning_kubernetes/blob/master/concept/component_overview.md" target="_blank" rel="noopener">組成元件概觀</a></p></li><li><p><a href="https://github.com/godleon/learning_kubernetes/blob/master/concept/overview.md" target="_blank" rel="noopener">Kubernetes Overview</a></p></li></ul><h2 id="Networking"><a href="#Networking" class="headerlink" title="Networking"></a>Networking</h2><ul><li><p><a href="https://github.com/godleon/learning_kubernetes/blob/master/concept/network/service.md" target="_blank" rel="noopener">Service</a></p></li><li><p><a href="https://github.com/godleon/learning_kubernetes/blob/master/concept/network/ingress.md" target="_blank" rel="noopener">Ingress</a></p></li></ul><h2 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h2><ul><li><a href="https://github.com/godleon/learning_kubernetes/blob/master/concept/storage/volume.md" target="_blank" rel="noopener">Volume, PersistentVolume &amp; PersistentVolumeClaim</a></li></ul><hr><h1 id="Operating"><a href="#Operating" class="headerlink" title="Operating"></a>Operating</h1><ul><li><p><a href="https://kubernetes.io/docs/reference/kubectl/cheatsheet/" target="_blank" rel="noopener">kubectl Cheat Sheet - Kubernetes</a></p></li><li><p><a href="https://github.com/godleon/learning_kubernetes/blob/master/operation/basic.md" target="_blank" rel="noopener">Kubernetes 基本操作</a></p></li></ul><h2 id="Persistent-Volume"><a href="#Persistent-Volume" class="headerlink" title="Persistent Volume"></a>Persistent Volume</h2><ul><li><a href="https://github.com/godleon/learning_kubernetes/blob/master/operation/use_PersistentVolume_NFS.md" target="_blank" rel="noopener">使用 Persistent Volume - 以 NFS 為例</a></li></ul><h1 id="學習資源"><a href="#學習資源" class="headerlink" title="學習資源"></a>學習資源</h1><ul><li><a href="http://docs.kubernetes.org.cn/" target="_blank" rel="noopener">Kubernetes(K8S)中文文档_Kubernetes中文社区</a></li></ul>]]></content>
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ceph 簡單指令操作</title>
      <link href="/blog/2017/05/25/Ceph/Ceph-Cheatsheet/"/>
      <url>/blog/2017/05/25/Ceph/Ceph-Cheatsheet/</url>
      <content type="html"><![CDATA[<h1 id="Monitoring-and-Health"><a href="#Monitoring-and-Health" class="headerlink" title="Monitoring and Health"></a>Monitoring and Health</h1><p>剛安裝完，首先先檢查 ceph cluster 的狀態：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 檢視 ceph cluster status</span></span><br><span class="line">$ ceph -s</span><br><span class="line">    cluster cd6fcb41-c373-48fb-aab3-f8d330a26ccb</span><br><span class="line">     health HEALTH_WARN</span><br><span class="line">            too few PGs per OSD (16 &lt; min 30)</span><br><span class="line">     monmap e1: 3 mons at &#123;ceph01=10.102.41.101:6789/0,ceph02=10.102.41.102:6789/0,ceph03=10.102.41.103:6789/0&#125;</span><br><span class="line">            election epoch 8, quorum 0,1,2 ceph01,ceph02,ceph03</span><br><span class="line">     osdmap e36: 12 osds: 12 up, 12 <span class="keyword">in</span></span><br><span class="line">            flags sortbitwise,require_jewel_osds</span><br><span class="line">      pgmap v84: 64 pgs, 1 pools, 0 bytes data, 0 objects</span><br><span class="line">            405 MB used, 2174 GB / 2174 GB avail</span><br><span class="line">                  64 active+clean</span><br></pre></td></tr></table></figure><blockquote><p>也可以用 <code>ceph -w</code> 檢視即時的狀態</p></blockquote><p>檢查健康狀態：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ceph health detail</span><br><span class="line">HEALTH_WARN too few PGs per OSD (16 &lt; min 30)</span><br><span class="line">too few PGs per OSD (16 &lt; min 30)</span><br></pre></td></tr></table></figure><p>接著檢視目前 ceph cluster 提供了多少容量可用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 檢視目前可用的容量、每個 pool 的使用狀況 &amp; quota 等資訊</span></span><br><span class="line">$ ceph df</span><br><span class="line">GLOBAL:</span><br><span class="line">    SIZE      AVAIL     RAW USED     %RAW USED </span><br><span class="line">    2174G     2174G         405M          0.02 </span><br><span class="line">POOLS:</span><br><span class="line">    NAME     ID     USED     %USED     MAX AVAIL     OBJECTS </span><br><span class="line">    rbd      0         0         0          724G           0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 連到 CRUSH tree, 顯示 weight, variance, capacity ... etc</span></span><br><span class="line">$ ceph osd df tree</span><br><span class="line">ID WEIGHT  REWEIGHT SIZE  USE    AVAIL %USE VAR  PGS TYPE NAME       </span><br><span class="line">-1 2.12384        - 2174G   405M 2174G 0.02 1.00   0 root default    </span><br><span class="line">-2 0.70795        -  724G   135M  724G 0.02 1.00   0     host ceph01 </span><br><span class="line"> 0 0.17699  1.00000  181G 35200k  181G 0.02 1.02  11         osd.0   </span><br><span class="line"> 3 0.17699  1.00000  181G 34708k  181G 0.02 1.00  19         osd.3   </span><br><span class="line"> 6 0.17699  1.00000  181G 34420k  181G 0.02 0.99  14         osd.6   </span><br><span class="line"> 8 0.17699  1.00000  181G 34336k  181G 0.02 0.99  20         osd.8   </span><br><span class="line">-3 0.70795        -  724G   135M  724G 0.02 1.00   0     host ceph03 </span><br><span class="line"> 1 0.17699  1.00000  181G 35568k  181G 0.02 1.03  17         osd.1   </span><br><span class="line"> 5 0.17699  1.00000  181G 34432k  181G 0.02 0.99  12         osd.5   </span><br><span class="line"> 9 0.17699  1.00000  181G 34272k  181G 0.02 0.99  18         osd.9   </span><br><span class="line">11 0.17699  1.00000  181G 34200k  181G 0.02 0.99  17         osd.11  </span><br><span class="line">-4 0.70795        -  724G   135M  724G 0.02 1.00   0     host ceph02 </span><br><span class="line"> 2 0.17699  1.00000  181G 35076k  181G 0.02 1.01  19         osd.2   </span><br><span class="line"> 4 0.17699  1.00000  181G 34652k  181G 0.02 1.00  18         osd.4   </span><br><span class="line"> 7 0.17699  1.00000  181G 34456k  181G 0.02 0.99  11         osd.7   </span><br><span class="line">10 0.17699  1.00000  181G 34280k  181G 0.02 0.99  16         osd.10  </span><br><span class="line">              TOTAL 2174G   405M 2174G 0.02</span><br></pre></td></tr></table></figure><h1 id="Working-with-Pools-and-OSDs"><a href="#Working-with-Pools-and-OSDs" class="headerlink" title="Working with Pools and OSDs"></a>Working with Pools and OSDs</h1><p>若要尋找單顆 OSD 的相關資訊：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 尋找 OSD physical location</span></span><br><span class="line">$ ceph osd find 1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"osd"</span>: 1,</span><br><span class="line">    <span class="string">"ip"</span>: <span class="string">"10.102.41.103:6800\/63011"</span>,</span><br><span class="line">    <span class="string">"crush_location"</span>: &#123;</span><br><span class="line">        <span class="string">"host"</span>: <span class="string">"ceph03"</span>,</span><br><span class="line">        <span class="string">"root"</span>: <span class="string">"default"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示指定 OSD metadata</span></span><br><span class="line">$ ceph osd metadata 1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"id"</span>: 1,</span><br><span class="line">    <span class="string">"arch"</span>: <span class="string">"x86_64"</span>,</span><br><span class="line">    <span class="string">"back_addr"</span>: <span class="string">"10.102.41.103:6801\/63011"</span>,</span><br><span class="line">    <span class="string">"backend_filestore_dev_node"</span>: <span class="string">"unknown"</span>,</span><br><span class="line">    <span class="string">"backend_filestore_partition_path"</span>: <span class="string">"unknown"</span>,</span><br><span class="line">    <span class="string">"ceph_version"</span>: <span class="string">"ceph version 10.2.5-37.el7cp (033f137cde8573cfc5a4662b4ed6a63b8a8d1464)"</span>,</span><br><span class="line">    ......</span><br><span class="line">    <span class="string">"osd_data"</span>: <span class="string">"\/var\/lib\/ceph\/osd\/ceph-1"</span>,</span><br><span class="line">    <span class="string">"osd_journal"</span>: <span class="string">"\/var\/lib\/ceph\/osd\/ceph-1\/journal"</span>,</span><br><span class="line">    <span class="string">"osd_objectstore"</span>: <span class="string">"filestore"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立/移除 pool: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立 pool, 名稱為 pve_image, pg 數量為 1024</span></span><br><span class="line">$ ceph osd pool create pve_images 1024</span><br><span class="line">pool <span class="string">'pve_images'</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示目前 pool 詳細狀態</span></span><br><span class="line">$ ceph osd pool ls detail</span><br><span class="line">pool 0 <span class="string">'rbd'</span> replicated size 3 min_size 2 crush_ruleset 0 object_hash rjenkins pg_num 64 pgp_num 64 last_change 1 flags hashpspool stripe_width 0</span><br><span class="line">pool 1 <span class="string">'pve_images'</span> replicated size 3 min_size 2 crush_ruleset 0 object_hash rjenkins pg_num 1024 pgp_num 1024 last_change 37 flags hashpspool stripe_width 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示指定 pool 的詳細資料</span></span><br><span class="line">$ ceph osd pool get pve_images all</span><br><span class="line">size: 3</span><br><span class="line">min_size: 2</span><br><span class="line">crash_replay_interval: 0</span><br><span class="line">pg_num: 1024</span><br><span class="line">pgp_num: 1024</span><br><span class="line">crush_ruleset: 0</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除 pool (要重複 pool name 兩次還要加上那有趣的參數)</span></span><br><span class="line">$ ceph osd pool delete pve_images pve_images --yes-i-really-really-mean-it</span><br><span class="line">pool <span class="string">'pve_images'</span> removed</span><br></pre></td></tr></table></figure><p>調整現有 pool 的狀態：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 設定 placement groups 的數量</span></span><br><span class="line">$ ceph osd pool <span class="built_in">set</span> rbd pg_num 384</span><br><span class="line"><span class="built_in">set</span> pool 0 pg_num to 384</span><br><span class="line"></span><br><span class="line"><span class="comment"># pgp =&gt; The effective number of placement groups to use when calculating data placement.</span></span><br><span class="line">$ ceph osd pool <span class="built_in">set</span> rbd pgp_num 384</span><br><span class="line"><span class="built_in">set</span> pool 0 pgp_num to 384</span><br><span class="line"></span><br><span class="line"><span class="comment"># 調整完就會從原本的 warning 狀態變成 health_ok 了!</span></span><br><span class="line">$ ceph -s</span><br><span class="line">    cluster cd6fcb41-c373-48fb-aab3-f8d330a26ccb</span><br><span class="line">     health HEALTH_OK</span><br><span class="line">     monmap e1: 3 mons at &#123;ceph01=10.102.41.101:6789/0,ceph02=10.102.41.102:6789/0,ceph03=10.102.41.103:6789/0&#125;</span><br><span class="line">            election epoch 8, quorum 0,1,2 ceph01,ceph02,ceph03</span><br><span class="line">     osdmap e47: 12 osds: 12 up, 12 <span class="keyword">in</span></span><br><span class="line">            flags sortbitwise,require_jewel_osds</span><br><span class="line">      pgmap v177: 384 pgs, 1 pools, 0 bytes data, 0 objects</span><br><span class="line">            461 MB used, 2174 GB / 2174 GB avail</span><br><span class="line">                 384 active+clean</span><br></pre></td></tr></table></figure><h1 id="RBD-Block-Storage"><a href="#RBD-Block-Storage" class="headerlink" title="RBD Block Storage"></a>RBD Block Storage</h1><p>這個部份是用在把 Ceph 作為 block-based storage 時所需要了解的指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 顯示目前的 RBD volume</span></span><br><span class="line">$ rbd ls</span><br><span class="line">vm-101-disk-1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示指定 RBD volume 的狀態</span></span><br><span class="line">$ rbd status vm-101-disk-1</span><br><span class="line">Watchers:</span><br><span class="line">watcher=10.102.70.124:0/3361738208 client.143192 cookie=140498849842176</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示指定 RBD volume 的相關資訊</span></span><br><span class="line">$ rbd info vm-101-disk-1</span><br><span class="line">rbd image <span class="string">'vm-101-disk-1'</span>:</span><br><span class="line">size 32768 MB <span class="keyword">in</span> 8192 objects</span><br><span class="line">order 22 (4096 kB objects)</span><br><span class="line">block_name_prefix: rbd_data.22f52238e1f29</span><br><span class="line">format: 2</span><br><span class="line">features: layering, exclusive-lock, object-map, fast-diff, deep-flatten</span><br><span class="line">flags: </span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除指定的 RBD volume</span></span><br><span class="line">$ rbd rm vm-101-disk-1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立名稱為 Jenkins_Data，大小為 40GB 的 RBD volume</span></span><br><span class="line">$ rbd create --pool rbd --image Jenkins_Data --size 40960</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視 RBD volume 資訊</span></span><br><span class="line">$ rbd --image Jenkins_Data info</span><br><span class="line">rbd image <span class="string">'Jenkins_Data'</span>:</span><br><span class="line">size 40960 MB <span class="keyword">in</span> 10240 objects</span><br><span class="line">order 22 (4096 kB objects)</span><br><span class="line">block_name_prefix: rbd_data.a71d6238e1f29</span><br><span class="line">format: 2</span><br><span class="line">features: layering, exclusive-lock, object-map, fast-diff, deep-flatten</span><br><span class="line">flags: </span><br><span class="line"></span><br><span class="line"><span class="comment"># 變更 RBD volume 大小，縮小要加上 "--allow-shrink" 以確保安全</span></span><br><span class="line">$ rbd --image Jenkins_Data resize --size 10240 --allow-shrink</span><br><span class="line">Resizing image: 100% complete...done.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 確認 RBD volume 容量正確變更</span></span><br><span class="line">$ rbd --image Jenkins_Data info</span><br><span class="line">rbd image <span class="string">'Jenkins_Data'</span>:</span><br><span class="line">size 10240 MB <span class="keyword">in</span> 2560 objects</span><br><span class="line">order 22 (4096 kB objects)</span><br><span class="line">block_name_prefix: rbd_data.a71d6238e1f29</span><br><span class="line">format: 2</span><br><span class="line">features: layering, exclusive-lock, object-map, fast-diff, deep-flatten</span><br><span class="line">flags: </span><br><span class="line"></span><br><span class="line"><span class="comment"># 放大 RBD Volume</span></span><br><span class="line">$ rbd --image Jenkins_Data resize --size 20480</span><br><span class="line">Resizing image: 100% complete...done.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 確認 RBD volume 容量正確變更</span></span><br><span class="line">$ rbd --image Jenkins_Data info</span><br><span class="line">rbd image <span class="string">'Jenkins_Data'</span>:</span><br><span class="line">size 20480 MB <span class="keyword">in</span> 5120 objects</span><br><span class="line">order 22 (4096 kB objects)</span><br><span class="line">block_name_prefix: rbd_data.a71d6238e1f29</span><br><span class="line">format: 2</span><br><span class="line">features: layering, exclusive-lock, object-map, fast-diff, deep-flatten</span><br><span class="line">flags:</span><br></pre></td></tr></table></figure><h1 id="Authentication-and-Authorization"><a href="#Authentication-and-Authorization" class="headerlink" title="Authentication and Authorization"></a>Authentication and Authorization</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 檢視目前可使用 ceph cluster 的 user list</span></span><br><span class="line">$ ceph auth list</span><br><span class="line">installed auth entries:</span><br><span class="line"></span><br><span class="line">osd.0</span><br><span class="line">key: ABxxxxxxx</span><br><span class="line">caps: [mon] allow profile osd</span><br><span class="line">caps: [osd] allow *</span><br><span class="line">......</span><br><span class="line">client.admin</span><br><span class="line">key: ABxxxxxxx</span><br><span class="line">caps: [mds] allow *</span><br><span class="line">caps: [mon] allow *</span><br><span class="line">caps: [osd] allow *</span><br><span class="line">client.bootstrap-mds</span><br><span class="line">key: ABxxxxxxx</span><br><span class="line">caps: [mon] allow profile bootstrap-mds</span><br><span class="line">client.bootstrap-osd</span><br><span class="line">key: ABxxxxxxx</span><br><span class="line">caps: [mon] allow profile bootstrap-osd</span><br><span class="line">client.bootstrap-rgw</span><br><span class="line">key: ABxxxxxxx</span><br><span class="line">caps: [mon] allow profile bootstrap-rgw</span><br></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><p><a href="https://www.gitbook.com/book/tobegit3hub1/ceph_from_scratch/details" target="_blank" rel="noopener">Ceph From Scratch · GitBook</a></p></li><li><p><a href="https://sabaini.at/pages/ceph-cheatsheet.html" target="_blank" rel="noopener">Ceph Cheatsheet - sabaini.at</a></p></li><li><p><a href="http://michaelkang.blog.51cto.com/1553154/1698287" target="_blank" rel="noopener">最新ceph集群常用命令梳理 - 康建华 - 51CTO技术博客</a></p></li><li><p><a href="http://docs.ceph.com/docs/jewel/rados/operations/pools/" target="_blank" rel="noopener">Pools — Ceph Documentation</a></p></li><li><p><a href="http://docs.ceph.com/docs/master/rados/operations/placement-groups/" target="_blank" rel="noopener">Placement Groups — Ceph Documentation</a></p></li></ul>]]></content>
      
      <categories>
          
          <category> Ceph </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ceph </tag>
            
            <tag> SDS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AWS 學習筆記 - S3(Simple Storage Service)</title>
      <link href="/blog/2017/05/14/AWS/AWS-Learning-Notes-S3/"/>
      <url>/blog/2017/05/14/AWS/AWS-Learning-Notes-S3/</url>
      <content type="html"><![CDATA[<h1 id="What-is-S3"><a href="#What-is-S3" class="headerlink" title="What is S3?"></a>What is S3?</h1><p>Amazon Simple Storage Service (Amazon S3) is object storage with a simple web service interface to store and retrieve any amount of data from anywhere on the web. It is designed to deliver 99.999999999% durability, and scale past trillions of objects worldwide.</p><p>Customers use S3 as primary storage for cloud-native applications; as a bulk repository, or “<a href="https://aws.amazon.com/big-data/data-lake-on-aws/download/" target="_blank" rel="noopener">data lake</a>,” for analytics; as a target for <a href="https://aws.amazon.com/backup-recovery/getting-started/" target="_blank" rel="noopener">backup &amp; recovery</a> and disaster recovery; and with <a href="https://aws.amazon.com/lambda/details/" target="_blank" rel="noopener">serverless computing</a>.</p><p>It’s simple to move large volumes of data into or out of Amazon S3 with Amazon’s <a href="https://aws.amazon.com/cloud-data-migration/" target="_blank" rel="noopener">cloud data migration</a> options. Once data is stored in S3, it can be automatically tiered into lower cost, longer-term cloud storage classes like S3 Standard - Infrequent Access and <a href="https://aws.amazon.com/glacier/details/" target="_blank" rel="noopener">Amazon Glacier</a> for archiving.</p><h1 id="S3-The-Basics"><a href="#S3-The-Basics" class="headerlink" title="S3 - The Basics"></a>S3 - The Basics</h1><ul><li><p>單一檔案大小的限制為 <code>0 bytes</code> ~ <code>5 TB</code></p></li><li><p>檔案一律存在 bucket 中 (Bucket 裏面無法再放一個 bucket，但可以放 folder)</p></li><li><p>單一帳號預設最大上限可存放 100 個 buckets，但可以通知 AWS 協助放大上限</p></li><li><p>S3 裡面的每個 bucket 都會有一個全球獨一無二的 DNS 名稱(ex: <a href="https://s3-eu-west-1.amazonaws.com/YOUR_UNIQUE_BUCKET_NAME" target="_blank" rel="noopener">https://s3-eu-west-1.amazonaws.com/YOUR_UNIQUE_BUCKET_NAME</a>)</p><blockquote><p>因此可以做為 static website hosting 之用</p></blockquote></li><li><p>成功上傳檔案到 S3 後，會收到 HTTP 200 的回應</p></li><li><p>Built for 99.99% availability for S3 platform</p></li><li><p>Amazon 實際保證 99.9% availability</p></li><li><p>Amazon 保證 11 個 9 的 durability for S3 information (資料遺失的可能性)</p><blockquote><p>為避免人為不小心刪除的狀況發生，最好的方法還是建議把 versioning, cross-regsion replication, MFA 刪除等機制啟用</p></blockquote></li><li><p>Tiered Storage available</p></li><li><p>Lifecycle Management</p><blockquote><p>可以設定前 30 天在正常的 <strong>standard</strong> tier, 接著 30 天移到另外一個 IA(Infrequently Accessed) tier, 90 天後進行 archive</p></blockquote></li><li><p>Versioning</p></li><li><p>Encryption</p></li><li><p>可透過 Access Control Lists &amp; Bucket Policies 來提升安全性</p><blockquote><p>剛建立好的 bucket or 上傳的 object 所預設的權限僅限於自己可以存取(private &amp; inaccessible)，完全沒有預設對外開放的規則</p></blockquote></li></ul><h1 id="Data-Consistency-Model-for-S3"><a href="#Data-Consistency-Model-for-S3" class="headerlink" title="Data Consistency Model for S3"></a>Data Consistency Model for S3</h1><ul><li><p>Read after consistency for PUTS of new Object (新增檔案後馬上就可以讀取)</p></li><li><p>Eventually Consistency for overwrite PUTS and DELETES(can take some time to propagate)</p><blockquote><p>若是針對已經存在的檔案進行修改 or 刪除，這樣的變更需要花點時間才會完全套用到所有的硬體設施中</p></blockquote></li></ul><h1 id="S3-is-a-simple-key-value-store"><a href="#S3-is-a-simple-key-value-store" class="headerlink" title="S3 is a simple key, value store"></a>S3 is a simple key, value store</h1><p>S3 is object based. 每個 object 都包含以下資訊：</p><ul><li><p><strong>Key</strong>: object name (檔案會依照字母順序排序，新增時要考量這個問題，建議在每個檔案名稱前 random 一個字串作為開始)</p></li><li><p><strong>Value</strong>: 基本上就是此檔案的資料本身</p></li><li><p><strong>Version ID</strong>: 作為版本控管之用</p></li><li><p><strong>Metadata</strong>: 額外用來記錄 object 相關資訊的資料(ex: 上傳檔案的時間、最後變更的時間…etc)</p><blockquote><p>使用者也可以自訂客製化的 metadata，藉此來為 object 標註不同的屬性值</p></blockquote></li><li><p><strong>Subresources</strong></p><ul><li>Access Control Lists (用來做細部的存取控管)</li><li>Torrent (S3 支援 bittorrent protocol)</li></ul></li></ul><h1 id="S3-vs-Glacier"><a href="#S3-vs-Glacier" class="headerlink" title="S3 vs Glacier"></a>S3 vs Glacier</h1><table><thead><tr><th></th><th style="text-align:center">Standard</th><th style="text-align:center">Standard - IA</th><th style="text-align:center">Glacier</th></tr></thead><tbody><tr><td>Designed for Durability</td><td style="text-align:center">11 x 9’s</td><td style="text-align:center">11 x 9’s</td><td style="text-align:center">11 x 9’s</td></tr><tr><td>Designed for Availability</td><td style="text-align:center">99.99%</td><td style="text-align:center">99.99%</td><td style="text-align:center">N/A</td></tr><tr><td>Availability SLA</td><td style="text-align:center">99.9%</td><td style="text-align:center">99%</td><td style="text-align:center">N/A</td></tr><tr><td>Minumum Object Size</td><td style="text-align:center">N/A</td><td style="text-align:center">128KB</td><td style="text-align:center">N/A</td></tr><tr><td>Minumum Storage Duration</td><td style="text-align:center">N/A</td><td style="text-align:center">30 days</td><td style="text-align:center">90 days</td></tr><tr><td>Retrieval Fee</td><td style="text-align:center">N/A</td><td style="text-align:center">per GB retrieved</td><td style="text-align:center">per GB retrieved</td></tr><tr><td>First Byte Latency</td><td style="text-align:center">ms</td><td style="text-align:center">ms</td><td style="text-align:center">select minutes or hours</td></tr><tr><td>Storage Class</td><td style="text-align:center">object level</td><td style="text-align:center">object level</td><td style="text-align:center">object level</td></tr><tr><td>Lifecycle Transitions</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td><td style="text-align:center">yes</td></tr></tbody></table><table><thead><tr><th style="text-align:center">S3</th><th style="text-align:center">Glacier</th></tr></thead><tbody><tr><td style="text-align:center">up to 5TB object</td><td style="text-align:center">up to 40TB archive</td></tr><tr><td style="text-align:center">user-definable key</td><td style="text-align:center">system-generated archive ID</td></tr><tr><td style="text-align:center">encrypt is optional</td><td style="text-align:center">automatically encrypted</td></tr></tbody></table><h1 id="S3-收費標準"><a href="#S3-收費標準" class="headerlink" title="S3 收費標準"></a>S3 收費標準</h1><ul><li><p>Storage Pricing</p></li><li><p>Request Pricing</p></li><li><p>Storage Management Pricing</p><blockquote><p>例如：analysis, tagging, inventory check</p></blockquote></li><li><p>Data Transfer Pricing</p><blockquote><p>資料存入 S3 免費，往其他地方傳則要付費，即使是 region 之間互傳</p></blockquote></li><li><p>Transfer Acceleration</p><blockquote><p>Amazon S3 Transfer Acceleration enables fast, easy, and secure transfers of files over long distances between your client and an S3 bucket. Transfer Acceleration takes advantage of Amazon CloudFront’s globally distributed edge locations. As the data arrives at an edge location, data is routed to Amazon S3 over an optimized network path.</p></blockquote></li></ul><h1 id="Advanced-Features"><a href="#Advanced-Features" class="headerlink" title="Advanced Features"></a>Advanced Features</h1><h2 id="Prefix-amp-Delimiter"><a href="#Prefix-amp-Delimiter" class="headerlink" title="Prefix &amp; Delimiter"></a>Prefix &amp; Delimiter</h2><p>以下面的 object 名稱為例：</p><blockquote><p>logs/2016/January/server42.log<br>logs/2016/February/server42.log<br>logs/2016/March/server42.log</p></blockquote><ul><li><p>S3 可透過 prefix &amp; delimiter 作到類似檔案階層的功能(hierachy &amp; folder)，但事實那些都只是透過 object 的檔名虛構出來的，並沒有實際階層功能</p></li><li><p>REST API, SDK, CLI, Management Console 都支援使用 prefix &amp; delimiter</p></li><li><p>與 IAM or S3 Bucket Plicies 搭配，可以在單一個 bucket 中達成像是 department subdirectories, user home directories … 等效果</p></li></ul><h2 id="Storage-Tiers-Classes"><a href="#Storage-Tiers-Classes" class="headerlink" title="Storage Tiers/Classes"></a>Storage Tiers/Classes</h2><table><thead><tr><th></th><th style="text-align:center">Standard</th><th style="text-align:center">Standard (Infrequent Access)</th><th style="text-align:center">Reduced Redundancy Storage</th></tr></thead><tbody><tr><td>Durability</td><td style="text-align:center">99.999999999%</td><td style="text-align:center">99.999999999%</td><td style="text-align:center">99.99%</td></tr><tr><td>Availability</td><td style="text-align:center">99.99%</td><td style="text-align:center">99.99%</td><td style="text-align:center">99.99%</td></tr><tr><td>Concurrect facility fault tolerance</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr><tr><td>SSL support</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td></tr><tr><td>First byte latency</td><td style="text-align:center">Miliseconds</td><td style="text-align:center">Miliseconds</td><td style="text-align:center">Miliseconds</td></tr><tr><td>Lifecycle Management Policies</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td></tr><tr><td>附註</td><td style="text-align:center"></td><td style="text-align:center">object 大小限制為最小 128KB, 最少要存放 30 天, 存取資料要額外收費</td></tr></tbody></table><h3 id="1-Standard"><a href="#1-Standard" class="headerlink" title="1. Standard"></a>1. Standard</h3><p>99.99 availability, 99.999999999% durability, stored redundantly across multiple devices in multiple facilities and is designed to sustain the loss of 2 facilities concurrently.</p><h3 id="2-IA-Infrequently-Accessed"><a href="#2-IA-Infrequently-Accessed" class="headerlink" title="2. IA(Infrequently Accessed)"></a>2. IA(Infrequently Accessed)</h3><p>適合不常存取的資料，比 standard 便宜，要存取時可以馬上取得，但存取需要額外付費</p><h3 id="3-Reduced-Redundancy-Storage-RRS"><a href="#3-Reduced-Redundancy-Storage-RRS" class="headerlink" title="3. Reduced Redundancy Storage (RRS)"></a>3. Reduced Redundancy Storage (RRS)</h3><p>Design to provide 99.99% durability and 99.99 availability of objects over a given year.</p><blockquote><p>durability 從 <strong>11 x 9’s</strong> 變成 <strong>4 x 9’s</strong>，適合存像是圖片的 thumb nails 之類的資料</p></blockquote><h3 id="4-Glacier"><a href="#4-Glacier" class="headerlink" title="4. Glacier"></a>4. Glacier</h3><ul><li><p>very cheap, but used for archival only. </p></li><li><p>存取前需先執行 restore 命令，並需要等待 3~5 個小時的資料準備時間</p></li><li><p>Glacier 上的資料不會因為 restore 命令而刪除，除非明確執行刪除指令</p></li><li><p>資料還原時會放到 S3 <strong>RRS(Reduced Redundancy Storage)</strong> class</p></li><li><p>AWS 提供每個月免費取得 5% Glacier 資料的額度 (每日為單位計算)</p><blockquote><p>可透過設定 <strong>retrieval policy</strong> or <strong>設定 max GB-per-hour limit</strong> 來確保存取資料會在免費的額度下進行，來降低甚至避免還原費用的發生</p></blockquote></li><li><p>雖然是 S3 Storage Class 的一個選項，但其實 Glacier 是個獨立服務且有獨立的 API，並提供一些 S3 沒有的功能</p></li><li><p>可用來作為取代傳統磁帶作為長期備份的選項 (在某些行業必須有保留資料 N 年的規定)</p></li><li><p>非常可靠，也是有 11 個 9 的 durability</p></li></ul><h4 id="Archive"><a href="#Archive" class="headerlink" title="Archive"></a>Archive</h4><ul><li><p>在 Glacier 上儲存的備份單位稱為 <strong>archive</strong>（等同 S3 上 object 的概念)</p></li><li><p>每個 archive 最大可以到 <strong>40TB</strong></p></li><li><p>使用者可以擁有無限數量的 archive</p></li><li><p>每個 archive 都會有一個 unique archive ID (無法自己取名字)</p></li><li><p>所有的 archive 都會被自動加密 &amp; 無法被修改</p></li></ul><h4 id="Vault"><a href="#Vault" class="headerlink" title="Vault"></a>Vault</h4><ul><li><p>在 Glacier 中存放 archive 的容器稱為 <strong>vault</strong> (等同 S3 上 bucket 的概念)</p></li><li><p>可透過設定 IAM policy or vault access policy 來限制存取</p></li></ul><h4 id="Vaults-Locks"><a href="#Vaults-Locks" class="headerlink" title="Vaults    Locks"></a>Vaults    Locks</h4><ul><li><p>使用者可透過 Vaults    Locks 針對 Glacier 設定強制管理</p></li><li><p>可藉由設定 Write Once Read Many(WORM) 在 vault lock policy 中來套用到未來所有存放到 valut 的 archive</p></li><li><p>一旦設定了 vault lock policy，就無法再度變更規則</p></li></ul><h2 id="Lifecycle-Management"><a href="#Lifecycle-Management" class="headerlink" title="Lifecycle Management"></a>Lifecycle Management</h2><ul><li><p>等同於傳統 IT storage infra 中的 <strong>automated storage tiering</strong> 功能，是一種 data 從 <code>hot</code>(frequently    accessed) -&gt; <code>warm</code>(less    frequently    accessed) -&gt; <code>cold</code>(long-term    backup    or    archive) 的概念</p></li><li><p>Can be used in conjuction with versioning.</p></li><li><p>Can be applied to current versions and previous versions</p></li><li><p>Following actions can now be done:</p><ul><li>Transition to the <strong>Standard - Infrequent Access</strong> storage class (128Kb and 30 days after the creation date)</li><li>Archive to the <strong>Glacier</strong> storage class (30 days after IA, if relevent)</li><li>Permanently Delete (若有移到 Glacier 要把刪除的日期設為 90 天以上，因為 Glacier 費用低消是 90 days)</li></ul></li></ul><h2 id="Encryption"><a href="#Encryption" class="headerlink" title="Encryption"></a>Encryption</h2><h3 id="1-In-Transit"><a href="#1-In-Transit" class="headerlink" title="1. In Transit"></a>1. In Transit</h3><p>透過 AWS SSL API endpoints 存取 S3 (<strong>HTTPS</strong>)，存取的流量都會被加密</p><h3 id="2-At-Rest"><a href="#2-At-Rest" class="headerlink" title="2. At Rest"></a>2. At Rest</h3><h4 id="1-Server-Side-Encryption"><a href="#1-Server-Side-Encryption" class="headerlink" title="(1) Server Side Encryption"></a>(1) Server Side Encryption</h4><ul><li><p>S3 Managed Keys (<code>SSE-S3</code>)</p><blockquote><p>AWS 會將資料用 master key(AES-256) 進行加密，且 key 會定期更換，全由 AWS 託管</p></blockquote></li><li><p>AWS Key Management Service, Managed Keys (<code>SSE-KMS</code>)</p><blockquote><p>透過 KMS 指定 master key 來進行加密，<strong>需要額外支付 KMS 的費用</strong><br>但可以控管 S3 的存取，也可以確認存取 S3 的人是擁有 key 的使用者(可以搭配 AWS 的追蹤功能之道誰在何時存取了 S3 並解密，甚至可以檢視哪個沒有權限的使用者嘗試解密資料時發生的錯誤)</p></blockquote></li><li><p>Server Side Encryption with Customer Provided Keys (<code>SSE-C</code>)</p></li></ul><h4 id="2-Client-Side-Encryption-將資料加密後傳到-S3"><a href="#2-Client-Side-Encryption-將資料加密後傳到-S3" class="headerlink" title="(2) Client Side Encryption (將資料加密後傳到 S3)"></a>(2) Client Side Encryption (將資料加密後傳到 S3)</h4><p>AWS 可從兩個管道取得 data encryption key:</p><ul><li><p>AWS KMS-managed customer master key</p></li><li><p>client-side master key</p></li></ul><h2 id="Versioning"><a href="#Versioning" class="headerlink" title="Versioning"></a>Versioning</h2><ul><li><p>object 的所有版本資訊都會被保留下來，<strong>包含所有的寫入資訊甚至是刪除的資訊</strong>都會被完整保留 (<strong>同樣也要支付多倍的費用來儲存不同的版本</strong>)</p></li><li><p>Great backup tool</p></li><li><p>Once enabled, Versioning cannot be disabled, only suspended.</p></li><li><p>Integrates with Lifecycle rules</p></li><li><p>Versioning’s MFA Delete capability, which uses multi-factor authentication, can be used to provide an additional layer of security. (<strong>只能由 root 帳號啟用此功能</strong>)</p><blockquote><p>刪除 object 前必須提供 token or security code 來完成</p></blockquote></li><li><p>Cross Region Replication, requires versioning enabled on the source bucket</p></li></ul><h2 id="Pre-Signed-URLs"><a href="#Pre-Signed-URLs" class="headerlink" title="Pre-Signed URLs"></a>Pre-Signed URLs</h2><p>object owner 可以透過 <strong>pre-signed URL</strong> 的機制，提供給其他人<strong>暫時</strong>存取 object 的權限，而有效期限則是由 owner 自行指定；也可以透過來保護公開的網頁資料，避免未授權的惡意行為發生。</p><h2 id="Multipart-Upload"><a href="#Multipart-Upload" class="headerlink" title="Multipart Upload"></a>Multipart Upload</h2><p>當使用者有大檔案要上傳時，可開啟 multipart upload 的功能，檔案會被切成多個部份同時上傳，到 S3 上後會自動重組而成原本的檔案。</p><blockquote><p>建議超過 100MB 的檔案使用 multipart upload；此外，超過 5GB 的檔案一定要用 multipart upload 才可以上傳</p></blockquote><blockquote><p>可以針對未完成上傳的檔案設定 lifecycle policy，如此可以減少費用的支出，讓超過期限未完成上傳的檔案自動失效</p></blockquote><h2 id="Range-GETs"><a href="#Range-GETs" class="headerlink" title="Range    GETs"></a>Range    GETs</h2><p>可下載指定 object 的部份內容，透過指定 byte 的範圍來取得 object 的部份資料；而這功能必須透過 SDK 搭配 Range HTTP header 才能實現。</p><blockquote><p>若是網路品質很差，或是想要從很大的 Glacier 備份中取得部份資料時可能會用到</p></blockquote><h2 id="Cross-Region-Replication"><a href="#Cross-Region-Replication" class="headerlink" title="Cross-Region Replication"></a>Cross-Region Replication</h2><p>cross-region replication 允許使用者將指定 bucket 的 object 非同步的複製到其他的 region。</p><ul><li><p>啟用 cross-region replication 的功能前，必須先啟動 bucket 的 versioning 功能</p></li><li><p>任何與 object 相關的 metadata or ACL 設定更動時，都會觸發 replication 的發生</p></li><li><p>必須設定正確的 IAM policy 讓 S3 本身可以進行 replication 的工作</p></li><li><p>若是已經存在的 bucket 開啟 cross-region replication 的功能，原有的資料不會被複製，必須自行複製 or 透過額外的命令來進行資料搬移</p></li></ul><blockquote><p>此功能常被用來將 object 放在靠使用者較近的地方來減少延遲；或是滿足不同地理區域備份的需求</p></blockquote><h2 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h2><ul><li><p>針對 bucket 存取的 logging 功能預設關閉，可透過 S3 server access logs 功能開啟</p></li><li><p>log 可儲存在同一個 bucket 內，也可以存在另外一個 bucket 中；但重點是設定 prefix(例如：<code>logs/</code> or <code>bucket_name/logs/</code>) 讓後續尋找 log 方便是很重要的</p></li><li><p>log 資訊包含：</p><ul><li>requestor account &amp; IP</li><li>request time</li><li>bucket name</li><li>action (GET, PUT, LIST … etc)</li><li>response status &amp; error code</li></ul></li></ul><h2 id="Event-Notification"><a href="#Event-Notification" class="headerlink" title="Event Notification"></a>Event Notification</h2><p>event notification 可以用來在 bucket 狀態有變更(例如：上傳 object)時驅動某些事件的發生，使用者可以透過此特性來加入到 workflow 的設計，發送警告，或是執行特定工作…等等。</p><ul><li><p>設定於 bucket level</p></li><li><p>可在 object 被建立(PUT, POST, COPY or multipart upload), 被刪除(DELETE)，或是偵測到有 RRS(Reduced Redundancy Storage) object 遺失的時候發送通知</p></li><li><p>可透過 Amazon SNS(Simple Notification Service) or SQS(Simple Queue Service) 發送通知，也可以直接呼叫 AWS Lambda function</p></li></ul><h1 id="S3-Management-Console"><a href="#S3-Management-Console" class="headerlink" title="S3 Management Console"></a>S3 Management Console</h1><h2 id="Permissions"><a href="#Permissions" class="headerlink" title="Permissions"></a>Permissions</h2><p>在權限管理的部分，有分成 <code>Objects</code> &amp; <code>Object permissions</code> 兩種：</p><ol><li><p><strong>Objects</strong>: 對於 object 本身內容的存取權限</p><blockquote><p>Grant permissions to the user to list, create, overwrite, or delete objects in the bucket.</p></blockquote></li><li><p><strong>Object permissions</strong>: 對於 object 的 ACL 的存取權限，並非 object 本身</p><blockquote><p>Grant permissions to the user to read or write to an access control list (ACL) for the bucket</p></blockquote></li></ol><p>即使 bucket 的權限被設定為 public readable，也不代表後續上傳到此 bucket 的 object 也是 public readable，權限是分開管理的</p><h2 id="Versioning-1"><a href="#Versioning-1" class="headerlink" title="Versioning"></a>Versioning</h2><ul><li><p>當此功能開啟後，之後無法移除，只能關閉</p></li><li><p>上傳相同名稱的檔案多次，S3 會在介面上看到一個檔案搭配多個 version 可選 (透過檢視 metadata 可以發現其實根本就是不同的 object)</p><blockquote><p>而使用容量的計算當然就是所有版本 object 的 size 總和 (<strong>計算成本的時候要特別注意這件事情</strong>)</p></blockquote></li><li><p>若移除 object 的 version，永遠就會消失無法還原</p></li><li><p>刪除 object 之後，會在系統上留下一個 <code>Delete Marker</code>(需要在 Versions 的地方選 <strong>Show</strong> 藉以顯示所有歷程記錄)，刪除 Delete Marker 之後就可以回復原本被刪除的檔案 </p><blockquote><p>目前還原功能是在舊版的版面上找到的，新版的目前沒有看到類似的功能頁面</p></blockquote></li></ul><h1 id="S3-Transfer-Acceleration"><a href="#S3-Transfer-Acceleration" class="headerlink" title="S3 Transfer Acceleration"></a>S3 Transfer Acceleration</h1><h2 id="What-is-S3-Transfer-Acceleration"><a href="#What-is-S3-Transfer-Acceleration" class="headerlink" title="What is S3 Transfer Acceleration?"></a>What is S3 Transfer Acceleration?</h2><p>S3 Transfer Acceleration utilise the CloudFront Edge Network to accelerate your uploads to S3. Instead of uploading directly to your S3 bucket, you can use a distinct URL to upload directly to an edge location which will then transfer that file to S3. You will get a distinct URL to upload to:</p><blockquote><p>your-bucket-name.s3-accelerate.amazonaws.com</p></blockquote><p>若要上傳大量的資料到距離本地端很遠的 region，使用 S3 Transfer Acceleration 會很有幫助</p><h1 id="Create-a-Static-Website-using-S3"><a href="#Create-a-Static-Website-using-S3" class="headerlink" title="Create a Static Website using S3"></a>Create a Static Website using S3</h1><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol><li><p>建立 bucket</p></li><li><p>啟用 <strong>Static website hosting</strong></p></li></ol><blockquote><p>這裡會取得一個 <strong><a href="http://your-bucket-name.s3-website.region-alias.amazonaws.com" target="_blank" rel="noopener">http://your-bucket-name.s3-website.region-alias.amazonaws.com</a></strong> 的 domain name</p></blockquote><ol start="3"><li><p>可以額外設定 index/error pages.</p></li><li><p>依然要提供 object read permission 才可以</p></li></ol><h1 id="Exam-Tips"><a href="#Exam-Tips" class="headerlink" title="Exam Tips"></a>Exam Tips</h1><h2 id="S3-101"><a href="#S3-101" class="headerlink" title="S3 101"></a>S3 101</h2><ul><li><p>S3 is Object based.</p></li><li><p>Files can be from 0 Bytes ~ 5 TB.</p></li><li><p>There is unlimited storage.</p></li><li><p>Files are stored in Buckets.</p></li><li><p>S3 is a universal namespace, that is, names must be unique globally.</p><blockquote><p>網址的格式為: https://[RegionName].amazonaws.com/[YourBucketName]</p></blockquote></li><li><p>Read after Write consistency for PUTS of new Object</p></li><li><p>Eventual Consistency for overwrite PUTS and DELETES (can take some time to propagate)</p></li><li><p>S3 Storage Classes/Tiers</p><ul><li>S3 (durable, immediately available, frequently accessed)</li><li>S3 - IA (durable, immediately available, infrequently accessed)</li><li>S3 - Reduced Redundancy Storage (data that is easily reproducible, such as thumb nails etc)</li><li>Glacier - Archived data, where you can wait 3~5 hours before accessing</li></ul></li><li><p>Remember the core fundamentals of an S3 object</p><ul><li>Key (name)<blockquote><p>這是一個 1024 bytes 的 UTF-8 字元所組成，在同一個 bucket 內不會重複(但不同的 bucket 可能會有同樣的 key)</p></blockquote></li><li>Value (data)</li><li>version ID</li><li>metadata</li><li>subresource (ACL, torrent)</li></ul></li><li><p>Object based storage only (for files).</p></li><li><p><strong>Not suitable to install an operating system</strong>.</p></li><li><p>Successfuly upload will generate a HTTP 200 status code.</p></li></ul><h2 id="Versioning-2"><a href="#Versioning-2" class="headerlink" title="Versioning"></a>Versioning</h2><ul><li><p>object 的所有版本資訊都會被保留下來，<strong>包含所有的寫入資訊甚至是刪除的資訊</strong>都會被完整保留 (<strong>同樣也要支付多倍的費用來儲存不同的版本</strong>)</p></li><li><p>Great backup tool</p></li><li><p>Once enabled, Versioning cannot be disabled, only suspended.</p></li><li><p>Integrates with Lifecycle rules</p></li><li><p>Versioning’s MFA Delete capability, which uses multi-factor authentication, can be used to provide an additional layer of security. (<strong>只能由 root 帳號啟用此功能</strong>)</p><blockquote><p>刪除 object 前必須提供 token or security code 來完成</p></blockquote></li><li><p>Cross Region Replication, requires versioning enabled on the source bucket</p></li></ul><h2 id="Cross-Region-Replication-1"><a href="#Cross-Region-Replication-1" class="headerlink" title="Cross Region Replication"></a>Cross Region Replication</h2><ul><li><p>要啟用 cross region replication 的功能，source &amp; destination bucket 都必須要啟用 versioning 才可以</p></li><li><p>設定 replication 前已經存在的 object 不會自動被同步，只有後續上傳的 object 會被同步</p><blockquote><p>如果上傳新版的 object，原來所有版本的記錄都會一併被同步</p></blockquote></li><li><p>任何與 object 相關的 metadata or ACL 被變更時，都會觸發 replication 的工作執行</p></li><li><p>必須設定 IAM policy，用以提供 S3 合適的權限進行 replication 工作</p></li><li><p>單一 bucket 無法同步到多個 region，但可透過 <code>region1_bucket -&gt; region2_bucket -&gt; region3_bucket</code> 的方式達成相同效果 (daisy chain 似乎也不行)</p></li><li><p>刪除 object 後，原本同步 region 上的 object 也會被刪除</p><ul><li>所從舊版的 console 刪除 delete maker 後可以恢復檔案，但刪除 delete marker 這動作不會被同步，因此同步的 destination bucket 上的檔案不會回復</li><li>若使用 <code>region1_bucket -&gt; region2_bucket -&gt; region3_bucket</code> 同步到多個 region，delete marker 只會被同步到 region2，region3 只會得到檔案被刪除的結果，看不到 delete marker</li></ul></li><li><p>Deleting individual versions or delete markers will not be replicated</p><blockquote><p>在 source bucket 中刪除 delete marker or 特定版本(在舊版的 console)的結果，不會被同步到 destination bucket</p></blockquote></li></ul><h2 id="Lifecycle-Management-1"><a href="#Lifecycle-Management-1" class="headerlink" title="Lifecycle Management"></a>Lifecycle Management</h2><ul><li><p>等同於傳統 IT storage infra 中的 <strong>automated storage tiering</strong> 功能，是一種 data 從 <code>hot</code>(frequently    accessed) -&gt; <code>warm</code>(less    frequently    accessed) -&gt; <code>cold</code>(long-term    backup    or    archive) 的概念</p></li><li><p>Can be used in conjuction with versioning.</p></li><li><p>Can be applied to current versions and previous versions</p></li><li><p>Following actions can now be done:</p><ul><li>Transition to the <strong>Standard - Infrequent Access</strong> storage class (128Kb and 30 days after the creation date)</li><li>Archive to the <strong>Glacier</strong> storage class (30 days after IA, if relevent)</li><li>Permanently Delete (若有移到 Glacier 要把刪除的日期設為 90 天以上，因為 Glacier 費用低消是 90 days)</li></ul></li></ul><h2 id="CloudFront"><a href="#CloudFront" class="headerlink" title="CloudFront"></a>CloudFront</h2><ul><li><p>Edge Location: This is the location where content will be cached. This is separate to an AWS Region/AZ.</p></li><li><p>Origin: This is the origin of all the files that the CDN will distribute. This can be either an S3 bucket, an EC2 instance, an Elastic Load Balancer or Route53.</p></li><li><p>Distribution: This is the name given the CDN which consists of a collection of Edge Locations.</p><ul><li><strong>Web Distribution</strong>: Typically used for websites.</li><li><strong>RTMP</strong>: Used for media streaming. (ex: Adobe Flash)</li></ul></li><li><p>Edge Locations are <strong>not just READ only</strong>, you can write to them too. (ie. put an object on to them).</p></li><li><p>Objects are cached for the life of the TTL (Time to Live)</p></li><li><p>You can clear cached objects, but you will be charged. (不需要等到 TTL 結束)</p></li></ul><h2 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h2><ul><li><p>By default, all newly created buckets are <strong>PRIVATE</strong></p></li><li><p>You can setup access control to your buckets using:</p><ul><li>Bucket Policies</li><li>Access Control Lists (可調整個別 object 的權限)</li></ul></li><li><p>S3 buckets can be configured to create access logs which log all requests made to the S3 buckets. This can be done to another bucket. (也可以將 log 放到另一個 AWS 帳號 S3 bucket 中，需要進行跨帳號連結的設定) </p></li></ul><h2 id="Encryption-1"><a href="#Encryption-1" class="headerlink" title="Encryption"></a>Encryption</h2><h3 id="1-In-Transit-SSL-TLS"><a href="#1-In-Transit-SSL-TLS" class="headerlink" title="1. In Transit (SSL/TLS)"></a>1. In Transit (SSL/TLS)</h3><h3 id="2-At-Rest-1"><a href="#2-At-Rest-1" class="headerlink" title="2. At Rest"></a>2. At Rest</h3><ul><li><p>Server Side Encryption</p><ul><li>S3 Managed Keys (<code>SSE-S3</code>)</li><li>AWS Key Management Service, Managed Keys (<code>SSE-KMS</code>)</li><li>Server Side Encryption with Customer Provided Keys (<code>SSE-C</code>)</li></ul></li><li><p>Client Side Encryption</p></li></ul><h2 id="Storage-Gateway"><a href="#Storage-Gateway" class="headerlink" title="Storage Gateway"></a>Storage Gateway</h2><ul><li><p><strong>File Gateway</strong>: For flat files, stored directly on S3</p></li><li><p><strong>Volume Gateway</strong></p><ul><li><strong>Stored Volumes</strong> - Entire Dataset is stored on site and is asynchronously backed up to S3.</li><li><strong>Cached Volumes</strong> - Entire Dataset is stored on S3 and the most frequently accessed data is cached on site.</li></ul></li><li><p><strong>Gateway Virtual Tape Library (VTL)</strong>: Used for backup and uses popular backup applications like NetBackup, Backup Exec, Veam etc</p></li></ul><h2 id="Snowball"><a href="#Snowball" class="headerlink" title="Snowball"></a>Snowball</h2><ul><li><p>Snowball</p></li><li><p>Snowball Edge</p></li><li><p>Snowmobile</p></li><li><p>Understand what Snowball is</p></li><li><p>Understand what Import Export is</p></li><li><p>Snowball can</p><ul><li>Import to S3</li><li>Export from S3</li></ul></li></ul><h2 id="S3-Transfer-Acceleration-1"><a href="#S3-Transfer-Acceleration-1" class="headerlink" title="S3 Transfer Acceleration"></a>S3 Transfer Acceleration</h2><p>You can speed up transfers to S3 using S3 transfer acceleration. This cost extra, and has the greatest impact on people who are in far away location.</p><h2 id="S3-Static-Websites"><a href="#S3-Static-Websites" class="headerlink" title="S3 Static Websites"></a>S3 Static Websites</h2><ul><li><p>You can use S3 to hsot static websites</p></li><li><p>Serverless</p></li><li><p>Very cheap, scales automatically</p></li><li><p><strong>STATIC</strong> only, canonot host dynamic sites</p></li></ul><h2 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h2><ul><li><p>Write to S3 - HTTP 200 code for a successful write.</p></li><li><p>You can load files to S3 much faster by enabling multipart upload</p></li><li><p>Read the S3 FAQ before taking the exam. It comes up A LOT!</p></li></ul><p>##　Best Practices, Patterns,    and    Performance</p><ul><li><p>S3 &amp; Glacier 非常適合在 hybrid cloud 的環境下作為異地備份的工具</p></li><li><p>另一個常見的應用是將 S3 作為大量 blob 檔案的儲存位置，而把這些 blob 的 index 存於其他的服務(例如：Amazon DynamoDB or Amazon RDS)，透過此方式可以針對 key name 提高搜尋的速度並支援複雜的查詢</p></li><li><p>S3 會自動 scale 來支援 high request rate，也會自動的根據需求針對 bucket 進行 repartition 的動作</p></li><li><p>若有每秒超過 100 個 reuqest 的需求，可參考 developer guide 中的資訊，讓 object key 可以隨機的分佈 (可透過像是使用 hash 值作為 key name prefix 的方式來達成)</p></li></ul><h1 id="應考前建議"><a href="#應考前建議" class="headerlink" title="應考前建議"></a>應考前建議</h1><p>詳細閱讀下列資料：</p><ul><li><a href="https://aws.amazon.com/s3/faqs/" target="_blank" rel="noopener">Amazon Simple Storage Service (S3) FAQs</a> <a href="https://aws.amazon.com/tw/s3/faqs/" target="_blank" rel="noopener">(中文)</a></li></ul>]]></content>
      
      <categories>
          
          <category> AWS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> S3 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AWS 學習筆記 - IAM(Identity and Access Management)</title>
      <link href="/blog/2017/05/02/AWS/AWS-Learning-Notes-IAM/"/>
      <url>/blog/2017/05/02/AWS/AWS-Learning-Notes-IAM/</url>
      <content type="html"><![CDATA[<h1 id="What-is-IAM"><a href="#What-is-IAM" class="headerlink" title="What is IAM?"></a>What is IAM?</h1><p>AWS Identity and Access Management (IAM) enables you to securely control access to AWS services and resources for your users. Using IAM, you can create and manage AWS users and groups, and use permissions to allow and deny their access to AWS resources. </p><p>IAM is a feature of your AWS account offered at no additional charge. You will be charged only for use of other AWS services by your users.</p><h1 id="What-does-IAM-give-you"><a href="#What-does-IAM-give-you" class="headerlink" title="What does IAM give you?"></a>What does IAM give you?</h1><ul><li><p>Centralized control of your AWS account</p></li><li><p>Shared Access to your AWS account</p><blockquote><p>可以分享權限到其他帳號去</p></blockquote></li><li><p>Granular Permissions</p><blockquote><p>可以針對每個帳號可存取的資源權限進行很細部的控制，例如<strong>限制某人只能對 DynamoDB 進行唯讀的存取</strong></p></blockquote></li><li><p>Identity Federation(including Active Directory, Facebook, Linkedin etc)</p><blockquote><p>可以透過其他服務(AD, Facebook, Linkedin etc)的帳號透過 SSO 登入 AWS</p></blockquote></li><li><p>Multifactor Authentication</p><blockquote><p>AWS 建議為每個帳號都設定 multifactor authentication</p></blockquote></li><li><p>Provide temporary access for users/devices and services where necessary</p></li><li><p>Allows you to set up your own password rotation policy</p></li><li><p>Integrates with many different AWS services</p></li><li><p>Supports PCI DSS(Payment Card Industry Data Security Standards) Compliance</p><blockquote><p>PCI DSS(支付卡產業資料安全標準)是在整合外部付費服務之用，為了提升線上支付的安全性</p></blockquote></li></ul><h1 id="Critical-Terms"><a href="#Critical-Terms" class="headerlink" title="Critical Terms"></a>Critical Terms</h1><ul><li><p><strong>Users</strong> - End Users(think people)</p></li><li><p><strong>Group</strong> - A collection of userss under one set of permissions.</p><blockquote><p>A way to group our users and apply policies to them collectively</p></blockquote></li><li><p><strong>Roles</strong> - You create roles and can then assign them to AWS resources</p></li><li><p><strong>Policies</strong> - A document that defined one(or more permission)</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"Version"</span>: <span class="string">"2012-10-17"</span>,</span><br><span class="line">  <span class="attr">"Statement"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"Effect"</span>: <span class="string">"Allow"</span>,</span><br><span class="line">      <span class="attr">"Action"</span>: <span class="string">"s3:*"</span>,</span><br><span class="line">      <span class="attr">"Resource"</span>: <span class="string">"*"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="學習筆記"><a href="#學習筆記" class="headerlink" title="學習筆記"></a>學習筆記</h1><h2 id="IAM-is-global-universal"><a href="#IAM-is-global-universal" class="headerlink" title="IAM is global(universal)"></a>IAM is global(universal)</h2><p>從 management console 進入 IAM 的功能頁面後，Region 的部份會變成 <code>global</code>，表示 IAM 只需要設定一次，這個設定就可以用來套用到使用者在全球所有 region 中的 resource</p><h3 id="IAM-users-sign-in-link"><a href="#IAM-users-sign-in-link" class="headerlink" title="IAM users sign-in link"></a>IAM users sign-in link</h3><p><img src="http://etutorialsworld.com/wp-content/uploads/2016/05/72.22BAWS2BIAM2BDashboard-1.png" alt="IAM users sign-in link"></p><ol><li><p>這是用來提供給其他使用者存取 AWS resource 之用，並非 root account，需要注意一下!</p></li><li><p>網址是動態產生的，可以透過 <strong>Customize</strong> 的 link 設定別名以方便記憶</p></li></ol><h2 id="Security-Status"><a href="#Security-Status" class="headerlink" title="Security Status"></a>Security Status</h2><h3 id="1-Delete-your-root-access-keys"><a href="#1-Delete-your-root-access-keys" class="headerlink" title="(1) Delete your root access keys"></a>(1) Delete your root access keys</h3><p>AWS 建議儘量不要用 root account 進行資源的存取；正確的作法應該新增使用者，並為使用者設定所需要的資源存取權限。</p><p>例如：一開始我在 root account 加了一把 access key，在這個部份就無法 pass 檢查了</p><h3 id="2-Activate-MFA-on-your-root-account"><a href="#2-Activate-MFA-on-your-root-account" class="headerlink" title="(2) Activate MFA on your root account"></a>(2) Activate MFA on your root account</h3><p>選擇 <code>A virtual MFA device</code> 作為 MFA device type(Hardware 是要花錢買的)，接著可以選用 <code>Google Authenticator</code> 作為接收驗證碼之用。</p><p>在 Google Authenticator 中可以設定很多個要用來作 MFA 的帳號，當然也就可以把 AWS IAM 設定進來。</p><p>透過掃描 barcode 的方式，手機上會一直出現 random 的啟用碼(要等一下)，輸入兩個就可以用來啟用 AWS IAM MFA 了。</p><h3 id="3-Create-individual-IAM-users"><a href="#3-Create-individual-IAM-users" class="headerlink" title="(3) Create individual IAM users"></a>(3) Create individual IAM users</h3><p>在建立 user 時，有幾點需要注意一下：</p><ul><li><p><strong>Access type</strong>：勾選 <code>Programmatic access</code> 才可以用這個帳號搭配 AWS API, CLI, SDK …. 等其他開發工具來存取 AWS 的資源；勾選 <code>AWS Management Console access</code> 才可以透過密碼登入的方式進入 AWS Management console</p></li><li><p>可在此時順便建立 or 指定特定的 group，也可以順便指定 policy 來設定權限</p><blockquote><p>policy 並非 group 專屬，也可以 attach 到單一 user</p></blockquote></li><li><p>建立完成的 user(若有勾選 <strong>Programmatic access</strong>) 會得到 <code>Access key ID</code> &amp; <code>Secret access key</code>，這是開發用來存取 AWS 資源的程式需要的資訊</p></li></ul><h3 id="4-Use-groups-to-assign-permissions"><a href="#4-Use-groups-to-assign-permissions" class="headerlink" title="(4) Use groups to assign permissions"></a>(4) Use groups to assign permissions</h3><p>目前 AWS 已經提供了很多內建的權限清單可以用，例如：S3 唯讀, Glacier 唯讀….等等，但目前還不確定能不能自訂權限的選項。。</p><h3 id="5-Apply-an-IAM-password-policy"><a href="#5-Apply-an-IAM-password-policy" class="headerlink" title="(5) Apply an IAM password policy"></a>(5) Apply an IAM password policy</h3><p>這沒什麼特別，就是設定密碼的規則….(長度, rotation period…等等)</p><h2 id="Add-Role"><a href="#Add-Role" class="headerlink" title="Add Role"></a>Add Role</h2><h3 id="1-Role-Type"><a href="#1-Role-Type" class="headerlink" title="(1) Role Type"></a>(1) Role Type</h3><ul><li><p><strong>AWS Service Role</strong>: 用來指定 AWS 上面的特定 service</p><blockquote><p>這可以設定的非常細，例如：只讓 EC2 對 S3 完全存取，無其他 service 的存取權限</p></blockquote></li><li><p><strong>Role for Cross-Account Access</strong>: 可以用來讓特定帳號去存取其他帳號的 management console</p></li><li><p><strong>Role for Identity Provider Access</strong>: 作 SSO, 整合 FB, Linkedin 帳號時才會用到的部份</p></li></ul><h3 id="2-Attach-Policy"><a href="#2-Attach-Policy" class="headerlink" title="(2) Attach Policy"></a>(2) Attach Policy</h3><h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><ul><li><p>IAM is universal. It does not apply to regions at this time.</p></li><li><p>The <strong>root account</strong> is simplely the account created when first setup your AWS account. It has complete Admin access.</p></li><li><p>New Users have <strong>NO</strong> permissions when first created.</p></li><li><p>New Users are assigned <strong>Access Key ID</strong> &amp; <strong>Secrect Access Keys</strong> when first created.</p></li><li><p>These are not the same as a password, and you cannot use the Access Key ID &amp; Secret Access Key to Login in to the console. You can use this to access AWS via the APIs, SDK and Command Line however.</p></li><li><p>You only get to view these once. If you lose them, you have to regenerate them. So save them in a secure location.</p></li><li><p>Always setup Multifactor Authentication on your root account.</p></li><li><p>You can create and customize your own password rotation policies.</p></li></ul>]]></content>
      
      <categories>
          
          <category> AWS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> IAM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Linux KVM] Template &amp; Snapshot 的運用</title>
      <link href="/blog/2017/01/01/KVM/KVM-Template-And-Snapshot/"/>
      <url>/blog/2017/01/01/KVM/KVM-Template-And-Snapshot/</url>
      <content type="html"><![CDATA[<p>此篇文章介紹如何使用 KVM 中的 template &amp; snapshot 功能</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>虛擬化技術有些非常吸引人使用的特性，例如：</p><ul><li><p>Fast Provisioning</p></li><li><p>Snapshots</p></li><li><p>不複雜的 backup &amp; recovery 方式</p></li></ul><p>以上這些特性都不是在實體環境上容易實現的，但透過 KVM 中的 template，可以實現 fast provisioning，而透過 snapshot 則可簡單實現 backup &amp; recovery。</p><hr><h1 id="VM-Templates"><a href="#VM-Templates" class="headerlink" title="VM Templates"></a>VM Templates</h1><p>template 有別於一般的 VM clone，clone 只是從其他 VM 複製成另外一個完整的 VM；而 template 則是可以作為其他 VM 的 master copy，並用來產生很多個 clone</p><h2 id="建立-template"><a href="#建立-template" class="headerlink" title="建立 template"></a>建立 template</h2><p>template 是由以存在的 VM 所轉換過來的，因此在建立 template 之前，我們必須先完成以下步驟：</p><ol><li><p>安裝 &amp; 設定 VM，確認上面已經安裝所需要的所有軟體套件</p></li><li><p>移除所有系統特定的設定，確保只與此 VM 相關的設定(例如：固定 IP)不會被複製到其他 VM 上</p></li><li><p>修改 VM 名稱讓其容易辨識，例如以 <strong>template</strong> 作為開頭</p></li></ol><h3 id="1-建立-Centos-Template"><a href="#1-建立-Centos-Template" class="headerlink" title="(1) 建立 Centos Template"></a>(1) 建立 Centos Template</h3><p>要建立 Linux template，必須透過 <code>virt-sysprep</code> 工具的協助。</p><p>這工具由 <code>libguestfs-tools-s</code> 套件所提供，可以移除 VM 中系統特定的資訊，以便於轉換成 template 之用；此外也可以客製化 VM，例如加上 SSH Key、加入使用者、設定 Logo …. 等等。</p><p>輸入 <code>virt-prep --help</code> 可以知道 virt-sysprep 支援哪些調整選項：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@ocp-kvm-host ~]<span class="comment"># virt-sysprep -help</span></span><br><span class="line">virt-sysprep: reset or unconfigure a virtual machine so clones can be made</span><br><span class="line"></span><br><span class="line"> virt-sysprep [--options] -d domname</span><br><span class="line"></span><br><span class="line"> virt-sysprep [--options] -a disk.img [-a disk.img ...]</span><br><span class="line"></span><br><span class="line">A short summary of the options is given below.  For detailed <span class="built_in">help</span> please</span><br><span class="line"><span class="built_in">read</span> the man page virt-sysprep(1).</span><br><span class="line"></span><br><span class="line">  -a file                             Add disk image file</span><br><span class="line">  --add file                          Add disk image file</span><br><span class="line">  -c uri                              Set libvirt URI</span><br><span class="line">  --chmod PERMISSIONS:FILE            Change the permissions of a file</span><br><span class="line">  --connect uri                       Set libvirt URI</span><br><span class="line">  -d domain                           Set libvirt guest name</span><br><span class="line">  --debug-gc                          Debug GC and memory allocations (internal)</span><br><span class="line">  --delete PATH                       Delete a file or directory</span><br><span class="line">  --domain domain                     Set libvirt guest name</span><br><span class="line">  --dry-run                           Perform a dry run</span><br><span class="line">  --dryrun                            Perform a dry run</span><br><span class="line">  --dump-pod                          Dump POD (internal)</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>從 help 中的說明可以看出，virt-sysprep 有兩個參數分別是 <code>-d</code> &amp; <code>-a</code>，其中 <code>-d</code> 所處理的對象是 VM，而 <code>-a</code> 所處理的對象則是獨立的 virtual disk。</p><p>以下使用對 VM 為範例來操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@ocp-kvm-host ~]<span class="comment"># virsh list --all</span></span><br><span class="line"> Id    Name                           State</span><br><span class="line">----------------------------------------------------</span><br><span class="line"> -     centos7                        shut off</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">[root@ocp-kvm-host ~]<span class="comment"># virt-sysprep -d centos7</span></span><br><span class="line">[   0.0] Examining the guest ...</span><br><span class="line">[  43.0] Performing <span class="string">"abrt-data"</span> ...</span><br><span class="line">[  43.0] Performing <span class="string">"bash-history"</span> ...</span><br><span class="line">........</span><br><span class="line">[  43.0] Performing <span class="string">"udev-persistent-net"</span> ...</span><br><span class="line">[  43.0] Performing <span class="string">"utmp"</span> ...</span><br><span class="line">[  43.0] Performing <span class="string">"yum-uuid"</span> ...</span><br><span class="line">[  43.0] Performing <span class="string">"customize"</span> ...</span><br><span class="line">[  43.0] Setting a random seed</span><br><span class="line">[  43.0] Performing <span class="string">"lvm-uuids"</span> ...</span><br></pre></td></tr></table></figure><blockquote><p>到此步驟時，VM template 已經準備完成；還有一點更重要的是，<strong>不要再啟動 template VM</strong>，否則將會失去之前 virt-sysprep 所完成的結果，甚至有可能會在使用 thin method(參考下方) 產生 VM 時發生問題 </p></blockquote><h3 id="2-建立-Windows-Template"><a href="#2-建立-Windows-Template" class="headerlink" title="(2) 建立 Windows Template"></a>(2) 建立 Windows Template</h3><p>要製作 template，可以透過 <code>virt-clone</code> + <code>virt-sysprep</code> 的方式</p><p>要透過 template 建立新的 VM，有以下兩種方式可以進行：</p><h2 id="透過-template-佈署-VM"><a href="#透過-template-佈署-VM" class="headerlink" title="透過 template 佈署 VM"></a>透過 template 佈署 VM</h2><ol><li><p><strong>thin method</strong></p><blockquote><p>此方式會以 template image 為 base image以 read-only(template VM image) 搭配 copy-on-write(新的 VM) 來處理，所需要的磁碟空間比較小，但需要確保 base image 可以被存取</p></blockquote></li><li><p><strong>clone method</strong></p><blockquote><p>此方式會完整複製一份 template image 作為 新 VM 的 image，會消耗較多的磁碟空間，但可以完全獨立不依賴原本的 base image</p></blockquote></li></ol><hr><h1 id="Snapshots"><a href="#Snapshots" class="headerlink" title="Snapshots"></a>Snapshots</h1><p>snapshot 是以檔案為基礎，用來表示 VM 在某個特定時間點的狀態，包含了相關設定檔 &amp; disk 資料；而透過 snapshot，管理者可以隨時將 VM 還原到當時建立 snapshot 時的狀態，而這功能在進行對於 VM 要進行重大變更前時特別好用。</p><p>此外，libvirt 還提供了 live snapshot 的功能，可以針對執行中的 VM 進行 snapshot，但這功能不建議使用在 I/O 工作頻繁的 VM 上，建議這類的 VM 還是 shutdown or suspend 之後再來做 snapshot 會較好。</p><p>libvirt 支援兩種 snapshop，分別如下：</p><h3 id="internal-snapshot"><a href="#internal-snapshot" class="headerlink" title="internal snapshot"></a>internal snapshot</h3><p>internal snapshot 的 snapshot 資訊會存在於同一個 qcow2 檔案中(before/after snapshot bit)，有以下的限制需要注意：</p><ul><li><p>僅支援 qcow2 format</p></li><li><p>當建立 snapshot 時，VM 會進入暫停狀態</p></li><li><p>無法使用在 LVM storage pool 上</p></li></ul><h3 id="external-snapshot"><a href="#external-snapshot" class="headerlink" title="external snapshot"></a>external snapshot</h3><p>external snapshot 是以 copy-on-write 的概念進行的，當 VM 進行 snapshot 後，system disk 就會進入 read-only 的模式，後續 VM guest 新增的資料就會放在 overlay disk image 上，以下有個圖示來說明：</p><p><img src="https://github.com/godleon/godleon.github.io/blob/master/_posts/images/2017/KVM-Template-And-Snapshot/copy-on-write_overlay-disk0-image.png?raw=true" alt="copy-on-write overlay disk image"></p><p>external snapshot 也有以下特點：</p><ol><li><p>overlay disk image 的起始大小為 0，最大可以到 original disk 的大小</p></li><li><p>base disk 可以是任何的格式(例如：raw, qcow2, 或是其他 libvirt 支援的格式)</p></li><li><p>overlay disk image 一定是 qcow2 格式</p></li></ol><h2 id="VM-Disk-Image-Format"><a href="#VM-Disk-Image-Format" class="headerlink" title="VM Disk Image Format"></a>VM Disk Image Format</h2><p>libvirt 支援很多種不同的 disk foramt，包含 iso, dmg, qcow2, raw, vmdk, vpc … 等等，但與 libvirt 搭配起來運作的最好的是 <strong>raw</strong> &amp; <strong>qcow2</strong> 兩種：</p><h3 id="1-raw"><a href="#1-raw" class="headerlink" title="(1) raw"></a>(1) <strong>raw</strong></h3><ul><li><p>效能最佳，performace overhead 最低，適合給有高度 I/O 需求的 VM 使用</p></li><li><p>完全佔據 disk 所指定的空間</p></li><li><p>沒有 snapshot &amp; compression 的功能</p></li></ul><h3 id="2-qcow2"><a href="#2-qcow2" class="headerlink" title="(2) qcow2"></a>(2) <strong>qcow2</strong></h3><ul><li><p>完全以 cloud 架構出發所設計的格式</p></li><li><p>支援 read-only backing、snapshot、compression、encryption、pre-allocation … 等功能</p></li></ul><h2 id="轉換-Disk-Image-Format"><a href="#轉換-Disk-Image-Format" class="headerlink" title="轉換 Disk Image Format"></a>轉換 Disk Image Format</h2><p>以下介紹如何透過 <code>qemu-img</code> 指令在 <strong>raw</strong> &amp; <strong>qcow2</strong> 之間進行轉換：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># raw -&gt; qcow2</span></span><br><span class="line">$ qemu-img convert -f raw -O qcow2 vm_disk.img vm_disk.qcow2</span><br><span class="line"></span><br><span class="line"><span class="comment"># qcow2 -&gt; raw</span></span><br><span class="line">$ qemu-img convert -f qcow2 -O ram vm_disk.qcow2 vm_disk.img</span><br></pre></td></tr></table></figure><h2 id="操作-Internal-Snapshot"><a href="#操作-Internal-Snapshot" class="headerlink" title="操作 Internal Snapshot"></a>操作 Internal Snapshot</h2><h3 id="1-建立-amp-檢視-snapshot"><a href="#1-建立-amp-檢視-snapshot" class="headerlink" title="(1) 建立 &amp; 檢視 snapshot"></a>(1) 建立 &amp; 檢視 snapshot</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">$ virsh snapshot-list rhel7.3</span><br><span class="line"> Name                 Creation Time             State</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 internal snapshot</span></span><br><span class="line">$ virsh snapshot-create rhel7.3</span><br><span class="line">Domain snapshot 1481514143 created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 internal snapshot (使用 snapshot-create-as 搭配 --name, --description 等參數)</span></span><br><span class="line"><span class="comment"># --atomic 可以確保 snapshot 是可以用的 (若是 snapshot 無法使用，建立時就會 fail)</span></span><br><span class="line">$ virsh snapshot-create-as rhel7.3 --name <span class="string">"rhel7.3_snapshot_1"</span> --description <span class="string">"First named snapshot"</span> --atomic</span><br><span class="line">Domain snapshot rhel7.3_snapshot_1 created</span><br><span class="line"></span><br><span class="line">$ virsh snapshot-list rhel7.3</span><br><span class="line"> Name                 Creation Time             State</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"> 1481514143           2016-12-12 11:42:23 +0800 shutoff</span><br><span class="line"> rhel7.3_snapshot_1   2016-12-14 08:32:23 +0800 shutoff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示 snapshot 資訊</span></span><br><span class="line">$ virsh snapshot-info rhel7.3 --snapshotname 1481514143</span><br><span class="line">Name:           1481514143</span><br><span class="line">Domain:         rhel7.3</span><br><span class="line">Current:        no</span><br><span class="line">State:          shutoff</span><br><span class="line">Location:       internal</span><br><span class="line">Parent:         -</span><br><span class="line">Children:       1</span><br><span class="line">Descendants:    1</span><br><span class="line">Metadata:       yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視指定 VM 的 current snapshot 資訊</span></span><br><span class="line">$ virsh snapshot-current rhel7.3</span><br><span class="line">&lt;domainsnapshot&gt;</span><br><span class="line">  &lt;name&gt;rhel7.3_snapshot_1&lt;/name&gt;</span><br><span class="line">  &lt;description&gt;First named snapshot&lt;/description&gt;</span><br><span class="line">  &lt;state&gt;shutoff&lt;/state&gt;</span><br><span class="line">  &lt;parent&gt;</span><br><span class="line">    &lt;name&gt;1481514143&lt;/name&gt;</span><br><span class="line">  &lt;/parent&gt;</span><br><span class="line">  &lt;creationTime&gt;1481675543&lt;/creationTime&gt;</span><br><span class="line">  &lt;memory snapshot=<span class="string">'no'</span>/&gt;</span><br><span class="line">  &lt;disks&gt;</span><br><span class="line">    &lt;disk name=<span class="string">'vda'</span> snapshot=<span class="string">'internal'</span>/&gt;</span><br><span class="line">  &lt;/disks&gt;</span><br><span class="line">  &lt;domain <span class="built_in">type</span>=<span class="string">'kvm'</span>&gt;</span><br><span class="line">    ....</span><br><span class="line">  &lt;/domain&gt;</span><br><span class="line">&lt;/domainsnapshot&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示 snapshot XML 資訊</span></span><br><span class="line">$ virsh snapshot-dumpxml rhel7.3 --snapshotname 1481514143</span><br><span class="line">&lt;domainsnapshot&gt;</span><br><span class="line">  .... 與上面類似</span><br><span class="line">&lt;/domainsnapshot&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示 snapshot 的 parent snapshot (第一個 snapshot 沒有 parent snapshot)</span></span><br><span class="line">$ virsh snapshot-parent rhel7.3 --snapshotname 1481514143</span><br><span class="line">error: snapshot <span class="string">'1481514143'</span> has no parent</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二個 snapshot 就有 parent snapshot 了</span></span><br><span class="line">$ virsh snapshot-parent rhel7.3 --snapshotname rhel7.3_snapshot_1</span><br><span class="line">1481514143</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示每個 snapshot 的 parent</span></span><br><span class="line">$ virsh snapshot-list rhel7.3 --parent</span><br><span class="line"> Name                 Creation Time             State           Parent</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"> 1481514143           2016-12-12 11:42:23 +0800 shutoff         (null)</span><br><span class="line"> rhel7.3_snapshot_1   2016-12-14 08:32:23 +0800 shutoff         1481514143</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以樹狀結構顯示每個 snapshot 的關係</span></span><br><span class="line">$ virsh snapshot-list rhel7.3 --tree</span><br><span class="line">1481514143</span><br><span class="line">  |</span><br><span class="line">  +- rhel7.3_snapshot_1</span><br></pre></td></tr></table></figure><blockquote><p>若是在 VM 正在 running 的狀態下建立 snapshot，會需要多花一點時間，因為 VM 必須先進入到 <strong>pause</strong> 的狀態，當 snapshot 完成後才會回到 running 的狀態；而這一段時間的長短取決於 VM 當時耗用了多少記憶體，以及當時對記憶體存取的頻繁程度。</p></blockquote><p>另外還可以透過 <code>qemu-image</code> 工具來查詢 VM image 的狀態：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查詢 image 的狀態</span></span><br><span class="line">$ qemu-img info /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.qcow2 </span><br><span class="line">image: /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.qcow2</span><br><span class="line">file format: qcow2</span><br><span class="line">virtual size: 40G (42949672960 bytes)</span><br><span class="line">disk size: 572M</span><br><span class="line">cluster_size: 65536</span><br><span class="line">Snapshot list:</span><br><span class="line">ID        TAG                 VM SIZE                DATE       VM CLOCK</span><br><span class="line">1         1481514143                0 2016-12-12 11:42:23   00:00:00.000</span><br><span class="line">2         rhel7.3_snapshot_1        0 2016-12-14 08:32:23   00:00:00.000</span><br><span class="line">Format specific information:</span><br><span class="line">    compat: 0.10</span><br><span class="line">    refcount bits: 16</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢查 image 是否有錯誤</span></span><br><span class="line"><span class="comment"># 適合用在 running 過程中建立 snapshot 後，檢查有無錯誤發生</span></span><br><span class="line">$ qemu-img check /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.qcow2 </span><br><span class="line">No errors were found on the image.</span><br><span class="line">19467/655360 = 2.97% allocated, 93.71% fragmented, 90.63% compressed clusters</span><br><span class="line">Image end offset: 599916544</span><br></pre></td></tr></table></figure><h3 id="2-透過-snapshot-還原-VM"><a href="#2-透過-snapshot-還原-VM" class="headerlink" title="(2) 透過 snapshot 還原 VM"></a>(2) 透過 snapshot 還原 VM</h3><p>接著介紹如何透過 internal snapshot 還原 VM：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 從指定的 snapshot 還原 VM</span></span><br><span class="line">$ virsh snapshot-revert rhel7.3 --snapshotname rhel7.3_snapshot_1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 從指定的 snapshot 還原 &amp; 自動啟動 VM</span></span><br><span class="line">$ virsh snapshot-revert rhel7.3 --snapshotname rhel7.3_snapshot_1 --running</span><br></pre></td></tr></table></figure><h3 id="3-刪除-snapshot"><a href="#3-刪除-snapshot" class="headerlink" title="(3) 刪除 snapshot"></a>(3) 刪除 snapshot</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 刪除指定的 snapshot</span></span><br><span class="line">$ virsh snapshot-delete rhel7.3 1481514143</span><br><span class="line">Domain snapshot 1481514143 deleted</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示目前 snapshot 的狀態</span></span><br><span class="line">[root@ocp-kvm-host ~]<span class="comment"># virsh snapshot-list rhel7.3 --parent</span></span><br><span class="line"> Name                 Creation Time             State           Parent</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"> rhel7.3_snapshot_1   2016-12-14 08:32:23 +0800 shutoff         (null)</span><br></pre></td></tr></table></figure><h2 id="操作-External-Snapshot"><a href="#操作-External-Snapshot" class="headerlink" title="操作 External Snapshot"></a>操作 External Snapshot</h2><p>external snapshot 的原理是由 <code>overlay_image</code> &amp; <code>backing_file</code> 兩個所組成；其中 backing file 會變成 read-only，後續使用者針對 VM 的變更都會寫到 overlay_image 中。</p><p>而 external snapshot 比較有優勢的地方，在於支援各種不同的 disk image type(raw, qcow, vmdk … etc)，不僅有 qcow2 而已。</p><p>但由於目前 virsh 還不完全支援 external snapshot 的操作，這邊就先保留，等到 virsh 可以完整支援 external snapshot 之後再來補。</p><h3 id="1-建立-external-snapshot"><a href="#1-建立-external-snapshot" class="headerlink" title="(1) 建立 external snapshot"></a>(1) 建立 external snapshot</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ virsh list</span><br><span class="line"> Id    Name                           State</span><br><span class="line">----------------------------------------------------</span><br><span class="line"> 32    rhel7.3                        running</span><br><span class="line"></span><br><span class="line">$ virsh domblklist rhel7.3 --details</span><br><span class="line">Type       Device     Target     Source</span><br><span class="line">------------------------------------------------</span><br><span class="line">file       disk       vda        /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.qcow2</span><br><span class="line"></span><br><span class="line">$ virsh snapshot-create-as rhel7.3 ext_snapshot1 <span class="string">"first external snapshot"</span> --disk-only --atomic</span><br><span class="line">Domain snapshot ext_snapshot1 created</span><br><span class="line"></span><br><span class="line">$ virsh snapshot-list rhel7.3</span><br><span class="line">Name                 Creation Time             State</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">ext_snapshot1        2016-12-31 21:00:23 +0800 disk-snapshot</span><br><span class="line"></span><br><span class="line">$ virsh snapshot-info rhel7.3 ext_snapshot1</span><br><span class="line">Name:           ext_snapshot1</span><br><span class="line">Domain:         rhel7.3</span><br><span class="line">Current:        yes</span><br><span class="line">State:          disk-snapshot</span><br><span class="line">Location:       external</span><br><span class="line">Parent:         -</span><br><span class="line">Children:       0</span><br><span class="line">Descendants:    0</span><br><span class="line">Metadata:       yes</span><br></pre></td></tr></table></figure><p>利用上面的命令就可以建立 VM external snapshot；此外，還有幾點需要注意：</p><ol><li><p>external snapshot 可以在 VM running 的狀態下建立(若是 disk I/O 頻繁的 VM，建議還是 shutdown 之後再作)</p></li><li><p><code>--disk-only</code> 表示只針對 disk 作 snapshot</p></li><li><p><code>--atomic</code> 會確保 snapshot 建立的工作執行成功後會得到一個可用的 snapshot；若是中途發生任何問題，就不會有 snapshot 的產生，也不會對原有的 VM 產生任何異動，藉此確保建立 snapshot 不會損壞原有的 VM</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 檢視目前 VM disk 資訊</span></span><br><span class="line"><span class="comment"># 已經被 external disk 取代了!</span></span><br><span class="line">$ virsh domblklist rhel7.3 --details</span><br><span class="line">Type       Device     Target     Source</span><br><span class="line">------------------------------------------------</span><br><span class="line">file       disk       vda        /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot1</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 可看出原本的 disk 已經變成了 backing file</span></span><br><span class="line">$ qemu-img info /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot1</span><br><span class="line">image: /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot1</span><br><span class="line">file format: qcow2</span><br><span class="line">virtual size: 40G (42949672960 bytes)</span><br><span class="line">disk size: 2.0M</span><br><span class="line">cluster_size: 65536</span><br><span class="line">backing file: /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.qcow2</span><br><span class="line">backing file format: qcow2</span><br><span class="line">Format specific information:</span><br><span class="line">    compat: 1.1</span><br><span class="line">    lazy refcounts: <span class="literal">false</span></span><br><span class="line">    refcount bits: 16</span><br><span class="line">    corrupt: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>從上面可看出，從此刻開始對 VM 的變更將會直接寫入 external snapshot，而原本的 disk image 變成了 backing file。</p><p>接著再建立兩個 external snapshot 試試看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ virsh snapshot-create-as rhel7.3 ext_snapshot2 <span class="string">"second external snapshot"</span> --disk-only --atomic</span><br><span class="line">Domain snapshot ext_snapshot2 created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過 "--quiesce" 參數，確保連同記憶體內的資訊都一併進入到 snapshot 中</span></span><br><span class="line">$ virsh snapshot-create-as rhel7.3 ext_snapshot3 <span class="string">"third external snapshot"</span> --disk-only --quiesce</span><br><span class="line">Domain snapshot ext_snapshot3 created</span><br><span class="line"></span><br><span class="line">$ virsh snapshot-list rhel7.3</span><br><span class="line"> Name                 Creation Time             State</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"> ext_snapshot1        2016-12-31 21:00:23 +0800 disk-snapshot</span><br><span class="line"> ext_snapshot2        2016-12-31 22:16:42 +0800 disk-snapshot</span><br><span class="line"> ext_snapshot3        2016-12-31 22:17:53 +0800 disk-snapshot</span><br></pre></td></tr></table></figure><p>在第三個 snapshot 中使用了 <code>--quiesce</code> 參數，目的就是要讓尚未寫入 disk(記憶體中的資料) 一併進入到 snapshot 中，這樣就可以確保 snapshot 是最完整的狀態，但要使用這參數必須預先在 VM 上安裝 <code>qemu-guest agent</code> 才可以。</p><p>最後，每個 snapshot 的相依性可以使用下列命令觀察：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ qemu-img info --backing-chain /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot3 | grep backing</span><br><span class="line">backing file: /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot2</span><br><span class="line">backing file format: qcow2</span><br><span class="line">backing file: /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot1</span><br><span class="line">backing file format: qcow2</span><br><span class="line">backing file: /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.qcow2</span><br><span class="line">backing file format: qcow2</span><br></pre></td></tr></table></figure><h3 id="2-從-external-snapshot-還原"><a href="#2-從-external-snapshot-還原" class="headerlink" title="(2) 從 external snapshot 還原"></a>(2) 從 external snapshot 還原</h3><p>external snapshot 看似不錯，但其實無法透過 virsh 指令直接還原 VM：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ virsh snapshot-revert rhel7.3 --snapshotname <span class="string">"ext_snapshot3"</span></span><br><span class="line">error: unsupported configuration: revert to external snapshot not supported yet</span><br></pre></td></tr></table></figure><p>但這並不代表沒辦法從 external snapshot 還原，只是要透過以下步驟來完成：(假設要還原到 <code>ext_snapshot2</code>)</p><ol><li><p>關閉 VM (<strong>這是必須的!</strong>)</p></li><li><p>檢查要還原的 external snapshot overlay image 有無損毀</p></li><li><p>若 snapshot 完整無誤，編輯 VM XML 定義檔，將 boot disk 指向 <code>ext_snapshot2</code></p></li><li><p>確認 external snapshot image 格式</p></li><li><p>從 VM XML 定義中移除原本的 disk，改成指定要還原的 <code>ext_snapshot2</code></p></li><li><p>透過 <code>domblklist</code> 參數確認 VM 使用的 disk 已經指向 ext_snapshot2</p></li><li><p>重新啟動 VM</p></li></ol><p>以下是實際操作步驟：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 關閉 VM</span></span><br><span class="line">$ virsh shutdown rhel7.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取得 ext_snapshot2 的詳細路徑</span></span><br><span class="line">$ virsh snapshot-dumpxml rhel7.3 --snapshotname ext_snapshot2 | grep ext_snapshot2</span><br><span class="line">  &lt;name&gt;ext_snapshot2&lt;/name&gt;</span><br><span class="line">      &lt;<span class="built_in">source</span> file=<span class="string">'/var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot2'</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先使用 qemu-img 工具檢查 overlay image 有無損毀</span></span><br><span class="line">$ qemu-img check /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot2</span><br><span class="line">No errors were found on the image.</span><br><span class="line">11/655360 = 0.00% allocated, 36.36% fragmented, 0.00% compressed clusters</span><br><span class="line"></span><br><span class="line"><span class="comment"># 確認 overlay image 格式</span></span><br><span class="line">$ qemu-img info /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot2 | grep backing</span><br><span class="line">backing file: /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot1</span><br><span class="line">backing file format: qcow2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除原本的 disk</span></span><br><span class="line">$ virt-xml rhel7.3 --remove-device --disk target=vda</span><br><span class="line">Domain <span class="string">'rhel7.3'</span> defined successfully.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 換上要還原的 ext_snapshot2</span></span><br><span class="line">$ virt-xml rhel7.3 --add-device --disk /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot2,format=qcow2,bus=virtio</span><br><span class="line">Domain <span class="string">'rhel7.3'</span> defined successfully.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 確認目前 VM 所使用的 disk</span></span><br><span class="line">$ virsh domblklist rhel7.3</span><br><span class="line">Target     Source</span><br><span class="line">------------------------------------------------</span><br><span class="line">vda        /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新啟動 VM</span></span><br><span class="line">$ virsh start rhel7.3</span><br><span class="line">Domain rhel7.3 started</span><br></pre></td></tr></table></figure><h3 id="3-刪除-external-snapshot"><a href="#3-刪除-external-snapshot" class="headerlink" title="(3) 刪除 external snapshot"></a>(3) 刪除 external snapshot</h3><p>由於 virsh 不支援 external snapshot 的刪除，所以刪除 snapshot 就必須自己來了!</p><p>假設要移除所有的 snapshot，但又想要保留在 snapshot 上完整的變更，此時必須把 snapshot merge 到 base image 上，以下是操作步驟：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 目前 disk 所使用的 snapshot</span></span><br><span class="line">$ virsh domblklist rhel7.3</span><br><span class="line">Target     Source</span><br><span class="line">------------------------------------------------</span><br><span class="line">vda        /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢 snapshot overlay image 的相依關係</span></span><br><span class="line">$ qemu-img info --backing-chain /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot2 | grep backing</span><br><span class="line">backing file: /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.ext_snapshot1</span><br><span class="line">backing file format: qcow2</span><br><span class="line">backing file: /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.qcow2</span><br><span class="line">backing file format: qcow2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將 base image &amp; snapshot overlay image 合併!</span></span><br><span class="line">$ virsh blockcommit rhel7.3 vda --verbose --pivot --active</span><br><span class="line">Block commit: [100 %]</span><br><span class="line">Successfully pivoted</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可看出 VM disk 已經變成 base image</span></span><br><span class="line">$ virsh domblklist rhel7.3</span><br><span class="line">Target     Source</span><br><span class="line">------------------------------------------------</span><br><span class="line">vda        /var/lib/libvirt/images/rhel-guest-image-7.3-35.x86_64.qcow2</span><br><span class="line"></span><br><span class="line">$ virsh snapshot-list rhel7.3</span><br><span class="line"> Name                 Creation Time             State</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"> ext_snapshot1        2016-12-31 21:00:23 +0800 disk-snapshot</span><br><span class="line"> ext_snapshot2        2016-12-31 22:16:42 +0800 disk-snapshot</span><br><span class="line"> ext_snapshot3        2016-12-31 22:17:53 +0800 disk-snapshot</span><br></pre></td></tr></table></figure><p>確認好 VM disk 已經不是指向 external snapshot 了，就可以開始進行刪除 snapshot 的動作，而刪除 external snapshot 必須從 metadata 下手，以下為操作範例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定刪除從 ext_snapshot1 開始的所有 children snapshot 的 metadata &amp; image</span></span><br><span class="line">$ virsh snapshot-delete rhel7.3 ext_snapshot1 --children --metadata</span><br><span class="line">Domain snapshot ext_snapshot1 deleted</span><br><span class="line"></span><br><span class="line"><span class="comment"># 確認所有 external snapshot 都已經被刪除</span></span><br><span class="line">$ virsh snapshot-list rhel7.3</span><br><span class="line"> Name                 Creation Time             State</span><br><span class="line">------------------------------------------------------------</span><br></pre></td></tr></table></figure><h2 id="使用-snapshot-時所需的正確觀念"><a href="#使用-snapshot-時所需的正確觀念" class="headerlink" title="使用 snapshot 時所需的正確觀念"></a>使用 snapshot 時所需的正確觀念</h2><ol><li><p>不建議在 production 的環境中讓 VM 去 attach 之前做好的 snapshot 來使用</p></li><li><p>不要把 snapshot 當作是備份的方式，只是用來留下當時 VM 的狀態做後續使用而已</p></li><li><p>snapshot 不要保留太久，若確定不需要的就把 snapshot commit(for external snapshot) or 刪除</p></li><li><p>external snapshot 出現故障的機率比 internal snapshot 還低，因此建議優先使用 external snapshot</p></li><li><p>snapshot 數量要控制，太多的 snapshot 可能會倒置系統效能低落</p></li><li><p>建立 snapshot 前要先安裝 guest agent</p></li><li><p>建立 snapshot 確認都有帶上 <code>--quiesce</code> &amp;&amp; <code>--atomic</code> 兩個參數</p></li></ol>]]></content>
      
      <categories>
          
          <category> KVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> KVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Linux KVM] VM Life Cycle 管理</title>
      <link href="/blog/2016/11/30/KVM/KVM-Lifecycle-Management/"/>
      <url>/blog/2016/11/30/KVM/KVM-Lifecycle-Management/</url>
      <content type="html"><![CDATA[<p>此篇文章將會介紹 VM 生命周期管理、Qemu Guest Agent、Virtual Video Card、Graphic Server … 等主題。</p><h1 id="VM-Lifecycle"><a href="#VM-Lifecycle" class="headerlink" title="VM Lifecycle"></a>VM Lifecycle</h1><p>在 KVM 中的 virtual machine 共會有以下幾種狀態：</p><ul><li><p><strong>Undefined</strong>：未定義</p></li><li><p><strong>Defined / Shutoff</strong>：已定義，libvirtd 已經知道有此 VM 存在，但狀態為關機中(Stopped or Shutdown)</p></li><li><p><strong>Running</strong>：執行中</p></li><li><p><strong>Shutdown</strong>：關機中</p></li><li><p><strong>Paused</strong>：暫停中，VM 記憶體中的資料暫時被保留，並且可以在 guest OS 無法知悉的狀況下回復</p></li><li><p><strong>Saved</strong>：VM 處於完全暫停的狀態，記憶體中的資料被存到一般檔案中，並存在於 persistent storage (可回復到進行 save 時的狀態)</p></li><li><p><strong>Idle</strong>：等待 I/O，或是因為沒有工作需要進行而休眠中</p></li><li><p><strong>Crashed</strong>：可能因為 QEMU process 被強制移除 or core dump 所造成的 VM 損毀</p></li><li><p><strong>Dying</strong>：在 shutdown 的過程中失敗所產生的況狀</p></li><li><p><strong>Pmsuspended</strong>：透過 guest OS 中的電源管理功能進行 suspend 後進入的狀態</p></li></ul><p>有了上面概念後，可以透過 virsh 來檢視目前 domain(virtual machine) 的狀態：</p><hr><h1 id="檢視-VM"><a href="#檢視-VM" class="headerlink" title="檢視 VM"></a>檢視 VM</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 顯示所有 VM (包含關機中的)</span></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.3/system list --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示特定狀態的 VM</span></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.3/system list --state-[running|paused|shutoff|]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示(未)包含 snapshot 的 VM</span></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.3/system list --[with|without]-snapshot</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示(未)包含 managed save 狀態的 VM</span></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.3/system list --[with|without]-managed-save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 僅顯示 uuid or name</span></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.3/system list --[uuid|name]</span><br></pre></td></tr></table></figure><blockquote><p>還有許多其他參數可用，使用者可透過 <code>virsh help</code> or <code>virsh help list</code> 來查詢更多使用方式</p></blockquote><hr><h1 id="操作-VM"><a href="#操作-VM" class="headerlink" title="操作 VM"></a>操作 VM</h1><p>了解 VM 有這麼多狀態之後，自然就會有相對應的操作了，virsh 提供以下幾項對 VM 的操作：</p><ul><li><p><strong>start</strong>：啟動 VM</p></li><li><p><strong>shutdown</strong>：關閉 VM (正常關機程序)</p></li><li><p><strong>reboot</strong>：重新啟動 VM</p></li><li><p><strong>reset</strong>：與 power cycle 相同效果</p></li><li><p><strong>save</strong>：將 VM 狀態儲存到檔案中，並關閉 VM</p></li><li><p><strong>restore</strong>：從指定的檔案將 VM 狀態回復為執行中</p></li><li><p><strong>suspend</strong>：暫停 VM 運作</p></li><li><p><strong>resume</strong>：回復 VM 運作</p></li><li><p><strong>destroy</strong>：直接刪除 QEMU process (類似直接拔掉電腦電源線的效果)</p></li><li><p><strong>create</strong>：使用指定的 XML 建立 VM，並啟動 VM</p></li><li><p><strong>define</strong>：使用指定的 XML 建立 VM，但不啟動 VM</p></li><li><p><strong>undefine</strong>：將 VM 從 libvird 的控制中移除</p></li></ul><hr><h1 id="QEMU-guest-agent"><a href="#QEMU-guest-agent" class="headerlink" title="QEMU guest agent"></a>QEMU guest agent</h1><p>在安裝 virtualbox or VMware 的 VM 時，安裝結束之後都會詢問要不要額外安裝 agent 在 guest VM 中，透過這個 agent，hypervisor 可以更有效率的管理每一個 VM；同樣的在 KVM 中，也是有相同的作法，稱為 <strong>QEMU guest agent</strong>。</p><p><strong>QEMU guest agent</strong> 是一個裝在 guest VM 中的套件，會以 service 的形式存在於背景，接著 service 就變成了 hypervisor &amp; guest OS 之間溝通的橋樑(channel)，hypervisor 會透過這個 channle 取得 VM 的資訊，以及對 VM 進行後續更多的操作；而兩者相互通訊的協定稱為 <strong>Qemu Machine Protocol(QMP)</strong>。</p><p>其中 Hypervisor 與 guest agent 是透過一個名稱為 <code>org.qemu.guest_agent.0</code> 的 virtio-serial channel 或是 isa-serial channel 來處理；而在 Hypervisor 這一端，相對應處理這些資訊交換的 socket file 則是存在於 <code>/var/lib/libvirt/qemu/channel/target</code> 目錄中，且同一個 socket file 可以同時被多個 VM 所共享，因此不會產生太多檔案。</p><p>若 guest VM 為 Linux，可安裝名稱為 <code>qemu-guest-agent</code> 的套件，若是 windows，則可以參考以下連結：</p><ul><li><p><a href="http://www.linux-kvm.org/page/WindowsGuestDrivers/Download_Drivers" target="_blank" rel="noopener">WindowsGuestDrivers/Download Drivers - KVM</a></p></li><li><p><a href="https://fedoraproject.org/wiki/Windows_Virtio_Drivers" target="_blank" rel="noopener">Windows Virtio Drivers - FedoraProject</a></p></li></ul><p>除了安裝 <code>qemu-guest-agent</code> 套件之外，還要確認 <code>qemu-guest-agent</code> service 是否有正確啟動：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl status qemu-guest-agent</span><br><span class="line">● qemu-guest-agent.service - QEMU Guest Agent</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/qemu-guest-agent.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Thu 2016-11-24 22:25:07 EST; 35min ago</span><br><span class="line">   ......</span><br></pre></td></tr></table></figure><p>確認服務沒有問題，我們就可以使用類似以下的命令在 KVM host 端取得 guest VM 的相關資訊：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ virsh qemu-agent-command &lt;GUEST_VM_NAME&gt; <span class="string">'&#123;"execute": "guest-info"&#125;'</span> --pretty</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"return"</span>: &#123;</span><br><span class="line">        <span class="string">"version"</span>: <span class="string">"2.3.0"</span>,</span><br><span class="line">        <span class="string">"supported_commands"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"enabled"</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">"name"</span>: <span class="string">"guest-get-memory-block-info"</span>,</span><br><span class="line">                <span class="string">"success-response"</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">.......</span><br></pre></td></tr></table></figure><blockquote><p>QMP 資料通訊使用 JSON format</p></blockquote><hr><h1 id="Virtual-Video-cards-amp-graphics"><a href="#Virtual-Video-cards-amp-graphics" class="headerlink" title="Virtual Video cards &amp; graphics"></a>Virtual Video cards &amp; graphics</h1><p>為了可以”看見” VM 的運作狀態，QEMU 需要提供兩個元素來達成這件任務：</p><ol><li><p><strong>virtual video card</strong>：讓每個 VM 都擁有一張虛擬的顯示卡</p></li><li><p>從遠端存取 VM 虛擬顯示卡的方式 or 協定</p></li></ol><h2 id="Virtual-Video-Card"><a href="#Virtual-Video-Card" class="headerlink" title="Virtual Video Card"></a>Virtual Video Card</h2><p>顯示卡的用途在於顯示圖形資料到顯示設備上，而虛擬顯示卡同樣也是為了這個目的而存在的。</p><p>然而在虛擬環境中當然沒有實體顯示卡，因此 QEMU 支援模擬以下幾種顯示卡：</p><ul><li><p><strong>Cirrus</strong>：libvirt 預設的顯示卡，可模擬 <strong>Cirrus Logic GD5446</strong> 顯示卡，Windows 95 之後的作業系統都支援這張顯示卡</p></li><li><p><strong>VGA</strong>：搭配 Bochs VBE extensions 的標準顯示卡，Windows XP 以後的作業系統可以支援(可設定 &gt;= 1280x1024x16 解析度 &amp; 大小的畫質)</p></li><li><p><strong>VMVGA</strong>：在 VGA 再更高階的虛擬顯示卡</p></li><li><p><strong>QXL</strong>：半虛擬化顯示卡，搭配在 VM 內安裝 QXL guest driver，可得到很不錯的顯示效果，而且是搭配 <strong>spice</strong> protocol 的最佳選擇</p></li></ul><p>在安裝 VM 時，libvirt 就會根據安裝的 OS，協助選擇一個最合適的顯示卡，通常安裝最近發佈的 OS，都會直接選配 QXL；若是 Windows 或是比較舊版的 Linux，可能就會使用 Cirrus。</p><h2 id="Graphics"><a href="#Graphics" class="headerlink" title="Graphics"></a>Graphics</h2><p>當 VM 有了顯示卡之後，接著需要一個可以存取圖形訊號的方法，在 KVM 中是透過 <strong>graphic server</strong> 的方式，目前提供了 <strong>VNC</strong> &amp; *<em>SPICE</em> 兩種 graphic server。</p><p>當 VM 確定好顯示卡之後，QEMU 就會啟動相對應的 Spice or VNC server，並與 VM 的顯示卡進行連接，以便讓外部的 client 可以使用圖形化的方式存取 VM。</p><h3 id="1-VNC"><a href="#1-VNC" class="headerlink" title="(1) VNC"></a>(1) VNC</h3><p>要為 VM 設定一個 VNC graphic server，可在 XML 定義檔中的 <code>&lt;device&gt;</code> section 內部加入類似以下的定義：(IP &amp; port 都可以自己定義)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">graphics</span> <span class="attr">type</span>=<span class="string">'vnc'</span> <span class="attr">port</span>=<span class="string">'-1'</span> <span class="attr">autoport</span>=<span class="string">'yes'</span> <span class="attr">listen</span>=<span class="string">'192.168.122.1'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listen</span> <span class="attr">type</span>=<span class="string">'address'</span> <span class="attr">address</span>=<span class="string">'192.168.122.1'</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">graphics</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-SPICE"><a href="#2-SPICE" class="headerlink" title="(2) SPICE"></a>(2) SPICE</h3><p>SPICE(Simple Protocol for Independent Computing Environment) 僅有在 Linux 上支援，有以下特色：</p><ol><li><p>可以提供雙向的 audio</p></li><li><p>高效率的 2D 圖像繪製能力</p></li><li><p>可利用到 client 端的顯示卡的能力</p></li><li><p>支援加密、資料壓縮</p></li><li><p>支援透過網路的 USB passthrough</p></li></ol><p>因此若要規劃把 KVM 用在 VDI 的應用上，使用 <code>QXL</code> + <code>SPICE</code> 目前是最好的組合。</p><p>要為 VM 設定一個 SPICE graphic server，可在 XML 定義檔中的 <code>&lt;device&gt;</code> section 內部加入類似以下的定義：(IP &amp; port 都可以自己定義)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">graphics</span> <span class="attr">type</span>=<span class="string">'spice'</span> <span class="attr">autoport</span>=<span class="string">'yes'</span> <span class="attr">listen</span>=<span class="string">'0.0.0.0'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listen</span> <span class="attr">type</span>=<span class="string">'address'</span> <span class="attr">address</span>=<span class="string">'0.0.0.0'</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">graphics</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><p><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Virtualization_Administration_Guide/sect-QEMU_Guest_Agent-Running_the_QEMU_guest_agent_on_a_Windows_guest.html" target="_blank" rel="noopener">Virtualization Administration Guide &gt; Running the QEMU Guest Agent on a Windows Guest</a></p></li><li><p><a href="http://www.linux-kvm.org/page/WindowsGuestDrivers/Download_Drivers" target="_blank" rel="noopener">WindowsGuestDrivers/Download Drivers - KVM</a></p></li><li><p><a href="https://fedoraproject.org/wiki/Windows_Virtio_Drivers" target="_blank" rel="noopener">Windows Virtio Drivers - FedoraProject</a></p></li></ul>]]></content>
      
      <categories>
          
          <category> KVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> KVM </tag>
            
            <tag> SPICE </tag>
            
            <tag> VNC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Git] Cheat Sheet</title>
      <link href="/blog/2016/11/08/Git/Git-Cheat-Sheets/"/>
      <url>/blog/2016/11/08/Git/Git-Cheat-Sheets/</url>
      <content type="html"><![CDATA[<h1 id="The-Basics"><a href="#The-Basics" class="headerlink" title="The Basics"></a>The Basics</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a Git repository in the current folder.</span></span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># View the status of each file in a repository.</span></span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># Stage a file for the next commit.</span></span><br><span class="line">$ git add &lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Commit the staged files with a descriptive message.</span></span><br><span class="line">$ git commit</span><br><span class="line"></span><br><span class="line"><span class="comment"># View a repository’s commit history.</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以單行的方式顯示 git log (commit log)</span></span><br><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以單行的方式顯示與指定檔案相關的 git log</span></span><br><span class="line">$ git <span class="built_in">log</span> --oneline &lt;file_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 詳細列出所有 commit 的歷史紀錄</span></span><br><span class="line">$ git <span class="built_in">log</span> --graph --abbrev-commit --decorate --date=relative --all</span><br><span class="line">    </span><br><span class="line"><span class="comment"># Define the author name to be used in all repositories.</span></span><br><span class="line">$ git config --global user.name <span class="string">"&lt;name&gt;"</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># Define the author email to be used in all repositories. </span></span><br><span class="line">$ git config --global user.email &lt;email&gt;</span><br></pre></td></tr></table></figure><hr><h1 id="Undoing-Changes"><a href="#Undoing-Changes" class="headerlink" title="Undoing Changes"></a>Undoing Changes</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 將 HEAD 指標移到指定的 commit or tag(sha1_checksum_prefix 可由 "git log --oneline" 取得)</span></span><br><span class="line"><span class="comment"># 若 git log 沒有加上 "--all" 參數，就會看不到比 HEAD 更新的 commit snapshot</span></span><br><span class="line">$ git checkout &lt;commit-id | tag-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回到最新的 commit 紀錄("master" 會固定指向最新一筆 commit snapshot)</span></span><br><span class="line">$ git checkout master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 為目前最新的 commit 加上一個 annotated tag (通常 tag 用來作為正式 release 的標記用途)</span></span><br><span class="line">$ git tag -a &lt;tag-name&gt; -m <span class="string">"&lt;description&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出目前所有的 tag 紀錄</span></span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># undo 指定的 commit (重要! 這並非是回到特定 commit 的概念)</span></span><br><span class="line"><span class="comment"># 即使 commit 被 undo，其實歷史紀錄還是永遠保留著，這是 git 的特性</span></span><br><span class="line">$ git revert &lt;commit-id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消所有 tracked 的變更，回到最新的 commit (但不包含 untracked 的部分，例如：新增的檔案)</span></span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除 untracked files (與上一個指令搭配使用，此時應該回復到一個乾淨的 working directory，亦即為最新的 commit snapshot)</span></span><br><span class="line">$ git clean -f</span><br></pre></td></tr></table></figure><blockquote><p>需要注意 <code>git reset --hard</code> + <code>git clean -f</code> 的使用，是在 working directory 上生效，並不是在 commit snapshot 上，因此一旦 undo 之後，所有尚未 commit 的變更都會完全消失且無法追溯，請確定真的不要這些變更之後，再執行這兩個指令</p></blockquote><hr><h1 id="Branches"><a href="#Branches" class="headerlink" title="Branches"></a>Branches</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 顯示所有的 branch (星號的部分表示目前所在的 branch)</span></span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用目前的 working directory 作為基礎，新增 branch</span></span><br><span class="line">$ git branch &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將 HEAD 指標以及 working directory 移到指定的 branch</span></span><br><span class="line">$ git checkout &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將指定的 branch 與目前所在的 branch(checked-out) 做合併</span></span><br><span class="line">$ git merge &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刪除指定的 branch</span></span><br><span class="line">$ git branch -d &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 強制刪除尚未合併的 branch (將會永遠遺失所有的檔案變更)</span></span><br><span class="line">$ git branch -D &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 從 working directory 中移除 &amp; 停止追蹤指定的檔案</span></span><br><span class="line">$ git rm &lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改檔案名稱</span></span><br><span class="line">$ git mv &lt;old-filename&gt; &lt;new-filename&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用一行指令直接 commit 所有狀態為 tracked 的檔案，並指定 commit 內容</span></span><br><span class="line">$ git commit -a -m <span class="string">"&lt;message&gt;"</span></span><br></pre></td></tr></table></figure><p>以下 <strong>master</strong> branch 合併 <strong>css</strong> branch 的狀況稱為 <code>fast-forward merge</code>：</p><p><img src="http://rypress.com/tutorials/git/media/3-10.png" alt="fast-forward merge"></p><blockquote><p>因為 css branch 是從 master branch 中最新的 commit snapshot 所延伸出來，所以 master branch 合併 css branch 是不需要做什麼額外的判斷處理</p></blockquote><p>使用 branch 的基本原則：</p><ol><li><p>為每一個主要的新增功能，都使用 branch 的方式來完成</p></li><li><p>若無法為 branch 取一個實際的名稱(無法定義修改的內容為何)，就不要使用 branch</p></li></ol><p>!3-way merge](<a href="http://rypress.com/tutorials/git/media/4-1.png" target="_blank" rel="noopener">http://rypress.com/tutorials/git/media/4-1.png</a>)</p><blockquote><p>3-way merge 在當要合併兩個擁有不同 commit snapshot 時會發生，此時 Git 會額外建立一個 merge commit snapshot，並同時指向兩個不同的 branch(如上圖中的 <strong>After</strong>，紅色圈圈表示這個 commit snapshot 同時來自 crazy &amp; master 兩個 branch)</p></blockquote><blockquote><p>fast-forward merge 不會在 project history 中看到，這是與 3-way merge 不同的地方</p></blockquote><hr><h1 id="Rebasing"><a href="#Rebasing" class="headerlink" title="Rebasing"></a>Rebasing</h1><p>當整個 git 專案越來越多 branch 時，可以透過 rebase 的方式來整理 branch，避免過於凌亂；此外，rebase 也有在不進行 merge 的情況下，取得最新版 master 的效果。</p><p>透過 rebase 可以把 branch 指向指定 branch 的最新 commit snapshot；舉例來說，可將多餘的 branch 重新 rebase 後指向 master 最新的 commit snapshot，如此一來後續進行 merge 時就會變成 <strong>fast-forward merge</strong>，相關的 commit snapshot 都變成了 linear history，這樣在後續檢視上會更為直覺。</p><blockquote><p>rebase 雖然可以讓整體專案的 branch 更為簡潔易讀，但在某些 rebase 操作上會移除(or 修改)某些 commit snapshot，因此後續就會無法還原當初 commit snapshot 的全貌，這也是 rebase 功能有所爭議的地方</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 檢視 branch-feature 是否有落後 branch-dev，有顯示 commit snapshot 則表示落後，可考慮進行 rebase</span></span><br><span class="line">$ git <span class="built_in">log</span> &lt;branch-feature&gt;..&lt;branch-dev&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將目前的 branch 的 root commit snapshot 指向 new-base 最新的 commit snapshot</span></span><br><span class="line">$ git rebase &lt;new-base&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以互動的方式進行 rebse 的設定，並可選擇對每個 commit snapshot 所要執行的動作</span></span><br><span class="line">$ git rebase -i &lt;new-base&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改已經存在的 commit snapshot，不產生新的 (搭配上面 rebase 編輯 commit snapshop list 時使用 edit/squash 等關鍵是)</span></span><br><span class="line">$ git commit --amend</span><br><span class="line"></span><br><span class="line"><span class="comment"># 完成修改了特定的 commit snapshot 資訊後，繼續進行 rebase 工作</span></span><br><span class="line">$ git rebase --<span class="built_in">continue</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 放棄目前的 rebase 結果並回到原先的狀態</span></span><br><span class="line">git rebase --abort</span><br><span class="line"></span><br><span class="line"><span class="comment"># 強制 git 不以 fast-forward 的方式進行 merge，藉此保留 branch 的相關資訊</span></span><br><span class="line">git merge --no-ff &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p>以下用圖說明執行 <code>git merge</code> 指令時有無加上 <code>--no-ff</code> 參數所產生的效果：</p><p><img src="https://i0.wp.com/farm6.static.flickr.com/5054/5488984566_359f74ecc2.jpg?resize=463%2C414&amp;ssl=1" alt="git merge"></p><hr><h1 id="Rewriting-History"><a href="#Rewriting-History" class="headerlink" title="Rewriting History"></a>Rewriting History</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 顯示本地端所有的 commit snapshot (以時間排序，包含已經被 reset 的 commit snapshot)</span></span><br><span class="line">$ git reflog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將 HEAD 指標往前移到第 n 的 commit snapshot，但不變更 working directory 中的內容</span></span><br><span class="line"><span class="comment"># 比 HEAD~&lt;n&gt; 還新的 commit snapshot 中的變更會保留</span></span><br><span class="line">$ git reset --mixed HEAD~&lt;n&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將 HEAD 指標往前移到第 n 的 commit snapshot，但會變更 working directory 中的內容</span></span><br><span class="line"><span class="comment"># 比 HEAD~&lt;n&gt; 還新的 commit snapshot 中的變更會被移除</span></span><br><span class="line">$ git reset --hard HEAD~&lt;n&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示從 &lt;since&gt; &amp; &lt;until&gt; 兩個 branch 之間的 commit snapshot 紀錄</span></span><br><span class="line">$ git <span class="built_in">log</span> &lt;since&gt;..&lt;until&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 git log 顯示訊息中額外包含被修改的檔案資訊</span></span><br><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span></span><br></pre></td></tr></table></figure><hr><h1 id="Remotes"><a href="#Remotes" class="headerlink" title="Remotes"></a>Remotes</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 從遠端複製指定的 Git repository 回來</span></span><br><span class="line">$ git <span class="built_in">clone</span> &lt;remote-path&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出 remote repository 列表(若加上 -v 參數會顯示每個 remote repository 的詳細位址)</span></span><br><span class="line">$ git remote</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增一筆 remote repository 記錄</span></span><br><span class="line">$ git remote add &lt;remote-name&gt; &lt;remote-path&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取得 remote repository 的指定 branch (不進行 merge)</span></span><br><span class="line">$ git fetch &lt;remote-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># merge 指定的 remote repository branch 到目前所在的 branch</span></span><br><span class="line">$ git merge &lt;remote-name&gt;/&lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出 remote repository branch</span></span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將 local repository branch 推送到 remote repository branch 進行更新</span></span><br><span class="line">$ git push &lt;remote-name&gt; &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 為 remote repository 加上一個 tag</span></span><br><span class="line">$ git push &lt;remote-name&gt; &lt;tag-name&gt;</span><br></pre></td></tr></table></figure><hr><h1 id="Centralized-Workflows"><a href="#Centralized-Workflows" class="headerlink" title="Centralized Workflows"></a>Centralized Workflows</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立 git repository，但沒有 working directory (只是用來存放檔案用)</span></span><br><span class="line">$ git init --bare &lt;repository-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除 remote connection</span></span><br><span class="line">$ git remote rm &lt;remote-name&gt;</span><br></pre></td></tr></table></figure><hr><h1 id="Patch-Workflows"><a href="#Patch-Workflows" class="headerlink" title="Patch Workflows"></a>Patch Workflows</h1><p><img src="http://rypress.com/tutorials/git/media/10-2.png" alt="patch workflows"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立 patch，包含了目前所在的 branch 有的，卻沒有在 &lt;branch-name&gt; branch 出現的 commit snapshot</span></span><br><span class="line">$ git format-patch &lt;branch-name&gt;</span><br><span class="line">    Create a patch <span class="keyword">for</span> each commit contained <span class="keyword">in</span> the current branch but not <span class="keyword">in</span> &lt;branch-name&gt;. You can also specify a commit ID instead of &lt;branch-name&gt;.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 套用  patch 到目前的 branch</span></span><br><span class="line">$ git am &lt; &lt;patch-file&gt;</span><br></pre></td></tr></table></figure><hr><h1 id="Tips-amp-Tricks"><a href="#Tips-amp-Tricks" class="headerlink" title="Tips &amp; Tricks"></a>Tips &amp; Tricks</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 備份目前的 branch，但只留下最新的一筆 commit snapshot</span></span><br><span class="line">$ git archive &lt;branch-name&gt; --format=zip --output=&lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 完整匯出指定的 branch 到指定檔案(會包含所有 commit snapshot 記錄)</span></span><br><span class="line">$ git bundle create &lt;file&gt; &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過 bundled repository 重新建立一個 repository 並 checkout 指定的 branch</span></span><br><span class="line">$ git <span class="built_in">clone</span> repo.bundle &lt;repo-dir&gt; -b &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暫時將變更隱藏，將目前的目錄變為乾淨的 working directory</span></span><br><span class="line">$ git stash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將隱藏的變更套用到 working directory</span></span><br><span class="line">$ git stash apply</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視兩個 commit snapshot 之間的差異</span></span><br><span class="line">$ git diff &lt;commit-id&gt;..&lt;commit-id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視目前 working directory 與 staging area 的差異</span></span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視目前 staging area 與最新一筆 commit snapshot 之間的差異</span></span><br><span class="line">$ git diff --cached</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將指令檔案從 commit snapshot 中移到 staged snapshot 中</span></span><br><span class="line">$ git reset HEAD &lt;file&gt;</span><br><span class="line">    Unstage a file, but don’t alter the working directory or move the current branch.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 從指定的 commit snapshot 中取得指定檔案</span></span><br><span class="line">$ git checkout &lt;commit-id&gt; &lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定 git command alias</span></span><br><span class="line">$ git config --global <span class="built_in">alias</span>.&lt;<span class="built_in">alias</span>-name&gt; &lt;git-command&gt;</span><br></pre></td></tr></table></figure><p><strong>git reset</strong>：<br><img src="http://rypress.com/tutorials/git/media/11-1.png" alt="git reset"></p><p><strong>git checkout</strong>：<br><img src="http://rypress.com/tutorials/git/media/11-2.png" alt="git checkout"></p><hr><h1 id="Plumbing"><a href="#Plumbing" class="headerlink" title="Plumbing"></a>Plumbing</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 顯示指定的 object 內容(其中 &lt;type&gt; 可以是 commit / tree / blob / tag)</span></span><br><span class="line">$ git cat-file &lt;<span class="built_in">type</span>&gt; &lt;object-id&gt;</span><br></pre></td></tr></table></figure><p><img src="http://rypress.com/tutorials/git/media/12-1.png" alt="commit and tree objects"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查詢指定的 object id 是屬於哪種 type</span></span><br><span class="line">$ git cat-file -t &lt;object-id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出指定 tree 物件的內容</span></span><br><span class="line">$ git ls-tree &lt;tree-id&gt;</span><br><span class="line">040000 tree 5aa02e7f90df11621262d7fe91a9357bb44494aaabout</span><br><span class="line">100644 blob 4838a99c7bb4cc75941ff0a5e3a05fe4889570f9blue.html</span><br><span class="line">.......</span><br><span class="line">100644 blob c9d942d8aadb84617d78455f8e2da25866c079a2style.css</span><br><span class="line">100644 blob e9d1781fd949fd41d2439ae3824a293531bc38a5yellow.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示指定 object id(這裡指的是 blob 物件) 的內容</span></span><br><span class="line">$ git cat-file blob e9d178</span><br></pre></td></tr></table></figure><p><img src="http://rypress.com/tutorials/git/media/12-2.png" alt="commit, tree, and blob objects"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 對 git object database 進行 garbage collection </span></span><br><span class="line">$ git gc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將指定的檔案從 working directory 移到 staged area (新增的檔案要額外加上 --add 參數)</span></span><br><span class="line">$ git update-index [--add] &lt;file&gt;</span><br><span class="line">    Stage the specified file, using the optional --add flag to denote a new untracked file.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 從目前的 index 中產生一個 tree 物件，並存入 object database 中</span></span><br><span class="line">$ git write-tree</span><br><span class="line"></span><br><span class="line"><span class="comment"># 從指定的 tree object &amp; parent commit 中產生一個新的 commit 物件</span></span><br><span class="line">$ git commit-tree &lt;tree-id&gt; -p &lt;parent-id&gt;</span><br></pre></td></tr></table></figure><hr><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><p><a href="http://rypress.com/tutorials/git/index" target="_blank" rel="noopener">Ry’s Git Tutorial - RyPress</a></p></li><li><p><a href="https://blog.yorkxin.org/2011/07/29/git-rebase" target="_blank" rel="noopener">Git-rebase 小筆記 - Yu-Cheng Chuang’s Blog</a></p></li><li><p><a href="https://blog.wu-boy.com/2011/03/git-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6-branch-model-%E5%88%86%E6%94%AF%E6%A8%A1%E7%B5%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%B4%B9/" target="_blank" rel="noopener">Git 版本控制 branch model 分支模組基本介紹 | 小惡魔 - 電腦技術 - 工作筆記 - AppleBOY</a></p></li><li><p><a href="http://hungyuhei.github.io/2012/08/07/better-git-commit-graph-using-pull---rebase-and-merge---no-ff.html" target="_blank" rel="noopener">洁癖者用 Git：pull –rebase 和 merge –no-ff</a></p></li><li><p><a href="https://speakerdeck.com/mouson/laradebut-number-03-cong-git-ru-men-dao-tuan-dui-he-zuo-kai-fa" target="_blank" rel="noopener">Laradebut #03 從 git 入門到團隊合作開發 // Speaker Deck</a></p></li><li><p><a href="http://ithelp.ithome.com.tw/tags/articles/git?page=2" target="_blank" rel="noopener">Tag 列表頁(git) - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天</a></p></li></ul>]]></content>
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Git] Get Started with Git</title>
      <link href="/blog/2016/10/29/Git/Get-Started-with-Git/"/>
      <url>/blog/2016/10/29/Git/Get-Started-with-Git/</url>
      <content type="html"><![CDATA[<p>介紹開始使用 Git 前調教 config 的相關資訊</p><h1 id="初始化-Git-Repository"><a href="#初始化-Git-Repository" class="headerlink" title="初始化 Git Repository"></a>初始化 Git Repository</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化 git repository</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git init</span></span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /root/git/git-lab/.git/</span><br></pre></td></tr></table></figure><hr><h1 id="Git-config"><a href="#Git-config" class="headerlink" title="Git config"></a>Git config</h1><h2 id="常用-Git-config-gitconfig"><a href="#常用-Git-config-gitconfig" class="headerlink" title="常用 Git config (~/.gitconfig)"></a>常用 Git config (~/.gitconfig)</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[user]</span></span><br><span class="line">    email = godleon@gmail.com</span><br><span class="line">    name = godleon</span><br><span class="line"><span class="section">[core]</span></span><br><span class="line">    editor = vim</span><br><span class="line">    </span><br><span class="line">    repositoryformatversion = 0</span><br><span class="line">    filemode = true</span><br><span class="line">    bare = false</span><br><span class="line">    logallrefupdates = true</span><br><span class="line"><span class="section">[color]</span></span><br><span class="line">    ui = true</span><br><span class="line"><span class="section">[alias]</span></span><br><span class="line">    tree = log --all --graph --decorate=short --color --format=format:'%C(bold blue)%h%C(reset) %C(auto)%d%C(reset)\n         %C(black)[%cr]%C(reset)  %x09%C(black)%an: %s %C(reset)'</span><br><span class="line"></span><br><span class="line">    logs = log --all --graph --decorate=short --color --format=format:'%C(bold blue)%h%C(reset)+%C(dim black)(%cr)%C(reset)+%C(auto)%d%C(reset)++\n+++       %C(bold black)%an%C(reset)%C(black): %s%C(reset)'</span><br><span class="line"></span><br><span class="line">    stree = !bash -c '"                                                                             \</span><br><span class="line">    while IFS=+ read -r hash time branch message; do                                            \</span><br><span class="line">        timelength=$(echo \"$time\" | sed -r \"s:[^ ][[]([0-9]&#123;1,2&#125;(;[0-9]&#123;1,2&#125;)?)?m::g\");     \</span><br><span class="line">        timelength=$(echo \"16+$&#123;#time&#125;-$&#123;#timelength&#125;\" | bc);                                 \</span><br><span class="line">        printf \"%$&#123;timelength&#125;s    %s %s %s\n\" \"$time\" \"$hash\" \"$branch\" \"\";          \</span><br><span class="line">    done &lt; &lt;(git logs &amp;&amp; echo);"'</span><br><span class="line"></span><br><span class="line">    logv = log --all --graph --decorate=short --color --format=format:'%C(bold blue)%h%C(reset)+%C(dim black)(%cr)%C(reset)+%C(auto)%d%C(reset)++\n+++       %C(bold black)%an%C(reset)%C(black): %s%C(reset)'</span><br><span class="line"></span><br><span class="line">    vtree = !bash -c '"                                                                             \</span><br><span class="line">    while IFS=+ read -r hash time branch message; do                                            \</span><br><span class="line">        timelength=$(echo \"$time\" | sed -r \"s:[^ ][[]([0-9]&#123;1,2&#125;(;[0-9]&#123;1,2&#125;)?)?m::g\");     \</span><br><span class="line">        timelength=$(echo \"16+$&#123;#time&#125;-$&#123;#timelength&#125;\" | bc);                                 \</span><br><span class="line">        printf \"%$&#123;timelength&#125;s    %s %s %s\n\" \"$time\" \"$hash\" \"$branch\" \"$message\";  \</span><br><span class="line">    done &lt; &lt;(git logv &amp;&amp; echo);"'</span><br></pre></td></tr></table></figure><h2 id="Git-config-優先權"><a href="#Git-config-優先權" class="headerlink" title="Git config 優先權"></a>Git config 優先權</h2><p>Git config 的優先權如下：</p><ol><li><p><code>.git/config</code></p></li><li><p><code>~/.gitconfig</code></p></li><li><p><code>/etc/gitconfig</code></p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 檢視 ".git/config" 的內容</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># cat .git/config</span></span><br><span class="line">[core]</span><br><span class="line">        repositoryformatversion = 0</span><br><span class="line">        filemode = <span class="literal">true</span></span><br><span class="line">        bare = <span class="literal">false</span></span><br><span class="line">        logallrefupdates = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示目前有效的 git config</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git config -l</span></span><br><span class="line">core.repositoryformatversion=0</span><br><span class="line">core.filemode=<span class="literal">true</span></span><br><span class="line">core.bare=<span class="literal">false</span></span><br><span class="line">core.logallrefupdates=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 '/etc/gitconfig' 中的設定</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git config --system -l</span></span><br><span class="line">fatal: unable to <span class="built_in">read</span> config file <span class="string">'/etc/gitconfig'</span>: No such file or directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 ~/.gitconfig 中的設定</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git config --global -l</span></span><br><span class="line">fatal: unable to <span class="built_in">read</span> config file <span class="string">'/root/.gitconfig'</span>: No such file or directory</span><br></pre></td></tr></table></figure><h2 id="設定-amp-移除-git-config"><a href="#設定-amp-移除-git-config" class="headerlink" title="設定 &amp; 移除 git config"></a>設定 &amp; 移除 git config</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下的設定將會存在 ~/.gitconfig 中</span></span><br><span class="line"><span class="comment"># 若改成 "--system" 參數，則設定會存在 '/etc/gitconfig'</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git config --global user.name 'godleon'</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git config --global user.email 'godleon@gmail.com'</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git config --list</span></span><br><span class="line">user.name=godleon</span><br><span class="line">user.email=godleon@gmail.com</span><br><span class="line">core.repositoryformatversion=0</span><br><span class="line">core.filemode=<span class="literal">true</span></span><br><span class="line">core.bare=<span class="literal">false</span></span><br><span class="line">core.logallrefupdates=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除 git config 設定</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git config --global --unset user.name</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git config --list</span></span><br><span class="line">user.email=godleon@gmail.com</span><br><span class="line">core.repositoryformatversion=0</span><br><span class="line">core.filemode=<span class="literal">true</span></span><br><span class="line">core.bare=<span class="literal">false</span></span><br><span class="line">core.logallrefupdates=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="設定-Git-alias"><a href="#設定-Git-alias" class="headerlink" title="設定 Git alias"></a>設定 Git alias</h2><p>跟 Linux 的 alias 很像，可以自訂簡單的命令來替代複雜的指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 git-lab]<span class="comment"># git config alias.con 'config -l'</span></span><br><span class="line"><span class="comment"># 此命令等同於 "git config -l" 的效果</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git con</span></span><br><span class="line">user.email=godleon@gmail.com</span><br><span class="line">core.repositoryformatversion=0</span><br><span class="line">core.filemode=<span class="literal">true</span></span><br><span class="line">core.bare=<span class="literal">false</span></span><br><span class="line">core.logallrefupdates=<span class="literal">true</span></span><br><span class="line">alias.con=config -l</span><br></pre></td></tr></table></figure><h2 id="設定-editor-amp-diff-tool"><a href="#設定-editor-amp-diff-tool" class="headerlink" title="設定 editor &amp; diff tool"></a>設定 editor &amp; diff tool</h2><ul><li><p><code>git config --global color.ui true</code>：加上顏色</p></li><li><p><code>git config --global core.editor vim</code>：把預設的文字編輯器改為 vim</p></li><li><p><code>git config --global diff.tool meld</code>：把預設的 diff tool 改為 meld (要先安裝 meld，且這是 GUI tool，不適用 text mode)</p></li><li><p><code>git difftool</code>：查詢檔案差異</p></li></ul><hr><h1 id="將檔案存入-Git-Repository"><a href="#將檔案存入-Git-Repository" class="headerlink" title="將檔案存入 Git Repository"></a>將檔案存入 Git Repository</h1><h2 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h2><p>Git 追蹤檔案的方式，會將檔案 &amp; 資料夾分成三類：</p><ol><li><p>untracked</p><blockquote><p>一開始所有檔案都是 untracked，執行 <code>git status</code> 可以看到 untracked 的檔案清單</p></blockquote></li><li><p>tracked</p><blockquote><p>當透過 <code>git add</code> 處理之後的檔案，狀態會變成 tracked，等待使用者進一步的 commit or cancel</p></blockquote></li><li><p>ignored</p><blockquote><p>會被 git 忽略處理的檔案，需要新增 <code>.gitignore</code> 檔案，並逐行宣告要忽略的檔案 (被設定忽略的檔案狀態不會變成 untracked)</p></blockquote></li></ol><p>以下為 <code>.gitignore</code> 設定範例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可用萬用字元(# 開頭為註解)</span></span><br><span class="line">*.txt</span><br><span class="line"><span class="comment"># 不要忽略 note.txt 檔案</span></span><br><span class="line">!note.txt</span><br><span class="line"><span class="comment"># folder 資料夾 &amp; 資料夾內的檔案通通忽略</span></span><br><span class="line">folder</span><br></pre></td></tr></table></figure><h2 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h2><h3 id="1、從-tracked-復原到-untracked"><a href="#1、從-tracked-復原到-untracked" class="headerlink" title="1、從 tracked 復原到 untracked"></a>1、從 tracked 復原到 untracked</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加入 file1.txt，狀態變成 tracked</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git add file1.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 從 git index 中移除，狀態變回 untracked</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git rm --cache file1.txt</span></span><br></pre></td></tr></table></figure><h3 id="2、從已經-commit-後的狀態回復原狀"><a href="#2、從已經-commit-後的狀態回復原狀" class="headerlink" title="2、從已經 commit 後的狀態回復原狀"></a>2、從已經 commit 後的狀態回復原狀</h3><p>首先先來看看如何顯示目前 commit 的狀態</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此為自訂的 alias，請參考上方設定</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git tree</span></span><br><span class="line">* 72f32d4  (HEAD, master)</span><br><span class="line">|          [25 minutes ago]     root: commit of file1</span><br><span class="line">* fbaedbb</span><br><span class="line"></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git log --graph --oneline --decorate --date=relative --all</span></span><br><span class="line">* 72f32d4 (HEAD, master) commit of file1</span><br><span class="line">* fbaedbb First commit</span><br><span class="line"></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git log --graph --abbrev-commit --decorate --date=relative --all</span></span><br><span class="line">* commit 72f32d4 (HEAD, master)</span><br><span class="line">| Author: root &lt;godleon@gmail.com&gt;</span><br><span class="line">| Date:   23 minutes ago</span><br><span class="line">|</span><br><span class="line">|     commit of file1</span><br><span class="line">|</span><br><span class="line">* commit fbaedbb</span><br><span class="line">  Author: root &lt;godleon@gmail.com&gt;</span><br><span class="line">  Date:   9 hours ago</span><br><span class="line"></span><br><span class="line">      First commit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消剛剛 commit 的狀態，將 file1.txt 狀態回復到 untracked 的狀態</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git reset HEAD^</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git status</span></span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Untracked files:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to include in what will be committed)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       .gitignore</span></span><br><span class="line"><span class="comment">#       file1.txt</span></span><br><span class="line"><span class="comment">#       file2.txt</span></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">"git add"</span> to track)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目前 HEAD 已經回到第一次  commit 的地方</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git tree</span></span><br><span class="line">* fbaedbb  (HEAD, master)</span><br></pre></td></tr></table></figure><hr><h1 id="比較檔案差異-amp-從-Git-Repository-取回檔案"><a href="#比較檔案差異-amp-從-Git-Repository-取回檔案" class="headerlink" title="比較檔案差異 &amp; 從 Git Repository 取回檔案"></a>比較檔案差異 &amp; 從 Git Repository 取回檔案</h1><h2 id="比較檔案差異"><a href="#比較檔案差異" class="headerlink" title="比較檔案差異"></a>比較檔案差異</h2><p>git 提供了很多方式來檢視不同版本間的檔案差異，主要就是使用 <code>git diff</code> &amp; <code>git difftool</code> 來完成此功能，以下用個簡單範例來說明：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出目前的 commit 紀錄</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git tree</span></span><br><span class="line">* 81618ad  (HEAD, master)</span><br><span class="line">|          [2 hours ago]        godleon: 2nd commit <span class="keyword">for</span> file1.txt</span><br><span class="line">* fbaedbb</span><br><span class="line">           [2 days ago]         root: First commit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目前 file1.txt 已經有修改</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git status</span></span><br><span class="line"><span class="comment"># On branch master</span></span><br><span class="line"><span class="comment"># Changes not staged for commit:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to update what will be committed)</span></span><br><span class="line"><span class="comment">#   (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       modified:   file1.txt</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Untracked files:</span></span><br><span class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to include in what will be committed)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       .gitignore</span></span><br><span class="line"><span class="comment">#       file2.txt</span></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比較本地端檔案 &amp; git repository 的差異</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git diff</span></span><br><span class="line">diff --git a/file1.txt b/file1.txt</span><br><span class="line">index 7cca94a..3aff906 100644</span><br><span class="line">--- a/file1.txt</span><br><span class="line">+++ b/file1.txt</span><br><span class="line">@@ -1,2 +1,3 @@</span><br><span class="line"> file1, line 1</span><br><span class="line"> file1, line2</span><br><span class="line">+file1, line3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將檔案 file1.txt 移到 staging 中</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git add file1.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 比較 staging 與 HEAD 的版本差異</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git diff --cached file1.txt</span></span><br><span class="line">diff --git a/file1.txt b/file1.txt</span><br><span class="line">index 7cca94a..3aff906 100644</span><br><span class="line">--- a/file1.txt</span><br><span class="line">+++ b/file1.txt</span><br><span class="line">@@ -1,2 +1,3 @@</span><br><span class="line"> file1, line 1</span><br><span class="line"> file1, line2</span><br><span class="line">+file1, line3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比較不同 commit 之間指定檔案的差異</span></span><br><span class="line">[root@centos7 git-lab]<span class="comment"># git diff HEAD HEAD~1 file1.txt</span></span><br><span class="line">diff --git a/file1.txt b/file1.txt</span><br><span class="line">deleted file mode 100644</span><br><span class="line">index 7cca94a..0000000</span><br><span class="line">--- a/file1.txt</span><br><span class="line">+++ /dev/null</span><br><span class="line">@@ -1,2 +0,0 @@</span><br><span class="line">-file1, line 1</span><br><span class="line">-file1, line2</span><br></pre></td></tr></table></figure><hr><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><p><a href="https://github.com/geeeeeeeeek/git-recipes/wiki" target="_blank" rel="noopener">git-recipes</a></p></li><li><p><a href="http://www-cs-students.stanford.edu/%7Eblynn/gitmagic/intl/zh_tw/index.html" target="_blank" rel="noopener">Git Magic</a></p></li><li><p><a href="http://www.cnblogs.com/fanfan259/p/4810517.html" target="_blank" rel="noopener">我所记录的git命令（非常实用） - 糖糖果 - 博客园</a></p></li><li><p><a href="https://ihower.tw/blog/archives/2622" target="_blank" rel="noopener">Git 版本控制系統(3) 還沒 push 前可以做的事 | ihower { blogging }</a></p></li></ul>]]></content>
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Linux KVM] libvirt &amp; Storage</title>
      <link href="/blog/2016/10/27/KVM/KVM-libvirt-storage/"/>
      <url>/blog/2016/10/27/KVM/KVM-libvirt-storage/</url>
      <content type="html"><![CDATA[<h1 id="建立-amp-使用-unmanaged-storage"><a href="#建立-amp-使用-unmanaged-storage" class="headerlink" title="建立 &amp; 使用 unmanaged storage"></a>建立 &amp; 使用 unmanaged storage</h1><p>建立 unmanaged storage 是幫 VM 增加 virtual disk 最快的方式，其中有兩種作法：</p><ol><li><p><strong>preallocated</strong>：效能好，但完全佔據磁碟空間</p></li><li><p><strong>thin-provisioned</strong>：效能較差，但僅佔據實際使用到的磁碟空間</p></li></ol><p>以下是兩種不同 image 的建立示範：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 產生 preallocated image</span></span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/zero of=/tmp/dbvm_disk1.img bs=1G count=10</span><br><span class="line">10+0 records <span class="keyword">in</span></span><br><span class="line">10+0 records out</span><br><span class="line">10737418240 bytes (11 GB) copied, 8.32924 s, 1.3 GB/s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 產生 thin-provisioned image</span></span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/zero of=/tmp/dbvm_disk1_seek.img bs=1G seek=10 count=0</span><br><span class="line">0+0 records <span class="keyword">in</span></span><br><span class="line">0+0 records out</span><br><span class="line">0 bytes (0 B) copied, 0.000307303 s, 0.0 kB/s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢 image 資訊 (preallocated image 已經完全佔據磁碟空間)</span></span><br><span class="line">$ qemu-img info /tmp/dbvm_disk1.img </span><br><span class="line">image: /tmp/dbvm_disk1.img</span><br><span class="line">file format: raw</span><br><span class="line">virtual size: 10G (10737418240 bytes)</span><br><span class="line">disk size: 10G</span><br><span class="line"><span class="comment"># 查詢 image 資訊 (thin-provisioned image 並未預先佔據磁碟空間)</span></span><br><span class="line">$ qemu-img info /tmp/dbvm_disk1_seek.img </span><br><span class="line">image: /tmp/dbvm_disk1_seek.img</span><br><span class="line">file format: raw</span><br><span class="line">virtual size: 10G (10737418240 bytes)</span><br><span class="line">disk size: 0</span><br></pre></td></tr></table></figure><p>當 image 建立完成，可用以下指令直接掛載到執行中的 VM：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ virsh domblklist centos7</span><br><span class="line">Target     Source</span><br><span class="line">------------------------------------------------</span><br><span class="line">vda        /var/lib/libvirt/images/hdd/vmdisk/centos7.qcow2</span><br><span class="line"></span><br><span class="line"><span class="comment"># vdb =&gt; 指定 image 掛載為 vdb</span></span><br><span class="line"><span class="comment"># --live =&gt; 指定在執行中的 VM 掛載 image</span></span><br><span class="line"><span class="comment"># --config =&gt; 讓此掛載設定可以永久保留，不會因為 VM reboot 而消失</span></span><br><span class="line">$ virsh attach-disk centos7 /tmp/dbvm_disk1.img vdb --live --config</span><br><span class="line">Disk attached successfully</span><br><span class="line"></span><br><span class="line">$ virsh domblklist centos7</span><br><span class="line">Target     Source- [KVM XML 設定檔基本內容](http://www.tfcis.org/~lantw44/download/notes/cs/libvirt.domain(5))</span><br><span class="line">------------------------------------------------</span><br><span class="line">vda        /var/lib/libvirt/images/hdd/vmdisk/centos7.qcow2</span><br><span class="line">vdb        /tmp/dbvm_disk1.img</span><br></pre></td></tr></table></figure><hr><h1 id="建立-amp-使用-managed-storage"><a href="#建立-amp-使用-managed-storage" class="headerlink" title="建立 &amp; 使用 managed storage"></a>建立 &amp; 使用 managed storage</h1><p>為了讓 storage 有個統一標準的管理，除非是很臨時的測試目的需求，不然上面 unmanage 的作法就盡量少作囉!</p><p>libvirt 支援了相當多種的 storage pool，以下一一列出：</p><ul><li><p><code>-dir</code>：使用<strong>標準的檔案系統目錄</strong>儲存 virtual disk</p></li><li><p><code>-disk</code>：使用<strong>實體磁碟機</strong>來建立 virtual disk</p></li><li><p><code>-fs</code>：使用<strong>預設格式化好的磁碟分割</strong>來儲存 virtual disk</p></li><li><p><code>-netfs</code>：使用 <strong>network-shared storage</strong>(例如：NFS) 來儲存 virtual disk</p></li><li><p><code>-gluster</code>：使用 <strong>glusterfs</strong> 儲存 virtual disk</p></li><li><p><code>-iscsi</code>：使用 <strong>iscsi storage</strong> 儲存 virtual disk</p></li><li><p><code>-scsi</code>：使用 <strong>本地端 scsi storage</strong> 儲存 virtual disk </p></li><li><p><code>-lvm</code>：使用 <strong>LVM volume group</strong> 儲存 virtual disk</p></li><li><p><code>-rbd</code>：使用 <strong>Ceph storage</strong> 儲存 virtual disk </p></li></ul><blockquote><p>在 libvirt 中，managed storage 是以 <code>pool</code> + <code>volume</code> 所組合而成</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查詢 pool 列表</span></span><br><span class="line">$ $ virsh -c qemu+ssh://root@10.20.190.2/system pool-list</span><br><span class="line"> Name                 State      Autostart </span><br><span class="line">-------------------------------------------</span><br><span class="line"> default              active     yes       </span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視 pool 的詳細資訊</span></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system pool-info default</span><br><span class="line">Name:           default</span><br><span class="line">UUID:           0896bbcd-a502-4ed8-b484-34d8baf05e84</span><br><span class="line">State:          running</span><br><span class="line">Persistent:     yes</span><br><span class="line">Autostart:      yes</span><br><span class="line">Capacity:       1007.80 GiB</span><br><span class="line">Allocation:     70.07 GiB</span><br><span class="line">Available:      937.73 GiB</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">這些資訊會以 XML 的形式存在於 KVM host 上，以 `default` 為例，其 XML 定義檔的位置為 `/etc/libvirt/storage/default.xml`。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">管理 Storage Pool</span><br><span class="line">=================</span><br><span class="line"></span><br><span class="line">以下使用 filesystem &amp; LVM 作為建立 storage pool 的範例：</span><br><span class="line"></span><br><span class="line"><span class="comment">## (1) 建立 fife system directory backed storage pool</span></span><br><span class="line"></span><br><span class="line">這是上述 `defautl` pool 的方式，使用的是 KVM host 上的 `/var/lib/libvirt/images` 資料夾作為儲存 volume 的位置</span><br><span class="line"></span><br><span class="line">以下是建立一個名稱為 **dedicated_storage** 的簡單方式：</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line"><span class="comment"># 定義 storage pool (會產生 XML 定義檔案在 /etc/libvirt/storage 目錄中)</span></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system pool-define-as dedicated_storage dir - - - - <span class="string">"/vms"</span></span><br><span class="line">Pool dedicated_storage defined</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 storage pool (建立指定目錄 &amp; 設定 SELinux 相關權限)</span></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system pool-build dedicated_storage</span><br><span class="line">Pool dedicated_storage built</span><br><span class="line"></span><br><span class="line"><span class="comment"># 啟動 storage pool</span></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system pool-start dedicated_storage</span><br><span class="line">Pool dedicated_storage started</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定 libvirtd 啟動時，同時啟動此 storage pool</span></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system pool-autostart dedicated_storage</span><br><span class="line">Pool dedicated_storage marked as autostarted</span><br></pre></td></tr></table></figure><h2 id="2-建立-LVM-volume-Group-backed-storage-pool"><a href="#2-建立-LVM-volume-Group-backed-storage-pool" class="headerlink" title="(2) 建立 LVM volume Group backed storage pool"></a>(2) 建立 LVM volume Group backed storage pool</h2><p>使用 LVM 的優點就會有以下優點啦：</p><ol><li><p>彈性伸縮磁碟容量</p></li><li><p>整合不同的磁碟</p></li><li><p>volume snapshots</p></li><li><p>自定義的裝置名稱</p></li><li><p>data striping 提昇 I/O throughput</p></li><li><p>Mirror volumes</p></li></ol><p>所以使用 LVM 作為 storage pool 也是個相當不錯的選項。</p><p>假設目前在 KVM host 中有 <strong>/dev/sdb</strong> &amp; <strong>/dev/sdc</strong> 兩個硬碟可拿來作為 LVM volume，可用以下指令建立 LVM storage pool：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ bash -c <span class="string">'cat &lt;&lt;EOF &gt; /tmp/storage-lvm.xml</span></span><br><span class="line"><span class="string">&lt;pool type="logical"&gt;</span></span><br><span class="line"><span class="string">  &lt;name&gt;HostVG&lt;/name&gt;</span></span><br><span class="line"><span class="string">  &lt;source&gt;</span></span><br><span class="line"><span class="string">    &lt;device path="/dev/sdb"/&gt;</span></span><br><span class="line"><span class="string">    &lt;device path="/dev/sdc"/&gt;</span></span><br><span class="line"><span class="string">  &lt;/source&gt;</span></span><br><span class="line"><span class="string">  &lt;target&gt;</span></span><br><span class="line"><span class="string">    &lt;path&gt;/dev/HostVG&lt;/path&gt;</span></span><br><span class="line"><span class="string">  &lt;/target&gt;</span></span><br><span class="line"><span class="string">&lt;/pool&gt;</span></span><br><span class="line"><span class="string">EOF'</span></span><br><span class="line"></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system pool-define /tmp/storage-lvm.xml </span><br><span class="line">Pool HostVG defined from /tmp/storage-lvm.xml</span><br><span class="line"></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system pool-build HostVG</span><br><span class="line">Pool HostVG built</span><br><span class="line"></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system pool-start HostVG</span><br><span class="line">Pool HostVG started</span><br><span class="line"></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system pool-autostart HostVG</span><br><span class="line">Pool HostVG marked as autostarted</span><br></pre></td></tr></table></figure><h2 id="3-刪除-storage-pool"><a href="#3-刪除-storage-pool" class="headerlink" title="(3) 刪除 storage pool"></a>(3) 刪除 storage pool</h2><p>刪除 storage pool 就相對簡單，假設要刪除上面的 <strong>HostVG</strong> pool，只要透過以下指令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system pool-destroy HostVG</span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system pool-undefine HostVG</span><br></pre></td></tr></table></figure><hr><h1 id="Storage-Volume-的管理"><a href="#Storage-Volume-的管理" class="headerlink" title="Storage Volume 的管理"></a>Storage Volume 的管理</h1><p>透過 virsh 建立 storage volume 的語法類似如下：</p><blockquote><p>virsh vol-create-as –pool POOL_NAME VOL_NAME VOL_SIZE –format raw|qcow2|qed </p></blockquote><p>因此假設我們要在 pool <strong>dedicated_storage</strong> 中建立一個格式為 <strong>qcow2</strong>，大小為 <strong>10G</strong> 的 volume，可用下列語法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立一個名稱為 vm_vol1.qcow2 的 storage volume</span></span><br><span class="line">$ $ virsh -c qemu+ssh://root@10.20.190.2/system vol-create-as --pool dedicated_storage vm_vol1.qcow2 10G --format qcow2</span><br><span class="line">Vol vm_vol1.qcow2 created</span><br><span class="line"></span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system vol-info --pool dedicated_storage vm_vol1.qcow2</span><br><span class="line">Name:           vm_vol1.qcow2</span><br><span class="line">Type:           file</span><br><span class="line">Capacity:       10.00 GiB</span><br><span class="line">Allocation:     196.00 KiB</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">若要刪除 storage volume，則可用以下指令</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">$ virsh -c qemu+ssh://root@10.20.190.2/system vol-delete --pool dedicated_storage vm_vol1.qcow2</span><br><span class="line">Vol vm_vol1.qcow2 deleted</span><br></pre></td></tr></table></figure><hr><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><p><a href="http://beakdoosan.blogspot.tw/2011/01/lvm.html" target="_blank" rel="noopener">Beakdoosan’s Weblog: LVM 筆記 - 觀念篇</a></p></li><li><p><a href="https://libvirt.org/storage.html" target="_blank" rel="noopener">libvirt: Storage Management</a></p></li><li><p><a href="https://www.suse.com/documentation/sles11/book_kvm/data/sec_libvirt_storage_virsh.html" target="_blank" rel="noopener">Suse Doc: Virtualization with KVM - Managing Storage with virsh</a></p></li><li><p><a href="http://docs.ceph.com/docs/hammer/rbd/libvirt/" target="_blank" rel="noopener">Using libvirt with Ceph RBD — Ceph Documentation</a></p></li><li><p><a href="http://www.tfcis.org/~lantw44/download/notes/cs/libvirt.domain(5" target="_blank" rel="noopener">KVM XML 設定檔基本內容</a>)</p></li></ul>]]></content>
      
      <categories>
          
          <category> KVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> KVM </tag>
            
            <tag> libvirt </tag>
            
            <tag> Storage </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Linux KVM] libvirt &amp; network</title>
      <link href="/blog/2016/10/21/KVM/KVM-libvirt-network/"/>
      <url>/blog/2016/10/21/KVM/KVM-libvirt-network/</url>
      <content type="html"><![CDATA[<p>介紹如何使用 libvirt 來管理 KVM virtual network</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>以下圖片來說明 libvirt 在整個虛擬化架構中所扮演的角色：</p><p><img src="http://smilejay.com/wp-content/uploads/2013/03/libvirt-manage-hypervisors.jpg" alt="libvirt 1"></p><blockquote><p>其中 other tools 的部份，甚至可以是 <strong>OpenStack</strong>、<strong>oVirt</strong> … 等工具</p></blockquote><p>libvirt 的管理功能一共包含五個部分：</p><ol><li><p>Virtual Machine</p><blockquote><p>包含 VM lifecycle(啟動/停止/暫停/保存/恢復/Live Migration …. 等等) 的管理，也支援對各種設備的熱插拔(不同的 hypervisor 對熱插拔的支援程度不一)</p></blockquote></li><li><p>Remote Node</p><blockquote><p>只要 remote node 上執行了 libvirtd 服務，libvirt 就可以用遠端的方式進行管理，支援 SSH / TCP socket … 等不同的連線方式，以 SSH 為例，可用像是 <code>virsh -c qemu+ssh://root@remotehost.com/system</code> 的命令進行連線</p></blockquote></li><li><p>Storage</p><blockquote><p>與上面相同，只要 remote node 上執行了 libvirtd 服務，就可以透過 libvirt 來管理不同類型的 storage，例如：建立不同格式的 virtual machine image(qcow2 / raw / vmdk … 等等)、掛載 remote NFS/iSCSI share、磁碟分割 …. 等等</p></blockquote></li><li><p>Network</p><blockquote><p>與上面相同，只要 remote node 上執行了 libvirtd 服務，就可以透過 libvirt 進行像是配置 tap device、建立 virtual network tap、bridge device 設定、VLAN/NAT 管理…等功能</p></blockquote></li><li><p>提供穩定、高效 API interface</p></li></ol><p>更清楚一點解釋 libvirt 在整個 QEMU/KVM 虛擬環境中所扮演的角色，可參考下圖：</p><p><img src="https://github.com/godleon/godleon.github.io/blob/master/_posts/images/2016/KVM-libvirt/libvirt.png?raw=true" alt="libvirt"></p><hr><h1 id="遠端操作-libvirtd"><a href="#遠端操作-libvirtd" class="headerlink" title="遠端操作 libvirtd"></a>遠端操作 libvirtd</h1><p>以下用個很簡單的範例，透過 virsh 命令連線到遠端主機的 libvirtd 並執行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 遠端主機為 10.20.190.3</span></span><br><span class="line"><span class="comment"># 執行命令 "list --all"</span></span><br><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system list --all</span><br><span class="line"> Id    Name                           State</span><br><span class="line">----------------------------------------------------</span><br><span class="line"> 3     centos7                        running</span><br></pre></td></tr></table></figure><p>用圖來表示的話，遠端操作 libvirtd 的流程如下：</p><p><img src="https://github.com/godleon/godleon.github.io/blob/master/_posts/images/2016/KVM-libvirt/remote_access_libvirtd.png?raw=true" alt="Remote Accrss libvirtd"></p><hr><h1 id="Linux-Virtual-Networking"><a href="#Linux-Virtual-Networking" class="headerlink" title="Linux Virtual Networking"></a>Linux Virtual Networking</h1><p>libvirt networking 的主要元件是 virtual network switch，也就是 Linux 中的 <strong><font color="red">bridge devices</font></strong>，而連接在 bridge 上的 interface，我們稱為 <strong><font color="red">TAP devices</font></strong>。</p><blockquote><p>TAP device 是由 Linux 的 TUN/TAP 模組所實作出來，其中 TUN(tunnel) 用來模擬 layer 3 的設備，而 TAP(network tap) 則是用來模擬 layer 2 設備</p></blockquote><p>以下示範如何建立 bridge device &amp; TAP device：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查詢是否已經掛載 bridge 模組</span></span><br><span class="line">$ lsmod | grep bridge</span><br><span class="line">bridge                119562  0</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增 bridge device</span></span><br><span class="line">$ brctl addbr tester</span><br><span class="line">$ brctl show</span><br><span class="line">bridge name  bridge id       STP enabledinterfaces</span><br><span class="line">.......</span><br><span class="line">tester    8000.000000000000 no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢查 TUN/TAP 模組是否已經載入到 kernel 中</span></span><br><span class="line">$ lsmod | grep tun</span><br><span class="line">tun                    27141  4 vhost_net</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 TAP device(vm-vnic)</span></span><br><span class="line">$ ip tuntap add dev vm-vnic mode tap</span><br><span class="line">$ ip addr show vm-vnic</span><br><span class="line">21: vm-vnic: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN qlen 500</span><br><span class="line">    link/ether 92:ee:17:b7:2b:c4 brd ff:ff:ff:ff:ff:ff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將 TAP device 與 bridge 相連</span></span><br><span class="line">$ brctl addif tester vm-vnic</span><br><span class="line">$ brctl show</span><br><span class="line">bridge namebridge id       STP enabled interfaces</span><br><span class="line">.......</span><br><span class="line">tester  8000.92ee17b72bc4 no         vm-vnic</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視目前連接到 bridge 的 TAP devices</span></span><br><span class="line">$ brctl showmacs tester</span><br><span class="line">port nomac addris <span class="built_in">local</span>?ageing timer</span><br><span class="line">  192:ee:17:b7:2b:c4yes   0.00</span><br><span class="line">  192:ee:17:b7:2b:c4yes   0.00</span><br></pre></td></tr></table></figure><p>若以上的 vm-vnic 連接到 VM 後，整個 network topology 會變成類似如下圖：</p><p><img src="https://github.com/godleon/godleon.github.io/blob/master/_posts/images/2016/KVM-Virtual-Networking/Linux_bridge_taps.png?raw=true" alt="Linux Bridge &amp; TAP devices"></p><p>測試完畢後，我們可以用以下指令移除上面建立的 TAP device &amp; bridge：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ brctl delif tester vm-vnic</span><br><span class="line"></span><br><span class="line">$ brctl show</span><br><span class="line">bridge namebridge id       STP enabledinterfaces</span><br><span class="line">........</span><br><span class="line">tester  8000.000000000000 no</span><br><span class="line"></span><br><span class="line">$ ip tuntap del dev vm-vnic mode tap</span><br><span class="line">$ brctl delbr tester</span><br></pre></td></tr></table></figure><hr><h1 id="Virtual-Network-Types"><a href="#Virtual-Network-Types" class="headerlink" title="Virtual Network Types"></a>Virtual Network Types</h1><p>在 KVM 中，virtual network 分為以下幾種類型：</p><ul><li><p><strong>NATed</strong>：以 host 作為 NAT server 的方式提供網路</p></li><li><p><strong>Routed</strong>：透過設定在 hypervisor 上的 routing rules，允許 VM 與實體網路卡相連進行資料傳輸</p></li><li><p><strong>Isolated</strong>：與外界完全區隔的內部私有網路，只有在裡面的 VM 可以互相通訊</p></li></ul><p>透過以下指令可以查詢 virtual network 相關的資訊：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$ virsh -c qemu+ssh://root@10.20.190.3/system net-list --all</span><br><span class="line"> Name                 State      Autostart     Persistent</span><br><span class="line">----------------------------------------------------------</span><br><span class="line"> default              active     yes           yes</span><br><span class="line"></span><br><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system net-info default</span><br><span class="line">Name:           default  <span class="comment"># virtual network 名稱</span></span><br><span class="line">UUID:           83bea138-4c65-4ca2-8199-db3400d87fa5</span><br><span class="line">Active:         yes      <span class="comment"># 目前的啟動狀態</span></span><br><span class="line">Persistent:     yes      </span><br><span class="line">Autostart:      yes      <span class="comment"># 是否隨著 libvird 一起啟動</span></span><br><span class="line">Bridge:         virbr0   <span class="comment"># 使用那個 device 進行對外通訊 </span></span><br><span class="line"></span><br><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system net-dumpxml default</span><br><span class="line">&lt;network&gt;</span><br><span class="line">  &lt;name&gt;default&lt;/name&gt;</span><br><span class="line">  &lt;uuid&gt;83bea138-4c65-4ca2-8199-db3400d87fa5&lt;/uuid&gt;</span><br><span class="line">  &lt;forward mode=<span class="string">'nat'</span>&gt;</span><br><span class="line">    &lt;nat&gt;</span><br><span class="line">      &lt;port start=<span class="string">'1024'</span> end=<span class="string">'65535'</span>/&gt;</span><br><span class="line">    &lt;/nat&gt;</span><br><span class="line">  &lt;/forward&gt;</span><br><span class="line">  &lt;bridge name=<span class="string">'virbr0'</span> stp=<span class="string">'on'</span> delay=<span class="string">'0'</span>/&gt;</span><br><span class="line">  &lt;mac address=<span class="string">'52:54:00:f8:50:f2'</span>/&gt;</span><br><span class="line">  &lt;ip address=<span class="string">'192.168.122.1'</span> netmask=<span class="string">'255.255.255.0'</span>&gt;</span><br><span class="line">    &lt;dhcp&gt;</span><br><span class="line">      &lt;range start=<span class="string">'192.168.122.2'</span> end=<span class="string">'192.168.122.254'</span>/&gt;</span><br><span class="line">    &lt;/dhcp&gt;</span><br><span class="line">  &lt;/ip&gt;</span><br><span class="line">&lt;/network&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 啟動 default virtual network</span></span><br><span class="line">$ virsh net-start default</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刪除 default virtual network</span></span><br><span class="line">$ virsh net-destroy default</span><br></pre></td></tr></table></figure><p>系統預設的 <strong><font color="red">default</font></strong> virtual network 屬於 NATed，host 會自動派發 IP 給此網路中 VM，並設定相關的 firewall rule 讓 VM 可以透過 host 對外通訊。</p><hr><h1 id="使用-libvirt-管理-virtual-network-Isolated"><a href="#使用-libvirt-管理-virtual-network-Isolated" class="headerlink" title="使用 libvirt 管理 virtual network - Isolated"></a>使用 libvirt 管理 virtual network - Isolated</h1><p>顧名思義，isolated network 表示外面是無法與在 isolated network 中的 VM 進行通訊的，只有加入到此 network 的 VM 才可以相互通訊，而在 isolated network 內部的 VM 也無法對外連線。</p><p><img src="https://github.com/godleon/godleon.github.io/blob/master/_posts/images/2016/KVM-libvirt/kvm_isolated-network.jpg?raw=true" alt="KVM isolated network"></p><p>建立 isolated network 的方式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ bash -c <span class="string">'cat &lt;&lt;EOF &gt; /tmp/isolated.xml</span></span><br><span class="line"><span class="string">&lt;network&gt; </span></span><br><span class="line"><span class="string">  &lt;name&gt;isolated&lt;/name&gt;</span></span><br><span class="line"><span class="string">&lt;/network&gt;</span></span><br><span class="line"><span class="string">EOF'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定義 virtual network </span></span><br><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system net-define /tmp/isolated.xml </span><br><span class="line">Network isolated defined from /tmp/isolated.xml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視目前的 virtual network 清單 (isolated 已經加入，但尚未啟動)</span></span><br><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system net-list --all</span><br><span class="line"> Name                 State      Autostart     Persistent</span><br><span class="line">----------------------------------------------------------</span><br><span class="line"> default              active     yes           yes</span><br><span class="line"> isolated             inactive   no            yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># libvirt 會自動指派 UUID, virtual bridge ...等資訊</span></span><br><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system net-dumpxml isolated</span><br><span class="line">&lt;network&gt;</span><br><span class="line">  &lt;name&gt;isolated&lt;/name&gt;</span><br><span class="line">  &lt;uuid&gt;765e746b-334d-4acf-8b9c-cb32be5b77f5&lt;/uuid&gt;</span><br><span class="line">  &lt;bridge name=<span class="string">'virbr1'</span> stp=<span class="string">'on'</span> delay=<span class="string">'0'</span>/&gt;</span><br><span class="line">  &lt;mac address=<span class="string">'52:54:00:70:8b:87'</span>/&gt;</span><br><span class="line">&lt;/network&gt;</span><br></pre></td></tr></table></figure><blockquote><p>定義一個新的 virtual network 後，會在 KVM host 上的 <code>/etc/libvirt/qemu/networks</code> 目錄產生對應的 XML 設定檔，以上面為例，XML 設定檔完整名稱是 <code>/etc/libvirt/qemu/networks/isolated.xml</code></p></blockquote><p>完成 virtual network define 之後，接著要啟動 virtual network：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system net-start isolated</span><br><span class="line">Network isolated started</span><br><span class="line"></span><br><span class="line"><span class="comment"># network isolated 已經啟動</span></span><br><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system net-list --all</span><br><span class="line"> Name                 State      Autostart     Persistent</span><br><span class="line">----------------------------------------------------------</span><br><span class="line"> default              active     yes           yes</span><br><span class="line"> isolated             active     no            yes</span><br></pre></td></tr></table></figure><p>完成了 isolated virtual network 的配置後，以下是動態產生 &amp; 刪除 NIC 並與 VM 相連的相關操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 檢視 domain interface list (目前只有連接 default network)</span></span><br><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system domiflist centos7</span><br><span class="line">Interface  Type       Source     Model       MAC</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">vnet0      network    default    virtio      52:54:00:7e:f8:5c</span><br><span class="line"></span><br><span class="line"><span class="comment"># attach-interface =&gt; 產生一個 interface 並連接到後續指定的 virtual network</span></span><br><span class="line"><span class="comment"># --domain =&gt; 指定要變更設定的 VM (稱為 domain)</span></span><br><span class="line"><span class="comment"># --source isolated --type network =&gt; 使用 virtual network isolated</span></span><br><span class="line"><span class="comment"># --model virtio =&gt; 使用 virtio (效能較好)</span></span><br><span class="line"><span class="comment"># --config =&gt; 變更設定 &amp; 儲存 (若沒使用此參數，NIC 僅會暫時出現)</span></span><br><span class="line"><span class="comment"># --live =&gt; 在 VM 執行狀態下動態新增 (若要針對停止中的 VM 新增 NIC 不需要使用此參數)</span></span><br><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system attach-interface --domain centos7 --<span class="built_in">source</span> isolated --<span class="built_in">type</span> network --model virtio --config --live</span><br><span class="line">Interface attached successfully</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新檢視 VM 的 interface list，發現新的 NIC 已經安裝上去了</span></span><br><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system domiflist centos7</span><br><span class="line">Interface  Type       Source     Model       MAC</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">vnet0      network    default    virtio      52:54:00:7e:f8:5c</span><br><span class="line">vnet1      network    isolated   virtio      52:54:00:07:b8:72</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除指定的 NIC</span></span><br><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system detach-interface --domain centos7 --<span class="built_in">type</span> network --mac 52:54:00:07:b8:72 --config --live</span><br><span class="line">Interface detached successfully</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可看出其中一的 NIC 已經被移除</span></span><br><span class="line">$ virsh --connect qemu+ssh://root@10.20.190.3/system domiflist centos7</span><br><span class="line">Interface  Type       Source     Model       MAC</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">vnet0      network    default    virtio      52:54:00:7e:f8:5c</span><br></pre></td></tr></table></figure><p>當透過 virsh 新增一個 NIC 與 VM 相連後，直接到 KVM host 上使用 <code>brctl show</code> 指令檢視目前與 bridge device 相連的 interface：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ brctl show</span><br><span class="line">bridge namebridge id      STP enabledinterfaces</span><br><span class="line">......</span><br><span class="line">virbr1  8000.525400708b87yes      virbr1-nic</span><br><span class="line">                            vnet1</span><br></pre></td></tr></table></figure><p>可以看出 interface 已經被 libvirt 自動建立且與 bridge 相連。(其中的 <strong>virbr1-nic</strong> 是在 isolated virtual network 建立時，libvirt 一併同時產生的)</p><hr><h1 id="virtual-network-NATed-amp-Routed"><a href="#virtual-network-NATed-amp-Routed" class="headerlink" title="virtual network - NATed &amp; Routed"></a>virtual network - NATed &amp; Routed</h1><h2 id="NATed-virtual-network"><a href="#NATed-virtual-network" class="headerlink" title="NATed virtual network"></a>NATed virtual network</h2><p>安裝好 KVM 後，預設就會附上一個名稱為 <code>default</code> 的 NATed virtual network，所有使用 default virtual network 的 VM，都可以透過 KVM host 中新增的 bridge device  <code>virbr0</code>，以 NAT 的方式連到外部網路。 </p><p>NATed virtual network 的設定步驟如下：</p><ol><li><p>建立 bridge device，並與特定的 nic 連結</p></li><li><p>設定防火牆規則 for NAT masquerade</p></li><li><p>virtual network 中 XML 定義的 <code>forward mode</code> 要設為 yes </p></li></ol><p>接著就是 <code>virsh net-{define,start,autostart}</code> 的工作了，這與上面雷同，就不再贅述</p><h2 id="Routed-virtual-network"><a href="#Routed-virtual-network" class="headerlink" title="Routed virtual network"></a>Routed virtual network</h2><p>這在實際應用中很少遇到，因此就略過先不測試，有機會試過之後再來補!</p><hr><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><p><a href="">Networking - KVM</a><a href="http://www.linux-kvm.org/page/Networking" target="_blank" rel="noopener">http://www.linux-kvm.org/page/Networking</a></p></li><li><p><a href="https://libvirt.org/formatnetwork.html" target="_blank" rel="noopener">libvirt: Network XML format</a></p></li><li><p><a href="http://www.tfcis.org/~lantw44/download/notes/cs/libvirt.domain(5" target="_blank" rel="noopener">KVM XML 設定檔基本內容</a>)</p></li></ul>]]></content>
      
      <categories>
          
          <category> KVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> KVM </tag>
            
            <tag> libvirt </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Linux KVM] 半虛擬化驅動(Paravirtualization Driver)</title>
      <link href="/blog/2016/08/20/KVM/KVM-Paravirtualization-Drivers/"/>
      <url>/blog/2016/08/20/KVM/KVM-Paravirtualization-Drivers/</url>
      <content type="html"><![CDATA[<p>介紹如何使用 QEMU/KVM 中的半虛擬化，並了解此技術如何帶來效能上的提升</p><h1 id="QEMU-I-O-Overview"><a href="#QEMU-I-O-Overview" class="headerlink" title="QEMU I/O Overview"></a>QEMU I/O Overview</h1><p>QEMU/KVM 是屬於全虛擬化的解決方案，若沒有硬體加速輔助的情況下，所有的工作都必須透過軟體模擬，其實效率是很不好的，特別是 device I/O 的部分。</p><p>以下的圖可以說明純 QEMU 模擬下的 device I/O 狀況：</p><p><img src="http://smilejay.b0.upaiyun.com/wp-content/uploads/2012/11/qemu-emulated-io.jpg" alt="KVM virtio"></p><p>一個 virtual machine 的 I/O request 會透過以下流程完成：</p><ol><li><p>被 KVM module 中的 I/O trap 捕捉到 &amp; 處理</p></li><li><p>將處理結果放到 I/O sharing page 中</p></li><li><p>通知 QEMU process 來取得 I/O 資訊，並交由 QEMU I/O Emulation Code 來模擬 I/O request</p></li><li><p>完成後將結果放回 I/O sharing page</p></li><li><p>通知 KVM module 中的 I/O trap 將處理結果取回並回傳給 virtual machine</p></li></ol><p>透過 QEMU 可以模擬出各式各樣的 I/O device，甚至很老舊的設備都沒有問題；但從上面複雜的步驟不難看出為何使用 QEMU 模擬 device I/O 會效率不彰，除了每次 I/O request 處理的流程繁複之外，過多的 VMEntry, VMExit, context switch，也都是拖垮 QEMU 效能的原因。</p><hr><h1 id="virtio-Overview"><a href="#virtio-Overview" class="headerlink" title="virtio Overview"></a>virtio Overview</h1><p>有鑑於此，<a href="http://www.linux-kvm.org/page/Virtio" target="_blank" rel="noopener">virtio</a> 被提出來，作為運行在 Hypervisor 上的一組 API interface，讓 virtual machine 知道自己運行在虛擬環境中，並根據 virtio 標準與 hypervisor 互動，藉此達到更好的運作效能(I/O 效能提升最為明顯)。</p><p>以下是純 QEMU 模擬 &amp; virtio 的架構比較，可以看出 virtio 省略了 I/O trap，讓 virtual machine 可以直接與 QEMU 的 I/O 模組通訊：</p><p><img src="http://images0.cnblogs.com/blog2015/697113/201506/011807259737673.jpg" alt="QEMU v.s. virtio"></p><p>更細部一點檢視 virtio 的架構：</p><p><img src="http://smilejay.b0.upaiyun.com/wp-content/uploads/2012/11/qemu-kvm-virtio.jpg" alt="virtio architecture"></p><ol><li><p>第一層 <strong>virtio_blk</strong>、<strong>virtio_net</strong>、<strong>virtio_scsi</strong> …. 等等屬於 <strong><font color="red">virtio Frontend，存在於</font></strong> virtual machine OS kernel module 中</p></li><li><p>最下面一層稱為 <strong><font color="red">virtio Backend</font></strong>，是在 QEMU 中實作，讓 I/O request 可以透過 QEMU 直接送給 host machine 中的 device driver，減少整體 I/O 的 overhead</p></li><li><p><strong><font color="red">virtio</font></strong> 屬於虛擬佇列，目的是將 Frontend 的驅動程序附加到 Backend 的處理程序 (一個 Frontend 的驅動程序可以根據需求使用 0 個或多個佇列，例如 virtio_net 同時需要傳送 &amp; 接收用的兩個虛擬佇列，virtio_blk 則僅需要一個)</p></li><li><p><strong><font color="red">virtio-ring</font></strong> 透過實作 ring buffer 的機制，讓 I/O request 得以批次處理，藉以提升 virtual machine 與 hypervisor 之間訊息交換的效率</p></li></ol><p>雖然 virtio 可以大幅的提升 I/O 性能，但不僅需要 host machine 的 OS kernel 有支援，連 virtual machine 也要同時有安裝 virtio driver，不過目前較新的 Linux 都已經支援 virtio 了! 所以若使用的是最近幾年的 Linux 版本，在 I/O 裝置的部分應該都可以選擇以 virtio 的方式運行。</p><blockquote><p>Windows 也都有對應的 virtio driver 可對應下載</p></blockquote><hr><h1 id="檢查-virtio-環境"><a href="#檢查-virtio-環境" class="headerlink" title="檢查 virtio 環境"></a>檢查 virtio 環境</h1><h2 id="1-1-virtio-Backend"><a href="#1-1-virtio-Backend" class="headerlink" title="1.1 virtio Backend"></a>1.1 virtio Backend</h2><p>由於 host machine 安裝的是 CentOS 7，因此都已經預設安裝 virtio driver 了! 可以用以下指令查詢：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ find / -name <span class="string">'virtio*.ko'</span> | grep $(uname -r)</span><br><span class="line">/usr/lib/modules/3.10.0-327.28.2.el7.x86_64/kernel/drivers/virtio/virtio_pci.ko</span><br><span class="line">/usr/lib/modules/3.10.0-327.28.2.el7.x86_64/kernel/drivers/virtio/virtio.ko</span><br><span class="line">/usr/lib/modules/3.10.0-327.28.2.el7.x86_64/kernel/drivers/virtio/virtio_ring.ko</span><br><span class="line">/usr/lib/modules/3.10.0-327.28.2.el7.x86_64/kernel/drivers/virtio/virtio_input.ko</span><br><span class="line">/usr/lib/modules/3.10.0-327.28.2.el7.x86_64/kernel/drivers/virtio/virtio_balloon.ko</span><br><span class="line">/usr/lib/modules/3.10.0-327.28.2.el7.x86_64/kernel/drivers/char/virtio_console.ko</span><br><span class="line">/usr/lib/modules/3.10.0-327.28.2.el7.x86_64/kernel/drivers/char/hw_random/virtio-rng.ko</span><br><span class="line">/usr/lib/modules/3.10.0-327.28.2.el7.x86_64/kernel/drivers/scsi/virtio_scsi.ko</span><br><span class="line">/usr/lib/modules/3.10.0-327.28.2.el7.x86_64/kernel/drivers/block/virtio_blk.ko</span><br><span class="line">/usr/lib/modules/3.10.0-327.28.2.el7.x86_64/kernel/drivers/net/virtio_net.ko</span><br></pre></td></tr></table></figure><h2 id="1-2-virtio-Frontend"><a href="#1-2-virtio-Frontend" class="headerlink" title="1.2 virtio Frontend"></a>1.2 virtio Frontend</h2><h3 id="1-2-1-Linux"><a href="#1-2-1-Linux" class="headerlink" title="1.2.1 Linux"></a>1.2.1 Linux</h3><p>目前新版本的 Linux(Ubuntu / CentOS / …. 等等)都已經內建 virtio driver 了，不需要再額外安裝囉!</p><h3 id="1-2-2-Windows"><a href="#1-2-2-Windows" class="headerlink" title="1.2.2 Windows"></a>1.2.2 Windows</h3><p>若是要安裝 Windows 的 virtio driver，可以使用以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://fedorapeople.org/groups/virt/virtio-win/virtio-win.repo -O /etc/yum.repos.d/virtio-win.repo</span><br><span class="line"></span><br><span class="line">$ yum info virtio-win</span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: ftp.yzu.edu.tw</span><br><span class="line"> * epel: mirror01.idc.hinet.net</span><br><span class="line"> * extras: ftp.yzu.edu.tw</span><br><span class="line"> * updates: ftp.yzu.edu.tw</span><br><span class="line">Available Packages</span><br><span class="line">Name        : virtio-win</span><br><span class="line">Arch        : noarch</span><br><span class="line">Version     : 0.1.102</span><br><span class="line">Release     : 1</span><br><span class="line">Size        : 75 M</span><br><span class="line">Repo        : virtio-win-stable</span><br><span class="line">Summary     : VirtIO para-virtualized drivers <span class="keyword">for</span> Windows(R)</span><br><span class="line">URL         : http://www.redhat.com/</span><br><span class="line">License     : GPLv2</span><br><span class="line">Description : VirtIO para-virtualized Windows(R) drivers <span class="keyword">for</span> 32-bit and 64-bit</span><br><span class="line">            : Windows(R) guests.</span><br><span class="line"></span><br><span class="line">$ yum -y install virtio-win</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢目前 virtio-win 的支援程度</span></span><br><span class="line">$ ls -R /usr/share/virtio-win</span><br><span class="line">/usr/share/virtio-win:</span><br><span class="line">drivers  guest-agent  virtio-win-0.1.102_amd64.vfd  virtio-win-0.1.102.iso  virtio-win-0.1.102_x86.vfd  virtio-win_amd64.vfd  virtio-win.iso  virtio-win_x86.vfd</span><br><span class="line"></span><br><span class="line">/usr/share/virtio-win/drivers:</span><br><span class="line">amd64  i386</span><br><span class="line"></span><br><span class="line">/usr/share/virtio-win/drivers/amd64:</span><br><span class="line">Win2003  Win2008  Win2008R2  Win2012  Win2012R2  Win7  Win8  Win8.1</span><br><span class="line">.......</span><br><span class="line">/usr/share/virtio-win/drivers/amd64/Win2012R2:</span><br><span class="line">netkvm.cat  netkvm.inf  netkvm.sys  vioscsi.cat  vioscsi.inf  vioscsi.sys  viostor.cat  viostor.inf  viostor.sys</span><br><span class="line">.......</span><br><span class="line">/usr/share/virtio-win/drivers/amd64/Win7:</span><br><span class="line">netkvm.cat  netkvm.inf  netkvm.sys  qxl.cat  qxldd.dll  qxl.inf  qxl.sys  vioscsi.cat  vioscsi.inf  vioscsi.sys  viostor.cat  viostor.inf  viostor.sys</span><br><span class="line">.......</span><br></pre></td></tr></table></figure><blockquote><p>從上面的檔案列表得知，目前 stable 的 virtio-win 支援到 Windows 2012R2 &amp; Windows 8.1，若要更新的 Windows OS 需求，可能要使用 latest 版本</p></blockquote><p>若希望可以在最新版的 Windows 上安裝 virtio driver，那就要升級到最新版的 virtio-win，可以透過以下的指令來啟用最新的 repository &amp; 升級：(目前最新版已經支援 Windows 10)</p><blockquote><p>yum –enablerepo=virtio-win-latest update virtio-win</p></blockquote><p>使用方式很容易，只要在啟動 windows virtual machine 時，指定 CDRom 裝置掛載 <font color="red"><strong>/usr/share/virtio-win/virtio-win-0.1.102.iso</strong></font> 後，進入 Windows 把相關的 virtio 裝置驅動即可，詳細的使用方式可以參考 =&gt; <a href="http://www.lijyyh.com/2015/12/linux-kvm-set-up-linux-kvm.html" target="_blank" rel="noopener">傲笑紅塵路: 架設 Linux KVM 虛擬化主機 (Set up Linux KVM virtualization host)</a></p><hr><h1 id="使用-virtio-balloon"><a href="#使用-virtio-balloon" class="headerlink" title="使用 virtio_balloon"></a>使用 virtio_balloon</h1><h2 id="balloonning-Overview"><a href="#balloonning-Overview" class="headerlink" title="balloonning Overview"></a>balloonning Overview</h2><p><img src="http://smilejay.com/wp-content/uploads/2012/11/linux-ballooning-demo.jpg" alt="KVM ballooning"></p><p>透過 balloon 的技術，可以如上圖所示，在 virtual machine 運行時動態調整記憶體的配置，而不需要 virtual machine 關機。</p><p>情境如下：</p><ol><li><p>當 host machine 記憶體空間不足時，在 virtual machine 中的記憶體 balloon 會膨脹(inflate)，讓 virtual machine 實際上無法使用到太多的記憶體，進而讓記憶體空間可以讓 host machine 暫時利用</p></li><li><p>當 virtual machine 記憶體空間不足時，在 virtual machine 中的記憶體 balloon 則會壓縮(deflate)，讓 host machine 可以分配閒置的記憶體給 virtual machine</p></li></ol><blockquote><p>以上功能必須透過 <code>virtio-balloon driver</code> 來達成</p></blockquote><h2 id="使用-balloonning-技術的優缺點"><a href="#使用-balloonning-技術的優缺點" class="headerlink" title="使用 balloonning 技術的優缺點"></a>使用 balloonning 技術的優缺點</h2><p>使用 balloon 的技術肯定也是有優缺點的，管理者可以根據實際需求評估使用：</p><p>優點如下：</p><ul><li><p>由於 balloonning 是能夠被監控 &amp; 控制的(不同於不可控制的 KSM 技術)，因此能夠有效率的節省記憶體的實際耗用</p></li><li><p>balloonning 對於記憶體的調度是很靈活的</p></li><li><p>hypervisor 透過 balloonning 從 virtual machine 中取得歸還的部分記憶體空間，不一定一定要用在其他地方，可自己保留住，端看管理者想要如何管理記憶體空間</p></li></ul><p>但 balloonning 同樣也是有些缺點存在的的：</p><ul><li><p>virtual machine 必須安裝 virtio_balloon driver 才可使用此功能(新版的 Linux 有內建，但 Windows 就必須要另外安裝了)</p></li><li><p>若透過 balloonning 從 virtual machine 中取回大量的記憶體空間，可能會提升 virtual machine 對於 swap 的 I/O 存取而導致效能降低；也有可能會造成 virtual machine 中的某些 process 運作時發生記憶體不足的況狀而失敗</p></li><li><p>雖然 balloonning 可被監控 &amp; 控制，但目前尚缺乏有效的自動化機制，對於大規模佈署使用上是不方便的</p></li><li><p>記憶體動態調整的過於頻繁，可能會使記憶體空間配置上過於零散而不連續，如此一來記憶體的使用效率就會降低</p></li></ul><h2 id="在-QEMU-KVM-中使用-balloonning"><a href="#在-QEMU-KVM-中使用-balloonning" class="headerlink" title="在 QEMU/KVM 中使用 balloonning"></a>在 QEMU/KVM 中使用 balloonning</h2><p>首先要先檢查 host machine 是否支援 balloonning：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cat /boot/config-`uname -r` | grep VIRTIO</span><br><span class="line">CONFIG_VIRTIO_BLK=m</span><br><span class="line">CONFIG_SCSI_VIRTIO=m</span><br><span class="line">CONFIG_VIRTIO_NET=m</span><br><span class="line">CONFIG_VIRTIO_CONSOLE=m</span><br><span class="line">CONFIG_HW_RANDOM_VIRTIO=m</span><br><span class="line">CONFIG_VIRTIO=m</span><br><span class="line">CONFIG_VIRTIO_PCI=m</span><br><span class="line">CONFIG_VIRTIO_PCI_LEGACY=y</span><br><span class="line">CONFIG_VIRTIO_BALLOON=m</span><br><span class="line">CONFIG_VIRTIO_INPUT=m</span><br><span class="line"><span class="comment"># CONFIG_VIRTIO_MMIO is not set</span></span><br></pre></td></tr></table></figure><blockquote><p>CONFIG_VIRTIO_BALLOON=m 表示已經支援(以 module 方式載入)</p></blockquote><p>接著要在 virtual machine 中啟用 balloonning，則必須在啟動 virtual machine 的指令中加上以下參數：(預設為 <code>-balloon none</code>)</p><blockquote><p>-balloon virtio[,addr=addr]</p></blockquote><p>參數中的 addr 是可用來指定 virtual machine 中 balloon device 的 PCI address</p><p>也可以使用 <font color="red"><strong>-device</strong></font> 參數來統一設定不同的 device，使用方法如下：</p><blockquote><p>-device driver[,prop[=value][,…]]</p></blockquote><p>了解啟用 balloon 的參數後，可以用以下指令啟動搭載 balloonning 功能的 virtual machine：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kvm -vnc 0.0.0.0:1 -m 2048 /kvm/storage/vm_disks/ubnutu1604.img \</span><br><span class="line">  -net nic -net tap,script=/etc/qemu-ifup \</span><br><span class="line">  -device virtio-balloon-pci --daemonize</span><br></pre></td></tr></table></figure><p>接著連線到 virtual machine 中，查詢 balloonning device 的狀態：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># balloon 功能已開啟</span></span><br><span class="line">ubuntu@vm-ubuntu1604:~$ cat /boot/config-`uname -r` | grep VIRTIO</span><br><span class="line">.....</span><br><span class="line">CONFIG_VIRTIO_BALLOON=y</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視目前 pci device 狀態</span></span><br><span class="line">ubuntu@vm-ubuntu1604:~$ lspci</span><br><span class="line">00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)</span><br><span class="line">00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]</span><br><span class="line">00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]</span><br><span class="line">00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03)</span><br><span class="line">00:02.0 VGA compatible controller: Cirrus Logic GD 5446</span><br><span class="line">00:03.0 Ethernet controller: Intel Corporation 82540EM Gigabit Ethernet Controller (rev 03)</span><br><span class="line">00:04.0 Unclassified device [00ff]: Red Hat, Inc Virtio memory balloon</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢 balloonning device 的詳細資訊</span></span><br><span class="line">ubuntu@vm-ubuntu1604:~$ lspci -s 00:04.0 -v</span><br><span class="line">00:04.0 Unclassified device [00ff]: Red Hat, Inc Virtio memory balloon</span><br><span class="line">        Subsystem: Red Hat, Inc Virtio memory balloon</span><br><span class="line">        Physical Slot: 4</span><br><span class="line">        Flags: bus master, fast devsel, latency 0, IRQ 11</span><br><span class="line">        I/O ports at c040 [size=32]</span><br><span class="line">        Kernel driver <span class="keyword">in</span> use: virtio-pci</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視 virtual machine 記憶體狀態</span></span><br><span class="line">ubuntu@vm-ubuntu1604:~$ free -m</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           2000          40        1851           3         108        1823</span><br><span class="line">Swap:          2045           0        2045</span><br></pre></td></tr></table></figure><p>接著在 QEMU monitor 中透過 <code>balloon 512</code> 把 virtual machine 的記憶體限縮到僅能使用 512 MB：</p><p><img src="https://github.com/godleon/godleon.github.io/blob/master/_posts/images/2016/KVM-Paravirtualization-Drivers/kvm_virtio_balloon.PNG?raw=true" alt="balloon"></p><p>以下是 virtual machine 中目前的記憶體狀況：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 經過 balloon 縮小可用記憶體空間後，檢視記憶體狀態</span></span><br><span class="line">ubuntu@vm-ubuntu1604:~$ free -m</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:            464          39         316           3         108         288</span><br><span class="line">Swap:          2045           0        2045</span><br></pre></td></tr></table></figure><blockquote><p>可以看出 total memory 已經變少，可見 balloon 的確是起了作用</p></blockquote><p>另外一個比較需要注意的是，balloon 沒辦法用於增加 virtual machine 的記憶體配置；例如，啟用 virtual machine 時配置了 2048 MB 的記憶體，即使在 QEMU monitor 中使用 <code>ballon 4096</code>，也無法讓 virtual machine 的記憶體變成 4096 MB。</p><hr><h1 id="使用-virtio-net"><a href="#使用-virtio-net" class="headerlink" title="使用 virtio_net"></a>使用 virtio_net</h1><p>使用 virtio network device，有提高 throughput &amp; 降低 latency 的兩項優點，可以達到接近原生網卡的效能，因此通常是配置網路時的優先選擇。</p><p>以下指令可以查詢是否支援 virtio_net：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 有出現 virtio 表示支援 virtio network device</span></span><br><span class="line">$ kvm -net nic,model=?</span><br><span class="line">qemu: Supported NIC models: ne2k_pci,i82551,i82557b,i82559er,rtl8139,e1000,pcnet,virtio</span><br></pre></td></tr></table></figure><h2 id="1、啟用支援-virtio-net-的-vitual-machine"><a href="#1、啟用支援-virtio-net-的-vitual-machine" class="headerlink" title="1、啟用支援 virtio_net 的 vitual machine"></a>1、啟用支援 virtio_net 的 vitual machine</h2><p>接著可以用以下指令啟動一個使用 virtio_net 的 virtual machine：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kvm -vnc 0.0.0.0:1 -m 2048 --daemonize \</span><br><span class="line">  -drive format=raw,file=/kvm/storage/vm_disks/ubnutu1604.img \</span><br><span class="line">  -device virtio-balloon-pci \</span><br><span class="line">  -net nic,model=virtio -net tap</span><br></pre></td></tr></table></figure><p>當 virtual machine 啟動後，登入檢查 virtio_net 的狀態：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ubuntu 16.04 原生已經搭載 virtio driver</span></span><br><span class="line">ubuntu@vm-ubuntu1604:~$ cat /boot/config-`uname -r` | grep VIRTIO</span><br><span class="line">.....</span><br><span class="line">CONFIG_VIRTIO_NET=y</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可看出目前 virtual machine 的網卡已經以 virtio 模式運作</span></span><br><span class="line">ubuntu@vm-ubuntu1604:~$ lspci</span><br><span class="line">....</span><br><span class="line">00:03.0 Ethernet controller: Red Hat, Inc Virtio network device</span><br><span class="line">00:04.0 Unclassified device [00ff]: Red Hat, Inc Virtio memory balloon</span><br><span class="line"></span><br><span class="line"><span class="comment"># virtio_net 詳細資訊</span></span><br><span class="line">ubuntu@vm-ubuntu1604:~$ lspci -vv -s 00:03.0</span><br><span class="line">00:03.0 Ethernet controller: Red Hat, Inc Virtio network device</span><br><span class="line">        Subsystem: Red Hat, Inc Virtio network device</span><br><span class="line">        Physical Slot: 3</span><br><span class="line">        Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR+ FastB2B- DisINTx+</span><br><span class="line">        Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast &gt;TAbort- &lt;TAbort- &lt;MAbort- &gt;SERR- &lt;PERR- INTx-</span><br><span class="line">        Latency: 0</span><br><span class="line">        Interrupt: pin A routed to IRQ 11</span><br><span class="line">        Region 0: I/O ports at c000 [size=32]</span><br><span class="line">        Region 1: Memory at febd1000 (32-bit, non-prefetchable) [size=4K]</span><br><span class="line">        Expansion ROM at feb80000 [disabled] [size=256K]</span><br><span class="line">        Capabilities: &lt;access denied&gt;</span><br><span class="line">        Kernel driver <span class="keyword">in</span> use: virtio-pci</span><br></pre></td></tr></table></figure><h2 id="2、進一步提升半虛擬化網卡效能"><a href="#2、進一步提升半虛擬化網卡效能" class="headerlink" title="2、進一步提升半虛擬化網卡效能"></a>2、進一步提升半虛擬化網卡效能</h2><h3 id="1-關閉-TSO-amp-GSO-以提升-virtio-net-的效能"><a href="#1-關閉-TSO-amp-GSO-以提升-virtio-net-的效能" class="headerlink" title="(1) 關閉 TSO &amp; GSO 以提升 virtio_net 的效能"></a>(1) 關閉 TSO &amp; GSO 以提升 virtio_net 的效能</h3><p>為了提升 virtual machine 網卡的效能，除了使用 virtio 半虛擬化的技術外，還可以透過關閉 host machine 的 TSO &amp; GSO 功能來更進一步提升</p><p>以下可以檢查 host machine 的網卡是否支援 TSO &amp; GSO：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ethtool -k ens1f1</span><br><span class="line">Features <span class="keyword">for</span> ens1f1:</span><br><span class="line">.....</span><br><span class="line">tcp-segmentation-offload: on</span><br><span class="line">        tx-tcp-segmentation: on</span><br><span class="line">        tx-tcp-ecn-segmentation: off [fixed]</span><br><span class="line">        tx-tcp6-segmentation: on</span><br><span class="line">.....</span><br><span class="line">generic-segmentation-offload: on</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>從上面可以看出目前 TSO &amp; GSO 的功能都是開啟的，可以透過以下方式關閉：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ethtool -K ens1f1 tso off</span><br><span class="line">$ ethtool -K ens1f1 gso off</span><br></pre></td></tr></table></figure><p>如此一來 virtio_net 的效能就可以進一步的提升。</p><h3 id="2-使用-vhost-net-後端驅動"><a href="#2-使用-vhost-net-後端驅動" class="headerlink" title="(2) 使用 vhost-net 後端驅動"></a>(2) 使用 vhost-net 後端驅動</h3><p>一般來說，virtio 在 host machine 是由每個 user space 中的 QEMU 來進行後端處理的，但若是可以將 network I/O 的部分移到 kernel space 來處理，不僅可以提高 network throughput，還可以降低 latency，進而提升網路的效率。</p><p>目前比較新的 Linux kernel 中都有搭載稱為 <strong><font color="red">vhost-net</font></strong> 的 module，可用來將 virtio_net 的後端處理移到 Linux kernel 中進行來提升 network I/O 的效率。</p><p>首先先來檢查 host machine 是否支援 <strong>vhost-net</strong> 的功能：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat /boot/config-`uname -r` | grep VHOST</span><br><span class="line">CONFIG_VHOST_NET=m</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">$ lsmod | grep vhost</span><br><span class="line">vhost_net              18152  1</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>從上面可以看出 host machine 有支援 vhost-net，接著就可以使用以下指令啟動支援 vhost-net 的 virtual machine：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kvm -vnc 0.0.0.0:1 -m 2048 --daemonize \</span><br><span class="line">  -drive format=raw,file=/kvm/storage/vm_disks/ubnutu1604.img,<span class="keyword">if</span>=virtio \</span><br><span class="line">  -device virtio-balloon-pci \</span><br><span class="line">  -netdev tap,id=net0,vhost=on -device virtio-net-pci,netdev=net0</span><br></pre></td></tr></table></figure><hr><h1 id="使用-virtio-blk"><a href="#使用-virtio-blk" class="headerlink" title="使用 virtio_blk"></a>使用 virtio_blk</h1><p>virtio_blk 提供了 virtual machine 可以透過 virtio API 進行 block device I/O 的相關驅動程式，藉以提升存取 block device 的效能。</p><p>同樣的，要使用 virtio_blk，host machine &amp; virtual machine 都必須要同時支援才行，目前新版的 Linux 都已經預設搭載 virtio driver 了，我們用以下的指令啟動支援 virtio_blk 的 virtual machine：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kvm -vnc 0.0.0.0:1 -m 2048 --daemonize \</span><br><span class="line">  -drive format=raw,file=/kvm/storage/vm_disks/ubnutu1604.img \</span><br><span class="line">  -device virtio-balloon-pci \</span><br><span class="line">  -netdev tap,id=net0,vhost=on -device virtio-net-pci,netdev=net0</span><br></pre></td></tr></table></figure><p>進入到 virtual machine 之後，可以透過以下指令確認 block device 的確是以 virtio driver 所驅動：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@vm-ubuntu1604:~$ cat /boot/config-`uname -r` | grep VIRTIO_BLK</span><br><span class="line">CONFIG_VIRTIO_BLK=y</span><br><span class="line"></span><br><span class="line">ubuntu@vm-ubuntu1604:~$ lspci | grep -i virtio</span><br><span class="line">00:03.0 Unclassified device [00ff]: Red Hat, Inc Virtio memory balloon</span><br><span class="line">00:04.0 Ethernet controller: Red Hat, Inc Virtio network device</span><br><span class="line">00:05.0 SCSI storage controller: Red Hat, Inc Virtio block devicei</span><br><span class="line"></span><br><span class="line">ubuntu@vm-ubuntu1604:~$ lspci -vv -s 00:05.0</span><br><span class="line">00:05.0 SCSI storage controller: Red Hat, Inc Virtio block device</span><br><span class="line">        Subsystem: Red Hat, Inc Virtio block device</span><br><span class="line">        Physical Slot: 5</span><br><span class="line">        Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR+ FastB2B- DisINTx+</span><br><span class="line">        Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast &gt;TAbort- &lt;TAbort- &lt;MAbort- &gt;SERR- &lt;PERR- INTx-</span><br><span class="line">        Latency: 0</span><br><span class="line">        Interrupt: pin A routed to IRQ 10</span><br><span class="line">        Region 0: I/O ports at c000 [size=64]</span><br><span class="line">        Region 1: Memory at febd2000 (32-bit, non-prefetchable) [size=4K]</span><br><span class="line">        Capabilities: &lt;access denied&gt;</span><br><span class="line">        Kernel driver <span class="keyword">in</span> use: virtio-pci</span><br></pre></td></tr></table></figure><hr><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><p><a href="https://read01.com/4aJdOL.html" target="_blank" rel="noopener">Virtio 基本概念和設備操作 - 壹讀</a></p></li><li><p><a href="http://www.cnblogs.com/sammyliu/p/4543657.html" target="_blank" rel="noopener">KVM 介绍（3）：I/O 全虚拟化和准虚拟化 [KVM I/O QEMU Full-Virtualizaiton Para-virtualization] - SammyLiu - 博客园</a></p></li><li><p><a href="http://www.lijyyh.com/2015/12/linux-kvm-set-up-linux-kvm.html" target="_blank" rel="noopener">傲笑紅塵路: 架設 Linux KVM 虛擬化主機 (Set up Linux KVM virtualization host)</a></p></li><li><p><a href="https://fedoraproject.org/wiki/Windows_Virtio_Drivers" target="_blank" rel="noopener">Windows Virtio Drivers - FedoraProject</a></p></li><li><p><a href="http://www.linux-kvm.org/page/Virtio" target="_blank" rel="noopener">Virtio - KVM</a></p></li><li><p><a href="http://seitran.com/2015/04/13/01-gso-gro-lro/" target="_blank" rel="noopener">网卡TSO/GSO/LRO/GRO简要介绍 | Chenny的部落格</a></p></li><li><p><a href="http://lirobo.blogspot.tw/2014/12/tso-gso-lro-gro.html" target="_blank" rel="noopener">小蘿蔔工作室 Little Robot Studio: TSO, GSO, LRO, GRO</a></p></li><li><p><a href="https://kris.io/2015/10/01/kvm-network-performance-tso-and-gso-turn-it-off/" target="_blank" rel="noopener">KVM Network Performance : TSO and GSO - Turn it off - kris.io : virtualization &amp; cloud</a></p></li></ul>]]></content>
      
      <categories>
          
          <category> KVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> KVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Linux KVM] Linux KVM concept - Networking</title>
      <link href="/blog/2016/08/10/KVM/KVM-Basic-Concept-Networking/"/>
      <url>/blog/2016/08/10/KVM/KVM-Basic-Concept-Networking/</url>
      <content type="html"><![CDATA[<p>此篇文章介紹學習 Linux KVM 時所需要了解的 Networking 相關知識</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>現今的虛擬化技術中，網路的部分永遠都是比重相當高的一部分，許多大型的 service provider 透過網路提供各種不同的服務給使用者，讓使用者在 IT 科技的幫助下，生活更加便利。</p><p>也因為這樣，當網路發生故障時，這些公司的損失常常難以估計，因此網路架構的設計上，保有彈性 &amp; 穩定性是相當重要的。</p><p>而現在 server 普遍都擁有多張網路卡，為了提高網路使用效率 &amp; 增加備援功能，建議 <strong><font color="red">透過 Linux bonding 的技術將所有的網路卡設定成為 single virtual channel</font></strong>。</p><blockquote><p>bonding mode 有分為 Mode 1(active-backup)、Mode 2(balance-xor)、Mode 4(802.3ad/LACP)、Mode 5(balance-tlb)，其中建議使用 <code>Mode 1(active-backup)</code> &amp; <code>Mode 5(balance-tlb)</code></p></blockquote><hr><h1 id="KVM-QEMU-支援的-Network-Type"><a href="#KVM-QEMU-支援的-Network-Type" class="headerlink" title="KVM/QEMU 支援的 Network Type"></a>KVM/QEMU 支援的 Network Type</h1><p>網路絕對是使用 vitual machine 時最不可或缺的一部分，而 QEMU 提供了 virtual machine 一共四種不同的 network type：</p><ol><li><p>bridge</p></li><li><p>NAT</p></li><li><p>user mode networking</p></li><li><p>VT-d &amp; SR-IOV (直接分配網路設備)</p></li></ol><p>要透過 QEMU 配置 virtual machine 的網路，必須使用 <code>-net</code> 參數，若是完全沒使用任何的網路相關參數，會系統自動帶上 <code>-net nic -net user</code> 做為網路預設值。</p><p>而 QEMU 可以模擬那些網路卡呢? 肯定必須是主流且被廣泛支援的，可以用以下指令查詢：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kvm -net nic,model=?</span><br><span class="line">qemu: Supported NIC models: ne2k_pci,i82551,i82557b,i82559er,rtl8139,e1000,pcnet,virtio</span><br></pre></td></tr></table></figure><blockquote><p>若沒指定任何網路相關參數，則預設會使用 RTL8139 網卡</p></blockquote><hr><h1 id="設定第一張虛擬網卡"><a href="#設定第一張虛擬網卡" class="headerlink" title="設定第一張虛擬網卡"></a>設定第一張虛擬網卡</h1><p>為了要設定虛擬網卡，必須先了解 <code>-net nic</code> 相關參數：</p><blockquote><p>-net nic[,vlan=n][,macaddr=mac][,model=type] [,name=name][,addr=addr][,vectors=v]</p></blockquote><ul><li><p><code>-net nic</code>：表示這是一個網卡的設定 (<strong><font color="red">必要!</font></strong>)</p></li><li><p><code>vlan=n</code>：將網卡連結到 ID 為 <strong><font color="red">n</font></strong> 的 VLAN</p></li><li><p><code>macaddr=mac</code>：指定網卡 MAC address</p></li><li><p><code>model=type</code>：設定網卡的種類，預設為 <strong><font color="red">rtl8139</font></strong></p></li><li><p><code>name=name</code>：為網卡命名(但僅有在 QEMU monitor 看的到)</p></li><li><p><code>addr=addr</code>：指定網卡在 virtual machine 中的 PCI device address</p></li><li><p><code>vectors=v</code>：設定網卡設備的 MSI-X 向量的數量，用於 virtio 驅動的網卡上</p></li></ul><p>簡單做個測試，我們透過以下指令指定網卡：</p><blockquote><p>kvm -vnc 0.0.0.0:1 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img -net nic,vlan=0,macaddr=52:53:00:11:12:13,model=e1000,addr=08 -net user</p></blockquote><p>於是在系統中可以得到以下訊息：</p><p><img src="https://lh3.googleusercontent.com/abxoQOVs8BrZGNtB7rvarf28_a0AomNu_UBJvLgblFG6uoAj2lWJnlMGMuujMu_V3ldlY2p2ZPYTQJa84180vlnBkGp4bkJmidQN29QBEO9zb9cWOOQOK5HTTOwglaXnEJ_WXdSnKO1xGFmKkdHZji1tulTDI_mihaOaghtA3YlT_I5ss4-OQbsdK2lIdLz_deaKnb5AcAQA9cmAt6rPaW0pocvL4THwvZY3d4QXOOMso96DPPTWntwl0qsHEd19BMg4B0uzuAbNlIVglYMX8k80YOTZxTQDsAFi16q5MDlgrTPDa0VY7UOoNFvI-7PWmktPf3RYSpXa1QQ6kmASVax3x3NCYC3pZW_HA27dxjwyA3GRM4IYtsjKA9EBjMkhpVZmHeoxAeCk9_gSXKMJUqEdg8u63JRm9xsJobEcOy_g_1YXmMPCc1v-8Mx1QFpwctMr5C7DXq8DI-C_Voz2Y8DGpz1p7prWgDb2j1v6daMfvJwJvtKAyw2p2HyulbsMuSZE3JNB6bsZLmJgi4WjvXT3rr32l1mJQcE64B4MK-ZLQMZjTA0g18g5w5wk5d83XtQiSahUc-5wGhudJ6l5sqqRwDQ1Nec=w771-h384-no" alt="System NIC Information"></p><p>在 QEMU monitor 則可以看到以下資訊：</p><p><img src="https://lh3.googleusercontent.com/RPzHnMisxvsHZx5xpTctONaavpAXkcjUxfqHdaiNfwYL-RyspfM2dGW4rffxz7Z-NyzLHH1ChC0zGwjNes5AclVYiW4-8Bb8YOgg61jHs58jmMchhv_ICNNvwhm-vkyHmkffIukmKxX7BqufthPly1VgVMNI1J2x17l66DD2LicTEbGPQB-414rpc8tTR1l3pBPnoNPZuaxTNCXNYlkfmvQUdx1ltYfWusoEUsxhLckpakEJ_F8qCEGrJ-dmLgh6BbLjDNlDfqBix-bMJaBdGlyngC8XvWR-f45eTKUyPCukFb-oSFVFH1VspTRqsBgccbSH06fKlq12CDu0pNhBNbte6zFPt7oJMAFn_Yf2ENBWXQbFjRs2H0x8eaCcQ0MiXY01wUmsNYoGJsgmZgKJZ2jQdhLDXu4bjtoH-0DuZw1NSfKPuIkDks9FdQR0j-adxK_rOg9oqpTdNOBOkU_QPfqQJUejhwlTr5OwjLjGkD5XIYHKbXU72D66eDCZNTMVUGxWo_EkhVluszNlN1PiCzOdqlRK4StC0LVWUFscHLHwyEjHuwTwg0BEIRs91_-nD0DrJT5mZF7emdCRPStDDdWGdP9ftVY=w541-h153-no" alt="Network Info in QEMU monitor"></p><hr><h1 id="設定-Bridge-Mode"><a href="#設定-Bridge-Mode" class="headerlink" title="設定 Bridge Mode"></a>設定 Bridge Mode</h1><h2 id="設定參數說明"><a href="#設定參數說明" class="headerlink" title="設定參數說明"></a>設定參數說明</h2><p>在 bridge mode 下，virtual machine 的網路可視為與 host machine 是相同的，可以有自己的獨立 ip，外部網路可以直接存取 virtual machine。</p><p>以下是建立 bridge mode NIC 的參數：</p><blockquote><p>-net tap[,vlan=n][,name=name][,fd=h][,ifname=name][,script=file][,downscript=dfile][,helper=helper]</p></blockquote><ul><li><p><code>tap</code>：表示使用 tap device(屬於 layer 2 的虛擬網路設備；附帶一提，<code>tun</code> 則是屬於 layer 3 的虛擬網路設備)</p></li><li><p><code>vlan=n</code>：指定使用的 VLAN ID</p></li><li><p><code>name=name</code>：設定網卡名稱(可從 QEMU monitor 中檢視，但大多數情況下可忽略)</p></li><li><p><code>fd=h</code>：連接到已經開啟 tap 的 file descriptor (<strong>一般交給 QEMU 自行建立</strong>)</p></li><li><p><code>ifname=name</code>：設定 tap device 名稱(未設定的話會由 QEMU 自行產生)</p></li><li><p><code>script=file</code>：指定啟動 virtual machine 時自動執行的 script</p></li><li><p><code>downscript=dfile</code>：指定關閉 virtual machine 時自動執行的 script</p></li><li><p><code>helper=helper</code>：指定啟動 virtual machine 時會在 host machine 上執行的 helper 程式(例如：建立 tap device)，一般可以忽略使用預設值即可</p></li></ul><h2 id="建立支援-bridge-mode-的環境"><a href="#建立支援-bridge-mode-的環境" class="headerlink" title="建立支援 bridge mode 的環境"></a>建立支援 bridge mode 的環境</h2><h3 id="1、檢查環境支援程度"><a href="#1、檢查環境支援程度" class="headerlink" title="1、檢查環境支援程度"></a>1、檢查環境支援程度</h3><p>在建立 bridge 模式的網路配置之前，我們必須先確定 host machine 已經掛載相關模組：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 檢查是否有掛載 tun 模組</span></span><br><span class="line">$ lsmod | grep tun</span><br><span class="line">tun                    27141  1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 確認目前的 user 有 /dev/net/tun 的讀寫權限</span></span><br><span class="line">$ ls -al /dev/net/tun</span><br><span class="line">crw-rw-rw-. 1 root root 10, 200 Aug  3 20:14 /dev/net/tun</span><br></pre></td></tr></table></figure><h3 id="2、在-host-machine-上可建立-bridge-device-的環境"><a href="#2、在-host-machine-上可建立-bridge-device-的環境" class="headerlink" title="2、在 host machine 上可建立 bridge device 的環境"></a>2、在 host machine 上可建立 bridge device 的環境</h3><p>環境說明：</p><ul><li><p>bridge device：<code>br0</code></p></li><li><p>physical device：<code>ens1f0</code></p></li><li><p>ip address：<code>10.20.190.2/24</code></p></li><li><p>gateway：<code>10.20.190.1</code></p></li></ul><p>以下要在 host machine 上建立一個 bridge device，並綁定到要連外的實體網卡，並讓 bridge device 成為連接 host machine 與外網的設備：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># nmcli connection add type bridge ifname br0</span></span><br><span class="line">[root@localhost ~]<span class="comment"># nmcli connection modify bridge-br0 bridge.stp yes</span></span><br><span class="line"><span class="comment"># 以下請根據自身的 lab 環境做調整</span></span><br><span class="line">[root@localhost ~]<span class="comment"># nmcli connection modify bridge-br0 ipv4.method manual ipv4.address "10.20.190.2/24" ipv4.gateway "10.20.190.1" ipv4.dns 8.8.8.8</span></span><br><span class="line">[root@localhost ~]<span class="comment"># nmcli connection add type bridge-slave ifname ens1f0 master br0</span></span><br><span class="line">[root@localhost ~]<span class="comment"># nmcli connection delete ens1f0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bridge device 設定完成後，可以檢查是否有與實體網卡連動</span></span><br><span class="line">$ brctl show</span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">br0             8000.2c600cb163d5       yes             ens1f0</span><br><span class="line">virbr0          8000.5254001001dc       yes             virbr0-nic</span><br></pre></td></tr></table></figure><p>設定完成後，實體網路卡會進入到 <strong><font color="red">promiscuous mode</font></strong>，而 bridge device 則會進入到 <strong><font color="red">forwarding state</font></strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ dmesg | grep ens1f0</span><br><span class="line">.....</span><br><span class="line">[807464.149861] device ens1f0 entered promiscuous mode</span><br><span class="line">.....</span><br><span class="line">[807494.252510] br0: port 1(ens1f0) entered forwarding state</span><br></pre></td></tr></table></figure><p>接著建立要進行 bridge 網路配置用的 script(<strong><font color="red">/etc/qemu-if{up,down}</font></strong>) 並設定可執行權限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立 script (/etc/qemu-ifup)</span></span><br><span class="line">$ cat &lt;&lt;\EOF &gt;/etc/qemu-ifup</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#This is a qemu-ifup script for bridging.</span></span><br><span class="line"><span class="comment">#You can use it when starting a KVM guest with bridge mode network.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#set your bridge name</span></span><br><span class="line">switch=br0</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$1</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="comment">#start up the TAP interface</span></span><br><span class="line">  ip link <span class="built_in">set</span> <span class="variable">$1</span> up</span><br><span class="line">  sleep 1</span><br><span class="line">  <span class="comment">#add TAP interface to the bridge</span></span><br><span class="line">  brctl addif <span class="variable">$&#123;switch&#125;</span> <span class="variable">$1</span></span><br><span class="line">  <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> “Error: no interface specified”</span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">$ cat &lt;&lt;\EOF &gt;/etc/qemu-ifdown</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#This is a qemu-ifdown script for bridging.</span></span><br><span class="line"><span class="comment">#You can use it when starting a KVM guest with bridge mode network.</span></span><br><span class="line"><span class="comment">#Don’t use this script in most cases; QEMU will handle it automatically.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#set your bridge name</span></span><br><span class="line">switch=br0</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$1</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="comment"># Delete the specified interfacename</span></span><br><span class="line">  tunctl -d <span class="variable">$1</span></span><br><span class="line">  <span class="comment">#release TAP interface from bridge</span></span><br><span class="line">  brctl delif <span class="variable">$&#123;switch&#125;</span> <span class="variable">$1</span></span><br><span class="line">  <span class="comment">#shutdown the TAP interface</span></span><br><span class="line">  ip link <span class="built_in">set</span> <span class="variable">$1</span> down</span><br><span class="line">  <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> “Error: no interface specified”</span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定執行權限</span></span><br><span class="line">$ chmod +x /etc/qemu-if&#123;up,down&#125;</span><br></pre></td></tr></table></figure><blockquote><p>若是目前使用者沒有 script 的 execute 權限，就無法新增 tap interface for bridge mode 喔!</p></blockquote><h3 id="3、啟動-bridge-mode-virtual-machine"><a href="#3、啟動-bridge-mode-virtual-machine" class="headerlink" title="3、啟動 bridge-mode virtual machine"></a>3、啟動 bridge-mode virtual machine</h3><p>當上述環境都準備好後，可使用以下指令啟動 virtual machine：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -net nic -net tap =&gt; 指定 virtual machine 網卡為 bridge mode，建立 tap interface</span></span><br><span class="line"><span class="comment"># script=/etc/qemu-ifup =&gt; 指定 script 配置網卡</span></span><br><span class="line"><span class="comment"># downscript=/etc/qemu-ifdown =&gt; 指定 script 移除網卡 (若設定為 no 則 QEMU 會自動協助處理)</span></span><br><span class="line"><span class="comment"># --daemonize =&gt; QEMU 程序背景執行</span></span><br><span class="line">$ kvm -vnc 0.0.0.0:1 -m 2048 /kvm/storage/vm_disks/ubnutu1604.img -net nic -net tap,script=/etc/qemu-ifup,downscript=/etc/qemu-ifdown --daemonize</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢是否有啟動 tap interface 並與 bridge device 相連</span></span><br><span class="line">$ brctl show</span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">br0             8000.26503b3a5e74       yes             ens1f0</span><br><span class="line">                                                        tap0</span><br><span class="line">virbr0          8000.5254001001dc       yes             virbr0-nic</span><br></pre></td></tr></table></figure><p>當 virtual machine 啟動後(會在 DHCP 的地方卡一段時間)，在 virtual machine 中可以透過以下指令設定 IP：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假設新增的 network interface 為 ens3</span></span><br><span class="line">$ sudo ip addr add 10.20.190.3/24 dev ens3</span><br><span class="line">$ sudo ip route add 0.0.0.0/0 via 10.20.190.1 dev ens3</span><br></pre></td></tr></table></figure><p>如此一來在網路的部分就可以等同 host machine 一樣，正常存取 Internet &amp; 提供網路服務了</p><p>詳細的設定操作可以參考下圖：</p><p><img src="https://github.com/godleon/godleon.github.io/blob/master/_posts/images/2016/KVM-Basic-Concept-Networking/kvm_network-bridge-mode-configure-ip.PNG?raw=true" alt="Configure static IP by using ip command"></p><hr><h1 id="設定-NAT-mode"><a href="#設定-NAT-mode" class="headerlink" title="設定 NAT mode"></a>設定 NAT mode</h1><h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p>NAT 是為了解決 public ip address 不足而產生的，其詳細的原理這邊就不贅述了，可參考下列網址：</p><ul><li><a href="http://linux.vbird.org/linux_server/0250simple_firewall/0320nat.php" target="_blank" rel="noopener">鳥哥的 Linux 私房菜 – Network Address Transfer ( NAT ) 架設</a></li></ul><h2 id="檢查-host-machine-環境"><a href="#檢查-host-machine-環境" class="headerlink" title="檢查 host machine 環境"></a>檢查 host machine 環境</h2><h3 id="1、檢查-bridge-device"><a href="#1、檢查-bridge-device" class="headerlink" title="1、檢查 bridge device"></a>1、檢查 bridge device</h3><p>在 QEMU/KVM 中，使用 NAT mode 的 virtual machine 其實是透過 host machine 中的 <strong><font color="red">virbr0</font></strong> 這個 bridge device 連外的，可以來檢視一下相關資訊：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ ip addr show</span><br><span class="line">1: lo: .......</span><br><span class="line">2: eno1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP qlen 1000</span><br><span class="line">    link/ether 2c:60:0c:c1:b9:2d brd ff:ff:ff:ff:ff:ff</span><br><span class="line">3: ens1f0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq master br0 state UP qlen 1000</span><br><span class="line">    link/ether 2c:60:0c:b1:63:d5 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">4: ens1f1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP qlen 1000</span><br><span class="line">    link/ether 2c:60:0c:b1:63:d6 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">5: virbr0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN</span><br><span class="line">    link/ether 52:54:00:10:01:dc brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.122.1/24 brd 192.168.122.255 scope global virbr0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">6: virbr0-nic: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc pfifo_fast master virbr0 state DOWN qlen 500</span><br><span class="line">    link/ether 52:54:00:10:01:dc brd ff:ff:ff:ff:ff:ff</span><br><span class="line">7: br0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP</span><br><span class="line">    link/ether 2c:60:0c:b1:63:d5 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.20.190.2/24 brd 10.20.190.255 scope global br0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::2e60:cff:feb1:63d5/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>從上面可以看出，QEMU/KVM 已經幫我們把 virbr0 設定完成，使用的是 <code>192.168.122.1/24</code> 的網段。</p><h3 id="2、檢查-DHCP-服務"><a href="#2、檢查-DHCP-服務" class="headerlink" title="2、檢查 DHCP 服務"></a>2、檢查 DHCP 服務</h3><p>但關於 DHCP 的部分呢? QEMU/KVM 同樣也設定好 <strong><font color="red">dnsmasq</font></strong> 幫我們處理好 ip 的分配 &amp; traffic forwarding 的相關問題，若是要進一步的了解詳細的設定細節，可使用下面方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ ps -aux | grep dns</span><br><span class="line">nobody    4322  0.0  0.0  15552   888 ?        S    Jul27   0:01 /sbin/dnsmasq --conf-file=/var/lib/libvirt/dnsmasq/default.conf --leasefile-ro --dhcp-script=/usr/libexec/libvirt_leaseshelper</span><br><span class="line">root      4323  0.0  0.0  15524   176 ?        S    Jul27   0:00 /sbin/dnsmasq --conf-file=/var/lib/libvirt/dnsmasq/default.conf --leasefile-ro --dhcp-script=/usr/libexec/libvirt_leaseshelper</span><br><span class="line">root     16414  0.0  0.0 112652   976 pts/2    S+   06:02   0:00 grep --color=auto dns</span><br><span class="line"></span><br><span class="line">[root@ocp-kvm-host ~]<span class="comment"># cat /var/lib/libvirt/dnsmasq/default.conf</span></span><br><span class="line"><span class="comment">##WARNING:  THIS IS AN AUTO-GENERATED FILE. CHANGES TO IT ARE LIKELY TO BE</span></span><br><span class="line"><span class="comment">##OVERWRITTEN AND LOST.  Changes to this configuration should be made using:</span></span><br><span class="line"><span class="comment">##    virsh net-edit default</span></span><br><span class="line"><span class="comment">## or other application using the libvirt API.</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">## dnsmasq conf file created by libvirt</span></span><br><span class="line">strict-order</span><br><span class="line">pid-file=/var/run/libvirt/network/default.pid</span><br><span class="line">except-interface=lo</span><br><span class="line"><span class="built_in">bind</span>-dynamic</span><br><span class="line">interface=virbr0</span><br><span class="line">dhcp-range=192.168.122.2,192.168.122.254</span><br><span class="line">dhcp-no-override</span><br><span class="line">dhcp-lease-max=253</span><br><span class="line">dhcp-hostsfile=/var/lib/libvirt/dnsmasq/default.hostsfile</span><br><span class="line">addn-hosts=/var/lib/libvirt/dnsmasq/default.addnhosts</span><br></pre></td></tr></table></figure><h3 id="3、檢查-traffic-forward-設定"><a href="#3、檢查-traffic-forward-設定" class="headerlink" title="3、檢查 traffic forward 設定"></a>3、檢查 traffic forward 設定</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/sys/net/ipv4/ip_forward</span><br><span class="line">1</span><br></pre></td></tr></table></figure><blockquote><p>‵<code>1</code> 表示 traffic forward 的功能是開啟的</p></blockquote><h3 id="3、檢查-firewall-設定"><a href="#3、檢查-firewall-設定" class="headerlink" title="3、檢查 firewall 設定"></a>3、檢查 firewall 設定</h3><p>最後要確認 host machine 可以將 virtual machine 對外的流量透過 virbr0 送出，因此要確認防火牆的設定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iptables -t nat -L -vn</span></span><br><span class="line">Chain PREROUTING (policy ACCEPT 29 packets, 4041 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line"></span><br><span class="line">Chain INPUT (policy ACCEPT 5 packets, 1044 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 39 packets, 2906 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line"></span><br><span class="line">Chain POSTROUTING (policy ACCEPT 39 packets, 2906 bytes)</span><br><span class="line"> pkts bytes target     prot opt <span class="keyword">in</span>     out     <span class="built_in">source</span>               destination</span><br><span class="line">    0     0 RETURN     all  --  *      *       192.168.122.0/24     224.0.0.0/24</span><br><span class="line">    0     0 RETURN     all  --  *      *       192.168.122.0/24     255.255.255.255</span><br><span class="line">    0     0 MASQUERADE  tcp  --  *      *       192.168.122.0/24    !192.168.122.0/24     masq ports: 1024-65535</span><br><span class="line">    0     0 MASQUERADE  udp  --  *      *       192.168.122.0/24    !192.168.122.0/24     masq ports: 1024-65535</span><br><span class="line">    0     0 MASQUERADE  all  --  *      *       192.168.122.0/24    !192.168.122.0/24</span><br></pre></td></tr></table></figure><blockquote><p>從上面可看出，來自於 192.168.122.0/24 網段且對外的流量，會以 NAT 的形式連外</p></blockquote><h2 id="建立可運行-NAT-mode-的環境"><a href="#建立可運行-NAT-mode-的環境" class="headerlink" title="建立可運行 NAT mode 的環境"></a>建立可運行 NAT mode 的環境</h2><p>確認好目前的環境後，我們便根據環境設定了兩支 script，分別用來產生 &amp; 移除 tap interface for NAT mode：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置 tap interface for NAT mode 的 script</span></span><br><span class="line">$ cat &lt;&lt;\EOF &gt;/etc/qemu-ifup-NAT</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># network information</span></span><br><span class="line">BRIDGE=virbr0</span><br><span class="line">NETWORK=192.168.122.0</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=192.168.122.1</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$1</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="comment"># 啟用 bridge device for NAT mode</span></span><br><span class="line">  brctl stp <span class="variable">$&#123;BRIDGE&#125;</span> on</span><br><span class="line">  ifconfig <span class="variable">$&#123;BRIDGE&#125;</span> <span class="variable">$&#123;GATEWAY&#125;</span> netmask <span class="variable">$&#123;NETMASK&#125;</span> up</span><br><span class="line"></span><br><span class="line">  ifconfig <span class="string">"<span class="variable">$1</span>"</span> 0.0.0.0 up</span><br><span class="line">  brctl addif <span class="variable">$&#123;BRIDGE&#125;</span> <span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line">  <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Error: no interface specified."</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除 tap interface for NAT mode 的 script</span></span><br><span class="line">$ cat &lt;&lt;\EOF &gt;/etc/qemu-ifdown-NAT</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># network information</span></span><br><span class="line">BRIDGE=virbr0</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$1</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Tearing down network bridge for <span class="variable">$1</span>"</span></span><br><span class="line">  ip link <span class="built_in">set</span> <span class="string">"<span class="variable">$1</span>"</span> down</span><br><span class="line">  brctl delif <span class="variable">$&#123;BRIDGE&#125;</span> <span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line">  <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Error: no interface specified."</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 為目前的使用者加入</span></span><br><span class="line">$ chmod +x /etc/qemu-if&#123;up,down&#125;-NAT</span><br></pre></td></tr></table></figure><blockquote><p>以上的 script 可能會因為自身的環境不同而有增減，需要特別注意一下</p></blockquote><h2 id="啟動-NAT-mode-virtual-machine"><a href="#啟動-NAT-mode-virtual-machine" class="headerlink" title="啟動 NAT-mode virtual machine"></a>啟動 NAT-mode virtual machine</h2><p>當環境都準備好後，可以使用以下指令啟動 virtual machine：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -net nic -net tap =&gt; 設定 tap interface</span></span><br><span class="line"><span class="comment"># script=/etc/qemu-ifup-NAT,downscript=/etc/qemu-ifdown-NAT =&gt; 使用指定的 script 配置網路</span></span><br><span class="line">$ kvm -vnc 0.0.0.0:1 -m 2048 /kvm/storage/vm_disks/ubnutu1604.img -net nic -net tap,script=/etc/qemu-ifup-NAT,downscript=/etc/qemu-ifdown-NAT --daemonize</span><br><span class="line"></span><br><span class="line"><span class="comment"># 從下面結果可看出 tap0 是與 virbr0 這個 bridge device 相連</span></span><br><span class="line">$ brctl show</span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">br0             8000.2c600cb163d5       yes             ens1f0</span><br><span class="line">virbr0          8000.1a507abb7dff       yes             tap0</span><br><span class="line">                                                        virbr0-nic</span><br></pre></td></tr></table></figure><p>最後確認一下 virtual machine 的狀況：</p><p><img src="https://github.com/godleon/godleon.github.io/blob/master/_posts/images/2016/KVM-Basic-Concept-Networking/kvm_network-NAT-mode-VM.PNG?raw=true" alt="NAT mode - virtual machine"></p><p>從上圖可看出 virtual machine 的確拿到了 192.168.122.0/24 網段中的 ip address，表示 host machine 中的 dnsmasq 運作正常；此外連外也正常，表示防火牆的設定部分也沒有問題</p><hr><h1 id="設定用戶模式-user-mode-網路-內部網路"><a href="#設定用戶模式-user-mode-網路-內部網路" class="headerlink" title="設定用戶模式(user-mode)網路(內部網路)"></a>設定用戶模式(user-mode)網路(內部網路)</h1><p>若在啟動 virtual machine 沒加上 <code>-net</code> 參數，預設 QEMU 就會使用 <code>-net nic -net user</code> 把 virtual machine 設定為 user mode。</p><p>user mode network 完全是由 QEMU 透過 <a href="http://wiki.qemu.org/Documentation/Networking" target="_blank" rel="noopener">SLiRP</a> 所實現的一個虛擬 NAT 網路，不用依賴先前所安裝的 <strong>bridge-utils</strong>、<strong>dnsmaq</strong>、<strong>iptables</strong> 等工具，也不需要 root 的權限就可執行。</p><p>以下是 user mode network 的架構圖：</p><p><img src="http://wiki.qemu.org/images/9/93/Slirp_concept.png" alt="SLiRP concept"></p><p>使用參數：<code>-net user[,option][,option][,...]</code></p><p>以下列出比較常用的 option：</p><ul><li><p><code>vlan=n</code>：將 user mode network 連接到 VLAN ID=n 的 VLAN</p></li><li><p><code>net=addr[/mask]</code>：設定 virtual machine 的 ip address (預設為 <strong><font color="red">10.0.2.0/24</font></strong>)</p></li><li><p><code>host=addr</code>：設定 host machine 的 ip address (預設為 <strong><font color="red">10.0.2.2</font></strong>)</p></li><li><p><code>dns=addr</code>：設定 virtual DNS 的 ip address (預設為 <strong><font color="red">10.0.2.3</font></strong>)</p></li><li><p><code>dhcpstart=addr</code>：設定 DHCP 的第一個 ip address (預設為 <strong><font color="red">10.0.2.15</font></strong>)</p></li><li><p><code>restrict=y|yes|n|no</code>：若設定 yes，virtual machine 將無法與 host machine 通訊，但不會影響 hostfwd 的設定</p></li><li><p><code>hostfwd=[tcp|udp]:[hostaddr]:hostport-[guestaddr]:guestport</code>：將 host machine 中的 hostport 導向 virtual machine 的 guestport (可一次定義多個 hostfwd 設定)</p></li></ul><p>以下是簡單的應用範例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -net nic -net user =&gt; user mode network</span></span><br><span class="line"><span class="comment"># hostfwd=tcp::5022-:22 =&gt; 將 host machine 的 tcp port 5022 導向 virtual machine 的 tcp port 22</span></span><br><span class="line">$ kvm -vnc 0.0.0.0:1 -m 2048 /kvm/storage/vm_disks/ubnutu1604.img -net nic -net user,hostfwd=tcp::5022-:22 --daemonize</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 tcp port 5022 連線到 virtual machine</span></span><br><span class="line">$ ssh -p 5022 ubuntu@10.20.190.2</span><br><span class="line">ubuntu@10.20.190.2\<span class="string">'s password:</span></span><br><span class="line"><span class="string">.......</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 查詢 ip address</span></span><br><span class="line"><span class="string">ubuntu@vm-ubuntu1604:~$ ip addr show</span></span><br><span class="line"><span class="string">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1</span></span><br><span class="line"><span class="string">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span></span><br><span class="line"><span class="string">    inet 127.0.0.1/8 scope host lo</span></span><br><span class="line"><span class="string">       valid_lft forever preferred_lft forever</span></span><br><span class="line"><span class="string">    inet6 ::1/128 scope host</span></span><br><span class="line"><span class="string">       valid_lft forever preferred_lft forever</span></span><br><span class="line"><span class="string">2: ens3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span></span><br><span class="line"><span class="string">    link/ether 52:54:00:12:34:56 brd ff:ff:ff:ff:ff:ff</span></span><br><span class="line"><span class="string">    inet 10.0.2.15/24 brd 10.0.2.255 scope global ens3</span></span><br><span class="line"><span class="string">       valid_lft forever preferred_lft forever</span></span><br><span class="line"><span class="string">    inet6 fe80::5054:ff:fe12:3456/64 scope link</span></span><br><span class="line"><span class="string">       valid_lft forever preferred_lft forever</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 實際上是可以上網的</span></span><br><span class="line"><span class="string">ubuntu@vm-ubuntu1604:~$ curl www.google.com.tw</span></span><br><span class="line"><span class="string">..........(省略一大堆內容)</span></span><br></pre></td></tr></table></figure><p>必須一提的是，使用 user mode network 也是有些缺點在的，像是：</p><ol><li><p>由於網路都是由 QEMU 虛擬出來的，因此效能比起其他模式相對差一些</p></li><li><p>不支援部分網路功能(例如：ICMP)，所以也就無法使用 ping command</p></li><li><p>無法從 host machine or 外部直接存取 virtual machine</p></li></ol><hr><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><p><a href="http://linux.die.net/man/1/qemu-kvm" target="_blank" rel="noopener">qemu-kvm(1): QEMU Emulator User Documentation - Linux man page</a></p></li><li><p><a href="http://wiki.qemu.org/download/qemu-doc.html" target="_blank" rel="noopener">QEMU Emulator User Documentation</a></p></li><li><p><a href="http://www.it610.com/article/4332744.htm" target="_blank" rel="noopener">桥网络配置 - info5 - IT610.com</a></p></li><li><p><a href="http://smilejay.com/2012/03/kvm_qemu_network_error/" target="_blank" rel="noopener">KVM “qemu-ifup: could not configure /dev/net/tun: Operation not permitted”解决方案 – 笑遍世界</a></p></li></ul>]]></content>
      
      <categories>
          
          <category> KVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> KVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Linux KVM] Linux KVM concept - Storage</title>
      <link href="/blog/2016/08/03/KVM/KVM-Basic-Concept-Storage/"/>
      <url>/blog/2016/08/03/KVM/KVM-Basic-Concept-Storage/</url>
      <content type="html"><![CDATA[<p>此篇文章介紹學習 Linux KVM 時所需要了解的 Storage 相關知識</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 Linux KVM 中，是由 QEMU 來提供 storage device 的模擬，可以模擬的 storage 類型很多，包含 IDE device / SCSI device / Floopy disk / USB disk / virtio disk …. 等等，可根據使用者需求的不同來提供不同組合以及不同的開機順序。</p><hr><h1 id="Host-Machine-Swap-空間應該要設定多大"><a href="#Host-Machine-Swap-空間應該要設定多大" class="headerlink" title="Host Machine Swap 空間應該要設定多大?"></a>Host Machine Swap 空間應該要設定多大?</h1><p>以前學 Linux 時知道，swap 是用來作為當記憶體不足時的 buffer 用，而現在虛擬化環境中，每台 host machine 的記憶體容量都很大，那 swap 應該如何規劃配置呢? 以下有幾個原則：</p><h3 id="不使用-memory-overcommit"><a href="#不使用-memory-overcommit" class="headerlink" title="不使用 memory overcommit"></a>不使用 memory overcommit</h3><ol><li><p>若實體記憶體 &lt;= 4GB，則 swap space 設定為 2GB</p></li><li><p>若 4GB &lt; 實體記憶體 &lt;= 16GB，則 swap space 設定為 4GB</p></li><li><p>若 16GB &lt; 實體記憶體 &lt;= 64GB，則 swap space 設定為 8GB</p></li><li><p>若 64GB &lt; 實體記憶體 &lt;= 526GB，則 swap space 設定為 16GB</p></li></ol><h3 id="使用-memory-overcommit"><a href="#使用-memory-overcommit" class="headerlink" title="使用 memory overcommit"></a>使用 memory overcommit</h3><p>假設配置 memory overcommit rate 為 0.5 (例如：128 GB 的記憶體卻配置 <code>128 * (1 + 0.5) = 192 GB</code>)，那 swap space 除了上面的大小外，還要額外在加上記憶體容量 x 0.5 的空間。</p><p>亦即設定 memory overcommit，還要多增加 <strong><font color="red">physical memory x memory overcommit rate</font></strong> 的容量大小給 swap space。</p><p>舉個實際例子，假設 host machine 有 32GB 記憶體，memory overcommit ratio 設定為 0.5，則 swap space 的容量計算如下：</p><blockquote><p>(32 * 0.5) + 8 = 24 GB</p></blockquote><hr><h1 id="Storage-Device-amp-開機順序的配置"><a href="#Storage-Device-amp-開機順序的配置" class="headerlink" title="Storage Device &amp; 開機順序的配置"></a>Storage Device &amp; 開機順序的配置</h1><p>在 <strong>qemu-kvm</strong> 可以直接在命令行中進行 storage device &amp; 開機順序的配置，以下是常用的參數：</p><h2 id="Storage-Devices"><a href="#Storage-Devices" class="headerlink" title="Storage Devices"></a>Storage Devices</h2><ul><li><code>-hd[a:d] file_path</code>：以 file_path 指定的 image 檔案作為系統的 IDE HDD，在 virtual machine 中會以 <strong>/dev/hd[a:d]</strong> or <strong>/dev/sd[a:d]</strong> 呈現</li></ul><blockquote><p>若在 qemu-kvm 中直接指定檔案而沒有設定 -hd[a:d]，則預設為 <strong>-hda</strong></p></blockquote><ul><li><p><code>-fd[a:b] file_path</code>：以 file_path 指定的 image 檔案作為系統的軟碟機，在 virtual machine 中會以 <strong>/dev/fd[a:b]</strong> 呈現</p></li><li><p><code>-cdrom file_path</code>：用來指定 iso 檔案作為 virtual machine 的 <strong>/dev/cdrom</strong> 時使用：不可與 <strong>-hdc</strong> 參數同時使用，會衝突</p></li><li><p><code>-driver option[, option[, option[, option[,....]]]]</code>：透過 <strong>-driver</strong> 參數指定 storage device 的設定細節</p></li></ul><p>由於以上的設定參數太多，所以這邊直接貼 man page 的內容來看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">-drive option[,option[,option[,...]]]</span><br><span class="line">    Define a new drive. Valid options are:</span><br><span class="line">    file=file</span><br><span class="line">      This option defines <span class="built_in">which</span> disk image to use with this drive. If the filename contains comma, you must double it (<span class="keyword">for</span> instance, <span class="string">"file=my,,file"</span> to use file <span class="string">"my,file"</span>).</span><br><span class="line">    <span class="keyword">if</span>=interface</span><br><span class="line">      This option defines on <span class="built_in">which</span> <span class="built_in">type</span> on interface the drive is connected. Available types are: ide, scsi, sd, mtd, floppy, pflash, virtio.</span><br><span class="line">    bus=bus,unit=unit</span><br><span class="line">      These options define <span class="built_in">where</span> is connected the drive by defining the bus number and the unit id.</span><br><span class="line">    index=index</span><br><span class="line">      This option defines <span class="built_in">where</span> is connected the drive by using an index <span class="keyword">in</span> the list of available connectors of a given interface <span class="built_in">type</span>.</span><br><span class="line">    media=media</span><br><span class="line">      This option defines the <span class="built_in">type</span> of the media: disk or cdrom.</span><br><span class="line">    cyls=c,heads=h,secs=s[,trans=t]</span><br><span class="line">      These options have the same definition as they have <span class="keyword">in</span> -hdachs.</span><br><span class="line">    snapshot=snapshot</span><br><span class="line">      snapshot is <span class="string">"on"</span> or <span class="string">"off"</span> and allows to <span class="built_in">enable</span> snapshot <span class="keyword">for</span> given drive (see -snapshot).</span><br><span class="line">    cache=cache</span><br><span class="line">      cache is <span class="string">"none"</span>, <span class="string">"writeback"</span>, <span class="string">"unsafe"</span>, or <span class="string">"writethrough"</span> and controls how the host cache is used to access block data.</span><br><span class="line">    aio=aio</span><br><span class="line">      aio is <span class="string">"threads"</span>, or <span class="string">"native"</span> and selects between pthread based disk I/O and native Linux AIO .</span><br><span class="line">    format=format</span><br><span class="line">      Specify <span class="built_in">which</span> disk format will be used rather than detecting the format. Can be used to specifiy format=raw to avoid interpreting an untrusted format header.</span><br><span class="line">    serial=serial</span><br><span class="line">      This option specifies the serial number to assign to the device.</span><br><span class="line">    addr=addr</span><br><span class="line">      Specify the controller\<span class="string">'s PCI address (if=virtio only).</span></span><br><span class="line"><span class="string">    copy-on-read=copy-on-read</span></span><br><span class="line"><span class="string">      copy-on-read is "on" or "off" and enables whether to copy read backing file sectors into the image file.</span></span><br></pre></td></tr></table></figure><p>在預設情況下，QEMU 會為所有的 block device 自動帶上 writethrough caching 的功能，這功能是利用 host page cache 所達成的，效率較差，但安全性高。</p><p>而另外一個 Writeback caching 可以提供更好的效率，但安全性較低，因為若是 host machine 突然掛點或發生電力中斷的情況，cache 中的資料很有可能會遺失；若是加上 <code>snapshot</code> 參數，則會預設使用 Writeback caching。</p><p>若是要完全關閉 cache 功能，可以加上參數 <code>cache=none</code>。</p><p>此外，其實每一個 storage device 都可以用 <code>-drive</code> 來設定，舉例來說：</p><ul><li><p><code>-cdrom file_path</code> = <code>-drive file=file,index=2,media=cdrom</code></p></li><li><p><code>-hda file_path</code> = <code>-drive file=file,index=0,media=disk</code></p></li><li><p><code>-fda file_path</code> = <code>-drive file=file,index=0,if=floppy</code></p></li></ul><h2 id="開機順率"><a href="#開機順率" class="headerlink" title="開機順率"></a>開機順率</h2><p>開機順序的參數設定如下：</p><blockquote><p>-boot [order=drives][,once=drives][,menu=on|off][,splash=sp_name][,splash-time=sp_time][,reboot-timeout=rb_timeout][,strict=on|off]</p></blockquote><p>QEMU 的開機順序，是以英文字母表示：</p><ul><li><p><code>a</code>：第一台軟碟機</p></li><li><p><code>b</code>：第二台軟碟機</p></li><li><p><code>c</code>：第一顆硬碟</p></li><li><p><code>d</code>：光碟機</p></li><li><p><code>n</code>：網路啟動</p></li></ul><p>以下是幾個簡單的範例：</p><ul><li><p><code>-boot order=d</code>：光碟開機</p></li><li><p><code>-boot once=d</code>：第一次以光碟開機，系統重開後以第一顆硬碟開機</p></li></ul><p>此外其他參數的說明：</p><ul><li><p><code>menu=on|off</code>：是否顯示開機選單</p></li><li><p><code>splash=sp_name</code> &amp; <code>splash-time=sp_time</code>：在 <code>menu=on</code> 時才有效，<code>splash</code> 設定開機 logo，<code>splash-time</code> 設定開機 logo 時間</p></li><li><p><code>-boot order=dc,menu=on</code>：開機順序為光碟機 &gt;&gt; 硬碟，顯示開機選單</p></li></ul><hr><h1 id="qemu-img"><a href="#qemu-img" class="headerlink" title="qemu-img"></a>qemu-img</h1><p><strong><a href="http://wiki.qemu.org/download/qemu-doc.html#qemu_005fimg_005finvocation" target="_blank" rel="noopener">qemu-img</a></strong> 是 QEMU 的磁碟管理工具，安裝好 QEMU 相關套件時就會存在於系統中，基本使用語法如下：</p><blockquote><p>qemu-img command [command options]</p></blockquote><p>以下就常用的相關命令 &amp; 參數進行介紹：</p><ul><li><code>create [-f fmt] [-o options] filename [size]</code>：建立 disk image；其中 <code>options</code> 的部分可以使用 <code>-o ?</code> 來查詢特定格式所支援的選項；<code>size</code> 則是支援 <code>k</code>(KB) / <code>M</code>(MB) / <code>G</code>(GB) / <code>T</code>(TB) 等大小。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 顯示目前 qcow2 格式支援的 options</span></span><br><span class="line">$ qemu-img create -f qcow2 -o ?</span><br><span class="line">Supported options:</span><br><span class="line">size             Virtual disk size</span><br><span class="line">compat           Compatibility level (0.10 or 1.1)</span><br><span class="line">backing_file     File name of a base image</span><br><span class="line">backing_fmt      Image format of the base image</span><br><span class="line">encryption       Encrypt the image</span><br><span class="line">cluster_size     qcow2 cluster size</span><br><span class="line">preallocation    Preallocation mode (allowed values: off, metadata, falloc, full)</span><br><span class="line">lazy_refcounts   Postpone refcount updates</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增檔名為 ubuntu1604.qcow2，格式為 qcow2，大小為 10GB 的 disk image</span></span><br><span class="line">$ qemu-img create -f qcow2 ubuntu1604.qcow2 10G</span><br><span class="line">Formatting <span class="string">'ubuntu1604.qcow2'</span>, fmt=qcow2 size=10737418240 encryption=off cluster_size=65536 lazy_refcounts=off</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增有 backing file(centos7.img，原生大小為 10GB) 的 disk image</span></span><br><span class="line"><span class="comment"># disk image 檔名為 centos7.qcow2，格式為 qcow2，大小為 20GB</span></span><br><span class="line">$ qemu-img create -f qcow2 centos7.img 10G</span><br><span class="line">Formatting <span class="string">'centos7.img'</span>, fmt=qcow2 size=10737418240 encryption=off cluster_size=65536 lazy_refcounts=off</span><br><span class="line">$ qemu-img create -f qcow2 -o backing_file=centos7.img,size=20G centos7.qcow2</span><br><span class="line">Formatting <span class="string">'centos7.qcow2'</span>, fmt=qcow2 size=21474836480 backing_file=<span class="string">'centos7.img'</span> encryption=off cluster_size=65536 lazy_refcounts=off</span><br></pre></td></tr></table></figure><ul><li><code>check [-f fmt] filename</code>：對 disk image 進行一致性 &amp; 錯誤的檢查，但目前只有支援 qcow2 / qed / vdi 等格式；若不加上 <code>[-f fmt]</code> 參數則會自動偵測格式</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ qemu-img check centos7.qcow2</span><br><span class="line">No errors were found on the image.</span><br><span class="line">Image end offset: 262144</span><br></pre></td></tr></table></figure><ul><li><p><code>commit [-f fmt] filename</code>：將指定 disk image 的修改 commit 到 backing file 中(例如上面範例中，把 centos7.qcow2 的修改 commit 回 centos7.img 中)</p></li><li><p><code>convert [-c] [-f fmt] [-O output_fmt] [-o options] filename [filename2 [...]] output_filename</code>：轉換 disk image 的格式；input file 的格式可自動偵測，但 output file 則需要指定，不指定則預設為 <code>raw</code>；<code>-c</code> 則是指定對 output file 進行壓縮，但只支援 qcow &amp; qcow2 格式的檔案；<code>-o options</code> 用來指定各種選項，例如 backing file，檔案大小、是否加密…等，附帶一提，使用 backing file 可以使產生的檔案變成 copy-on-write 的增量檔案</p></li></ul><blockquote><p>若是由 raw 轉成 qcow2，一般來說檔案還會有瘦身的效果</p></blockquote><ul><li><code>info [-f fmt] filename</code>：顯示 disk image 的詳細資訊</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ qemu-img info /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">image: /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">file format: raw</span><br><span class="line">virtual size: 8.0G (8589934592 bytes)</span><br><span class="line">disk size: 8.0G</span><br><span class="line"></span><br><span class="line">$  qemu-img info centos7.qcow2</span><br><span class="line">image: centos7.qcow2</span><br><span class="line">file format: qcow2</span><br><span class="line">virtual size: 20G (21474836480 bytes)</span><br><span class="line">disk size: 196K</span><br><span class="line">cluster_size: 65536</span><br><span class="line">backing file: centos7.img</span><br><span class="line">Format specific information:</span><br><span class="line">    compat: 1.1</span><br><span class="line">    lazy refcounts: <span class="literal">false</span></span><br></pre></td></tr></table></figure><ul><li><p><code>snapshot [-l | -a snapshot | -c snapshot | -d snapshot] filename</code>：snapshot 的管理，包含查詢 snapshot 列表資訊(<code>-l</code>) / 使用快照作為 disk image(<code>-a snapshot</code>) / 建立 snapshot(<code>-c snapshot</code>) / 刪除 snapshot(<code>-d snapshot</code>)</p></li><li><p><code>resize filename [+ | -]size</code>：改變 disk image 的大小；縮小空間要確保 disk image 有足夠的空間，否則會有資料損毀的風險；qcow2 格式不支援縮小；增加空間後，在 virtual machine 中需要使用 fdisk or parted 才可以使用到增加的空間</p></li></ul><blockquote><p>強烈建議在 resize 之前要做好備份</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@ocp-kvm-host ~]<span class="comment"># qemu-img resize ubuntu1604.qcow2 +1G</span></span><br><span class="line">Image resized.</span><br><span class="line"></span><br><span class="line">[root@ocp-kvm-host ~]<span class="comment"># qemu-img info ubuntu1604.qcow2</span></span><br><span class="line">image: ubuntu1604.qcow2</span><br><span class="line">file format: qcow2</span><br><span class="line">virtual size: 11G (11811160064 bytes)</span><br><span class="line">disk size: 200K</span><br><span class="line">cluster_size: 65536</span><br><span class="line">Format specific information:</span><br><span class="line">    compat: 1.1</span><br><span class="line">    lazy refcounts: <span class="literal">false</span></span><br></pre></td></tr></table></figure><hr><h1 id="Storage-Types"><a href="#Storage-Types" class="headerlink" title="Storage Types"></a>Storage Types</h1><p>在 QEMU/KVM 中，virual machine 的 disk image 其實可以用很多種不同方式來儲存，例如：</p><ol><li><p>Local storage (最常用的方式)</p></li><li><p>physical disk/partition</p></li><li><p>LVM</p></li><li><p>NFS</p></li><li><p>iSCSI</p></li><li><p>在 Local 端 or 透過 Fiber 連接的 LUN</p></li><li><p>GFS2</p></li></ol><blockquote><p>上面的幾個選項中，phtsical partition &amp; LVM 由於無法存放 MBR，因此無法作為 virtual machine 的開機磁碟，只能用來存放資料用。</p></blockquote><p>基本上，以 file-based 的方式管理 disk images 是比較有彈性的，可放在 Local / NFS / iSCSI / LUN / GFS2 … 等，若是 virtual machine 對於 I/O 效能不是非常要求時，選擇 qcow2 則是較為建議的 disk image 格式，其優點如下：</p><ul><li><p>儲存方便 (file-baed)</p></li><li><p>比起其他方式相對容易使用</p></li><li><p>可移動性佳</p></li><li><p>容易複製</p></li><li><p>可透過 sparse 的機制節省硬碟空間(類似 thin provision)</p></li><li><p>可放在透過網路連結的檔案系統中(例如：NFS，可把 backing file 放在 NFS，差異部分放在 local)，因此可以輕鬆達到 live migration 的效果</p></li></ul><p>最後，若需要高效能的 I/O，則可以使用半虛擬化的 <strong><font color="red">virtio</font></strong> 作為 disk image 的 driver。</p><hr><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><p><a href="http://linux.die.net/man/1/qemu-kvm" target="_blank" rel="noopener">qemu-kvm(1): QEMU Emulator User Documentation - Linux man page</a></p></li><li><p><a href="http://wiki.qemu.org/download/qemu-doc.html" target="_blank" rel="noopener">QEMU Emulator User Documentation</a></p></li><li><p><a href="http://benjr.tw/20361" target="_blank" rel="noopener">Cache 的 write back 和 write through – Benjr.tw</a></p></li><li><p><a href="http://www.pcdvd.com.tw/showthread.php?t=285217" target="_blank" rel="noopener">請教Cache運作方式的Write Back與Write Through之分別 - PCDVD數位科技討論區</a></p></li></ul>]]></content>
      
      <categories>
          
          <category> KVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> KVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Linux KVM] Linux KVM concept - Memory</title>
      <link href="/blog/2016/08/01/KVM/KVM-Basic-Concept-Memory/"/>
      <url>/blog/2016/08/01/KVM/KVM-Basic-Concept-Memory/</url>
      <content type="html"><![CDATA[<p>此篇文章介紹學習 Linux KVM 時所需要了解的 Memory 相關知識</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Memory 在作業系統是用來暫時存放 cpu 要執行的指令以及資料，所有 process 都必須先載入到 memory 中才能正確執行。</p><p>而在虛擬化的環境中，virtual machine 中 memory 的使用是需要額外的 mapping 機制對應到 host machine，在這個部分的效率的高低，當然也就會決定 virtual machine 整體的系統性能。</p><hr><h1 id="VM-可以使用多少記憶體"><a href="#VM-可以使用多少記憶體" class="headerlink" title="VM 可以使用多少記憶體?"></a>VM 可以使用多少記憶體?</h1><p>也許這是很多人想要了解的，在 host machine 上安裝了一大堆實體記憶體，究竟可以分配給 VM 的可以有多少呢? 以下有兩個簡單公式可以計算：</p><ol><li><p>實體記憶體 &lt;= 64 GB</p><blockquote><p>RAM - 2 GB = Amount of RAM available to VMs in GBs</p></blockquote></li><li><p>實體記憶體 &gt; 64GB</p><blockquote><p>RAM - (2 GiB + .5* (RAM/64)) = Amount of RAM available to VMs in GBs</p></blockquote></li></ol><p>假設 host machine 記憶體有 32GB，則一共可以配置 <code>32 - 2 = 10</code>GB 的記憶體給 VM。</p><p>假設 host machine 記憶體有 256GB，則一共可以配置 <code>256 - (2 + 0.5 * (256 / 64)) = 252</code>GB 的記憶體給 VM</p><hr><h1 id="配置-VM-記憶體"><a href="#配置-VM-記憶體" class="headerlink" title="配置 VM 記憶體"></a>配置 VM 記憶體</h1><p>幫 virtual machine 配置記憶體是很容易的，只要使用 <strong><font color="red">-m</font></strong> 參數即可，預設的格式是：</p><blockquote><p>-m megs</p></blockquote><p>預設是以 <strong><font color="red">MB</font></strong> 作為預設的單位，也可以使用 <strong><font color="red">G</font></strong> 表示要使用 GB 為單位，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 記憶體大小為 2048 MB</span></span><br><span class="line">$ kvm -vnc 0.0.0.0:1 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line"></span><br><span class="line"><span class="comment"># 記憶體大小為 4 GB</span></span><br><span class="line">$ kvm -vnc 0.0.0.0:1 -m 4G -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br></pre></td></tr></table></figure><hr><h1 id="EPT"><a href="#EPT" class="headerlink" title="EPT"></a>EPT</h1><p>傳統要把 virtual machine 中運行的應用程式所使用的 memory 對應到 host machine 的 memory，一共是有三層關係的，下圖可做個簡單說明：</p><p><img src="http://m.eet.com/media/1200411/CloudFig4a.jpg" alt="VM memory mapping"></p><blockquote><p>Guest Virtual Address(GVA) <--> Guest Physical Address(GPA) <--> Host Physical Address(HPA)</--></--></p></blockquote><p>但由於上面三層的轉換效率是很差的，因此後來透過軟體實作了稱為 <strong><font color="red">Shadow Page Tables</font></strong> 的機制，將三層中的第二層拿掉，直接讓 Guest Virtual Address 與 Host Physical Address 可以有直接對應的機制：</p><p><img src="http://image.slidesharecdn.com/windays-virtualization-090428034228-phpapp01/95/windows-server-virtualization-hyperv-2008-r2-30-728.jpg?cb=1240890219" alt="Shadow Page Tables"></p><p>此時 hypervisor 就可以把 shadow page tables 載入到 MMU(Memory Management Unit) 中進行 address translation 的工作。</p><p>但 shadow page tables 實作起來不僅複雜，也會 memory 的額外消耗(每一個 virtual machine 都需要一個 shadow page table)；因此 Intel 提出了 EPT(Extended Page Tables)，AMD 提出了 NPT(Nested Page Tables)，在硬體層直接提供了 <code>GVA &lt;--&gt; GPA &lt;--&gt; HPA</code> 的轉換，不僅提升了 memory 虛擬化的效能，也降低了 memory 虛擬化的複雜度。</p><p>以下是 Intel EPT 技術的概觀：</p><p><img src="http://virtualization.info/images/EPT-716833.png" alt="Intel EPT"></p><p>其中可以看到 Intel 在硬體中增加了 CR3(Control Registor 3) 來處理 GVA <--> GPA 的轉換，以及 EPT 來處理 GPA <--> HPA 的轉換。</--></--></p><p>由於所有的轉換都在硬體層級完成，因此速度很快；而且由於整個轉換過程只需要一個 EPT Page Table，因此在 memory 的消耗上也相對的低。</p><hr><h1 id="VPID"><a href="#VPID" class="headerlink" title="VPID"></a>VPID</h1><p>要了解 VPID，首先要知道 TLB(Translation Lookaside Buffer) 是什麼? 可以參考以下連結：</p><ul><li><a href="http://www.wikiwand.com/zh-hk/%E8%BD%89%E8%AD%AF%E5%BE%8C%E5%82%99%E7%B7%A9%E8%A1%9D%E5%8D%80" target="_blank" rel="noopener">TLB 轉譯後備緩衝區 - Wikiwand</a></li></ul><blockquote><p>分配給 virtual machine 的每一個 vCPU 都會有一個 TLB</p></blockquote><p>而 VPID 則是在硬體層級對 TLB 資源管理的優化，在 virtual machine 進行 migration / VM Entry / VM Exit 時，避免對 TLB 進行轉存 &amp; 清除，進而降低 memory 的額外消耗，對於 live migration 有顯著的效能提升。</p><hr><h1 id="查詢-EPT-amp-VPID-的支援度"><a href="#查詢-EPT-amp-VPID-的支援度" class="headerlink" title="查詢 EPT &amp; VPID 的支援度"></a>查詢 EPT &amp; VPID 的支援度</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查詢 CPU 是否支援 EPT &amp; VPID</span></span><br><span class="line">$  grep -E <span class="string">"\sept\s|\svpid\s"</span> /proc/cpuinfo | uniq</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢 kvm_intel 模組是否有開啟 EPT &amp; VPID 的功能</span></span><br><span class="line">$ cat /sys/module/kvm_intel/parameters/ept</span><br><span class="line">Y</span><br><span class="line">$ cat /sys/module/kvm_intel/parameters/vpid</span><br><span class="line">Y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 開啟 kvm_intel 模組 EPT &amp; VPID 的功能</span></span><br><span class="line">$ modprobe kvm_intel ept=1,vpid=1</span><br></pre></td></tr></table></figure><hr><h1 id="Huge-Page"><a href="#Huge-Page" class="headerlink" title="Huge Page"></a>Huge Page</h1><p>x86 架構的 CPU 預設的 memory page table 大小為 4KB，而 x86-64 則可以支援到 2MB 大小的 memory page table(亦稱為 <strong><font color="red">Huge Page</font></strong>)，在 Linux 2.6 以上的 kernel 都支援這個特性。</p><p>而使用 Huge Page 有何優缺點呢?</p><h3 id="優點："><a href="#優點：" class="headerlink" title="優點："></a>優點：</h3><ul><li><p>page table 數量減少，更節省 memory</p></li><li><p>由於 memory address translation 的工作減少了，因此 page fault 機率降低為 <strong><font color="red">Huge Page Size / 4KB</font></strong> 分之一</p></li><li><p>提升了 memory 存取的效能</p></li><li><p>提高 TLB 命中率，因而減少 CPU cache 的使用，最後提升了系統整體效能</p></li><li><p>適合用在 memory 存取密集的 virtual machine 上</p></li></ul><h3 id="缺點："><a href="#缺點：" class="headerlink" title="缺點："></a>缺點：</h3><ul><li><p>Huge Page 無法被 swap out 到硬碟上</p></li><li><p>無法使用 Ballooning 的方式自動增長</p></li><li><p>並非適合所有不同工作類型的 virtual machine</p></li></ul><h2 id="在-KVM-中使用-Huge-Page"><a href="#在-KVM-中使用-Huge-Page" class="headerlink" title="在 KVM 中使用 Huge Page"></a>在 KVM 中使用 Huge Page</h2><h3 id="1、檢查-host-machine-中-Huge-Page-的設定資訊："><a href="#1、檢查-host-machine-中-Huge-Page-的設定資訊：" class="headerlink" title="1、檢查 host machine 中 Huge Page 的設定資訊："></a>1、檢查 host machine 中 Huge Page 的設定資訊：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 目前預設的 page size</span></span><br><span class="line">$ getconf PAGESIZE</span><br><span class="line">4096</span><br><span class="line"></span><br><span class="line"><span class="comment"># 記憶體資訊中 Huge Page 的相關資訊 (size = 2048 KB)</span></span><br><span class="line">$ cat /proc/meminfo | grep Huge</span><br><span class="line">AnonHugePages:     14336 kB</span><br><span class="line">HugePages_Total:       0</span><br><span class="line">HugePages_Free:        0</span><br><span class="line">HugePages_Rsvd:        0</span><br><span class="line">HugePages_Surp:        0</span><br><span class="line">Hugepagesize:       2048 kB</span><br></pre></td></tr></table></figure><h3 id="2、掛載-hugetlbfs-檔案系統"><a href="#2、掛載-hugetlbfs-檔案系統" class="headerlink" title="2、掛載 hugetlbfs 檔案系統"></a>2、掛載 hugetlbfs 檔案系統</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 掛載 hugetlbfs 檔案系統</span></span><br><span class="line">$ mount -t hugetlbfs hugetlbfs /dev/hugepages</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢檔案系統資訊</span></span><br><span class="line">$ mount | grep huge</span><br><span class="line">cgroup on /sys/fs/cgroup/hugetlb <span class="built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)</span><br><span class="line">hugetlbfs on /dev/hugepages <span class="built_in">type</span> hugetlbfs (rw,relatime,seclabel)</span><br><span class="line">hugetlbfs on /dev/hugepages <span class="built_in">type</span> hugetlbfs (rw,relatime,seclabel)</span><br></pre></td></tr></table></figure><h3 id="3、設定-Huge-Page-的數量"><a href="#3、設定-Huge-Page-的數量" class="headerlink" title="3、設定 Huge Page 的數量"></a>3、設定 Huge Page 的數量</h3><p>假設要啟動一個 memory 為 2048 MB 的 virtual machine，可以算出 Huge Page(2048 KB) 的數量為：</p><blockquote><p>2048 * 1024 / 2048 = 1024</p></blockquote><p>因此這邊設定 Huge Page 的數量為 1024 個：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 設定 Huge Page 的數量為 1024 個</span></span><br><span class="line">$ sysctl vm.nr_hugepages=1024</span><br><span class="line">vm.nr_hugepages = 1024</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此時 host machine 中的記憶體資訊已經有 Huge Page 的數量資訊</span></span><br><span class="line">$ cat /proc/meminfo | grep Huge</span><br><span class="line">AnonHugePages:     14336 kB</span><br><span class="line">HugePages_Total:    1024</span><br><span class="line">HugePages_Free:     1024</span><br><span class="line">HugePages_Rsvd:        0</span><br><span class="line">HugePages_Surp:        0</span><br><span class="line">Hugepagesize:       2048 kB</span><br></pre></td></tr></table></figure><h3 id="4、啟動-virtual-machine-使用-Huge-Page"><a href="#4、啟動-virtual-machine-使用-Huge-Page" class="headerlink" title="4、啟動 virtual machine 使用 Huge Page"></a>4、啟動 virtual machine 使用 Huge Page</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ kvm -vnc 0.0.0.0:1 -smp 4 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img -mem-path /dev/hugepages</span><br><span class="line"></span><br><span class="line">$ cat /proc/meminfo | grep Huge</span><br><span class="line">AnonHugePages:     26624 kB</span><br><span class="line">HugePages_Total:    1024</span><br><span class="line">HugePages_Free:      738</span><br><span class="line">HugePages_Rsvd:      738</span><br><span class="line">HugePages_Surp:        0</span><br><span class="line">Hugepagesize:       2048 kB</span><br></pre></td></tr></table></figure><p>可以看出 virtual machine 的確消耗了一些 huge page，但其實並不是全部，因為 virtual machine 實際上並沒有完整分配到 2048 MB 的 memory；若要完整分配指定的 memory，則需要加上 <code>-mem-prealloc</code> 參數。</p><hr><h1 id="Memory-Overcommit"><a href="#Memory-Overcommit" class="headerlink" title="Memory Overcommit"></a>Memory Overcommit</h1><p>除了之前介紹 CPU 可以 overcommit 之外，memory 也可以設定一定程度的 overcommit，原因是因為每台電腦在運作時一般都不會耗盡記憶體。對 host machine 來說，virtual machine 也只是一個 QEMU process，在啟動的當下是不會分配完整記憶體的，而是隨著 virtual machine 的更多要求下逐步分配到位，因此可以在此行為的前提下設定 memory overcommit。</p><p>在 KVM 中有三種方式可以達到 memory overcommit：</p><ol><li><p><strong><font color="red">Swapping</font></strong>：透過 system swap(一般為硬碟空間) 來彌補 memory 不足的問題</p></li><li><p><strong><font color="red">Ballooning</font></strong>：透過 <code>virtio_balloon</code> driver 來達成</p></li><li><p><strong><font color="red">Page Sharing</font></strong>：使用 <code>KSM(Kernel Samepage Merging)</code> 合併多台 virtual machine 中相同的 memory page</p></li></ol><p>關於第一個方式的 swap，根據 <a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Storage_Administration_Guide/ch-swapspace.html#tb-recommended-system-swap-space" target="_blank" rel="noopener">RedHat RHEL 7 官方文件</a>所提供的建議，swap 大小的設定建議如下：</p><table><thead><tr><th>系統記憶體</th><th>建議 swap 大小</th></tr></thead><tbody><tr><td>⩽ 2 GB</td><td>2 x memory size</td></tr><tr><td>&gt; 2 GB – 8 GB</td><td>等同 memory size</td></tr><tr><td>&gt; 8 GB – 64 GB</td><td>至少 4 GB</td></tr><tr><td>&gt; 64 GB</td><td>至少 4 GB</td></tr></tbody></table><hr><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><p><a href="http://linux.die.net/man/1/qemu-kvm" target="_blank" rel="noopener">qemu-kvm(1): QEMU Emulator User Documentation - Linux man page</a></p></li><li><p><a href="http://www.gegugu.com/2016/03/22/9088.html" target="_blank" rel="noopener">精品：KVM學習筆記 : 歌穀穀</a></p></li><li><p><a href="http://tc.wangchao.net.cn/it/detail_128378.html" target="_blank" rel="noopener">Huge Page 是否是拯救性能的萬能良藥？ - 王朝網路 - wangchao.net.cn</a></p></li><li><p><a href="http://brandon-hy-lin.blogspot.tw/2016/04/compound-page-huge-page-transparent.html" target="_blank" rel="noopener">隨意寫寫: Compound Page, Huge Page, 和Transparent Huge Page(THP)</a></p></li><li><p><a href="http://jaychu649.blogspot.tw/2014/09/linux-huge-memory-greater-then-hundred.html" target="_blank" rel="noopener">IT 研究室 ( 前IT DBA’s 資訊站): 如何在Linux 使用大記憶體(huge memory greater then hundred of GB)</a></p></li><li><p><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Storage_Administration_Guide/ch-swapspace.html#tb-recommended-system-swap-space" target="_blank" rel="noopener">RedHat RHEL 7 Support &gt; Product Documentation &gt; Storage &gt; Administration Guide</a></p></li></ul>]]></content>
      
      <categories>
          
          <category> KVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> KVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Linux KVM] Linux KVM concept - CPU</title>
      <link href="/blog/2016/07/30/KVM/KVM-Basic-Concept-CPU/"/>
      <url>/blog/2016/07/30/KVM/KVM-Basic-Concept-CPU/</url>
      <content type="html"><![CDATA[<p>此篇文章介紹學習 Linux KVM 時所需要了解的 CPU 相關知識</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>KVM 在 Linux x86 硬體平台上提供了全虛擬化(Full Virtualization)的 solution，透過 QEMU 的模擬，顯示特定數量的 CPU &amp; 相關 feature 給使用者，而在支援 KVM 的前提下，virtual machine 的 CPU 指令則是直接由 CPU 來輔助執行，藉此大幅提升運作效率。</p><hr><h1 id="vCPU"><a href="#vCPU" class="headerlink" title="vCPU"></a>vCPU</h1><p>QEMU/KVM 提供每一台 virtual machine 有一個模擬的完整硬體環境，在 virual machine 中所看到的 CPU，即是 host machine 上的 vCPU。</p><p>在 KVM 環境中，每一台 virtual machine 都是一個的 QEMU userspace process，而 vCPU 則是 QEMU process 中的 thread。</p><p><img src="http://image.slidesharecdn.com/els305-100323102407-phpapp02/95/virtualization-with-kvm-kernelbased-virtual-machine-4-728.jpg" alt="KVM environment"></p><p>vCPU 一共有以下三種執行模式：</p><ol><li><p>User Mode</p></li><li><p>Kernel Mode</p></li><li><p>Guest Mode</p></li></ol><p>其中前兩個執行模式(<strong>User Mode</strong> &amp; <strong>Kernel Mode</strong>)是一般的 process 所擁有的執行模式，詳細的說明可以參考下面連結：</p><ul><li><p><a href="https://www.ptt.cc/bbs/b97902HW/M.1267018497.A.3B1.html" target="_blank" rel="noopener">[系程] 教學: 簡介 Kernel/User Mode 的概念 - 看板 b97902HW - 批踢踢實業坊</a></p></li><li><p><a href="http://peachwaneversay.blogspot.tw/2007/05/user-mode-vs-kernel-mode.html" target="_blank" rel="noopener">企鵝幫魚，魚幫兔: User mode vs. Kernel mode</a></p></li></ul><p>而 KVM 多了一個 <strong>Guest Mode</strong>，功能是用來<strong>執行關於 virtual machine 中的相關 I/O request</strong>，無法直接；所有 Memory &amp; CPU 的 I/O request，會透過 <strong>/dev/kvm(QUME)</strong> 來模擬完成，並可透過 QEMU 執行一些特權指令來存取 host machine 的資源。</p><p><img src="http://benjr.tw/wp-content/uploads/2013/11/kvm_qemu01.png" alt="KVM Guest Mode"></p><hr><h1 id="SMP-Symmetric-Multi-Processor"><a href="#SMP-Symmetric-Multi-Processor" class="headerlink" title="SMP(Symmetric Multi-Processor)"></a>SMP(Symmetric Multi-Processor)</h1><p>由於現在 multiple core、hyper threading 等相關技術已經很普遍，這讓作業系統可以進行真正的平行處理；而現在較新的作業系統都已經有對 SMP 的支援(Linux kernel 2.6 以上)，這對虛擬化的推展有相當大的助益。</p><p>透過以下指令，可以用來檢查目前 host machine 對 SMP 的支援程度：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查詢 logic cpu 數量</span></span><br><span class="line">$ cat /proc/cpuinfo | grep <span class="string">"processor"</span> | wc -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 實體 CPU 數量</span></span><br><span class="line">$ cat /proc/cpuinfo | grep <span class="string">"physical id"</span> | sort | uniq | wc -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每個 CPU 上的 core 數量</span></span><br><span class="line">$ cat /proc/cpuinfo | grep <span class="string">"core id"</span> | sort | uniq | wc -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每個 physical cpu 上分配的 logic cpu 的數量</span></span><br><span class="line">$ cat /proc/cpuinfo | grep <span class="string">"siblings"</span> | sort | uniq | awk -F: <span class="string">'&#123;print $2&#125;'</span></span><br></pre></td></tr></table></figure><p>以上一篇文章中的範例來說明：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kvm -smp 4 -m 2048 \</span><br><span class="line">  -vnc 0.0.0.0:5 -boot order=<span class="built_in">cd</span> \</span><br><span class="line">  -hda /kvm/storage/vm_disks/ubnutu1604.img \</span><br><span class="line">  -cdrom /kvm/os_images/ubuntu-16.04.1-server-amd64.iso</span><br></pre></td></tr></table></figure><p>其中 <code>-smp</code> 參數就是指定要使用多少的 vCPU 支援，完整的使用設定如下：(上例為使用 4 個 vCPU)</p><blockquote><p>-smp n[,<strong>cores=</strong>cores][,<strong>threads=</strong>threads][,<strong>sockets=</strong>sockets][,<strong>maxcpus=</strong>maxcpus]</p></blockquote><h2 id="範例-1-僅使用-smp"><a href="#範例-1-僅使用-smp" class="headerlink" title="範例 1 (僅使用 -smp)"></a>範例 1 (僅使用 -smp)</h2><p>而在 Linux 系統中，每一個 vCPU 的分配都會成為一個 process 運行在 host machine 中，以下開啟一個 vCPU=8 的 virtual machine：</p><blockquote><p>kvm -vnc 0.0.0.0:1 -smp 8 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</p></blockquote><p>可以從 QEMU monitor 中觀察 vCPU 對應到 kvm 的 process：</p><p><img src="https://lh3.googleusercontent.com/hHP9T9hWydFXixyMUCuCVFDkl7hlZ6Yv_lbljFDdv_azyt_rh01M6X8bHI1fRMV82a2UObBH6wQgAElavdVxByZ99u0cDBToT-t9OIqgWpSY6ZGreqooEuin8WvQqXpQ9g84uwed3-qO2akJatJTCJqpY0Xt_xU9J1ak4702nyJicXQ7h6HqppYXz0G_86NhyQMd6tv2w5venHGgaBoOF46L8UcYYTskX5rPptWqlmhJtNQSkFGj8F6t3DVVGpOJQfgErjdrfFm162spjhQGwZJ6OWiKTsdBAuXbeUscC-NUTPtGbVjSvAHXa-MVo3-h6jjWZ-TlNkjSmQYCICiRiTGIcFsLAkbIVMGw7-PXkPdqXhJyaC9bEWplxhPzhgGptGUeJCAOrdIhvF_l8lXzaSqeWGL-BSnBbA5qCuV-9UUZVGrcHgiQo2p5_Q_iUBBazlkqnRuM69ULxGEeM-q82gIztEmQiqqOrynKeAf9w5MZnJeb_w29u6qu6B-6d81hRGXwc68A1YHKH256EWxgtrd7_aVfsu08fLEIsPwo5qEuDnkef9G_hGNUHccLcWMSIOIr4J1ViP1vOrDsLpAA_qW-08QfZ4Q=w463-h210-no" alt="QEMU monitor - cpu infos"></p><p>以下則可以看出在 host machine 有相對應的 process 存在：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ps -efL | grep kvm</span><br><span class="line">root      1122     2  1122  0    1 Jul27 ?        00:00:00 [kvm-irqfd-clean]</span><br><span class="line">root     14606 11601 14606  3   11 17:46 pts/0    00:00:02 kvm -vnc 0.0.0.0:1 -smp 8 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">root     14606 11601 14610 10   11 17:46 pts/0    00:00:06 kvm -vnc 0.0.0.0:1 -smp 8 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">root     14606 11601 14611  2   11 17:46 pts/0    00:00:01 kvm -vnc 0.0.0.0:1 -smp 8 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">root     14606 11601 14612  1   11 17:46 pts/0    00:00:01 kvm -vnc 0.0.0.0:1 -smp 8 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">root     14606 11601 14613  1   11 17:46 pts/0    00:00:00 kvm -vnc 0.0.0.0:1 -smp 8 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">root     14606 11601 14614  1   11 17:46 pts/0    00:00:00 kvm -vnc 0.0.0.0:1 -smp 8 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">root     14606 11601 14615  1   11 17:46 pts/0    00:00:00 kvm -vnc 0.0.0.0:1 -smp 8 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">root     14606 11601 14616  1   11 17:46 pts/0    00:00:00 kvm -vnc 0.0.0.0:1 -smp 8 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">root     14606 11601 14617  1   11 17:46 pts/0    00:00:01 kvm -vnc 0.0.0.0:1 -smp 8 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">root     14606 11601 14619  1   11 17:46 pts/0    00:00:00 kvm -vnc 0.0.0.0:1 -smp 8 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">root     14606 11601 14631  0   11 17:46 pts/0    00:00:00 kvm -vnc 0.0.0.0:1 -smp 8 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br><span class="line">root     14618     2 14618  0    1 17:46 ?        00:00:00 [kvm-pit/14606]</span><br><span class="line">root     14633 12908 14633  0    1 17:47 pts/1    00:00:00 grep --color=auto kvm</span><br></pre></td></tr></table></figure><p>最後可以用上面的 grep 查詢 physical / cores / threads 等資訊：</p><p><img src="https://lh3.googleusercontent.com/mD_mnwyxWHinCr-2GSCfaMs-kyhi7p5c9cspDW5go_wM_76oHUj0Phj4n5dAahx39fazYXbMYa5xknxe1oRcoErP0cG84fMRu0WRwm9A1-_p4_bH0XediFmabBPzQQ6omUqJeBgJkwuyj0YRQ8-5kQ6zrE6elocc5sAt4q4tVKOXISDO0CZzSiYU9jHr6HeQVWO4xyLcBBkEUTZEeCfeR_tIrJzZF23nMGWDLI9CSu84ADbuL6KilIp4zDwQPNGrZmxNEwi2kUWyKcxC9-iZBm1W3wNdDYdIESmnVkTQuMe19XnTYsGdPiyRiOtMYv01WQ_KmBoCdRRZ1vfn0syyYdkt9PagLY3TjJ75dt57p918PI4z04YUZomaZ0lZ6Pqb8bt1Iaz1oljrslZpyveJ2AtAGWIdO9hFvE_9r3uvzK-ND77ZL1nAMbvuBPcD3rxuAGGr9ZqZTH_RACGOKtUN44cffI9VMvDp261xOj2NvYUDAVKxLogUNUj_ltOSyLGZ3uSffQtBkybY8OBAR3o3ycSsVy6Riwk8x2n6buCDR05dA4oTlaUqmR_o39TyTKsF6c1hzgoiJN9d_tc4cLS2c1PINXUh7W8=w785-h194-no" alt="SMP only"></p><ul><li>logic cpu = 8</li><li>physical cpu = 8</li><li>每個 CPU 上的 core 數量 = 1</li><li>每個 physical cpu 上分配的 logic cpu 的數量 = 1</li></ul><h2 id="範例-2-使用-smp，搭配-sockets-2-cores-2-threads-2"><a href="#範例-2-使用-smp，搭配-sockets-2-cores-2-threads-2" class="headerlink" title="範例 2 (使用 -smp，搭配 sockets=2,cores=2,threads=2)"></a>範例 2 (使用 -smp，搭配 sockets=2,cores=2,threads=2)</h2><p>此範例搭配 socket, cores, threads 等 smp 相關參數</p><blockquote><p> kvm -vnc 0.0.0.0:1 -smp 8,sockets=2,cores=2,threads=2 -m 2048 -hda /kvm/storage/vm_disks/ubnutu1604.img</p></blockquote><p>用 grep 查詢 physical / cores / threads 等資訊：</p><p><img src="https://lh3.googleusercontent.com/JmmR_lsIlsIsr66SlLZXaBJfVKdo6gim3rLxj7oMrVrTbDEYnluhtz-uj5FdlYwUAN4_W-FZDL2a6ykDgFBdwIlYNVrorpLPc7olTSl7oOsHlEoUVT1U9o9yDroSYZFNEGoJVJaMcKoIrtRr9HKB7R9uKrz5VNLR6iX_n2OZs5gL_UxPrxL5UOeYeqyyuZwswNDTyqh61qmqlJ2i0KBAHkSauTcUbASZScuk1rCL_wlp0B0VguRIhd2WZtq2oEe_G9nL6zRMclrXsOqhWsVBy0DyBibyGtqsUPIG7-7rYHcSGs1ao8j_fuTELJVA0P4nWoPpAX5sRI9p84M32vGuppudVSkFDdzACIo43FdB6ZkFftc4sPfRLk-qLXldYJ5ss_waqmqcIA2Qr-be1M443d0QiqYV6BF4XkIn6cKud7gCzy15I30CdM31gVZwK7rkQ6O_eWSCLYhiQoBR1y-B9jXV5qnN7axQfTC8hL46gRlQSyozEG4HXp-X2UmU12rfMWv8rZop2alI6pLa29CE5oywHl40BYI8qKgok52V0znrX1klcmgiCn5iYYdEFPYELqHwDW_EQv0-Z8oAXxmyIpk8tKnSR0E=w777-h190-no" alt="SMP with sockets, cores, and threads"></p><ul><li>logic cpu = 8</li><li>physical cpu = 2</li><li>每個 CPU 上的 core 數量 = 2</li><li>每個 physical cpu 上分配的 logic cpu 的數量 = 4</li></ul><hr><h1 id="Over-Commit"><a href="#Over-Commit" class="headerlink" title="Over-Commit"></a>Over-Commit</h1><p>一般正常使用情況下，每一台 virtual machine 不會總是在高負載狀況，很多時間會是閒置的；此時透過 over-commit 的方式，可以分配比 host machine 中所有的 vCPU 給 virtual machine。</p><p>但不建議分配給單一 virtual machine 超過 host machine 所有 vCPU 的數量，因為這會大大降低 virtual machine 的效能，例如：host machine 總共有 4 個 vCPU，但分配 8 個 vCPU 給 virtual machine。</p><p>若是 4 個 vCPU，分配 1 個 vCPU 給 virtual machine，但分配到 8 台 virtual machine，這樣的效能會比上面的配置更有效率。</p><blockquote><p>若是在 production 的環境，建議還是不要 over-commit</p></blockquote><hr><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><p><a href="http://linux.die.net/man/1/qemu-kvm" target="_blank" rel="noopener">qemu-kvm(1): QEMU Emulator User Documentation - Linux man page</a></p></li><li><p><a href="https://ncucsie.hackpad.com/ep/pad/static/QrwxkWD88gd" target="_blank" rel="noopener">虛擬化技術與應用</a></p></li><li><p><a href="https://www.ptt.cc/bbs/b97902HW/M.1267018497.A.3B1.html" target="_blank" rel="noopener">[系程] 教學: 簡介 Kernel/User Mode 的概念 - 看板 b97902HW - 批踢踢實業坊</a></p></li><li><p><a href="http://peachwaneversay.blogspot.tw/2007/05/user-mode-vs-kernel-mode.html" target="_blank" rel="noopener">企鵝幫魚，魚幫兔: User mode vs. Kernel mode</a></p></li></ul>]]></content>
      
      <categories>
          
          <category> KVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> KVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Linux KVM] 使用 Linux KVM 啟用第一個 virtual machine</title>
      <link href="/blog/2016/07/26/KVM/QEMU-KVM-In-CentOS7-GettingStart/"/>
      <url>/blog/2016/07/26/KVM/QEMU-KVM-In-CentOS7-GettingStart/</url>
      <content type="html"><![CDATA[<p>介紹如何使用 QEMU/KVM 在 Linux 上啟用第一個 virtual machine</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="KVM"><a href="#KVM" class="headerlink" title="KVM"></a>KVM</h2><p>KVM 屬於全虛擬化(Full Virtualization) 的技術，因此在上面運行的 OS 不需要經過任何修改。</p><p>原本因為 Full Virtualization 效能應該是很差的，但因為硬體虛擬化的支援(例如：<a href="http://stenlyho.blogspot.tw/2009/01/vt-xvt-d-intel.html" target="_blank" rel="noopener">Intel VT-d</a>，因此大幅提升了 KVM 的效能；此外 KVM 與 QEMU(負責周邊設備的模擬) 的搭配，提供了使用者在 CPU、Memory、Storage、Network、Display 上都有完全相同的虛擬化體驗。</p><h2 id="Linux-kernel"><a href="#Linux-kernel" class="headerlink" title="Linux kernel"></a>Linux kernel</h2><p>關於 Linux kernel 上，建議使用目前較新的 kernel，在以下的環境中，會選用安裝 CentOS 7 作為 host machine，搭配 3.10 版的 Linux kernel 做為測試環境之用。</p><h2 id="環境說明"><a href="#環境說明" class="headerlink" title="環境說明"></a>環境說明</h2><h3 id="硬體"><a href="#硬體" class="headerlink" title="硬體"></a>硬體</h3><p>CPU：Intel(R) Xeon(R) CPU E5-2660 v3 @ 2.60GHz</p><h3 id="軟體"><a href="#軟體" class="headerlink" title="軟體"></a>軟體</h3><ul><li><p>OS: CentOS 7</p></li><li><p>Linux Kernel: 3.10</p></li><li><p>qemu-kvm: 1.5.3 (預設開啟 KVM 加速)</p></li><li><p>qemu-img: 1.5.3</p></li></ul><hr><h1 id="前置環境設定"><a href="#前置環境設定" class="headerlink" title="前置環境設定"></a>前置環境設定</h1><h2 id="安裝套件"><a href="#安裝套件" class="headerlink" title="安裝套件"></a>安裝套件</h2><p>首先要安裝 KVM、QEMU、libvirtd 相關套件 &amp; 啟動 libvirtd service：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># KVM v2.3 需要使用此 repository</span></span><br><span class="line">$ bash -c <span class="string">"echo '[kvm-common]</span></span><br><span class="line"><span class="string">name=Latest KVM rpms</span></span><br><span class="line"><span class="string">baseurl=http://mirror.centos.org/centos-7/7/virt/x86_64/kvm-common/</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=0' &gt; /etc/yum.repos.d/kvm.repo"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安裝 KVM 1.5</span></span><br><span class="line">$ yum install -y qemu-kvm \</span><br><span class="line">    qemu-img \</span><br><span class="line">    qemu-system-x86 \</span><br><span class="line">    libvirt \</span><br><span class="line">    virt-install \</span><br><span class="line">    libvirt-python \</span><br><span class="line">    virt-manager \</span><br><span class="line">    python-virtinst \</span><br><span class="line">    libvirt-client \</span><br><span class="line">    bridge-utils \</span><br><span class="line">    net-tools \</span><br><span class="line">    libguestfs-tools-c \</span><br><span class="line">    iptables-services</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可使用 groupinstall 來批次安裝</span></span><br><span class="line">$ yum groupinstall <span class="string">"virtualization"</span> -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若要安裝 KVM 2.3 可使用下面指令</span></span><br><span class="line">$ yum install -y qemu-kvm-ev \</span><br><span class="line">    qemu-img-ev \</span><br><span class="line">    qemu-system-x86 \</span><br><span class="line">    libvirt \</span><br><span class="line">    virt-install \</span><br><span class="line">    libvirt-python \</span><br><span class="line">    virt-manager \</span><br><span class="line">    python-virtinst \</span><br><span class="line">    libvirt-client \</span><br><span class="line">    bridge-utils \</span><br><span class="line">    net-tools \</span><br><span class="line">    libguestfs-tools-c \</span><br><span class="line">    iptables-services</span><br></pre></td></tr></table></figure><p>也可以順便設定 <a href="http://www.linux-kvm.org/images/3/33/02x03-NestedVirtualization.pdf" target="_blank" rel="noopener">nested virtualization</a>，可以在虛擬環境中再虛擬一層而不會有太多的 performance lose：(此步驟可以略過)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 目前 nested virtualization 是關閉的 </span></span><br><span class="line">$ cat /sys/module/kvm_intel/parameters/nested</span><br><span class="line">N</span><br><span class="line"></span><br><span class="line"><span class="comment"># 開啟 nested virtualization</span></span><br><span class="line">$ sudo rmmod kvm-intel</span><br><span class="line">$ sudo sh -c <span class="string">"echo 'options kvm-intel nested=y' &gt;&gt; /etc/modprobe.d/dist.conf"</span></span><br><span class="line">$ sudo modprobe kvm-intel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 開啟 nested virtualization 成功</span></span><br><span class="line">$ cat /sys/module/kvm_intel/parameters/nested</span><br><span class="line">Y</span><br></pre></td></tr></table></figure><h2 id="防火牆設定"><a href="#防火牆設定" class="headerlink" title="防火牆設定"></a>防火牆設定</h2><p>停用預設的 <strong>firewalld.service</strong>，並啟用 <strong>iptables.service</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 關閉 firewalld</span></span><br><span class="line">$ systemctl stop firewalld.service</span><br><span class="line">$ systemctl <span class="built_in">disable</span> firewalld.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 啟用 iptables</span></span><br><span class="line">$ systemctl stop iptables.service</span><br><span class="line">$ systemctl <span class="built_in">disable</span> iptables.service</span><br></pre></td></tr></table></figure><p>改用傳統的 itpables 來進行防火牆設定，並使用以下 script 建立防火牆：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># global variables</span></span><br><span class="line">IIF=<span class="string">"ens1f0"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 防止 sync flooding 攻擊(開啟 tcp sync cookie)</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/tcp_syncookies</span><br><span class="line"></span><br><span class="line">iptables -t filter -F</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定 connection track</span></span><br><span class="line">iptables -t filter -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br><span class="line"><span class="comment"># 避免 INVALID 封包被其他服務所接收</span></span><br><span class="line">iptables -t filter -A INPUT -m state --state INVALID -j DROP</span><br><span class="line"></span><br><span class="line">iptables -t filter -A INPUT -p tcp --dport 22 -j ACCEPT</span><br><span class="line"><span class="comment"># 提供 vnc access</span></span><br><span class="line">iptables -t filter -A INPUT -p tcp --dport 5900:5910 -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用來取代 chain default policy</span></span><br><span class="line">iptables -t filter -A INPUT -i <span class="variable">$&#123;IIF&#125;</span> -j DROP</span><br></pre></td></tr></table></figure><blockquote><p>上面的套件安裝 &amp; 防火牆設定完成後，要將 KVM host 重新開啟，並啟動 <strong><font color="red">libvirtd.service</font></strong></p></blockquote><hr><h1 id="驗證環境"><a href="#驗證環境" class="headerlink" title="驗證環境"></a>驗證環境</h1><p>安裝好 QEMU/KVM 相關套件後，我們可以來檢查目前的環境是否可以正確的運行虛擬化功能：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ virt-host-validate</span><br><span class="line">  QEMU: Checking <span class="keyword">for</span> hardware virtualization                                 : PASS</span><br><span class="line">  QEMU: Checking <span class="keyword">for</span> device /dev/kvm                                         : PASS</span><br><span class="line">  QEMU: Checking <span class="keyword">for</span> device /dev/vhost-net                                   : PASS</span><br><span class="line">  QEMU: Checking <span class="keyword">for</span> device /dev/net/tun                                     : PASS</span><br><span class="line">   LXC: Checking <span class="keyword">for</span> Linux &gt;= 2.6.26                                         : PASS</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">$ virsh nodeinfo</span><br><span class="line">CPU model:           x86_64</span><br><span class="line">CPU(s):              48</span><br><span class="line">CPU frequency:       1200 MHz</span><br><span class="line">CPU socket(s):       1</span><br><span class="line">Core(s) per socket:  12</span><br><span class="line">Thread(s) per core:  2</span><br><span class="line">NUMA cell(s):        2</span><br><span class="line">Memory size:         263930636 KiB</span><br><span class="line"></span><br><span class="line">$ virsh domcapabilities</span><br><span class="line">&lt;domainCapabilities&gt;</span><br><span class="line">  &lt;path&gt;/usr/bin/qemu-system-x86_64&lt;/path&gt;</span><br><span class="line">  &lt;domain&gt;qemu&lt;/domain&gt;</span><br><span class="line">  &lt;machine&gt;pc-i440fx-2.0&lt;/machine&gt;</span><br><span class="line">  &lt;arch&gt;x86_64&lt;/arch&gt;</span><br><span class="line">  &lt;vcpu max=<span class="string">'255'</span>/&gt;</span><br><span class="line">  &lt;os supported=<span class="string">'yes'</span>&gt;</span><br><span class="line">    &lt;loader supported=<span class="string">'yes'</span>&gt;</span><br><span class="line">      &lt;enum name=<span class="string">'type'</span>&gt;</span><br><span class="line">        &lt;value&gt;rom&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;pflash&lt;/value&gt;</span><br><span class="line">      &lt;/enum&gt;</span><br><span class="line">      &lt;enum name=<span class="string">'readonly'</span>&gt;</span><br><span class="line">        &lt;value&gt;yes&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;no&lt;/value&gt;</span><br><span class="line">      &lt;/enum&gt;</span><br><span class="line">    &lt;/loader&gt;</span><br><span class="line">  &lt;/os&gt;</span><br><span class="line">  &lt;devices&gt;</span><br><span class="line">    &lt;disk supported=<span class="string">'yes'</span>&gt;</span><br><span class="line">      &lt;enum name=<span class="string">'diskDevice'</span>&gt;</span><br><span class="line">        &lt;value&gt;disk&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;cdrom&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;floppy&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;lun&lt;/value&gt;</span><br><span class="line">      &lt;/enum&gt;</span><br><span class="line">      &lt;enum name=<span class="string">'bus'</span>&gt;</span><br><span class="line">        &lt;value&gt;ide&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;fdc&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;scsi&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;virtio&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;usb&lt;/value&gt;</span><br><span class="line">      &lt;/enum&gt;</span><br><span class="line">    &lt;/disk&gt;</span><br><span class="line">    &lt;hostdev supported=<span class="string">'yes'</span>&gt;</span><br><span class="line">      &lt;enum name=<span class="string">'mode'</span>&gt;</span><br><span class="line">        &lt;value&gt;subsystem&lt;/value&gt;</span><br><span class="line">      &lt;/enum&gt;</span><br><span class="line">      &lt;enum name=<span class="string">'startupPolicy'</span>&gt;</span><br><span class="line">        &lt;value&gt;default&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;mandatory&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;requisite&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;optional&lt;/value&gt;</span><br><span class="line">      &lt;/enum&gt;</span><br><span class="line">      &lt;enum name=<span class="string">'subsysType'</span>&gt;</span><br><span class="line">        &lt;value&gt;usb&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;pci&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;scsi&lt;/value&gt;</span><br><span class="line">      &lt;/enum&gt;</span><br><span class="line">      &lt;enum name=<span class="string">'capsType'</span>/&gt;</span><br><span class="line">      &lt;enum name=<span class="string">'pciBackend'</span>&gt;</span><br><span class="line">        &lt;value&gt;default&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;vfio&lt;/value&gt;</span><br><span class="line">      &lt;/enum&gt;</span><br><span class="line">    &lt;/hostdev&gt;</span><br><span class="line">  &lt;/devices&gt;</span><br><span class="line">&lt;/domainCapabilities&gt;</span><br></pre></td></tr></table></figure><hr><h1 id="啟動第一個-virtual-machine"><a href="#啟動第一個-virtual-machine" class="headerlink" title="啟動第一個 virtual machine"></a>啟動第一個 virtual machine</h1><p>由於 RedHat 建議使用 virsh，因此 <strong><font color="red">qemu-kvm</font></strong> 就不存在於預設路徑中，用以下指令把它找出來：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 將 qemu-kvm 以 symlink 的形式複製到 $PATH</span></span><br><span class="line"><span class="comment"># qemu-kvm 指令已經預設啟用 KVM 支援</span></span><br><span class="line">$ ln -sf /usr/libexec/qemu-kvm /usr/bin/kvm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 製作一個 size = 8GB 的 raw image 作為 virtual machine disk</span></span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/zero of=/kvm/storage/vm_disks/ubnutu1604.img bs=1M count=8192</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目前系統中存在的 iso</span></span><br><span class="line">$ ls /kvm/os_images</span><br><span class="line">ubuntu-16.04.1-server-amd64.iso</span><br><span class="line"></span><br><span class="line"><span class="comment"># 啟動 VM (以光碟開機，安裝作業系統)</span></span><br><span class="line"><span class="comment"># -smp 4 =&gt; vCPU=4</span></span><br><span class="line"><span class="comment"># -m 2048 =&gt; RAM=2048MB</span></span><br><span class="line"><span class="comment"># -vnc 0.0.0.0:5 =&gt; 將 vnc 開在第五個 console，因此透過 vnc viewer 連線要使用 "ip:5" 來進行連線</span></span><br><span class="line"><span class="comment"># -boot order=cd =&gt; 開機順序為 cdrom &gt; hdd</span></span><br><span class="line"><span class="comment"># -hda /kvm/storage/vm_disks/ubnutu1604.img =&gt; 指定 hdd raw image</span></span><br><span class="line"><span class="comment"># -cdrom /kvm/os_images/ubuntu-16.04.1-server-amd64.iso =&gt; 指定開機光碟 iso</span></span><br><span class="line">$ kvm -smp 4 -m 2048 \</span><br><span class="line">  -vnc 0.0.0.0:5 -boot order=<span class="built_in">cd</span> \</span><br><span class="line">  -hda /kvm/storage/vm_disks/ubnutu1604.img \</span><br><span class="line">  -cdrom /kvm/os_images/ubuntu-16.04.1-server-amd64.iso</span><br></pre></td></tr></table></figure><p>接著可以使用 <a href="http://tigervnc.org/" target="_blank" rel="noopener">TigerVNC</a> or <a href="https://chrome.google.com/webstore/detail/vnc%C2%AE-viewer-for-google-ch/iabmpiboiopbgfabjmgeedhcmjenhbla" target="_blank" rel="noopener">VNC® Viewer for Google Chrome</a> 來進行連線，使用的的連線位置為 <code>server_ip:5</code>；連線進入後，就可以按照一般程序進行 OS 的安裝。</p><p>安裝完成後，<code>/kvm/storage/vm_disks/ubnutu1604.img</code> 將會是一個已經安裝好 OS 的硬碟 image 檔案，我們可以透過以下指令使用此 image 檔案來啟動系統：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -smp 4 =&gt; vCPU=4</span></span><br><span class="line"><span class="comment"># -m 2048 =&gt; RAM=2048MB</span></span><br><span class="line"><span class="comment"># -vnc 0.0.0.0:5 =&gt; 將 vnc 開在第五個 console，因此透過 vnc viewer 連線要使用 "ip:5" 來進行連線</span></span><br><span class="line">$ kvm -smp 4 -m 2048 -vnc 0.0.0.0:5 -hda /kvm/storage/vm_disks/ubnutu1604.img</span><br></pre></td></tr></table></figure><p>使用 VNC viewer 連到 virtual machine 之後，可使用 <code>Ctrl + Alt + 2</code> 切到 QEMU monitor，輸入 <code>kvm info</code> 就可以檢視目前 KVM 是否被使用，或是完全在 QEMU 模擬下產生：</p><p><img src="https://lh3.googleusercontent.com/Or8AH3hxAJbdXsIMADxmVkvUKlFYe_-DwTpSuw878fpP3bDAqyLv_ql_7W_HIrLYGHqc1hha7aecKMM6lytj2Wkv-NEyoXsZPuHE5RKa9mp_6apKEoPn7h-tp2DSjLcHaj72ByMefPKXRFKFYCLmYdbhsax0Ro8A-UCjSweOuB03zEL44VM7YbkxNE85vTmFv-JMUUERlX3CAdDotSWpvzl-ztgHzoU2E0iqwgLawhHAhn1JOX19Mn0ib3J0vxqZyLI6CNqaXEIc-7v5QNhAmAysEdWd3AMVKqkPVI41v8FDiUam2G_MDUkWOsAW4aQjnwrAbiw3-Ljpi72gjsM_iJWnsLF5nCuREGQxWC_LOrhRo7-AKLgU_XmzJuobqLRi6LoMzy_BKva5jI7nSgmgAfXDDTWpsXyGoKSgexpg_J7SRuLVZR1iZZ8HCZ9FZpre9qNIdr6xsvnH1NoUobJ73IKMbKn4YmGD0Z9Odi51bpWSh9eV1kOyCMFnF7Q5KZoPk-9lZwChK0gVUj6eObbJDKhlrFTpSvO7vYGJOmIBtfgCfKB9tAZ1-fpDSWxv8tGP38OQmKirl5oh0ozkGGQ-Z9QAr0mC31U=w642-h143-no" alt="QEMU Monitor"></p><blockquote><p>從上圖來看，可看出關鍵字 <code>kvm support: enabled</code>，表示 KVM 加速是開啟的</p></blockquote><blockquote><p>由於我們在上面所產生的 kvm 指令是來自於 qemu-kvm，因此已經預設啟用 KVM 加速 (若單純使用 QEMU，可搭配 <code>--enable-kvm</code> 參數來啟用 KVM 加速)</p></blockquote><hr><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><ul><li><p><a href="http://newtoypia.blogspot.tw/2015/02/qemu-kvm.html" target="_blank" rel="noopener">玩具烏托邦: 五分鐘開始玩 qemu-kvm 虛擬機</a></p></li><li><p><a href="http://www.vpsee.com/2012/04/install-kvm-on-centos-6-2/" target="_blank" rel="noopener">在 CentOS 6.2 上安装和配置 KVM @vpsee.com</a></p></li><li><p><a href="http://ot-note.logdown.com/posts/64644/launch-a-vm-with-qemu-kvm" target="_blank" rel="noopener">使用 libvirt 與 qemu-kvm 開啓 VM (內含 libvirt sample XML for KVM ) « OT Coding Note</a></p></li></ul><h2 id="VNC"><a href="#VNC" class="headerlink" title="VNC"></a>VNC</h2><ul><li><a href="http://jamyy.us.to/blog/2011/10/3365.html" target="_blank" rel="noopener">KVM/QEMU 設置 VNC 連線密碼 « Jamyy’s Weblog</a></li></ul>]]></content>
      
      <categories>
          
          <category> KVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> KVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Linux] PXE Booting</title>
      <link href="/blog/2016/07/01/Linux/Linux-PXE-Booting/"/>
      <url>/blog/2016/07/01/Linux/Linux-PXE-Booting/</url>
      <content type="html"><![CDATA[<p>此篇文章介紹 PXE &amp; iPXE 的開機流程</p><h1 id="PXE"><a href="#PXE" class="headerlink" title="PXE"></a>PXE</h1><p>首先以下圖說明一下傳統 PXE 的流程：</p><p><img src="https://github.com/coreos/coreos-baremetal/raw/master/Documentation/img/pxelinux.png" alt="PXE"></p><p>PXE 的開機流程，簡單來說就是幾個步驟：</p><ol><li><p>network client 從 DHCP service 取得 IP &amp; 其他 metadata(例如：TFTP 資訊 &amp; NBP 檔名)</p></li><li><p>network client 從 TFTP 取得 NBP(Network Boot Program，上面中的 <code>pxelinux.0</code>)，並啟動</p></li><li><p>network client 使用 NBP 載入 configs, scripts, 以及執行 OS 需要的 kernel(範例中的 <code>kernel.vmlinuz</code>) &amp; ramfs image(上圖中的 <code>initrd.cpio.gz</code>)</p></li></ol><hr><h1 id="Network-Boot-Program-NBP-也稱為-bootloader"><a href="#Network-Boot-Program-NBP-也稱為-bootloader" class="headerlink" title="Network Boot Program (NBP, 也稱為 bootloader)"></a>Network Boot Program (NBP, 也稱為 bootloader)</h1><p>CoreOS 可用多種不同的 bootloader 開機 &amp; 設定，如果是一個全新的設定環境，<a href="http://ipxe.org/" target="_blank" rel="noopener">iPXE</a> 是個不錯的選擇。</p><h2 id="PXELINUX"><a href="#PXELINUX" class="headerlink" title="PXELINUX"></a>PXELINUX</h2><p><a href="http://www.syslinux.org/wiki/index.php?title=PXELINUX" target="_blank" rel="noopener">PXELINUX</a> 是個相當普遍被使用的 bootloader(檔名為 <code>pxelinux.0</code>)，會自動從 <code>/tftp_bootdir/pxelinux.cfg</code> 目錄中載入設定檔。</p><p>若要控制特定機器使用特定的設定檔，可以利用 network client 的 UUID、MAC address、IP or default 來進行設定，因此設定檔就會變成如下面的範例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/tftp_bootdir/pxelinux.cfg/b8945908-d6a6-41a9-611d-74a6ab80b83d</span><br><span class="line">/tftp_bootdir/pxelinux.cfg/01-88-99-aa-bb-cc-dd</span><br><span class="line">/tftp_bootdir/pxelinux.cfg/default</span><br></pre></td></tr></table></figure><p>按照上圖的流程，可以很清楚知道，設定檔的內容肯定就是會包含了像是 config / script / kernel / ramfs image …. 等檔案的位置資訊(可能還會包含<strong>開機選單</strong>)，以下是個簡單範例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">default coreos</span><br><span class="line">prompt 1</span><br><span class="line">timeout 15</span><br><span class="line"></span><br><span class="line">display boot.msg</span><br><span class="line"></span><br><span class="line">label coreos</span><br><span class="line">  menu default</span><br><span class="line">  kernel coreos_production_pxe.vmlinuz</span><br><span class="line">  append initrd=coreos_production_pxe_image.cpio.gz cloud-config-url=http://example.com/pxe-cloud-config.yml</span><br></pre></td></tr></table></figure><blockquote><p>上面範例中的檔案若沒有指定目錄，就表示應該將其放在 <code>/tftp_bootdir</code> 目錄中<br>其中設定了一個簡單的 menu、顯示訊息、kernel(coreos_production_pxe.vmlinuz)、ramfs(coreos_production_pxe_image.cpio.gz) &amp; 設定 CoreOS 用的 cloud-config.yaml</p></blockquote><p>PXE 雖然普遍使用，但的確是有些缺點存在的，例如：</p><ol><li><p>TFTP 速度慢</p></li><li><p>若有許多針對不同機器的客製化設定檔需求，會需要撰寫很多份 pxelinux config</p></li></ol><h2 id="iPXE"><a href="#iPXE" class="headerlink" title="iPXE"></a>iPXE</h2><p><a href="http://ipxe.org/" target="_blank" rel="noopener">iPXE</a> 可是視為加強版的 PXE bootloader，使用的並非是設定檔，而是 <strong>iPXE script</strong>，而且 iPXE script &amp; image 都可以透過 HTTP 下載</p><p>以下是 iPXE 開機流程示意圖：</p><p><img src="https://github.com/coreos/coreos-baremetal/raw/master/Documentation/img/ipxe.png" alt="iPXE"></p><p>從上圖可以看出，為了可以運作在原有的環境中，使用了一個名稱為 <a href="http://boot.ipxe.org/undionly.kpxe" target="_blank" rel="noopener">undionly.kpxe</a> 的 bootloader 來協助開機，接著會發生以下的事情：</p><ol><li><p>bootloader undionly.kpxe 會提供給 machine 上網 &amp; 處理後續 iPXE script 的能力</p></li><li><p>透過網路取得 iPXE script <code>boot.ipxes</code></p></li><li><p>並會使用檔名為 <code>boot.ipxe</code>(來源可以是 HTTP) 的 iPXE script 來繼續執行後續的開機流程</p></li></ol><p>以下是個簡單的 iPXE script 範例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!ipxe</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> base-url http://stable.release.core-os.net/amd64-usr/current</span><br><span class="line">kernel <span class="variable">$&#123;base-url&#125;</span>/coreos_production_pxe.vmlinuz cloud-config-url=http://provisioner.example.net/cloud-config.yml</span><br><span class="line">initrd <span class="variable">$&#123;base-url&#125;</span>/coreos_production_pxe_image.cpio.gz</span><br><span class="line">boot</span><br></pre></td></tr></table></figure><blockquote><p>透過 iPXE script，可以用程式化的方式進行更多動態的開機設定</p></blockquote><p>在 iPXE 開機環境 for CoreOS 的架構中，有一些事情是值得注意一下的：</p><ol><li><p>TFTP 只用來提供 <a href="http://boot.ipxe.org/undionly.kpxe" target="_blank" rel="noopener">undionly.kpxe</a> bootloader，目的是為了讓老舊的 PXE firmware client 也可以使用 iPXE</p></li><li><p>CoreOS 提供了 <a href="coreos-baremetal/bootcfg.md at master · coreos/coreos-baremetal">bootcfg</a> 工具，可根據硬體的屬性，用來產生相對應的 iPXE script (把 iPXE script 的來源指向 bootcfg iPXE endpoint)</p></li></ol><hr><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><p><a href="http://www.syslinux.org/wiki/index.php?title=PXELINUX" target="_blank" rel="noopener">PXELINUX - Syslinux Wiki</a></p></li><li><p><a href="http://ipxe.org/howto/chainloading" target="_blank" rel="noopener">iPXE - open source boot firmware [howto:chainloading]</a></p></li><li><p><a href="https://github.com/coreos/coreos-baremetal/blob/master/Documentation/network-booting.md" target="_blank" rel="noopener">coreos-baremetal/network-booting.md at master · coreos/coreos-baremetal</a></p></li></ul>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Linux] 解決使用帶有密碼的 SSH keypair 時需要重複輸入密碼的問題</title>
      <link href="/blog/2016/07/01/Linux/Auto-Authenticate-with-Password-Protected-SSHKeypair/"/>
      <url>/blog/2016/07/01/Linux/Auto-Authenticate-with-Password-Protected-SSHKeypair/</url>
      <content type="html"><![CDATA[<blockquote><p>use ssh agent and keychain to input the secret of password-protected ssh key</p></blockquote><p>最近被 GitHub 騙了去產生個帶有密碼的 SSH keypair 來用</p><p>發現怎麼每次使用都要我輸入密碼呢….? 於是上網找了一下答案……</p><p>要解決這方式，需要 <strong>ssh agent</strong> 搭配 <strong>keychain</strong> 來將密碼安全的儲存起來</p><p>假設以下情況已經完成：</p><ol><li><p>SSK keypair 已經存在於 <code>~/.ssh/id_rsa*</code></p></li><li><p>keychain 套件已經安裝</p></li></ol><p>接著只要執行以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ tee --append ~/.bash_profile &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line"><span class="comment">### START-Keychain ###</span></span><br><span class="line"><span class="comment"># Let  re-use ssh-agent and/or gpg-agent between logins</span></span><br><span class="line">/usr/bin/keychain <span class="variable">$HOME</span>/.ssh/id_rsa</span><br><span class="line"><span class="built_in">source</span> <span class="variable">$HOME</span>/.keychain/<span class="variable">$HOSTNAME</span>-sh</span><br><span class="line"><span class="comment">### End-Keychain ###</span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>接著再重新登入，輸入一次密碼後，後續使用到 SSH keypair 時，就不用一直重複輸入了!</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><p><a href="https://help.github.com/articles/generating-an-ssh-key/" target="_blank" rel="noopener">Generating an SSH key - User Documentation</a></p></li><li><p><a href="http://unix.stackexchange.com/questions/83608/ssh-agent-how-to-set-it-up-so-my-centos-server-will-only-ask-for-passphrase-onc" target="_blank" rel="noopener">ssh-agent: How to set it up so my CentOS server will only ask for passphrase once? - Unix &amp; Linux Stack Exchange</a></p></li><li><p><a href="http://www.cyberciti.biz/faq/ssh-passwordless-login-with-keychain-for-scripts/" target="_blank" rel="noopener">keychain: Set Up Secure Passwordless SSH Access For Backup Scripts</a></p></li></ul>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[CoreOS] etcd、fleet &amp; flannel 簡介</title>
      <link href="/blog/2016/06/22/CoreOS/CoreOS-Introduction-Of-etcd-fleet-and-flannel/"/>
      <url>/blog/2016/06/22/CoreOS/CoreOS-Introduction-Of-etcd-fleet-and-flannel/</url>
      <content type="html"><![CDATA[<h1 id="環境說明"><a href="#環境說明" class="headerlink" title="環境說明"></a>環境說明</h1><p>測試環境建立於現有的 OpenStack infrastructure 上，使用以下設定：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#cloud-config</span></span><br><span class="line"></span><br><span class="line"><span class="attr">ssh_authorized_keys:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">[YOUR</span> <span class="string">SSH</span> <span class="string">PUBLIC</span> <span class="string">KEY]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">coreos:</span></span><br><span class="line"><span class="attr">  etcd2:</span></span><br><span class="line"><span class="attr">    discovery:</span> <span class="attr">https://discovery.etcd.io/ea524a83ed3f84e550417f0fb89e91c8</span></span><br><span class="line"><span class="attr">    advertise-client-urls:</span> <span class="attr">http://$private_ipv4:2379,http://$private_ipv4:4001</span></span><br><span class="line"><span class="attr">    initial-advertise-peer-urls:</span> <span class="attr">http://$private_ipv4:2380</span></span><br><span class="line"><span class="attr">    listen-client-urls:</span> <span class="attr">http://0.0.0.0:2379,http://0.0.0.0:4001</span></span><br><span class="line"><span class="attr">    listen-peer-urls:</span> <span class="attr">http://$private_ipv4:2380</span></span><br><span class="line"><span class="attr">  flannel:</span></span><br><span class="line"><span class="attr">    interface:</span> <span class="string">$public_ipv4</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  units:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">etcd2.service</span></span><br><span class="line"><span class="attr">      command:</span> <span class="string">start</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">fleet.service</span></span><br><span class="line"><span class="attr">      command:</span> <span class="string">start</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">flanneld.service</span></span><br><span class="line"><span class="attr">      drop-ins:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="number">50</span><span class="bullet">-network-config.conf</span></span><br><span class="line"><span class="attr">          content:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            [Service]</span></span><br><span class="line"><span class="string">            ExecStartPre=/usr/bin/etcdctl set /coreos.com/network/config '&#123; "Network": "10.1.0.0/16" &#125;'</span></span><br><span class="line"><span class="string"></span><span class="attr">      command:</span> <span class="string">start</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">redis.service</span></span><br><span class="line"><span class="attr">      content:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        [Unit]</span></span><br><span class="line"><span class="string">        Requires=flanneld.service</span></span><br><span class="line"><span class="string">        After=flanneld.service</span></span><br><span class="line"><span class="string">        [Service]</span></span><br><span class="line"><span class="string">        ExecStart=/usr/bin/docker run redis</span></span><br><span class="line"><span class="string">        Restart=always</span></span><br><span class="line"><span class="string"></span><span class="attr">      command:</span> <span class="string">start</span></span><br></pre></td></tr></table></figure><p>以上設定會把 <strong>etcd</strong>、<strong>fleet</strong>、<strong>flannel</strong>、<strong>docker</strong> 都啟動，還包含了一個執行 <strong>redis</strong> 服務的 container</p><hr><h1 id="驗證步驟"><a href="#驗證步驟" class="headerlink" title="驗證步驟"></a>驗證步驟</h1><p>當 CoreOS 安裝完成之後，首要之務就是驗證 CoreOS 是否安裝成功，以下測試三個主要的 service 分別是 <code>etcd</code>、<code>docker</code>、<code>fleet</code>：</p><h2 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h2><p>在 Machine A 新增資訊到 etcd service：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">core@coreos ~ $ etcdctl <span class="built_in">set</span> /message <span class="string">"Hello CoreOS"</span></span><br><span class="line">Hello CoreOS</span><br><span class="line"></span><br><span class="line">core@coreos ~ $ curl -L http://127.0.0.1:2379/v2/keys/message -XPUT -d value=<span class="string">"Hello CoreOS"</span></span><br><span class="line">&#123;<span class="string">"action"</span>:<span class="string">"set"</span>,<span class="string">"node"</span>:&#123;<span class="string">"key"</span>:<span class="string">"/message"</span>,<span class="string">"value"</span>:<span class="string">"Hello CoreOS"</span>,<span class="string">"modifiedIndex"</span>:1641,<span class="string">"createdIndex"</span>:1641&#125;,<span class="string">"prevNode"</span>:&#123;<span class="string">"key"</span>:<span class="string">"/message"</span>,<span class="string">"value"</span>:<span class="string">"Hello CoreOS"</span>,<span class="string">"modifiedIndex"</span>:1455,<span class="string">"createdIndex"</span>:1455&#125;&#125;</span><br></pre></td></tr></table></figure><p>可以從 Machine B 取得：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">core@coreos ~ $ etcdctl get /message   </span><br><span class="line">Hello CoreOS</span><br><span class="line"></span><br><span class="line">core@coreos ~ $ curl -L http://127.0.0.1:2379/v2/keys/message</span><br><span class="line">&#123;<span class="string">"action"</span>:<span class="string">"get"</span>,<span class="string">"node"</span>:&#123;<span class="string">"key"</span>:<span class="string">"/message"</span>,<span class="string">"value"</span>:<span class="string">"Hello CoreOS"</span>,<span class="string">"modifiedIndex"</span>:1641,<span class="string">"createdIndex"</span>:1641&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><p>由於 CoreOS 使用了 systemd port activate 的機制，因此一開始 docker service 是不會啟動的，直到有 container 啟動為止：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一開始 docker service 不會啟動</span></span><br><span class="line">core@coreos ~ $ systemctl status docker</span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (/usr/lib64/systemd/system/docker.service; disabled; vendor preset: disabled)</span><br><span class="line">   Active: inactive (dead)</span><br><span class="line">     Docs: http://docs.docker.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 啟動 container busybox</span></span><br><span class="line">core@coreos ~ $ docker run busybox /bin/<span class="built_in">echo</span> Hello CoreOS</span><br><span class="line">Unable to find image <span class="string">'busybox:latest'</span> locally</span><br><span class="line">latest: Pulling from library/busybox</span><br><span class="line">385e281300cc: Pull complete</span><br><span class="line">a3ed95caeb02: Pull complete</span><br><span class="line">Digest: sha256:4a731fb46adc5cefe3ae374a8b6020fc1b6ad667a279647766e9a3cd89f6fa92</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> busybox:latest</span><br><span class="line">Hello CoreOS</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker service 目前為啟動狀態</span></span><br><span class="line">core@coreos ~ $ systemctl status docker</span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (/usr/lib64/systemd/system/docker.service; disabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Mon 2016-06-20 07:58:52 UTC; 53s ago</span><br><span class="line">     Docs: http://docs.docker.com</span><br><span class="line"> Main PID: 1082 (docker)</span><br><span class="line">   Memory: 41.7M</span><br><span class="line">      CPU: 18.356s</span><br><span class="line">   CGroup: /system.slice/docker.service</span><br><span class="line">           └─1082 docker daemon --host=fd:// --<span class="built_in">exec</span>-opt native.cgroupdriver=systemd --selinux-enabled</span><br><span class="line">.........</span><br></pre></td></tr></table></figure><h2 id="fleet"><a href="#fleet" class="headerlink" title="fleet"></a>fleet</h2><p>CoreOS 會使用 fleet 用來管理 container 的生命週期。</p><p>fleet 是透過接收 <a href="https://coreos.com/os/docs/latest/getting-started-with-systemd.html" target="_blank" rel="noopener">systemd unit files</a> 為資訊來源進行工作，將 workload 分配到 cluster 中不同的機器執行；管理者可以透過 <code>fleetctl</code> 工具執行像是查詢 unit 的狀態、log 資訊等工作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">core@coreos ~ $ cat &lt;&lt;EOF &gt;hello.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=My Service</span><br><span class="line">After=docker.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">TimeoutStartSec=0</span><br><span class="line">ExecStartPre=-/usr/bin/docker <span class="built_in">kill</span> hello</span><br><span class="line">ExecStartPre=-/usr/bin/docker rm hello</span><br><span class="line">ExecStartPre=/usr/bin/docker pull busybox</span><br><span class="line">ExecStart=/usr/bin/docker run --name hello busybox /bin/sh -c <span class="string">"trap 'exit 0' INT TERM; while true; do echo Hello World; sleep 1; done"</span></span><br><span class="line">ExecStop=/usr/bin/docker stop hello</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">core@coreos ~ $ fleetctl load hello.service</span><br><span class="line">Unit hello.service inactive</span><br><span class="line">Unit hello.service loaded on 0682a8f2.../192.168.50.14</span><br><span class="line"></span><br><span class="line">core@coreos ~ $ fleetctl start hello.service</span><br><span class="line">Unit hello.service launched on 0682a8f2.../192.168.50.14</span><br><span class="line"></span><br><span class="line">core@coreos ~ $ fleetctl status hello.service</span><br><span class="line">● hello.service - My Service</span><br><span class="line">   Loaded: loaded (/run/fleet/units/hello.service; linked-runtime; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Mon 2016-06-20 08:52:43 UTC; 9s ago</span><br><span class="line">...........</span><br><span class="line">Jun 20 08:52:43 coreos docker[1355]: Status: Image is up to date <span class="keyword">for</span> busybox:latest</span><br><span class="line">Jun 20 08:52:43 coreos systemd[1]: Started My Service.</span><br><span class="line">Jun 20 08:52:50 coreos docker[1367]: Hello World</span><br><span class="line">...........</span><br><span class="line">Jun 20 08:52:52 coreos docker[1367]: Hello World</span><br><span class="line"></span><br><span class="line">core@coreos ~ $ fleetctl destroy hello.service</span><br><span class="line">Destroyed hello.service</span><br><span class="line"></span><br><span class="line">core@coreos ~ $ fleetctl status hello.service</span><br><span class="line">Unit hello.service does not exist.</span><br></pre></td></tr></table></figure><h2 id="flannel"><a href="#flannel" class="headerlink" title="flannel"></a>flannel</h2><p>flannel 是用來提供 cross hosts 的 container 互相連結之用，在上面的 cloud-config 中，每個 host 預設會從 10.1.0.0/16 的區段中取得自己的 class C subnet。</p><p>驗證 flannel 是否運作正常的的步驟如下：</p><ol><li><p>登入 machine A，並進入 redis container A 中，查詢到 IP A</p></li><li><p>登入 machine B，並進入 redis container B 中，查詢到 IP B</p></li><li><p>確認可以從 container A ping 到 container B</p></li></ol><p>若是兩個位於不同機器的 container 可以互通，就表示 flannel 目前的運作是正常的!</p><hr><h1 id="etcd-1"><a href="#etcd-1" class="headerlink" title="etcd"></a>etcd</h1><p><strong>etcd</strong> 是種分散式 key/value 儲存服務，存在於每一台 CoreOS 機器中，並在 CoreOS cluster 中負責 shared configuration &amp; service discovery 的工作。</p><p>而執行在 cluster 環境中的 application container 同樣可以使用 etcd 所提供的服務，可進行像是儲存資料庫連線設定、cache 設定、<a href="Feature Flag 功能發布控制 - 壹讀">feature flag</a> … 等不同的資訊。</p><h2 id="在-etcd-讀寫資料"><a href="#在-etcd-讀寫資料" class="headerlink" title="在 etcd 讀寫資料"></a>在 etcd 讀寫資料</h2><p>當對 etcd service 寫入資料後，cluster 內的機器都可以讀取的到(所以說是分散式的)</p><h3 id="寫入資料"><a href="#寫入資料" class="headerlink" title="寫入資料"></a>寫入資料</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">core@coreos ~ $ etcdctl <span class="built_in">set</span> /message Hello</span><br><span class="line">Hello</span><br><span class="line"></span><br><span class="line">core@coreos ~ $ curl -L -X PUT http://localhost:2379/v2/keys/message -d value=<span class="string">"Hello"</span></span><br><span class="line">&#123;<span class="string">"action"</span>:<span class="string">"set"</span>,<span class="string">"node"</span>:&#123;<span class="string">"key"</span>:<span class="string">"/message"</span>,<span class="string">"value"</span>:<span class="string">"Hello"</span>,<span class="string">"modifiedIndex"</span>:45040,<span class="string">"createdIndex"</span>:45040&#125;,<span class="string">"prevNode"</span>:&#123;<span class="string">"key"</span>:<span class="string">"/message"</span>,<span class="string">"value"</span>:<span class="string">"CoreOS"</span>,<span class="string">"modifiedIndex"</span>:44979,<span class="string">"createdIndex"</span>:44979&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="讀取資料"><a href="#讀取資料" class="headerlink" title="讀取資料"></a>讀取資料</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">core@coreos ~ $ etcdctl get /message</span><br><span class="line">Hello</span><br><span class="line"></span><br><span class="line">core@coreos ~ $ curl -L http://localhost:2379/v2/keys/message</span><br><span class="line">&#123;<span class="string">"action"</span>:<span class="string">"get"</span>,<span class="string">"node"</span>:&#123;<span class="string">"key"</span>:<span class="string">"/message"</span>,<span class="string">"value"</span>:<span class="string">"Hello"</span>,<span class="string">"modifiedIndex"</span>:45040,<span class="string">"createdIndex"</span>:45040&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="刪除資料"><a href="#刪除資料" class="headerlink" title="刪除資料"></a>刪除資料</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">core@coreos ~ $ etcdctl rm /message</span><br><span class="line">PrevNode.Value: Hello</span><br><span class="line"></span><br><span class="line">core@coreos ~ $ etcdctl <span class="built_in">set</span> /message Hello</span><br><span class="line">Hello</span><br><span class="line"></span><br><span class="line">core@coreos ~ $ curl -L -X DELETE http://localhost:2379/v2/keys/message</span><br><span class="line">&#123;<span class="string">"action"</span>:<span class="string">"delete"</span>,<span class="string">"node"</span>:&#123;<span class="string">"key"</span>:<span class="string">"/message"</span>,<span class="string">"modifiedIndex"</span>:45482,<span class="string">"createdIndex"</span>:45467&#125;,<span class="string">"prevNode"</span>:&#123;<span class="string">"key"</span>:<span class="string">"/message"</span>,<span class="string">"value"</span>:<span class="string">"Hello"</span>,<span class="string">"modifiedIndex"</span>:45467,<span class="string">"createdIndex"</span>:45467&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="從-container-中讀寫-etcd-中的資料"><a href="#從-container-中讀寫-etcd-中的資料" class="headerlink" title="從 container 中讀寫 etcd 中的資料"></a>從 container 中讀寫 etcd 中的資料</h2><p>要從 docker container 中對 etcd 讀寫資料，必須將 ip 指向 <code>docker0</code> interface，預設情況下 ip 為 <code>172.17.0.1</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@cb8e1cb26a7e:/<span class="comment"># curl -L http://172.17.0.1:2379/v2/keys</span></span><br><span class="line">&#123;<span class="string">"action"</span>:<span class="string">"get"</span>,<span class="string">"node"</span>:&#123;<span class="string">"dir"</span>:<span class="literal">true</span>,<span class="string">"nodes"</span>:[&#123;<span class="string">"key"</span>:<span class="string">"/coreos.com"</span>,<span class="string">"dir"</span>:<span class="literal">true</span>,<span class="string">"modifiedIndex"</span>:5,<span class="string">"createdIndex"</span>:5&#125;]&#125;&#125;</span><br><span class="line"></span><br><span class="line">root@cb8e1cb26a7e:/<span class="comment"># curl -L -X PUT http://172.17.0.1:2379/v2/keys/message -d value="I am container"</span></span><br><span class="line">&#123;<span class="string">"action"</span>:<span class="string">"set"</span>,<span class="string">"node"</span>:&#123;<span class="string">"key"</span>:<span class="string">"/message"</span>,<span class="string">"value"</span>:<span class="string">"I am container"</span>,<span class="string">"modifiedIndex"</span>:47075,<span class="string">"createdIndex"</span>:47075&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="監控-etcd-directory-的變化"><a href="#監控-etcd-directory-的變化" class="headerlink" title="監控 etcd directory 的變化"></a>監控 etcd directory 的變化</h2><h3 id="1、新增-etcd-directory"><a href="#1、新增-etcd-directory" class="headerlink" title="1、新增 etcd directory"></a>1、新增 etcd directory</h3><p>除了 <code>/</code> 之外，我們可以在 etcd 中自訂所需要的 directory 用來存放自訂的訊息，以下建立名稱為 <strong>foo-service</strong> 的 directory：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">core@coreos ~ $ etcdctl mkdir /foo-service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 etcd directory 中新增訊息</span></span><br><span class="line">core@coreos ~ $ etcdctl <span class="built_in">set</span> /foo-service/container1 localhost:1111</span><br><span class="line">localhost:1111</span><br></pre></td></tr></table></figure><h3 id="2、監控-etcd-directory"><a href="#2、監控-etcd-directory" class="headerlink" title="2、監控 etcd directory"></a>2、監控 etcd directory</h3><p>當其他 CoreOS host 執行 <code>etcdctl set /foo-service/container2 localhost:2222</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">core@coreos ~ $ etcdctl watch --recursive /foo-service</span><br><span class="line">[<span class="built_in">set</span>] /foo-service/container2</span><br><span class="line">localhost:2222</span><br><span class="line"></span><br><span class="line">core@coreos ~ $ curl -L http://localhost:2379/v2/keys/foo-service?<span class="built_in">wait</span>=<span class="literal">true</span>\&amp;recursive=<span class="literal">true</span></span><br><span class="line">&#123;<span class="string">"action"</span>:<span class="string">"set"</span>,<span class="string">"node"</span>:&#123;<span class="string">"key"</span>:<span class="string">"/foo-service/container2"</span>,<span class="string">"value"</span>:<span class="string">"localhost:2222"</span>,<span class="string">"modifiedIndex"</span>:48468,<span class="string">"createdIndex"</span>:48468&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="3、監控-etcd-directory-並觸發執行特定任務"><a href="#3、監控-etcd-directory-並觸發執行特定任務" class="headerlink" title="3、監控 etcd directory 並觸發執行特定任務"></a>3、監控 etcd directory 並觸發執行特定任務</h3><p>當其他 CoreOS host 執行執行以下指令：</p><ol><li><p><code>etcdctl set /foo-service/container2 localhost:2222</code></p></li><li><p><code>etcdctl set /foo-service/container3 localhost:3333</code></p></li><li><p><code>etcdctl rm /foo-service/container2</code></p></li><li><p><code>etcdctl rm /foo-service/container3</code></p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">core@coreos ~ $ etcdctl <span class="built_in">exec</span>-watch --recursive /foo-service -- sh -c <span class="string">'echo "\"$ETCD_WATCH_KEY\" key was updated to \"$ETCD_WATCH_VALUE\" value by \"$ETCD_WATCH_ACTION\" action"'</span></span><br><span class="line"><span class="string">"/foo-service/container2"</span> key was updated to <span class="string">"localhost:2222"</span> value by <span class="string">"set"</span> action</span><br><span class="line"><span class="string">"/foo-service/container3"</span> key was updated to <span class="string">"localhost:3333"</span> value by <span class="string">"set"</span> action</span><br><span class="line"><span class="string">"/foo-service/container2"</span> key was updated to <span class="string">""</span> value by <span class="string">"delete"</span> action</span><br><span class="line"><span class="string">"/foo-service/container3"</span> key was updated to <span class="string">""</span> value by <span class="string">"delete"</span> action</span><br></pre></td></tr></table></figure><h2 id="Test-and-Set"><a href="#Test-and-Set" class="headerlink" title="Test and Set"></a>Test and Set</h2><p>etcd 也可作為中央協調服務，提供 <strong>TestAndSet</strong> 功能；設定資料的人必須提供先前的值，有符合才可以變更值的內容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 設定值為 Hello</span></span><br><span class="line">core@coreos ~ $ etcdctl <span class="built_in">set</span> /message <span class="string">"Hello"</span></span><br><span class="line">Hello</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若是先前的值為 123，將值換為 Hi (操作失敗)</span></span><br><span class="line">core@coreos ~ $ etcdctl <span class="built_in">set</span> /message <span class="string">"Hi"</span> --swap-with-value=<span class="string">"123"</span></span><br><span class="line">Error:  101: Compare failed ([123 != Hello]) [48752]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若是先前的值為 Hello，將值換為 Hi (操作成功)</span></span><br><span class="line">core@coreos ~ $ etcdctl <span class="built_in">set</span> /message <span class="string">"Hi"</span> --swap-with-value=<span class="string">"Hello"</span></span><br><span class="line">Hi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新值已經變成 Hi</span></span><br><span class="line">core@coreos ~ $ etcdctl get /message</span><br><span class="line">Hi</span><br></pre></td></tr></table></figure><h2 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h2><p>將資料寫入 etcd 時，還可以設定 TTL，讓資料在一定的時間之後失效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">core@coreos ~ $ etcdctl <span class="built_in">set</span> /foo <span class="string">"Expiring Soon"</span> --ttl 10</span><br><span class="line">Expiring Soon</span><br><span class="line">core@coreos ~ $ etcdctl get /foo</span><br><span class="line">Expiring Soon</span><br><span class="line">core@coreos ~ $ etcdctl get /foo</span><br><span class="line">Expiring Soon</span><br><span class="line">.........</span><br><span class="line">core@coreos ~ $ etcdctl get /foo</span><br><span class="line">Error:  100: Key not found (/foo) [49020]</span><br></pre></td></tr></table></figure><hr><h1 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h1><p>systemd 提供了許多強大的功能作為啟動、停止、管理 process 之用，在 CoreOS 中，幾乎所有的 Docker container 的生命週期都是由 systemd 在管理的。</p><p>CoreOS 預設所使用的 systemd target 為 <code>multi-user.target</code>，裡面包含了所有常用來管理 container 的 <code>systemd unit</code>。(<strong>target 由多個 unit symbolic link 所集合而成</strong>)</p><blockquote><p>systemd unit 是一個描述管理者所要執行的 process 的設定檔</p></blockquote><p>以下用一個簡單範例 <code>/etc/systemd/system/myweb.service</code> 來說明：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=My Web Service</span><br><span class="line"><span class="attr">After</span>=etcd2.service</span><br><span class="line"><span class="attr">After</span>=docker.service</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">TimeoutStartSec</span>=<span class="number">0</span></span><br><span class="line"><span class="comment">; 在 ExecStart 所要執行的命令，"=-" 表示請 systemd 忽略執行命令時所發生的錯誤</span></span><br><span class="line"><span class="attr">ExecStartPre</span>=-/usr/bin/docker kill apache1</span><br><span class="line"><span class="attr">ExecStartPre</span>=-/usr/bin/docker rm apache1</span><br><span class="line"><span class="attr">ExecStartPre</span>=/usr/bin/docker pull coreos/apache</span><br><span class="line"><span class="comment">; service 啟動時所要執行的命令</span></span><br><span class="line"><span class="attr">ExecStart</span>=/usr/bin/docker run --name apache1 -p <span class="number">8081</span>:<span class="number">80</span> coreos/apache /usr/sbin/apache2ctl -D FOREGROUND</span><br><span class="line"><span class="comment">; service 啟動後要執行的指令 (以 machine ID 為 key，寫入訊息到 etcd /domains/example)</span></span><br><span class="line"><span class="attr">ExecStartPost</span>=/usr/bin/etcdctl set /domains/example.com/%m running</span><br><span class="line"><span class="comment">; service 停止時所要執行的指令 (停止 container apache1)</span></span><br><span class="line"><span class="attr">ExecStop</span>=/usr/bin/docker stop apache1</span><br><span class="line"><span class="comment">; service 停止後所要執行的步驟 (以 machine ID 為 key，移除 etcd /domains/example 上的訊息)</span></span><br><span class="line"><span class="attr">ExecStopPost</span>=/usr/bin/etcdctl rm /domains/example.com/%m</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure><blockquote><p>完整的設定參數可參考 =&gt; <a href="https://www.freedesktop.org/software/systemd/man/systemd.service.html" target="_blank" rel="noopener">systemd.service</a></p></blockquote><p>另外還可以在 system unit configuration 檔案中指定 <strong>specifiers</strong>，例如：</p><ul><li><p><code>%n</code>：Full Unit Name</p></li><li><p><code>%i</code>：Instance Name</p></li><li><p><code>%m</code>：Machine ID</p></li><li><p><code>%H</code>：Host Name</p></li></ul><p>詳細的資料可以參考 =&gt; <a href="https://www.freedesktop.org/software/systemd/man/systemd.unit.html#Specifiers" target="_blank" rel="noopener">systemd.unit - Specifiers</a></p><p>上述的 systemd service unit configuration 執行的結果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">core@coreos ~ $ sudo systemctl <span class="built_in">enable</span> myweb.service</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/myweb.service to /etc/systemd/system/myweb.service.</span><br><span class="line">core@coreos ~ $ sudo systemctl start myweb.service</span><br><span class="line"></span><br><span class="line">core@coreos ~ $ sudo systemctl status myweb.service</span><br><span class="line">● myweb.service - My Web Service</span><br><span class="line">   Loaded: loaded (/etc/systemd/system/myweb.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Tue 2016-06-21 07:36:22 UTC; 9s ago</span><br><span class="line">  Process: 2403 ExecStartPost=/usr/bin/etcdctl <span class="built_in">set</span> /domains/example.com/%m running (code=exited, status=0/SUCCESS)</span><br><span class="line">  Process: 2391 ExecStartPre=/usr/bin/docker pull coreos/apache (code=exited, status=0/SUCCESS)</span><br><span class="line">  Process: 2379 ExecStartPre=/usr/bin/docker rm apache1 (code=exited, status=0/SUCCESS)</span><br><span class="line">  Process: 2369 ExecStartPre=/usr/bin/docker <span class="built_in">kill</span> apache1 (code=exited, status=1/FAILURE)</span><br><span class="line"> Main PID: 2402 (docker)</span><br><span class="line">   Memory: 11.5M</span><br><span class="line">      CPU: 5.695s</span><br><span class="line">   CGroup: /system.slice/myweb.service</span><br><span class="line">           └─2402 /usr/bin/docker run --name apache1 -p 8081:80 coreos/apache /usr/sbin/apache2ctl -D FOREGROUND</span><br><span class="line">......</span><br><span class="line">Jun 21 07:36:19 coreos docker[2391]: Status: Image is up to date <span class="keyword">for</span> coreos/apache:latest</span><br><span class="line">Jun 21 07:36:22 coreos etcdctl[2403]: running</span><br><span class="line">Jun 21 07:36:22 coreos systemd[1]: Started My Web Service.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢 container 運作狀態</span></span><br><span class="line">core@coreos ~ $ docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES</span><br><span class="line">441cf4a6bf54        coreos/apache       <span class="string">"/usr/sbin/apache2ctl"</span>   35 seconds ago      Up 26 seconds       0.0.0.0:8081-&gt;80/tcp   apache1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 確認 web server 正常服務</span></span><br><span class="line">core@coreos ~ $ curl http://localhost:8081</span><br><span class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;This is the default web page <span class="keyword">for</span> this server.&lt;/p&gt;</span><br><span class="line">&lt;p&gt;The web server software is running but no content has been added, yet.&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢 systemd 寫入 etcd 中的資料</span></span><br><span class="line">core@coreos ~ $ etcdctl ls /domains/example.com</span><br><span class="line">/domains/example.com/72bda15890c14ee89b15214c1b87d71f</span><br><span class="line">core@coreos ~ $ etcdctl get /domains/example.com/72bda15890c14ee89b15214c1b87d71f</span><br><span class="line">running</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止 service</span></span><br><span class="line">core@coreos ~ $ sudo systemctl stop myweb.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢 container 狀態</span></span><br><span class="line">core@coreos ~ $ docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS                        PORTS               NAMES</span><br><span class="line">441cf4a6bf54        coreos/apache       <span class="string">"/usr/sbin/apache2ctl"</span>   About a minute ago   Exited (137) 13 seconds ago                       apache1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢 systemd 寫入 etcd 中的資料 (已經移除)</span></span><br><span class="line">core@coreos ~ $ etcdctl ls /domains/example.com</span><br></pre></td></tr></table></figure><hr><h1 id="fleet-1"><a href="#fleet-1" class="headerlink" title="fleet"></a>fleet</h1><p>fleet 是個 cluster manager，用途是在 cluster level 上管理 systemd，因此要在 CoreOS cluster 上運行相關服務，正確的方式就是”<strong>使用標準的 systemd unit 搭配 fleet</strong>“來達成。</p><h2 id="fleet-unit-type"><a href="#fleet-unit-type" class="headerlink" title="fleet unit type"></a>fleet unit type</h2><p>可以運行在 cluster 上的 unit 有兩種，分別是：</p><ol><li><p><strong>standard unit</strong>：會被分派到獨立的單一主機上長時間運行的 process，若是機器掛點了，standard unit 就會被轉移到其他正常的主機上重新啟動並繼續執行</p></li><li><p><strong>global unit</strong>：global unit 將會運行在 cluster 中所有的機器上，這種 unit 適合用在像是 monitoring agent，甚至像是 high level 的 orchestration tool，例如：Kubernetes、Mesos、OpenStack …. 等等。</p></li></ol><h2 id="在-cluster-中啟動-container"><a href="#在-cluster-中啟動-container" class="headerlink" title="在 cluster 中啟動 container"></a>在 cluster 中啟動 container</h2><p>在這邊我們利用之前寫好的 <code>/etc/systemd/system/myweb.service</code> 作示範：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">core@coreos ~ $ fleetctl start /etc/systemd/system/myweb.service</span><br><span class="line">Unit myweb.service inactive</span><br><span class="line">Unit myweb.service launched on 0682a8f2.../192.168.50.14</span><br><span class="line"></span><br><span class="line">core@coreos ~ $ fleetctl list-units   </span><br><span class="line">UNITMACHINEACTIVESUB</span><br><span class="line">myweb.service0682a8f2.../192.168.50.14activatingstart-pre</span><br><span class="line"></span><br><span class="line">(...... it takes some time to <span class="built_in">wait</span> .......)</span><br><span class="line"></span><br><span class="line">core@coreos ~ $ fleetctl list-units</span><br><span class="line">UNITMACHINEACTIVESUB</span><br><span class="line">myweb.service0682a8f2.../192.168.50.14activerunning</span><br><span class="line"></span><br><span class="line">core@coreos ~ $ curl http://192.168.50.14:8081</span><br><span class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;This is the default web page <span class="keyword">for</span> this server.&lt;/p&gt;</span><br><span class="line">&lt;p&gt;The web server software is running but no content has been added, yet.&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">core@coreos ~ $ fleetctl list-machines</span><br><span class="line">MACHINEIPMETADATA</span><br><span class="line">0682a8f2...192.168.50.14-</span><br><span class="line">72bda158...192.168.50.16-</span><br><span class="line">90c1e40c...192.168.50.15-</span><br></pre></td></tr></table></figure><h2 id="運行-High-Availability-Service"><a href="#運行-High-Availability-Service" class="headerlink" title="運行 High Availability Service"></a>運行 High Availability Service</h2><p>關於 fleet unit 的詳細設定方式，可以參考 =&gt; <a href="https://coreos.com/fleet/docs/latest/unit-files-and-scheduling.html" target="_blank" rel="noopener">fleet - Overview of Unit Files and Scheduling</a></p><p>以下將會設計一個具有 High Availability 的 web service，其中較為重要的設定就是 <code>[X-Fleet]</code> 區塊部份的設定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">core@coreos ~/demo $ cat &lt;&lt;EOF &gt;apache@.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=My Apache Frontend</span><br><span class="line">After=docker.service</span><br><span class="line">Requires=docker.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">TimeoutStartSec=0</span><br><span class="line">ExecStartPre=-/usr/bin/docker <span class="built_in">kill</span> apache1</span><br><span class="line">ExecStartPre=-/usr/bin/docker rm apache1</span><br><span class="line">ExecStartPre=/usr/bin/docker pull coreos/apache</span><br><span class="line">ExecStart=/usr/bin/docker run --rm --name apache1 -p 80:80 coreos/apache /usr/sbin/apache2ctl -D FOREGROUND</span><br><span class="line">ExecStop=/usr/bin/docker stop apache1</span><br><span class="line"></span><br><span class="line">[X-Fleet]</span><br><span class="line">; 告知 fleet 不要把 apache@* 的 service 放在同一台機器上</span><br><span class="line">Conflicts=apache@*.service</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 複製兩份 unit configuration file</span></span><br><span class="line">core@coreos ~/demo $ cp apache\@.service apache\@1.service</span><br><span class="line">core@coreos ~/demo $ cp apache\@.service apache\@2.service</span><br><span class="line">core@coreos ~/demo $ ls  </span><br><span class="line">apache@.service  apache@1.service  apache@2.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 啟動第 1 個 apache container</span></span><br><span class="line">core@coreos ~/demo $ fleetctl start apache@1</span><br><span class="line">Unit apache@1.service inactive</span><br><span class="line">Unit apache@1.service launched on 0682a8f2.../192.168.50.14</span><br><span class="line"></span><br><span class="line"><span class="comment"># 啟動第 2 個 apache container</span></span><br><span class="line">core@coreos ~/demo $ fleetctl start apache@2</span><br><span class="line">Unit apache@2.service inactive</span><br><span class="line">Unit apache@2.service launched on 72bda158.../192.168.50.16</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視 units</span></span><br><span class="line">core@coreos ~/demo $ fleetctl list-units</span><br><span class="line">UNITMACHINEACTIVESUB</span><br><span class="line">apache@1.service0682a8f2.../192.168.50.14activerunning</span><br><span class="line">apache@2.service72bda158.../192.168.50.16activerunning</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 驗證 web 服務有正確啟動</span></span><br><span class="line">core@coreos ~/demo $ curl http://192.168.50.14</span><br><span class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;This is the default web page <span class="keyword">for</span> this server.&lt;/p&gt;</span><br><span class="line">&lt;p&gt;The web server software is running but no content has been added, yet.&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;&lt;/html&gt;</span><br><span class="line">core@coreos ~/demo $ curl http://192.168.50.16</span><br><span class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;This is the default web page <span class="keyword">for</span> this server.&lt;/p&gt;</span><br><span class="line">&lt;p&gt;The web server software is running but no content has been added, yet.&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>接著把 <code>192.168.50.14</code> 這台機器重新開機，此時 service 將會被 fleet 轉移到正常的機器上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">core@coreos ~/demo $ fleetctl list-units</span><br><span class="line">UNITMACHINEACTIVESUB</span><br><span class="line">apache@1.service90c1e40c.../192.168.50.15activatingstart-pre</span><br><span class="line">apache@2.service72bda158.../192.168.50.16activerunning</span><br><span class="line"></span><br><span class="line">core@coreos ~/demo $ fleetctl list-units</span><br><span class="line">UNITMACHINEACTIVESUB</span><br><span class="line">apache@1.service90c1e40c.../192.168.50.15activatingstart-pre</span><br><span class="line">apache@2.service72bda158.../192.168.50.16activerunning</span><br><span class="line"></span><br><span class="line">core@coreos ~/demo $ fleetctl list-units</span><br><span class="line">UNITMACHINEACTIVESUB</span><br><span class="line">apache@1.service90c1e40c.../192.168.50.15activerunning</span><br><span class="line">apache@2.service72bda158.../192.168.50.16activerunning</span><br></pre></td></tr></table></figure><blockquote><p>存取這些 HA service 比較好的方式是透過 <strong>sidekick container</strong>，這類的 container 是用來提供像是 service discovery、load balancer、DNS 等工作，不建議直接存取 service container</p></blockquote><h2 id="運行-sidekick"><a href="#運行-sidekick" class="headerlink" title="運行 sidekick"></a>運行 sidekick</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">core@coreos ~/demo $ cat &lt;&lt;EOF &gt;apache_discovery@.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=Announce Apache1</span><br><span class="line">BindsTo=apache@%i.service</span><br><span class="line">After=apache@%i.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/bin/sh -c <span class="string">"while true; do etcdctl set /services/website/apache@%i '&#123; \"machine\": \"%m\", \"port\": 80, \"version\": \"52c7248a14\" &#125;' --ttl 60;sleep 45;done"</span></span><br><span class="line">ExecStop=/usr/bin/etcdctl rm /services/website/apache@%i</span><br><span class="line"></span><br><span class="line">[X-Fleet]</span><br><span class="line">MachineOf=apache@%i.service</span><br><span class="line">EOF</span><br><span class="line">core@coreos ~/demo $ cp apache_discovery\@.service apache_discovery\@1.service</span><br><span class="line">core@coreos ~/demo $ cp apache_discovery\@.service apache_discovery\@2.service</span><br><span class="line">core@coreos ~/demo $ ls</span><br><span class="line">apache@.service  apache@1.service  apache@2.service  apache_discovery@.service  apache_discovery@1.service  apache_discovery@2.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 啟動 service discovery</span></span><br><span class="line">core@coreos ~/demo $ fleetctl start apache_discovery@1         </span><br><span class="line">Unit apache_discovery@1.service inactive</span><br><span class="line">Unit apache_discovery@1.service launched on 90c1e40c.../192.168.50.15</span><br><span class="line"><span class="comment"># 啟動 service discovery</span></span><br><span class="line">core@coreos ~/demo $ fleetctl start apache_discovery@2</span><br><span class="line">Unit apache_discovery@2.service inactive</span><br><span class="line">Unit apache_discovery@2.service launched on 72bda158.../192.168.50.16</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">core@coreos ~/demo $ fleetctl list-units</span><br><span class="line">UNITMACHINEACTIVESUB</span><br><span class="line">apache@1.service90c1e40c.../192.168.50.15activerunning</span><br><span class="line">apache@2.service72bda158.../192.168.50.16activerunning</span><br><span class="line">apache_discovery@1.service90c1e40c.../192.168.50.15activerunning</span><br><span class="line">apache_discovery@2.service72bda158.../192.168.50.16activerunning</span><br><span class="line"></span><br><span class="line">core@coreos ~/demo $ etcdctl ls /services/ --recursive</span><br><span class="line">/services/website</span><br><span class="line">/services/website/apache@1</span><br><span class="line">/services/website/apache@2</span><br><span class="line"></span><br><span class="line">core@coreos ~/demo $ etcdctl get /services/website/apache@1</span><br><span class="line">&#123; <span class="string">"machine"</span>: <span class="string">"90c1e40ca1e749abbc23fa8b2391ce27"</span>, <span class="string">"port"</span>: 80, <span class="string">"version"</span>: <span class="string">"52c7248a14"</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="Global-Unit"><a href="#Global-Unit" class="headerlink" title="Global Unit"></a>Global Unit</h2><p>Global Unit 與其他一般的 unit 沒什麼太大差別，只有在 <code>[X-Fleet]</code>區段中多加了 <code>Global=true</code> 設定而已，如此一來這個 system unit 就會在所有機器上執行</p><blockquote><p>若要把 Global Unit 執行在特定幾台機器上，可搭配 Machine Metadata 使用，就可以達到此目的</p></blockquote><h2 id="Machine-Metadata"><a href="#Machine-Metadata" class="headerlink" title="Machine Metadata"></a>Machine Metadata</h2><p>Mechine Metadata 的來源是從 cloud-config 所設定的，設定的語法如下：</p><blockquote><p>metadata=”platform=metal,provider=rackspace,region=east,disk=ssd”</p></blockquote><p>接著 Machine Metadata 會設定在 unit configuration 中，以下是幾個範例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[X-Fleet]</span><br><span class="line">MachineMetadata=disk=ssd</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[X-Fleet]</span><br><span class="line">Conflicts=webapp*</span><br><span class="line">MachineMetadata=provider=rackspace</span><br><span class="line">MachineMetadata=platform=metal</span><br><span class="line">MachineMetadata=region=east</span><br></pre></td></tr></table></figure><hr><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><p><a href="https://coreos.com/os/docs/latest/quickstart.html" target="_blank" rel="noopener">CoreOS Quick Start</a></p></li><li><p><a href="https://coreos.com/etcd/docs/latest/getting-started-with-etcd.html" target="_blank" rel="noopener">Getting Started with etcd on CoreOS</a></p></li><li><p><a href="https://coreos.com/os/docs/latest/getting-started-with-docker.html" target="_blank" rel="noopener">Getting Started with docker</a></p></li><li><p><a href="https://coreos.com/os/docs/latest/getting-started-with-systemd.html" target="_blank" rel="noopener">Getting Started with systemd</a></p></li><li><p><a href="https://coreos.com/fleet/docs/latest/launching-containers-fleet.html" target="_blank" rel="noopener">Launching Containers with fleet</a></p></li><li><p><a href="https://github.com/coreos/unit-examples/tree/master/simple-fleet" target="_blank" rel="noopener">unit-examples/simple-fleet at master · coreos/unit-examples</a></p></li><li><p><a href="https://coreos.com/fleet/docs/latest/unit-files-and-scheduling.html" target="_blank" rel="noopener">fleet - Overview of Unit Files and Scheduling</a></p></li><li><p><a href="https://coreos.com/os/docs/latest/cloud-config.html" target="_blank" rel="noopener">Customize with Cloud-Config</a></p></li><li><p><a href="https://coreos.com/flannel/docs/latest/flannel-config.html" target="_blank" rel="noopener">Configuring flannel Networking for CoreOS</a></p></li><li><p><a href="http://dockone.io/article/618" target="_blank" rel="noopener">DockOne技术分享（十八）：一篇文章带你了解Flannel - DockOne.io</a></p></li></ul>]]></content>
      
      <categories>
          
          <category> CoreOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CoreOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[RHCE7] RH254 Chapter 6 Configuring Email Transmission Learning Notes</title>
      <link href="/blog/2016/05/29/RHCE/RHCE7-RH254-LearningNotes-CH06_ConfiguringEmailTransmission/"/>
      <url>/blog/2016/05/29/RHCE/RHCE7-RH254-LearningNotes-CH06_ConfiguringEmailTransmission/</url>
      <content type="html"><![CDATA[<h1 id="老師補充"><a href="#老師補充" class="headerlink" title="老師補充"></a>老師補充</h1><h2 id="postfix"><a href="#postfix" class="headerlink" title="postfix"></a>postfix</h2><ul><li><p>把功能獨立寫成一個個執行檔(例如：smtpd 收信、smtp 送信)</p></li><li><p>平時這些功能不會啟動，唯有真的要運作時，postfix(稱為 <strong>master</strong>) 才會把該功能叫起來執行後結束</p></li><li><p>可以加入 or 移除 third party 的模組(例如：防毒、防垃圾郵件)</p></li></ul><h2 id="郵件遞送流程"><a href="#郵件遞送流程" class="headerlink" title="郵件遞送流程"></a>郵件遞送流程</h2><ol><li><p>Kevin 寫了一封信給 David，使用 <strong>SMTP</strong> 協定把信送給自己公司的 mail server <strong>Mail_K</strong></p></li><li><p><strong>Mail_K</strong> 會暫時把 mail 放到系統的佇列中(<strong>/var/spool/postfix/*</strong>)</p><blockquote><p>透過 <code>postqueue -p</code> 可以搜尋目前佇列中待處理的 mail</p></blockquote></li><li><p>Kevin 的 mail 會被從佇列取出，並透過 SMTP 協定送給 David 公司的 mail server <strong>Mail_D</strong>，並存於 <strong>/var/spool/postfix/*</strong> 中</p></li><li><p>Mail_D 收完信後，會呼叫程式 <strong>local</strong>，把信件搬移到 <strong>/var/spool/mail</strong> 目錄中，並存成檔名 <strong>david</strong></p></li><li><p>David 可以使用 mail client，透過 <strong>POP3(tcp 110)</strong> or <strong>IMAP(tcp 43)</strong> 協定，把信件取回</p></li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li><p>POP3 會把 mail server 收回來，mail 就不會存在 mail sever 上了</p></li><li><p>IMAP 只用來讀取標題，可以指定讀取特定的信中的內容，從 mail server 複製回來</p></li></ol><h2 id="設定-mail-server"><a href="#設定-mail-server" class="headerlink" title="設定 mail server"></a>設定 mail server</h2><h3 id="架構"><a href="#架構" class="headerlink" title="架構"></a>架構</h3><ol><li><p>serverX 收信</p></li><li><p>desktopX 收信 &amp; 寄信</p></li><li><p>foundation 使用 mail function</p></li></ol><ul><li>模組設定檔：<strong>/etc/postfix/master.cf</strong></li></ul><h3 id="設定-desktopX-mail-sender-smtp0-example-com"><a href="#設定-desktopX-mail-sender-smtp0-example-com" class="headerlink" title="設定 desktopX (mail sender) (smtp0.example.com)"></a>設定 desktopX (mail sender) (smtp0.example.com)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果有多個 ip，表示只會在這兩個 ip 上開啟 tcp port 25(全開寫 all)</span></span><br><span class="line"><span class="comment">#$ sudo postconf -e "inet_interface = 127.0.0.1, 172.25.0.1"</span></span><br><span class="line">$ sudo postconf -e <span class="string">'inet_interface = all'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 郵件地址偽裝</span></span><br><span class="line">$ sudo postconf -e <span class="string">'myorigin = example.com'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ACL (relay controll)</span></span><br><span class="line">$ sudo postconf -e <span class="string">'mynetworks = 127.0.0.0/8, 172.25.0.0/24'</span></span><br><span class="line"></span><br><span class="line">$ sudo systemctl restart postfix.service</span><br></pre></td></tr></table></figure><h3 id="設定-serverX-mail-sender-amp-receiver-imap0-example-com"><a href="#設定-serverX-mail-sender-amp-receiver-imap0-example-com" class="headerlink" title="設定 serverX (mail sender &amp; receiver) (imap0.example.com)"></a>設定 serverX (mail sender &amp; receiver) (imap0.example.com)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo postconf -e <span class="string">'inet_interface = all'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只接收 "@" 之後指定的 domain 的信，例如：只收寄到 xxxx@imap0.example.com 的信</span></span><br><span class="line">$ sudo postconf -e <span class="string">'mydestination = $myhostname, localhost.$mydomain, localhost, server0.example.com'</span></span><br><span class="line"></span><br><span class="line">$ sudo systemctl restart postfix.service</span><br></pre></td></tr></table></figure><h3 id="foundation-發信"><a href="#foundation-發信" class="headerlink" title="foundation 發信"></a>foundation 發信</h3><p>發信流程：<code>user</code> -&gt; <code>sendmail</code> -&gt; <code>Queue</code> -&gt; <code>postfix</code> -&gt; 送出去</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 將信交給 smtp0.example.com 寄送</span></span><br><span class="line">$ sudo postconf -e <span class="string">'relay_host = [smtp0.example.com]'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 避免寄信時 domain 變成 foundation0.example.com</span></span><br><span class="line">$ sudo postconf -e <span class="string">'myorigin = example.com'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 別人寄信過來，信會被退回，後面加上自己設定的字串(local delivery disabled)</span></span><br><span class="line">$ sudo postconf -e <span class="string">'local_transport = error: local delivery disabled'</span></span><br><span class="line"></span><br><span class="line">$ sudo systemctl restart postfix.service</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"THIS IS MAIL TEST"</span> | mail -s <span class="string">"mail test"</span> server0.example.com</span><br></pre></td></tr></table></figure><h2 id="如何在-postfix-上設定-POP3"><a href="#如何在-postfix-上設定-POP3" class="headerlink" title="如何在 postfix 上設定 POP3"></a>如何在 postfix 上設定 POP3</h2><h3 id="設定-POP3-server"><a href="#設定-POP3-server" class="headerlink" title="設定 POP3 server"></a>設定 POP3 server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@server0 ~]<span class="comment"># yum -y install dovecot</span></span><br><span class="line"></span><br><span class="line">[root@server0 ~]<span class="comment"># vim /etc/dovecot/dovecot.conf</span></span><br><span class="line"><span class="comment"># 同時提供 imap &amp; POP3</span></span><br><span class="line">protocols = imap pop3</span><br><span class="line"></span><br><span class="line">[root@server0 ~]<span class="comment"># vim /etc/dovecot/conf.d/10-auth.conf</span></span><br><span class="line"><span class="comment"># 不允許明碼驗證 (建議實務上設定為 yes)</span></span><br><span class="line">disable_plaintext_auth = no</span><br><span class="line"></span><br><span class="line">[root@server0 ~]<span class="comment"># vim /etc/dovecot/conf.d/10-ssl.conf</span></span><br><span class="line"><span class="comment"># 不支援 SSL 加密(實務上建議設定為 required)</span></span><br><span class="line">ssl = no</span><br><span class="line"></span><br><span class="line">[root@server0 ~]<span class="comment"># vim /etc/dovecot/conf.d/10-mail.conf</span></span><br><span class="line"><span class="comment"># 告訴 POP3 server，使用者郵件信箱的路徑</span></span><br><span class="line">mail_localtion = mbox:~/mail:INBOX=/var/mail%u</span><br><span class="line"><span class="comment"># 指定用哪個群組的身份讀取 mail</span></span><br><span class="line">mail_access_groups = mail</span><br><span class="line"></span><br><span class="line">[root@server0 ~]<span class="comment"># systemctl restart dovecot</span></span><br></pre></td></tr></table></figure><h3 id="驗證-POP3"><a href="#驗證-POP3" class="headerlink" title="驗證 POP3"></a>驗證 POP3</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@server0 ~]<span class="comment"># telnet server0 110</span></span><br><span class="line">user student</span><br><span class="line">pass student</span><br><span class="line"><span class="comment"># 列出信件</span></span><br><span class="line">list</span><br><span class="line"><span class="comment"># 取得第一封信件</span></span><br><span class="line">retr 1</span><br><span class="line">quit</span><br></pre></td></tr></table></figure><hr><h1 id="6-1-Configuring-a-Send-only-Email-Configuration"><a href="#6-1-Configuring-a-Send-only-Email-Configuration" class="headerlink" title="6.1 Configuring a Send-only Email Configuration"></a>6.1 Configuring a Send-only Email Configuration</h1><h2 id="6-1-1-Email-architecture-and-null-clients"><a href="#6-1-1-Email-architecture-and-null-clients" class="headerlink" title="6.1.1 Email architecture and null clients"></a>6.1.1 Email architecture and null clients</h2><p>RHEL7 Postfix 提供了 <code>/usr/sbin/sendmail</code> 作為內部發送通知訊息之用。</p><p><code>null client</code> 的工作僅將所有 email 轉送到其他的 mail relay，本章重點在於如何把機器設定為 Postfix null client，藉此透過 <code>sendmail</code> &amp; <code>SMTP</code> 協定將訊息送到外面的 mail server</p><h2 id="6-2-2-Transmission-of-an-email-message"><a href="#6-2-2-Transmission-of-an-email-message" class="headerlink" title="6.2.2 Transmission of an email message"></a>6.2.2 Transmission of an email message</h2><ol><li><p>mail client 透過 <code>SMTP</code> 傳送郵件</p></li><li><p>內部的寄信需求可能不需要認證就可以被接受(relay 的部分則大多會有一些規則上 &amp; 防火牆上的限制)</p></li><li><p>外部的 relay server 會根據目的地 domain 的 <code>MX</code> 紀錄，將信轉過去</p></li><li><p>收信者的 mail server 可能會支援 <code>POP3</code> or <code>IMAP</code> 等協定來將信件取回，也可能提供 web interface 供使用</p></li></ol><h2 id="6-2-3-Postfix"><a href="#6-2-3-Postfix" class="headerlink" title="6.2.3 Postfix"></a>6.2.3 Postfix</h2><p>Postfix 是 RHEL7 預設的 mail server，模組化設計，主要設定檔位於 <code>/etc/postfix/main.cf</code> 中 (設定檔都集中在 <code>/etc/postfix</code> 目錄下)</p><p>以下是比較重要的 Postfix 設定：</p><table><thead><tr><th>Setting</th><th>Purpose</th></tr></thead><tbody><tr><td><code>inet_interfaces</code></td><td>設定監聽流入 &amp; 流出訊息的網路介面。<br><code>loopback-only</code>: 監聽 127.0.0.1 &amp; ::1<br><code>all</code>: 監聽所有網路介面<br>Default: <code>inet_interfaces = localhost</code><br><strong>【註】</strong>若有多個 hostname or ip 需要監聽，則用空白隔開</td></tr><tr><td><code>myorigin</code></td><td>將本地端發出去的 mail domain 改為此台主機<br>Default:<code>myorigin = $myhostname</code></td></tr><tr><td><code>relayhost</code></td><td>將訊息轉到指定的外部 mail relay<br>Default:<code>relayhost =</code></td></tr><tr><td><code>mydestination</code></td><td>設定 mail 的終點，到指定的地方後就會直接進入 local mailbox<br>Default:<code>mydestination = $myhostname, localhost.$mydomain, localhost</code></td></tr><tr><td><code>local_transport</code></td><td>定義到 <strong>mydestination</strong> 的 mail 要怎麼處理<br><code>local:$myhostname</code>：使用 local mail agent 把 mail 存放到 /var/spool/mail 中</td></tr><tr><td><code>mynetworks</code></td><td>允許從這台 mail server 進行 relay 的來源清單(用空白隔開)<br>Default:<code>mynetworks = 127.0.0.0/8 [::1]/128</code></td></tr></tbody></table><p>要變更 Postfix 的行為，使用者可以透過手動修改 <code>/etc/postfix/main.cf</code> 或是透過 <code>postconf</code> 指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 顯示所有設定</span></span><br><span class="line">$ postconf</span><br><span class="line">.....</span><br><span class="line">unverified_sender_reject_reason =</span><br><span class="line">unverified_sender_tempfail_action = <span class="variable">$reject_tempfail_action</span></span><br><span class="line">verp_delimiter_filter = -=+</span><br><span class="line">virtual_alias_domains = <span class="variable">$virtual_alias_maps</span></span><br><span class="line">virtual_alias_expansion_limit = 1000</span><br><span class="line">virtual_alias_maps = <span class="variable">$virtual_maps</span></span><br><span class="line">virtual_alias_recursion_limit = 1000</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="comment"># 僅查詢指定的設定</span></span><br><span class="line">$ postconf inet_interfaces myorigin</span><br><span class="line">inet_interfaces = localhost</span><br><span class="line">myorigin = <span class="variable">$myhostname</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 "-e" 參數修改設定</span></span><br><span class="line">$ sudo postconf -e <span class="string">'myorigin = example.com'</span></span><br><span class="line">$ postconf myorigin</span><br><span class="line">myorigin = example.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要 reload or restart postfix.service 才會生效</span></span><br><span class="line">$ sudo systemctl reload postfix.service</span><br></pre></td></tr></table></figure><blockquote><p>建議直接編輯 <code>/etc/postfix/main.cf</code>，因為參數選項太多不容易記憶，詳細參數說明可參考 <code>postconf(5)</code></p></blockquote><h2 id="6-2-4-Postfix-null-client-configuration"><a href="#6-2-4-Postfix-null-client-configuration" class="headerlink" title="6.2.4 Postfix null client configuration"></a>6.2.4 Postfix null client configuration</h2><p>要把 Postfix 設定成一個標準的 null client，要達到下面幾個要求：</p><ol><li><p>sendmail 是用來將所有 email 轉送到外部的 mail relay 之用</p></li><li><p>local Postfix 不接受處理本地端傳送任何郵件訊息，只會負責 relay 出去</p></li><li><p>使用者可以透過 null client 收發信件</p></li></ol><p>統整之後，一共需要以下設定：</p><table><thead><tr><th>Directive</th><th>Null Client(serverX.example.com)</th></tr></thead><tbody><tr><td><code>inet_interfaces</code></td><td>inet_interfaces=loopback-only</td></tr><tr><td><code>myorigin</code></td><td>myorigin=desktopX.example.com</td></tr><tr><td><code>relayhost</code></td><td>relayhost=[smtpX.example.com]</td></tr><tr><td><code>mydestination</code></td><td>mydestination=</td></tr><tr><td><code>local_transport</code></td><td>local_transport=error: local delivery disabled</td></tr><tr><td><code>mynetworks</code></td><td>mynetworks=127.0.0.0/8, [::1]/128</td></tr></tbody></table><p>因此我們可以透過以下指令設定 null client：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 設定要 relay mail 的主機資訊</span></span><br><span class="line">$ sudo postconf -e <span class="string">"relayhost=[smtpX.example.com]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定監聽介面</span></span><br><span class="line">$ sudo postconf -e <span class="string">"inet_interfaces = loopback-only"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定來自 localhsot 的郵件訊息都由 relay 處理</span></span><br><span class="line">$ sudo postconf -e <span class="string">"mynetworks=127.0.0.0/8 [::1]/128"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改寄信出去所表示的 domain name</span></span><br><span class="line">$ sudo postconf -e <span class="string">"myorigin=desktopX.example.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定 null client 不是郵件的終點位置，避免郵件訊息傳到本機帳號</span></span><br><span class="line">$ sudo postconf -e <span class="string">"mydestination="</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止 local mail delivery</span></span><br><span class="line">$ sudo postconf -e <span class="string">"local_transport=error: local delivery disabled"</span></span><br></pre></td></tr></table></figure><hr><h1 id="Practice-Configuring-Send-only-Email-Service"><a href="#Practice-Configuring-Send-only-Email-Service" class="headerlink" title="Practice: Configuring Send-only Email Service"></a>Practice: Configuring Send-only Email Service</h1><h2 id="目標"><a href="#目標" class="headerlink" title="目標"></a>目標</h2><ol><li><p>將 serverX 設定成 null client</p></li><li><p>將所有的 mail relay 到 <code>smtpX.example.com</code></p></li></ol><blockquote><p>desktopX &amp; serverX 都已經執行 lab 相關指令</p></blockquote><h2 id="實作過程"><a href="#實作過程" class="headerlink" title="實作過程"></a>實作過程</h2><p>1、設定 serverX</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo postconf -e <span class="string">"relayhost=[smtp0.example.com]"</span></span><br><span class="line">$ sudo postconf -e <span class="string">"inet_interfaces=loopback-only"</span></span><br><span class="line">$ sudo postconf -e <span class="string">"mynetworks=127.0.0.0/8 [::1]/128"</span></span><br><span class="line">$ sudo postconf -e <span class="string">"myorigin=desktop0.example.com"</span></span><br><span class="line">$ sudo postconf -e <span class="string">"mydestination="</span></span><br><span class="line">$ sudo postconf -e <span class="string">"local_transport=error: local delivery disabled"</span></span><br><span class="line"></span><br><span class="line">[student@server0 ~]$ sudo systemctl restart postfix.service</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RHCE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH254 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[RHCE7] RH254 Chapter 4 Network Port Security Learning Notes</title>
      <link href="/blog/2016/05/29/RHCE/RHCE7-RH254-LearningNotes-CH04_NetworkPortSecurity/"/>
      <url>/blog/2016/05/29/RHCE/RHCE7-RH254-LearningNotes-CH04_NetworkPortSecurity/</url>
      <content type="html"><![CDATA[<h1 id="4-1-Managing-Firewalld"><a href="#4-1-Managing-Firewalld" class="headerlink" title="4.1 Managing Firewalld"></a>4.1 Managing Firewalld</h1><h2 id="4-1-1-Firewalld-overview"><a href="#4-1-1-Firewalld-overview" class="headerlink" title="4.1.1 Firewalld overview"></a>4.1.1 Firewalld overview</h2><p><code>firewalld.service</code> 在 RHEL7 中目前是預設的防火牆管理用服務，因此也管理了 Linux kernel netfilter。</p><p>但因為 <code>firewalld.service</code> 與舊有的 <code>iptables.service</code>/<code>ip6tables.service</code>/<code>ebtables.service</code> 會衝突，因此兩個陣營建議選一個使用就好，假設若要使用 firewalld，那就使用 <code>systemctl mask</code> 指令把其他的 system unit 停止掉：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl mask iptables.service</span><br><span class="line">ln -s <span class="string">'/dev/null'</span> <span class="string">'/etc/systemd/system/iptables.service'</span></span><br><span class="line"></span><br><span class="line">$ sudo systemctl mask ip6tables.service</span><br><span class="line">ln -s <span class="string">'/dev/null'</span> <span class="string">'/etc/systemd/system/ip6tables.service'</span></span><br><span class="line"></span><br><span class="line">$ sudo systemctl mask ebtables.service</span><br><span class="line">ln -s <span class="string">'/dev/null'</span> <span class="string">'/etc/systemd/system/ebtables.service'</span></span><br></pre></td></tr></table></figure><p>firewalld 將所有進入的流量分為不同的 <code>zone</code> 來看待，每個 zone 都會擁有相對應的一組規則，處理原則就是<strong>先比對到的規則就先處理</strong></p><p>預設的 firewalld zone 如下：</p><table><thead><tr><th>Zone name</th><th>Default configuration</th></tr></thead><tbody><tr><td><code>trusted</code></td><td>允許全部進入的流量</td></tr><tr><td><code>home</code></td><td>1. 允許 <code>ssh</code>, <code>mdns</code>, <code>ipp-client</code>, <code>samba-client</code>, <code>dhcpv6-client</code> 等服務的流量<br>2. 允許與連外相關的進入流量<br>3. 其他所有進入的流量皆拒絕</td></tr><tr><td><code>internal</code></td><td>與 zone <code>home</code> 相同</td></tr><tr><td><code>work</code></td><td>1. 允許 <code>ssh</code>, <code>ipp-client</code>, <code>dhcpv6-client</code> 等服務的流量<br>2. 允許與連外相關的進入流量<br>3. 其他所有進入的流量皆拒絕</td></tr><tr><td><code>public</code></td><td>1. 允許 <code>ssh</code>, <code>dhcpv6-client</code> 等服務的流量<br>2. 允許與連外相關的進入流量<br>3. 其他所有進入的流量皆拒絕<br><strong>4. 是新增 network interface 的 default zone</strong></td></tr><tr><td><code>external</code></td><td>1. 僅允許 <code>ssh</code> 服務的流量<br>2. 允許與連外相關的進入流量<br>3. 其他所有進入的流量皆拒絕<br>4. 所有連外的流量都會偽裝來源(<strong>NAT</strong>)</td></tr><tr><td><code>dmz</code></td><td>1. 僅允許 <code>ssh</code> 服務的流量<br>2. 允許與連外相關的進入流量<br>3. 其他所有進入的流量皆拒絕</td></tr><tr><td><code>block</code></td><td>僅允許與連外相關的進入流量</td></tr><tr><td><code>drop</code></td><td>允許與連外相關的進入流量(<strong>連 ICMP error 都不會回應</strong>)</td></tr></tbody></table><h2 id="4-1-2-Managing-firewalld"><a href="#4-1-2-Managing-firewalld" class="headerlink" title="4.1.2 Managing firewalld"></a>4.1.2 Managing firewalld</h2><h3 id="Configure-firewall-settings-with-firewall-cmd"><a href="#Configure-firewall-settings-with-firewall-cmd" class="headerlink" title="Configure firewall settings with firewall-cmd"></a>Configure firewall settings with firewall-cmd</h3><p>RHEL7 提供 <code>firewall-cmd</code>(console) &amp; <code>firewall-config</code>(GUI) 作為管理防火牆之用。</p><p>透過 firewall-cmd 設定規則，有幾個重點需要注意：</p><ul><li><p>若沒特別指定都只是會只有在 runtime 才有效，重開機就無效了，除非加上 <code>--permanent</code> 選項。</p></li><li><p>指令中都會加上 <code>--zone=&lt;ZONE&gt;</code>，若沒加就會預設為 default zone</p></li><li><p>設定規則一般都會加上 <code>--permanent</code> 選項，並使用 <code>firewall-cmd --reload</code> 來進行永久性的變更套用</p></li><li><p>若只是暫時的測試，可以使用 <code>timeout=&lt;TIMEINSECONDS&gt;</code> 來讓規則短暫在 runtime 時有效</p></li></ul><table><thead><tr><th>firewall-cmd commands</th><th>Explanation</th></tr></thead><tbody><tr><td><code>--get-default-zone</code></td><td>查詢 default zone</td></tr><tr><td><code>--set-default-zone=&lt;ZONE&gt;</code></td><td>設定 dfault zone</td></tr><tr><td><code>--get-zones</code></td><td>列出所有支援的 zone</td></tr><tr><td><code>--get-services</code></td><td>列出所有支援的 service</td></tr><tr><td><code>--add-source=&lt;CIDR&gt;</code> [–zone=<zone>]</zone></td><td>允許來自指定 source 的進入流量</td></tr><tr><td><code>--remove-source=&lt;CIDR&gt;</code> [–zone=<zone>]</zone></td><td>禁止來自特定 source 的進入流量</td></tr><tr><td><code>--add-interface=&lt;INTERFACE&gt; [--zone=&lt;ZONE&gt;]</code></td><td>允許從特定裝置進入的流量</td></tr><tr><td><code>--change-interface=&lt;INTERFACE&gt; [--zone=&lt;ZONE&gt;]</code></td><td>設定指定的 interface 與 zone 關聯</td></tr><tr><td><code>--list-all [--zone=&lt;ZONE&gt;]</code></td><td>列出指定 zone 的所有 interface, source, service, port 等規則</td></tr><tr><td><code>--list-all-zones</code></td><td>取得所有 zone 的設定規則資訊</td></tr><tr><td><code>--add-service=&lt;SERVICE&gt; [--zone=&lt;ZONE&gt;]</code></td><td>允許進入流量到指定的 service</td></tr><tr><td><code>--add-port=&lt;PORT/PROTOCOL&gt; [--zone=&lt;ZONE&gt;]</code></td><td>允許進入流量到指定的 port or protocol</td></tr><tr><td><code>--remove-service=&lt;SERVICE&gt; [--zone=&lt;ZONE&gt;]</code></td><td>禁止進入流量到指定的 service</td></tr><tr><td><code>--remove-port=&lt;PORT/PROTOCOL&gt;</code> [–zone=<zone>]</zone></td><td>禁止進入流量到指定的 port or protocol</td></tr><tr><td><code>--reload</code></td><td>將 runtime 設定變成永久設定<br>(<strong>沒有加上 –permanent 選項的規則會失效</strong>)</td></tr></tbody></table><h3 id="firewall-cmd-example"><a href="#firewall-cmd-example" class="headerlink" title="firewall-cmd example"></a>firewall-cmd example</h3><p>以下用幾個簡單範例，示範使用 firewall-cmd 達成以下設定：(使用 <code>dmz</code> zone)</p><ol><li><p>將 default zone 設定為 <code>dmz</code></p></li><li><p>zone <code>internal</code> 允許來自 192.168.0.0/24 的流量</p></li><li><p>zone <code>internal</code> 允許存取 mysql 服務</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo firewall-cmd --<span class="built_in">set</span>-default-zone=dmz</span><br><span class="line"></span><br><span class="line">$ sudo firewall-cmd --permanent --zone=internal --add-source=192.168.0.0/24</span><br><span class="line"></span><br><span class="line">$ sudo firewall-cmd --perminant --zone=internal --add-service=mysql</span><br><span class="line"></span><br><span class="line">$ sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure><h3 id="Firewall-configuration-files"><a href="#Firewall-configuration-files" class="headerlink" title="Firewall configuration files"></a>Firewall configuration files</h3><p>firewalld 的設定檔放在 <code>/etc/firewalld</code> &amp; <code>/usr/lib/firewalld</code> 目錄下，同樣的設定，放在 <strong>/etc/firewalld</strong> 目錄下的會優先被採用，這是讓管理者可以用來修改原有的預設值之用</p><hr><h1 id="Practice-Configuring-a-Firewall"><a href="#Practice-Configuring-a-Firewall" class="headerlink" title="Practice: Configuring a Firewall"></a>Practice: Configuring a Firewall</h1><h2 id="目標"><a href="#目標" class="headerlink" title="目標"></a>目標</h2><ol><li><p>在 server 上安裝 <code>httpd</code> &amp; <code>mod_ssl</code> 套件，並確認 <code>httpd.service</code> 有啟用且運行中</p></li><li><p>web 首頁顯示 <code>COFFEE</code> 字眼</p></li><li><p>server 上必須啟動 <code>firewalld.service</code></p></li><li><p>在 server 上進行 firewalld 設定，使用 <code>dmz</code> zone 的設定處理未指定的連線</p></li><li><p>來自 <code>172.25.X.0/24</code> 的流量必須導引到 <code>work</code> zone 來處理</p></li><li><p><code>work</code> zone 必須開啟 <code>https</code> 服務所需要的所有 port，而 <code>http</code> 的流量則必須被過濾</p></li></ol><h2 id="實作過程"><a href="#實作過程" class="headerlink" title="實作過程"></a>實作過程</h2><p>安裝 &amp; 設定 httpd.service，並修改首頁：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum -y install httpd mod_ssl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 啟動 httpd.service</span></span><br><span class="line">$ sudo systemctl <span class="built_in">enable</span> httpd.service</span><br><span class="line">ln -s <span class="string">'/usr/lib/systemd/system/httpd.service'</span> <span class="string">'/etc/systemd/system/multi-user.target.wants/httpd.service'</span></span><br><span class="line">$ sudo systemctl start httpd.service</span><br><span class="line"></span><br><span class="line">$ sudo systemctl status httpd.service</span><br><span class="line">httpd.service - The Apache HTTP Server</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled)</span><br><span class="line">   Active: active (running) since Thu 2016-05-26 10:25:01 JST; 5s ago</span><br><span class="line"> Main PID: 29559 (httpd)</span><br><span class="line">   Status: <span class="string">"Processing requests..."</span></span><br><span class="line">   CGroup: /system.slice/httpd.service</span><br><span class="line">           ├─29559 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           ├─29560 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           ├─29561 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           ├─29562 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           ├─29563 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           └─29564 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line"></span><br><span class="line">May 26 10:25:01 server0.example.com systemd[1]: Started The Apache HTTP Server.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改首頁</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"COFFEE"</span> | sudo tee --append /var/www/html/index.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 確認網頁回傳的內容為 COFFEE</span></span><br><span class="line">$ curl http://localhost</span><br><span class="line">COFFEE</span><br></pre></td></tr></table></figure><p>確認 firewalld.service 狀態為啟動中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># firewalld.service 狀態</span></span><br><span class="line">$ sudo systemctl status firewalld.service</span><br><span class="line">firewalld.service - firewalld - dynamic firewall daemon</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/firewalld.service; enabled)</span><br><span class="line">   Active: active (running) since Thu 2016-05-26 09:59:39 JST; 28min ago</span><br><span class="line"> Main PID: 475 (firewalld)</span><br><span class="line">   CGroup: /system.slice/firewalld.service</span><br><span class="line">           └─475 /usr/bin/python -Es /usr/sbin/firewalld --nofork --nopid</span><br><span class="line"></span><br><span class="line">May 26 09:59:39 localhost systemd[1]: Started firewalld - dynamic firewall daemon.</span><br><span class="line"></span><br><span class="line"><span class="comment"># iptables.service 狀態</span></span><br><span class="line">$ sudo systemctl status iptables.service</span><br><span class="line">iptables.service - IPv4 firewall with iptables</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/iptables.service; disabled)</span><br><span class="line">   Active: inactive (dead)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ip6tables.service 狀態</span></span><br><span class="line">$ sudo systemctl status ip6tables.service</span><br><span class="line">ip6tables.service - IPv6 firewall with ip6tables</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/ip6tables.service; disabled)</span><br><span class="line">   Active: inactive (dead)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ebtables.service 狀態</span></span><br><span class="line">$ sudo systemctl status ebtables.service</span><br><span class="line">ebtables.service - Ethernet Bridge Filtering tables</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/ebtables.service; disabled)</span><br><span class="line">   Active: inactive (dead)</span><br></pre></td></tr></table></figure><p>設定 <code>dmz</code> zone 處理為指定連線：(即是設定為預設的 zone)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo firewall-cmd --<span class="built_in">set</span>-default-zone=dmz</span><br><span class="line">success</span><br></pre></td></tr></table></figure><p>來自 <code>172.25.X.0/24</code> 的流量必須導引到 <code>work</code> zone 來處理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo firewall-cmd --permanent --zone=work --add-source=172.25.X.0/24</span><br></pre></td></tr></table></figure><p><code>work</code> zone 必須開啟 <code>https</code> 服務所需要的所有 port，而 <code>http</code> 的流量則必須被過濾：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo firewall-cmd --permanent --zone=work --add-service=https</span><br></pre></td></tr></table></figure><p>套用 &amp; 檢查設定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ sudo firewall-cmd --reload</span><br><span class="line">success</span><br><span class="line"></span><br><span class="line">$ sudo firewall-cmd --get-default-zone</span><br><span class="line">dmz</span><br><span class="line"></span><br><span class="line">$ sudo firewall-cmd --get-active-zones</span><br><span class="line">dmz</span><br><span class="line">  interfaces: eth0</span><br><span class="line">work</span><br><span class="line">  sources: 172.25.X.0/24</span><br><span class="line">ROL</span><br><span class="line">  sources: 172.25.0.252/32</span><br><span class="line"></span><br><span class="line">$ sudo firewall-cmd --zone=work --list-all</span><br><span class="line">work</span><br><span class="line">  interfaces:</span><br><span class="line">  sources: 172.25.X.0/24</span><br><span class="line">  services: dhcpv6-client https ipp-client ssh</span><br><span class="line">  ports:</span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports:</span><br><span class="line">  icmp-blocks:</span><br><span class="line">  rich rules:</span><br></pre></td></tr></table></figure><p>最後，從 desktop 查詢：<code>curl -k https://serverX</code></p><hr><h1 id="4-2-Managing-Rich-Rules"><a href="#4-2-Managing-Rich-Rules" class="headerlink" title="4.2 Managing Rich Rules"></a>4.2 Managing Rich Rules</h1><h2 id="4-2-1-Rich-rules-concepts"><a href="#4-2-1-Rich-rules-concepts" class="headerlink" title="4.2.1 Rich rules concepts"></a>4.2.1 Rich rules concepts</h2><p>除了 firewalld 原生支援的 zone &amp; service 之外，使用者還可以透過 <code>direct rules</code> &amp; <code>rich rules</code> 兩種機制來自訂規則</p><h3 id="Direct-rules"><a href="#Direct-rules" class="headerlink" title="Direct rules"></a>Direct rules</h3><p>顧名思義，這種機制就是為了相容 {ip,ip6,eb}tables rule 所產生出來的，若已經有既有的 rules，可透過此機制加入到 firewalld 的管理下，詳細的設定可以參考 <code>firewall-cmd(1)</code> &amp; <code>firewalld.direct(5)</code></p><h3 id="Rich-rules"><a href="#Rich-rules" class="headerlink" title="Rich rules"></a>Rich rules</h3><p>這就是全新給 firewalld 使用的客製化 rule 機制，除了規則之外，還可以設定 logging 的機制(使用 <code>syslog</code> &amp; <code>auditd</code>)，甚至連 port forwards, masquerading, rate limiting 等功能都可以設定。</p><p>rich rule 的設定基本語法架構如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rule</span><br><span class="line">    [<span class="built_in">source</span>]</span><br><span class="line">    [destination]</span><br><span class="line">    service|port|protocol|icmp-block|masquerade|forward-port</span><br><span class="line">    [<span class="built_in">log</span>]</span><br><span class="line">    [audit]</span><br><span class="line">    [accept|reject|drop]</span><br></pre></td></tr></table></figure><blockquote><p>完整的 rich rule 設定語法可以參考 <code>firewalld.richlanguage(5)</code></p></blockquote><h3 id="Rule-ordering"><a href="#Rule-ordering" class="headerlink" title="Rule ordering"></a>Rule ordering</h3><p>當規則多起來時，順序的問題就很重要了，順序如下：</p><ol><li><p>任何與 port forwarding &amp; masquerading 相關的規則</p></li><li><p>任何 logging 相關的規則</p></li><li><p>任何放行的規則</p></li><li><p>任何禁止的規則</p></li></ol><p>基本上，先比對到的規則就會先使用，都沒相符的規則就使用預設的規則，而每個 zone 都會有不同的預設規則。</p><p>不過 direct rule 會是例外，direct rule 會在 firewalld 開始過濾前就會先執行。</p><h3 id="Test-and-debugging"><a href="#Test-and-debugging" class="headerlink" title="Test and debugging"></a>Test and debugging</h3><p>為了測試與 debug 的方便，幾乎所有加入到 runtime 設定的規則都可以額外加上 <code>timeout</code> 的設定，時間到就會自動移除，之後確認沒問題就可以改用 <code>--permanent</code> 讓設定永久生效</p><h2 id="4-2-2-Working-with-rich-rules"><a href="#4-2-2-Working-with-rich-rules" class="headerlink" title="4.2.2 Working with rich rules"></a>4.2.2 Working with rich rules</h2><p>firewall-cmd 有 4 個選項用來處理 rich rule 之用，這些選項都可以搭配 <code>--permanent</code> &amp; <code>--zone</code> 使用：</p><ul><li><p><code>--add-rich-rule=&#39;&lt;RULE&gt;&#39;</code>新增規則</p></li><li><p><code>--remove-rich-rule=&#39;&lt;RULE&gt;&#39;</code>：移除規則</p></li><li><p><code>--query-rich-rule-&#39;&lt;RULE&gt;&#39;</code>：查詢規則是否有被加入到指定的 zone(or default zone)，回傳 0 表示有，1 則是沒有</p></li><li><p><code>--list-rich-rules</code>：顯示所有規則 (也可以用 <code>--list-all</code> or <code>--list-all-zones</code> 檢視所有規則)</p></li></ul><p>以下為一些簡單範例：(以下權限以 root 身份執行)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># default zone = public</span></span><br><span class="line">[root@server ~]<span class="comment"># firewall-cmd --get-default-zone</span></span><br><span class="line">public</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 zone "work" 中設定拒絕來自 192.168.0.11 的流量，永久生效</span></span><br><span class="line"><span class="comment"># family 可以省略</span></span><br><span class="line">[root@server ~]<span class="comment"># firewall-cmd --permanent --zone=work --add-rich-rule='rule family=ipv4 source address=192.168.0.11/32 reject'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 default zone 中，允許每分鐘能有兩個 ftp 連線產生</span></span><br><span class="line">[root@server ~]<span class="comment"># firewall-cmd --add-rich-rule='rule service name=ftp limit value=2/m accept'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 default zone 中，丟棄 IPSec esp 協定的所有封包</span></span><br><span class="line"><span class="comment"># reject 會送 ICMP 回 client，但 drop 則丟棄後完全不回應(因此 drop 會常用在已知的惡意網路段上)</span></span><br><span class="line">[root@server ~]<span class="comment"># firewall-cmd --permanent --add-rich-rule='rule protocol value=esp drop'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 zone "work" 中，設定允許來自 192.168.1.0/24 網段的流量，進入 tcp port 7900-7905</span></span><br><span class="line">[root@server ~]<span class="comment"># firewall-cmd --permanent --zone=work --add-rich-rule='rule family=ipv4 source address=192.168.1.0/24 port port=7900-7905 protocol=tcp accept'</span></span><br></pre></td></tr></table></figure><h2 id="4-2-3-Loggind-with-rich-rules"><a href="#4-2-3-Loggind-with-rich-rules" class="headerlink" title="4.2.3 Loggind with rich rules"></a>4.2.3 Loggind with rich rules</h2><p>logging 的功能很適合用在 debug or monitor 的需求上，firewalld 可以使用 <code>syslog</code>，也可以將訊息送給 <code>auditd</code>；此外，還可以設定 rate limit，避免 log 爆量產生塞滿硬碟</p><p>若要搭配 <code>syslog</code>，使用下面語法：(其中 Log Level 有 <code>emerg</code>, <code>alert</code>, <code>crit</code>, <code>error</code>, <code>warning</code>, <code>notice</code>, <code>info</code>, <code>debug</code> 幾種可用)</p><blockquote><p>log [prefix=”<prefix text="">“] [level=<log level="">] [limit value=”&lt;RATE/DURATION&gt;”]</log></prefix></p></blockquote><p>若搭配 <code>auditd</code>，則使用下列語法：</p><blockquote><p>audit [limit value=”&lt;RATE/DURATION&gt;”]</p></blockquote><p>以下是則是設定 logging 功能相關的範例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 zone "work" 中，設定允許 ssh 的流量</span></span><br><span class="line"><span class="comment"># 搭配 syslog 記錄(prefix="ssh ", level="notice", 一分鐘最多三筆資料)</span></span><br><span class="line">[root@server ~]<span class="comment"># firewall-cmd --permanent --zone=work --add-rich-rule 'rule service name="ssh" log prefix="ssh " level="notice" limit value="3/m" accept'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 default zone 中，拒絕來自 ipv6 "2001:db8::/64" 網段到達 dns 服務的流量</span></span><br><span class="line"><span class="comment"># 搭配 auditd，每個小時最多一筆紀錄</span></span><br><span class="line"><span class="comment"># 此規則在 300 秒後會自動失效</span></span><br><span class="line">[root@server ~]<span class="comment"># firewall-cmd --add-rich-rule='rule family=ipv6 source address="2001:db8::/64" service name="dns" audit limit value="1/h" reject' --timeout=300</span></span><br></pre></td></tr></table></figure><hr><h1 id="Practice-Writing-Custom-Rules"><a href="#Practice-Writing-Custom-Rules" class="headerlink" title="Practice: Writing Custom Rules"></a>Practice: Writing Custom Rules</h1><h2 id="目標-1"><a href="#目標-1" class="headerlink" title="目標"></a>目標</h2><ol><li><p>server 安裝 <code>web server</code> 要讓 desktop 可以連</p></li><li><p>限定<code>最多每秒三筆 log 記錄</code>，且 log 記錄開頭必須為 <code>NEW HTTP</code></p></li></ol><h2 id="實作過程-1"><a href="#實作過程-1" class="headerlink" title="實作過程"></a>實作過程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum -y install httpd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定首頁</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"NEW HTTP"</span> | sudo tee /var/www/html/index.html</span><br><span class="line">NEW HTTP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 啟動 web server</span></span><br><span class="line">$ sudo systemctl <span class="built_in">enable</span> httpd.service</span><br><span class="line">ln -s <span class="string">'/usr/lib/systemd/system/httpd.service'</span> <span class="string">'/etc/systemd/system/multi-user.target.wants/httpd.service'</span></span><br><span class="line">$ sudo systemctl start httpd.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 確認本機服務正常 (此時 desktop 無法連入)</span></span><br><span class="line">$ curl http://localhost</span><br><span class="line">NEW HTTP</span><br><span class="line"></span><br><span class="line">[root@server ~]<span class="comment"># firewall-cmd --permanent --add-rich-rule='rule family=ipv4 source address=172.25.0.10/32 service name="http" log level=notice prefix="NEW HTTP " limit value="3/s" accept'</span></span><br><span class="line">[root@server ~]<span class="comment"># firewall-cmd --reload</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###### dekstop 連入一次 ######</span></span><br><span class="line">[root@server ~]<span class="comment"># tail /var/log/messages</span></span><br><span class="line">.......</span><br><span class="line">May 27 16:41:23 localhost kernel: NEW HTTP IN=eth0 OUT= MAC=52:54:00:00:00:0b:52:54:00:00:00:0a:08:00 SRC=172.25.0.10 DST=172.25.0.11 LEN=60 TOS=0x00 PREC=0x00 TTL=64 ID=55651 DF PROTO=TCP SPT=49712 DPT=80 WINDOW=14600 RES=0x00 SYN URGP=0</span><br></pre></td></tr></table></figure><hr><h1 id="4-3-Masquerading-and-Port-Forwarding"><a href="#4-3-Masquerading-and-Port-Forwarding" class="headerlink" title="4.3 Masquerading and Port Forwarding"></a>4.3 Masquerading and Port Forwarding</h1><p>firewalld 也支援了 <code>masquerading</code>(<strong>SNAT</strong>, 稍有差異) &amp; <code>port forwarding</code>(<strong>DNAT</strong>) 兩種 NAT 模式</p><h2 id="4-3-1-Masquerading"><a href="#4-3-1-Masquerading" class="headerlink" title="4.3.1 Masquerading"></a>4.3.1 Masquerading</h2><p>設定 masquerading 的方式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 將此機器設定為 zone "work" 的 NAT</span></span><br><span class="line">[root@server ~]<span class="comment"># firewall-cmd --permanent --zone=work --add-masquerade</span></span><br></pre></td></tr></table></figure><p>也可以使用 rich rule 設定較為複雜的規則：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 zone "work" 中，將此機器設定為來源為 192.168.0.0/24 的 NAT</span></span><br><span class="line">[root@server ~]<span class="comment"># firewall-cmd --permanent --zone=work --add-rich-rule 'rule family=ipv4 source address=192.168.0.0/24 masquerade'</span></span><br></pre></td></tr></table></figure><h2 id="4-3-2-Port-forwarding"><a href="#4-3-2-Port-forwarding" class="headerlink" title="4.3.2 Port forwarding"></a>4.3.2 Port forwarding</h2><p>設定 port forwarding 的語法如下：</p><blockquote><p>firewall-cmd –permanent –zone=\&lt;ZONE> –add-forward-port=port=\<port number\="">:proto=\&lt;PROTOCOL>[:toport=\&lt;PORTNUMBER>] [:toaddr=\&lt;IPADDR>]</port></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 zone "public" 中，將到達 tcp:513 的流量導向 192.168.0.254:132</span></span><br><span class="line">[root@server ~]<span class="comment"># firewall-cmd --permanent --zone=public --add-forward-port=port=513:proto=tcp:toport=132:toaddr=192.168.0.254</span></span><br></pre></td></tr></table></figure><p>也可以使用 rich rule 設定較為複雜的規則：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 zone "work" 中，將來自 192.168.0.0/26，且到 tcp:80 的流量，導向 tcp:8080</span></span><br><span class="line">[root@server ~]<span class="comment">#  firewall-cmd --permanent --zone=work --add-rich-rule='rule family=ipv4 source address=192.168.0.0/26 forward-port port=80 protocol=tcp to-port=8080'</span></span><br></pre></td></tr></table></figure><hr><h1 id="Practice-Forwarding-a-port"><a href="#Practice-Forwarding-a-port" class="headerlink" title="Practice: Forwarding a port"></a>Practice: Forwarding a port</h1><h2 id="目標-2"><a href="#目標-2" class="headerlink" title="目標"></a>目標</h2><p>將來自 172.25.0.10/32　的 <code>tcp port 443</code> <code>ssh</code> 連線流量轉到 <code>tcp port 22</code></p><h2 id="實作過程-2"><a href="#實作過程-2" class="headerlink" title="實作過程"></a>實作過程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server ~]<span class="comment"># firewall-cmd --permanent --add-rich-rule='rule family=ipv4 source address=172.25.0.10/32 forward-port port=443 protocol=tcp to-port=22'</span></span><br><span class="line">[root@server ~]<span class="comment"># firewall-cmd --reload</span></span><br></pre></td></tr></table></figure><hr><h1 id="4-4-Managing-SELinux-Port-Labeling"><a href="#4-4-Managing-SELinux-Port-Labeling" class="headerlink" title="4.4 Managing SELinux Port Labeling"></a>4.4 Managing SELinux Port Labeling</h1><p>要確保服務可以正常運行，就要確定 network port 擁有正確的 SELinux type　來與服務搭配才可以</p><h2 id="4-4-1-SELinux-port-labeling"><a href="#4-4-1-SELinux-port-labeling" class="headerlink" title="4.4.1 SELinux port labeling"></a>4.4.1 SELinux port labeling</h2><p>不僅是 file &amp; process，連 network traffic 都屬於 SELinux 的管理範圍內，舉例來說：<code>22/tcp</code> 就有一個 <code>ssh_port_t</code> 的 label 與其相關</p><p>因此當一個 process 要監聽某一個 port 時，SELinux 會去檢查 port 有沒有相對應的 label 可供 process 進行 binding，若沒有則 process 會無法正常監聽指定的 port；這功能可以防範不正常的 process 使用到一般服務的 port</p><h2 id="4-4-2-Managing-SELinux-port-labeling"><a href="#4-4-2-Managing-SELinux-port-labeling" class="headerlink" title="4.4.2 Managing SELinux port labeling"></a>4.4.2 Managing SELinux port labeling</h2><h3 id="Listing-port-labels"><a href="#Listing-port-labels" class="headerlink" title="Listing port labels"></a>Listing port labels</h3><p>需要調整 label 通常是因為管理者要讓服務監聽一個非標準的 port 上，以下指令可以列出目前系統中已經存在的 SELinux port type：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sudo semanage port -l</span><br><span class="line"></span><br><span class="line">SELinux Port Type              Proto    Port Number</span><br><span class="line">.........</span><br><span class="line">amavisd_send_port_t            tcp      10025</span><br><span class="line">amqp_port_t                    tcp      5671-5672</span><br><span class="line">amqp_port_t                    udp      5671-5672</span><br><span class="line">aol_port_t                     tcp      5190-5193</span><br><span class="line">.........</span><br></pre></td></tr></table></figure><h3 id="Managing-port-labels"><a href="#Managing-port-labels" class="headerlink" title="Managing port labels"></a>Managing port labels</h3><p>RHEL7 中提供 <code>semanage</code> 指令可用來修改 SELinux port type，指令類似如下：</p><blockquote><p>sudo semanage port -a -t PORT_LABEL -p tcp|udp PORT_NUMBER</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允許 gopher service 監聽 tcp port 71</span></span><br><span class="line">$ sudo semanage port -a -t gopher_port_t -p tcp 71</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 port lebel 為 http_port_t</span></span><br><span class="line">$ sudo semanage port -m -t http_port_t -p tcp 71</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除 port label</span></span><br><span class="line">$ sudo semanage port -d -t http_port_t -p tcp 71</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>詳細的 SELinux 參考文件可透過安裝 <code>selinux-policy-devel</code> 套件取得：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum -y install selinux-policy-devel</span><br><span class="line">$ sudo mandb</span><br><span class="line">$ man -k _selinux</span><br></pre></td></tr></table></figure><hr><h1 id="Practice-Managing-SELinux-Port-Labeling"><a href="#Practice-Managing-SELinux-Port-Labeling" class="headerlink" title="Practice: Managing SELinux Port Labeling"></a>Practice: Managing SELinux Port Labeling</h1><h2 id="目標-3"><a href="#目標-3" class="headerlink" title="目標"></a>目標</h2><ol><li><p>確保 <code>httpd.service</code> 啟用且執行</p></li><li><p>web server 監聽 <code>82/tcp</code></p></li></ol><h2 id="實作過程-3"><a href="#實作過程-3" class="headerlink" title="實作過程"></a>實作過程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新增 port type label</span></span><br><span class="line">$ sudo semanage port -a -t http_port_t -p tcp 82</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新啟動 httpd.service</span></span><br><span class="line">[student@server0 ~]$ sudo systemctl <span class="built_in">enable</span> httpd.service</span><br><span class="line">[student@server0 ~]$ sudo systemctl restart httpd.service</span><br><span class="line">[student@server0 ~]$ sudo systemctl status httpd.service</span><br><span class="line">httpd.service - The Apache HTTP Server</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled)</span><br><span class="line">   Active: active (running) since Sat 2016-05-28 10:43:14 JST; 2s ago</span><br><span class="line"> Main PID: 2080 (httpd)</span><br><span class="line">   Status: <span class="string">"Processing requests..."</span></span><br><span class="line">   CGroup: /system.slice/httpd.service</span><br><span class="line">           ├─2080 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           ├─2081 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           ├─2082 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           ├─2083 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           ├─2084 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           └─2085 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line"></span><br><span class="line">May 28 10:43:14 server0.example.com systemd[1]: Started The Apache HTTP Server.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 root 身分新增 firewall 設定</span></span><br><span class="line">[root@server ~]<span class="comment"># firewall-cmd --permanent --add-port=82/tcp</span></span><br><span class="line">[root@server ~]<span class="comment"># firewall-cmd --reload</span></span><br></pre></td></tr></table></figure><hr><h1 id="Lab-Network-Port-Security"><a href="#Lab-Network-Port-Security" class="headerlink" title="Lab: Network Port Security"></a>Lab: Network Port Security</h1><h2 id="目標-4"><a href="#目標-4" class="headerlink" title="目標"></a>目標</h2><ol><li><p>讓 <code>sshd.service</code> 同時監聽兩個 port(<code>22/tcp</code> &amp; <code>999/tcp</code>)</p></li><li><p>來自 <code>172.25.0.0/24</code> 的流量可以允許進入 zone <code>work</code></p></li><li><p><code>22/tcp</code> &amp; <code>999/tcp</code> 在 zone <code>work</code> 中必須都要能夠使用</p></li></ol><h2 id="實作過程-4"><a href="#實作過程-4" class="headerlink" title="實作過程"></a>實作過程</h2><p>檢查 sshd.service 狀態：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl status sshd.service</span><br><span class="line">sshd.service - OpenSSH server daemon</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/sshd.service; enabled)</span><br><span class="line">   Active: active (running) since Sat 2016-05-28 10:48:41 JST; 2min 6s ago</span><br><span class="line">  Process: 1742 ExecStartPre=/usr/sbin/sshd-keygen (code=exited, status=0/SUCCESS)</span><br><span class="line"> Main PID: 1743 (sshd)</span><br><span class="line">   CGroup: /system.slice/sshd.service</span><br><span class="line">           └─1743 /usr/sbin/sshd -D</span><br><span class="line"></span><br><span class="line">May 28 10:48:41 server0.example.com systemd[1]: Starting OpenSSH server daemon...</span><br><span class="line">May 28 10:48:41 server0.example.com systemd[1]: Started OpenSSH server daemon.</span><br><span class="line">May 28 10:48:41 server0.example.com sshd[1743]: error: Bind to port 999 on 0.0.0.0 failed: Permission denied.</span><br><span class="line">May 28 10:48:41 server0.example.com sshd[1743]: error: Bind to port 999 on :: failed: Permission denied.</span><br><span class="line">May 28 10:48:41 server0.example.com sshd[1743]: Server listening on 0.0.0.0 port 22.</span><br><span class="line">May 28 10:48:41 server0.example.com sshd[1743]: Server listening on :: port 22.</span><br><span class="line">May 28 10:48:42 server0.example.com python[1747]: SELinux is preventing /usr/sbin/sshd from name_bind access on the tcp_socket .</span><br><span class="line"></span><br><span class="line">                                                  *****  Plugin bind_ports (92.2 confidence) suggests   ************************...</span><br><span class="line">May 28 10:48:42 server0.example.com python[1747]: SELinux is preventing /usr/sbin/sshd from name_bind access on the tcp_socket .</span><br><span class="line"></span><br><span class="line">                                                  *****  Plugin bind_ports (92.2 confidence) suggests   ************************...</span><br><span class="line">Hint: Some lines were ellipsized, use -l to show <span class="keyword">in</span> full.</span><br></pre></td></tr></table></figure><p>加入 port label for sshd.service：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@server ~]<span class="comment"># semanage port -a -t ssh_port_t -p tcp 999</span></span><br><span class="line">[root@server ~]<span class="comment"># systemctl reload sshd.service</span></span><br><span class="line">[root@server ~]<span class="comment"># systemctl status sshd.service</span></span><br><span class="line">sshd.service - OpenSSH server daemon</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/sshd.service; enabled)</span><br><span class="line">   Active: active (running) since Sat 2016-05-28 11:10:17 JST; 2min 51s ago</span><br><span class="line">  Process: 2225 ExecReload=/bin/<span class="built_in">kill</span> -HUP <span class="variable">$MAINPID</span> (code=exited, status=0/SUCCESS)</span><br><span class="line">  Process: 1708 ExecStartPre=/usr/sbin/sshd-keygen (code=exited, status=0/SUCCESS)</span><br><span class="line"> Main PID: 1710 (sshd)</span><br><span class="line">   CGroup: /system.slice/sshd.service</span><br><span class="line">           └─1710 /usr/sbin/sshd -D</span><br><span class="line"></span><br><span class="line">May 28 11:10:17 server0.example.com sshd[1710]: Server listening on :: port 22.</span><br><span class="line">May 28 11:10:18 server0.example.com python[1713]: SELinux is preventing /usr/sbin/sshd from name_bind access on the tcp_socket .</span><br><span class="line"></span><br><span class="line">                                                  *****  Plugin bind_ports (92.2 confidence) suggests   ************************...</span><br><span class="line">May 28 11:10:18 server0.example.com python[1713]: SELinux is preventing /usr/sbin/sshd from name_bind access on the tcp_socket .</span><br><span class="line"></span><br><span class="line">                                                  *****  Plugin bind_ports (92.2 confidence) suggests   ************************...</span><br><span class="line">May 28 11:13:03 server0.example.com systemd[1]: Reloading OpenSSH server daemon.</span><br><span class="line">May 28 11:13:04 server0.example.com sshd[1710]: Received SIGHUP; restarting.</span><br><span class="line">May 28 11:13:04 server0.example.com systemd[1]: Reloaded OpenSSH server daemon.</span><br><span class="line">May 28 11:13:04 server0.example.com sshd[1710]: Server listening on 0.0.0.0 port 999.</span><br><span class="line">May 28 11:13:04 server0.example.com sshd[1710]: Server listening on :: port 999.</span><br><span class="line">May 28 11:13:04 server0.example.com sshd[1710]: Server listening on 0.0.0.0 port 22.</span><br><span class="line">May 28 11:13:04 server0.example.com sshd[1710]: Server listening on :: port 22.</span><br><span class="line">Hint: Some lines were ellipsized, use -l to show <span class="keyword">in</span> full.</span><br></pre></td></tr></table></figure><p>放行相關的防火牆：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@server ~]<span class="comment"># firewall-cmd --permanent --zone=work --add-source=172.25.0.0/24</span></span><br><span class="line">[root@server ~]<span class="comment"># firewall-cmd --permanent --zone=work --add-port=999/tcp</span></span><br><span class="line">[root@server ~]<span class="comment"># firewall-cmd --reload</span></span><br></pre></td></tr></table></figure><hr><h1 id="老師補充-iptables"><a href="#老師補充-iptables" class="headerlink" title="老師補充(iptables)"></a>老師補充(iptables)</h1><ul><li><p>Linux 防火牆叫做 <strong>netfilter</strong></p></li><li><p>Linux 把很多功能獨立出來成一個一個小檔案，可以到 <strong>/lib/modules/<kernel version="">/kernel/</kernel></strong> 目錄下找 <code>*.ko</code> 的檔案</p></li></ul><blockquote><p>在上面的目錄的 <code>netfilter</code> / <code>ipv4</code> / <code>ipv6</code> 等資料夾下，都是跟網路有關的模組，可參考 <a href="http://www.netfilter.org" target="_blank" rel="noopener">http://www.netfilter.org</a> 尋找 <code>extention howto</code> 文件，查詢 ko 的使用方式</p></blockquote><h2 id="1、netfilter-tables"><a href="#1、netfilter-tables" class="headerlink" title="1、netfilter tables"></a>1、netfilter tables</h2><p>主要有五個 table：</p><ol><li><p><strong>filter</strong>：主要防火牆的功能</p></li><li><p><strong>nat</strong>：IP 分享器的功能進到主機之後，就直接轉出去的封包，歸類為 FORWARD (例如：本機為 router)</p></li><li><p><strong>mangle</strong>：可對封包的內容小幅度的修改(例如：TTL，可偽裝成不同的作業系統)</p></li><li><p><strong>raw</strong>：調整連線追蹤的功能，可以指定某些電腦不做連線追蹤</p></li><li><p><strong>security</strong></p></li></ol><h3 id="1-1-filter-chains"><a href="#1-1-filter-chains" class="headerlink" title="1.1 filter chains"></a>1.1 filter chains</h3><ul><li><p><strong>INPUT</strong>：從外面進來，目的地為本機應用程式的封包，歸類為 INPUT</p></li><li><p><strong>FORWARD</strong>：進到主機之後，就直接轉出去的封包，歸類為 FORWARD (例如：本機為 router)</p></li><li><p><strong>OUTPUT</strong>：本機的應用程式，目的地是外面主機的封包，歸類為 OUTPUT</p></li></ul><blockquote><p>Linux netfilter 架構：<code>table</code> -&gt; <code>chain</code> -&gt; <code>rule</code></p></blockquote><blockquote><p>chain default policy：只有 <code>ACCEPT</code> &amp; <code>DROP</code> 兩種，完全沒動過就會是 ACCEPT</p></blockquote><h3 id="1-2-連線追蹤-使用-state-模組"><a href="#1-2-連線追蹤-使用-state-模組" class="headerlink" title="1.2 連線追蹤(使用 state 模組)"></a>1.2 連線追蹤(使用 state 模組)</h3><p>狀態分為四種：</p><ol><li><p><strong>NEW</strong>：所有連線的第一個封包狀態，皆為 NEW</p></li><li><p><strong>ESTABLISHED</strong>：當封包穿越了 FW，這條連線的後續封包狀態都會變成 ESTABLISHED</p></li><li><p><strong>RELATED</strong>：因為主動產生的連線而發生的其他類型封包</p></li><li><p><strong>INVALID</strong>：狀態不明的封包，建議一律丟棄</p></li></ol><h3 id="1-3-iptables-他使用上的注意事項"><a href="#1-3-iptables-他使用上的注意事項" class="headerlink" title="1.3 iptables 他使用上的注意事項"></a>1.3 iptables 他使用上的注意事項</h3><ul><li><p>若要阻擋特定其他使用上的注意事項</p></li><li><p>若要阻擋特定網路流量，對內使用 <strong>REJECT</strong>、對外使用 <strong>DROP</strong></p></li><li><p><code>--dport 80</code>：destination port = 80</p></li><li><p><code>-i eth0</code>：incoming interface = eth0</p></li><li><p><code>-o eth1</code>：outgoing interface = eth1</p></li><li><p>為了避免影響 loopback interface，不建議設定 chain default policy，而是加上 <code>iptables -t filter -A INPUT -i eth0 -j DROP</code> 到最後一條規則</p></li><li><p><code>iptables -L -v -n</code>：可看出那一條規則比較熱門</p></li></ul><h2 id="2、NAT-種類"><a href="#2、NAT-種類" class="headerlink" title="2、NAT 種類"></a>2、NAT 種類</h2><ul><li><p>把來源端 ip 換掉的 NAT，稱為 <strong>SNAT</strong> (POSTROUTING chain 的任務)</p></li><li><p>把目的端 ip 換掉的 NAT，稱為 <strong>DNAT</strong> (PREROUTING chain 的任務)</p></li><li><p>本機產生的封包，原本僅能有 SNAT，而 nat OUTPUT chain 是要補足 DNAT 的功能</p></li><li><p>要作 NAT 必須開啟 port forward 功能：<code>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</code></p></li></ul><h2 id="3、iptables-使用方式"><a href="#3、iptables-使用方式" class="headerlink" title="3、iptables 使用方式"></a>3、iptables 使用方式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@server0 /]<span class="comment"># systemctl disable firewalld</span></span><br><span class="line">[root@server0 /]<span class="comment"># systemctl stop firewalld</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># List chains of filter table (可以看 chain default rule)</span></span><br><span class="line">[root@server0 /]<span class="comment"># iptables -t filter -L</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Append rule to chain FORWARD</span></span><br><span class="line"><span class="comment"># -p：指定 protocol，可參考 /etc/protocols</span></span><br><span class="line"><span class="comment"># -s：source</span></span><br><span class="line">[root@server0 /]<span class="comment"># iptables -t filter -A FORWARD -p tcp -s 172.25.254.250 -j ACCEPT</span></span><br><span class="line">[root@server0 /]<span class="comment"># iptables -t filter -A FORWARD -p udp -s 172.25.254.250 -j ACCEPT</span></span><br><span class="line">[root@server0 /]<span class="comment"># iptables -t filter -A FORWARD -p icmp -s 172.25.254.250 -j ACCEPT</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -n：以數字方式表示</span></span><br><span class="line"><span class="comment"># --line-number：顯示第幾條規則</span></span><br><span class="line">[root@server0 /]<span class="comment"># iptables -t filter -L -n --line-number</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定 chain default rule</span></span><br><span class="line">[root@server0 /]<span class="comment"># iptables -t filter -P INPUT DROP</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除 chain rules</span></span><br><span class="line">[root@server0 /]<span class="comment"># iptables -t filter -F</span></span><br></pre></td></tr></table></figure><h2 id="4、基本操作練習"><a href="#4、基本操作練習" class="headerlink" title="4、基本操作練習"></a>4、基本操作練習</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[root@server0 ~]<span class="comment"># iptables -t filter -L</span></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">[root@server0 ~]<span class="comment"># iptables -t filter -A INPUT -p tcp -j ACCEPT</span></span><br><span class="line">[root@server0 ~]<span class="comment"># iptables -t filter -A INPUT -p udp -j ACCEPT</span></span><br><span class="line">[root@server0 ~]<span class="comment"># iptables -t filter -A INPUT -p icmp -j ACCEPT</span></span><br><span class="line">[root@server0 ~]<span class="comment"># iptables -t filter -L</span></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     udp  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     icmp --  anywhere             anywhere            </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定 chain default policy  </span></span><br><span class="line">[root@server0 ~]<span class="comment"># iptables -t filter -P INPUT DROP</span></span><br><span class="line">[root@server0 ~]<span class="comment"># iptables -t filter -L</span></span><br><span class="line">Chain INPUT (policy DROP)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     udp  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     icmp --  anywhere             anywhere            </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination         </span><br><span class="line">[root@server0 ~]<span class="comment"># iptables -t filter -F</span></span><br><span class="line">FORWARD  INPUT    OUTPUT   </span><br><span class="line"></span><br><span class="line"><span class="comment"># remove all chain rules</span></span><br><span class="line">[root@server0 ~]<span class="comment"># iptables -t filter -F INPUT</span></span><br></pre></td></tr></table></figure><h2 id="5、使用-shell-script-建立-FW"><a href="#5、使用-shell-script-建立-FW" class="headerlink" title="5、使用 shell script 建立 FW"></a>5、使用 shell script 建立 FW</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 防止 sync flooding 攻擊(開啟 tcp sync cookie)</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/tcp_syncookies</span><br><span class="line"></span><br><span class="line">SRV=172.25.0.11</span><br><span class="line"></span><br><span class="line">iptables -t filter -F</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定 connection track</span></span><br><span class="line">iptables -t filter -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br><span class="line"><span class="comment"># 避免 INVALID 封包被其他服務所接收</span></span><br><span class="line">iptables -t filter -A INPUT -m state --state INVALID -j DROP</span><br><span class="line"></span><br><span class="line">iptables -t filter -A INPUT -d <span class="variable">$SRV</span> -p tcp --dport 22 -j ACCEPT</span><br><span class="line">iptables -t filter -A INPUT -d <span class="variable">$SRV</span> -p tcp --dport 25 -j ACCEPT</span><br><span class="line">iptables -t filter -A INPUT -d <span class="variable">$SRV</span> -p tcp --dport 110 -j ACCEPT</span><br><span class="line"></span><br><span class="line">iptables -t nat -A PREROUTING -i eth0 --dport 443 -j DNAT --to 127.0.0.1:22</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用來取代 chain default policy</span></span><br><span class="line">iptables -t filter -A INPUT -i eth0 -j DROP</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RHCE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH254 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[RHCE7] RH254 Chapter 3 Configuring Link Aggregation And Bridging Learning Notes</title>
      <link href="/blog/2016/05/25/RHCE/RHCE7-RH254-LearningNotes-CH03_ConfiguringLinkAggregationAndBridging/"/>
      <url>/blog/2016/05/25/RHCE/RHCE7-RH254-LearningNotes-CH03_ConfiguringLinkAggregationAndBridging/</url>
      <content type="html"><![CDATA[<h1 id="老師補充"><a href="#老師補充" class="headerlink" title="老師補充"></a>老師補充</h1><h3 id="runner"><a href="#runner" class="headerlink" title="runner"></a>runner</h3><ul><li><p><strong>activebackup</strong>：同時間只有一張網卡提供服務</p></li><li><p><strong>roundrobin</strong>：outbound 頻寬可以合併，但 inbound 無法</p></li><li><p><strong>broadcast</strong>：封包往外送時，會往每張網卡都各送一份</p></li><li><p><strong>loadbalance</strong>：以 client ip 作 hash 後決定用哪個網卡提供網路服務</p></li><li><p><strong>lacp</strong>：進出都有 load balance</p></li></ul><h3 id="teaming"><a href="#teaming" class="headerlink" title="teaming"></a>teaming</h3><p>透過 nmcli 修改 runner：<code>nmcli connection modify team0 team.config &#39;{&quot;runner&quot;: {&quot;name&quot;: &quot;activebackup&quot;}}&#39;</code></p><hr><h1 id="3-1-Configuring-Network-Teaming"><a href="#3-1-Configuring-Network-Teaming" class="headerlink" title="3.1 Configuring Network Teaming"></a>3.1 Configuring Network Teaming</h1><h2 id="3-1-1-Network-teaming"><a href="#3-1-1-Network-teaming" class="headerlink" title="3.1.1 Network teaming"></a>3.1.1 Network teaming</h2><p>Network Teaming 的用途是將兩個實體的網路卡結合成一張邏輯上的虛擬網卡，用來提供 failover &amp; 更高的 throughput 目的之用，目前 RHEL7 中提供的 network teaming 比起以前的 bonding 有較好的效能以及擴充性(模組式設計)。</p><p>RHEL 7 中有一個 kernel driver(負責有效率的處理網路封包) 以及稱為 <code>teamd</code>(負責管理 interface) 的 user-space daemon 來負責實現 network teaming 的功能；其中還有稱為 <code>runner</code> 的軟體用來處理網路封包在多條實體網路間配送的問題。</p><p>RHEL 7 中以下支援五種 runner，分別是 <code>broadcast</code>、<code>roundrobin</code>、<code>activebackup</code>、<code>loadbalance</code>、<code>lacp</code>，其中以 <strong>lacp</strong> 的效率最好，但網路卡所連接的 switch 也要做相對應的設定才可以。</p><blockquote><p>bonding 消耗的資源比 teaming 還多，因此建議使用 teaming</p></blockquote><h2 id="3-1-2-Configuring-network-teams"><a href="#3-1-2-Configuring-network-teams" class="headerlink" title="3.1.2 Configuring network teams"></a>3.1.2 Configuring network teams</h2><p>設定 network teaming 共分為四個步驟：(以下直接用範例說明)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立 team interface (runner 會使用 json 格式字串來指定)</span></span><br><span class="line">$ sudo nmcli connection add con-name team0 <span class="built_in">type</span> team ifname team0 config <span class="string">'&#123;"runner": &#123;"name": "loadbalance"&#125;&#125;'</span></span><br><span class="line">Connection <span class="string">'team0'</span> (5d8173d9-fc07-4b11-a72c-5be10d1bea68) successfully added.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 馬上就會出現 teaming interface(team0) 了</span></span><br><span class="line">$ ip addr show team0</span><br><span class="line">5: team0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN</span><br><span class="line">    link/ether 6e:68:9a:d9:75:e7 brd ff:ff:ff:ff:ff:ff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定 IPv4 &amp; IPv6 相關資訊，以及此 teaming interface 的其他屬性</span></span><br><span class="line">$ sudo nmcli connection modify team0 ipv4.method manual ipv4.addresses 192.168.1.10/24</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定要做 network teaming 的網路卡</span></span><br><span class="line">[student@server0 ~]$ sudo nmcli connection add con-name team0-eth1 <span class="built_in">type</span> team-slave ifname eth1 master team0</span><br><span class="line">Connection <span class="string">'team0-eth1'</span> (07fc837c-81d8-4f4e-b4c1-a66151128e17) successfully added.</span><br><span class="line">[student@server0 ~]$ sudo nmcli connection add con-name team0-eth2 <span class="built_in">type</span> team-slave ifname eth2 master team0</span><br><span class="line">Connection <span class="string">'team0-eth2'</span> (70589bef-cd0d-4e6a-8ccc-fdba85733d1d) successfully added.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 啟動 teaming 介面</span></span><br><span class="line">$ sudo nmcli connection up team0</span><br><span class="line">Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/4)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視 teaming 介面狀態</span></span><br><span class="line">$ sudo teamdctl team0 state</span><br><span class="line">setup:</span><br><span class="line">  runner: loadbalance</span><br><span class="line">ports:</span><br><span class="line">  eth1</span><br><span class="line">    link watches:</span><br><span class="line">      link summary: up</span><br><span class="line">      instance[link_watch_0]:</span><br><span class="line">        name: ethtool</span><br><span class="line">        link: up</span><br><span class="line">  eth2</span><br><span class="line">    link watches:</span><br><span class="line">      link summary: up</span><br><span class="line">      instance[link_watch_0]:</span><br><span class="line">        name: ethtool</span><br><span class="line">        link: up</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若因特殊需求需要斷掉某個實體網路卡，可使用以下指令</span></span><br><span class="line">$ sudo nmcli device connect eth1</span><br></pre></td></tr></table></figure><hr><h1 id="Practice-Configuring-Network-Teaming"><a href="#Practice-Configuring-Network-Teaming" class="headerlink" title="Practice: Configuring Network Teaming"></a>Practice: Configuring Network Teaming</h1><h2 id="目標"><a href="#目標" class="headerlink" title="目標"></a>目標</h2><ol><li><p>建立一個名稱為 <code>team0</code> 的 network team interface，使用 <code>eno1</code> &amp; <code>eno2</code> 兩張網卡</p></li><li><p>runner 為 <code>activebackup</code></p></li><li><p>IP 為 <code>192.168.0.100/24</code></p></li></ol><h2 id="實作過程"><a href="#實作過程" class="headerlink" title="實作過程"></a>實作過程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ sudo nmcli connection add con-name team0 <span class="built_in">type</span> team ifname team0 config <span class="string">'&#123;"runner": &#123;"name": "activebackup"&#125;&#125;'</span></span><br><span class="line">Connection <span class="string">'team0'</span> (fa5de783-c31d-4239-ab4c-613a0ed0e9c2) successfully added.</span><br><span class="line"></span><br><span class="line">$ sudo nmcli connection modify team0 ipv4.method manual ipv4.addresses 192.168.0.100/24</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ sudo nmcli connection add con-name team0-eno1 <span class="built_in">type</span> team-slave ifname eno1 master team0</span><br><span class="line">Connection <span class="string">'team0-eno1'</span> (62f7a5d8-171d-457a-b113-af714042463e) successfully added.</span><br><span class="line">$ sudo nmcli connection add con-name team0-eno2 <span class="built_in">type</span> team-slave ifname eno2 master team0</span><br><span class="line">Connection <span class="string">'team0-eno2'</span> (565abdf0-0131-40e5-b492-281a27baf540) successfully added.</span><br><span class="line"></span><br><span class="line">$ sudo nmcli connection up team0</span><br><span class="line">Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/4)</span><br><span class="line">[student@server0 ~]$ sudo teamdctl team0 state</span><br><span class="line">setup:</span><br><span class="line">  runner: activebackup</span><br><span class="line">ports:</span><br><span class="line">  eno1</span><br><span class="line">    link watches:</span><br><span class="line">      link summary: up</span><br><span class="line">  instance[link_watch_0]:        name: ethtool</span><br><span class="line">        link: up</span><br><span class="line">  eno2</span><br><span class="line">    link watches:</span><br><span class="line">      link summary: up</span><br><span class="line">      instance[link_watch_0]:</span><br><span class="line">        name: ethtool</span><br><span class="line">        link: up</span><br><span class="line">runner:</span><br><span class="line">  active port: eno2</span><br></pre></td></tr></table></figure><hr><h1 id="3-2-Managing-Network-Teaming"><a href="#3-2-Managing-Network-Teaming" class="headerlink" title="3.2 Managing Network Teaming"></a>3.2 Managing Network Teaming</h1><h2 id="3-2-2-Setting-and-adjusting-team-configuration"><a href="#3-2-2-Setting-and-adjusting-team-configuration" class="headerlink" title="3.2.2 Setting and adjusting team configuration"></a>3.2.2 Setting and adjusting team configuration</h2><p>當 network team interface 設定完成後，後續還是可以進行修改調整，大部分與原有 nmcli connection modify 沒甚麼差別，主要是要更改 runner 的設定，需要加上 <code>team.config</code> 關鍵字。</p><p>一開始設定時使用一個簡單的 json 字串指定 runner 的設定，也可以透過一個較為複雜的 json 檔案來進行更細緻的 network teaming 設定，以下是個範例：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"device"</span>: <span class="string">"team0"</span>,</span><br><span class="line">    <span class="attr">"mcast_rejoin"</span>: &#123;</span><br><span class="line">        <span class="attr">"count"</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"notify_peers"</span>: &#123;</span><br><span class="line">        <span class="attr">"count"</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"ports"</span>: &#123;</span><br><span class="line">        <span class="attr">"eno1"</span>: &#123;</span><br><span class="line">        "prio": -10,    /* -32729~32727，數字愈小優先權愈高 */</span><br><span class="line">        "sticky": true, /* eno1 掛了會切到 eno2, eno1 回復後會再度主動切回 eno1(以 eno1 為優先使用的 NIC) */</span><br><span class="line">            "link_watch": &#123;</span><br><span class="line">                "name": "arp_ping", /* 比 ethtool 準確 */</span><br><span class="line">                "interval": 100, /* 100ms ping 一次 */</span><br><span class="line">                "missed_max": 30, /* 掉封包超過 30 個以上 */</span><br><span class="line">                "source_host": "192.168.23.2",  /* 需要給 ip 做檢測 */</span><br><span class="line">                "target_host": "192.168.23.1"</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        "eno2": &#123;</span><br><span class="line">            "link_watch": &#123;</span><br><span class="line">                "name": "ethtool"</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    "runner": &#123;</span><br><span class="line">        "name": "loadbalance"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假設檔案名稱為 <code>/tmp/team.conf</code>，接著依序執行以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo nmcli connection modify team0 team.config /tmp/team.conf</span><br><span class="line">$ sudo nmcli connection down team0</span><br><span class="line">$ sudo nmcli connection up team0</span><br><span class="line">$ sudo nmcli connection up team0-eno1</span><br><span class="line">$ sudo nmcli connection up team0-eno2</span><br></pre></td></tr></table></figure><blockquote><p>重新啟動 network teaming interface，它所包含的 port 也要一起重新啟動</p></blockquote><h2 id="3-2-3-Troubleshooting-network-teams"><a href="#3-2-3-Troubleshooting-network-teams" class="headerlink" title="3.2.3 Troubleshooting network teams"></a>3.2.3 Troubleshooting network teams</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查詢指定 network teaming interface 所相關連的 port$ sudo teamnl team0 ports</span></span><br><span class="line"> 4: eno1: up 10000Mbit FD</span><br><span class="line"> 6: eno2: up 10000Mbit FD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取得 active port</span></span><br><span class="line">$ sudo teamnl team0 getoption activeport</span><br><span class="line">6</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取得 network teaming interface 所有相關資訊</span></span><br><span class="line">$ sudo teamnl team0 options</span><br><span class="line"> queue_id (port:eno2) 0</span><br><span class="line"> priority (port:eno2) 0</span><br><span class="line"> user_linkup_enabled (port:eno2) <span class="literal">false</span></span><br><span class="line"> user_linkup (port:eno2) <span class="literal">true</span></span><br><span class="line"> enabled (port:eno2) <span class="literal">true</span></span><br><span class="line"> queue_id (port:eno1) 0</span><br><span class="line"> priority (port:eno1) 0</span><br><span class="line"> user_linkup_enabled (port:eno1) <span class="literal">false</span></span><br><span class="line"> user_linkup (port:eno1) <span class="literal">true</span></span><br><span class="line"> enabled (port:eno1) <span class="literal">true</span></span><br><span class="line"> mcast_rejoin_interval 0</span><br><span class="line"> mcast_rejoin_count 1</span><br><span class="line"> notify_peers_interval 0</span><br><span class="line"> notify_peers_count 1</span><br><span class="line"> mode roundrobin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢 network team interface 的狀態</span></span><br><span class="line">$ sudo teamdctl team0 state</span><br><span class="line">setup:</span><br><span class="line">  runner: activebackup</span><br><span class="line">ports:</span><br><span class="line">  eno1</span><br><span class="line">    link watches:</span><br><span class="line">      link summary: up</span><br><span class="line">      instance[link_watch_0]:</span><br><span class="line">        name: ethtool</span><br><span class="line">        link: up</span><br><span class="line">  eno2</span><br><span class="line">    link watches:</span><br><span class="line">      link summary: up</span><br><span class="line">      instance[link_watch_0]:</span><br><span class="line">        name: ethtool</span><br><span class="line">        link: up</span><br><span class="line">runner:</span><br><span class="line">  active port: eno2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 json 格式匯出 network teaming interface 的設定</span></span><br><span class="line">$ sudo teamdctl team0 config dump &gt; /tmp/team0.json</span><br></pre></td></tr></table></figure><hr><h1 id="Practice-Managing-Network-Teaming"><a href="#Practice-Managing-Network-Teaming" class="headerlink" title="Practice: Managing Network Teaming"></a>Practice: Managing Network Teaming</h1><h2 id="目標-1"><a href="#目標-1" class="headerlink" title="目標"></a>目標</h2><ol><li><p>現有一個 network team interface 為 <code>team0</code>，結合了 <code>eno1</code> &amp; <code>eno2</code> 兩個 interface，並設定 IP 為 <code>192.168.0.100/24</code>，runner 為 <code>activebackup</code></p></li><li><p>將 runner 從 <code>activebackup</code> 改為 <code>roundrobin</code></p></li></ol><h2 id="實作過程-1"><a href="#實作過程-1" class="headerlink" title="實作過程"></a>實作過程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 匯出 network teaming interface 設定檔</span></span><br><span class="line">$ sudo teamdctl team0 config dump &gt;&gt; /tmp/team.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將 runner 從 activebackup 改為 roundrobin，並套用設定</span></span><br><span class="line">$ sudo sed -i <span class="string">'s/activebackup/roundrobin/g'</span> /tmp/team.conf</span><br><span class="line">$ sudo nmcli connection modify team0 team.config /tmp/team.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停用 connection</span></span><br><span class="line">$ sudo nmcli connection down team0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 啟用 connection</span></span><br><span class="line">$ sudo nmcli connection up team0</span><br><span class="line">Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/7)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查雲 network teaming interface status (僅有 runner 資訊可看，要另外啟動兩個 port)</span></span><br><span class="line">$ sudo teamdctl team0 state</span><br><span class="line">setup:</span><br><span class="line">  runner: roundrobin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新啟動 participant port</span></span><br><span class="line">$ sudo nmcli connection up team0-eno1</span><br><span class="line">Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/8)</span><br><span class="line">$ sudo nmcli connection up team0-eno2</span><br><span class="line">Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/9)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新檢視 network teaming interface 資訊</span></span><br><span class="line">$ sudo teamdctl team0 state</span><br><span class="line">setup:</span><br><span class="line">  runner: roundrobin</span><br><span class="line">ports:</span><br><span class="line">  eno1</span><br><span class="line">    link watches:</span><br><span class="line">      link summary: up</span><br><span class="line">      instance[link_watch_0]:</span><br><span class="line">        name: ethtool</span><br><span class="line">        link: up</span><br><span class="line">  eno2</span><br><span class="line">    link watches:</span><br><span class="line">      link summary: up</span><br><span class="line">      instance[link_watch_0]:</span><br><span class="line">        name: ethtool</span><br><span class="line">        link: up</span><br><span class="line"></span><br><span class="line"><span class="comment"># 驗證連線</span></span><br><span class="line">$ ping -c 1 -I team0 192.168.0.254</span><br><span class="line">PING 192.168.0.254 (192.168.0.254) from 192.168.0.100 team0: 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.0.254: icmp_seq=1 ttl=64 time=0.142 ms</span><br><span class="line"></span><br><span class="line">--- 192.168.0.254 ping statistics ---</span><br><span class="line">1 packets transmitted, 1 received, 0% packet loss, time 0ms</span><br><span class="line">rtt min/avg/max/mdev = 0.142/0.142/0.142/0.000 ms</span><br></pre></td></tr></table></figure><hr><h1 id="3-3-Configuring-Software-Bridges"><a href="#3-3-Configuring-Software-Bridges" class="headerlink" title="3.3 Configuring Software Bridges"></a>3.3 Configuring Software Bridges</h1><h2 id="3-2-2-Configure-software-bridges"><a href="#3-2-2-Configure-software-bridges" class="headerlink" title="3.2.2 Configure software bridges"></a>3.2.2 Configure software bridges</h2><p>新增一個 bridge <code>br0</code>，並與實體 NIC <code>eno1</code> &amp; <code>eno2</code> 連接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ sudo nmcli connection add con-name br0 <span class="built_in">type</span> bridge ifname br0</span><br><span class="line">Connection <span class="string">'br0'</span> (8280bb56-62fb-4743-8ca3-86b3ed405c5d) successfully added.</span><br><span class="line"></span><br><span class="line">$ sudo nmcli connection add con-name br0-eno1 <span class="built_in">type</span> bridge-slave ifname eno1 master br0</span><br><span class="line">Connection <span class="string">'br0-eno1'</span> (2cc68634-e2ca-4dcf-8485-69f619a77e37) successfully added.</span><br><span class="line"></span><br><span class="line">$ sudo nmcli connection add con-name br0-eno2 <span class="built_in">type</span> bridge-slave ifname eno2 master br0</span><br><span class="line">Connection <span class="string">'br0-eno2'</span> (02df2464-0daf-4bc6-ad0f-c979323a5ef8) successfully added.</span><br><span class="line"></span><br><span class="line">[student@server0 ~]$ sudo brctl show</span><br><span class="line">bridge name    bridge id     STP enabled     interfaces</span><br><span class="line">br0        8000.9e32e837e9d6 yes     eno1</span><br><span class="line">                         eno2</span><br></pre></td></tr></table></figure><blockquote><p>詳細的使用方式可參考 <code>nmcli-examples(5)</code> &amp; <code>brctl(8)</code></p></blockquote><p>建立完 bridge 後，會產生以下鄉對應的設定檔：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/sysconfig/network-scripts/ifcfg-br0</span><br><span class="line">DEVICE=br0</span><br><span class="line">STP=yes</span><br><span class="line">BRIDGING_OPTS=priority=32768</span><br><span class="line">TYPE=Bridge</span><br><span class="line">BOOTPROTO=dhcp</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">PEERDNS=yes</span><br><span class="line">PEERROUTES=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_PEERDNS=yes</span><br><span class="line">IPV6_PEERROUTES=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">NAME=br0</span><br><span class="line">UUID=8280bb56-62fb-4743-8ca3-86b3ed405c5d</span><br><span class="line">ONBOOT=yes</span><br><span class="line"></span><br><span class="line">$ cat /etc/sysconfig/network-scripts/ifcfg-br0-eno1</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">NAME=br0-eno1</span><br><span class="line">UUID=2cc68634-e2ca-4dcf-8485-69f619a77e37</span><br><span class="line">DEVICE=eno1</span><br><span class="line">ONBOOT=yes</span><br><span class="line">BRIDGE=br0</span><br><span class="line"></span><br><span class="line">$ cat /etc/sysconfig/network-scripts/ifcfg-br0-eno2</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">NAME=br0-eno2</span><br><span class="line">UUID=02df2464-0daf-4bc6-ad0f-c979323a5ef8</span><br><span class="line">DEVICE=eno2</span><br><span class="line">ONBOOT=yes</span><br><span class="line">BRIDGE=br0</span><br></pre></td></tr></table></figure><blockquote><p>Network Manager 僅支援將實體網卡連接到 bridge，不支援將 aggregate interface 加入到 bridge</p></blockquote><hr><h1 id="Practice-Configuring-Software-Bridges"><a href="#Practice-Configuring-Software-Bridges" class="headerlink" title="Practice: Configuring Software Bridges"></a>Practice: Configuring Software Bridges</h1><h2 id="目標-2"><a href="#目標-2" class="headerlink" title="目標"></a>目標</h2><ol><li><p>建立一個名稱為 <code>br1</code> 的 bridge，並設定實體 NIC <code>eno1</code> 與其連接</p></li><li><p>設定 static ip 為 <code>192.168.0.100/24</code></p></li></ol><h2 id="實作過程-2"><a href="#實作過程-2" class="headerlink" title="實作過程"></a>實作過程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ sudo nmcli connection add con-name br1 <span class="built_in">type</span> bridge ifname br1 ip4 192.168.0.100/24</span><br><span class="line">Connection <span class="string">'br1'</span> (cf675bd7-607e-445e-a952-3dcdab359636) successfully added.</span><br><span class="line"></span><br><span class="line">$ sudo nmcli connection add con-name br1-eno1 <span class="built_in">type</span> bridge-slave ifname eno1 master br1</span><br><span class="line">Connection <span class="string">'br1-eno1'</span> (7f204182-dddf-4031-90dc-d8573059199f) successfully added.</span><br><span class="line"></span><br><span class="line">$ ip link</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT qlen 1000</span><br><span class="line">    link/ether 52:54:00:00:00:0b brd ff:ff:ff:ff:ff:ff</span><br><span class="line">4: eno1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast master br1 state UP mode DEFAULT qlen 1000</span><br><span class="line">    link/ether 4e:ea:9e:33:ac:ca brd ff:ff:ff:ff:ff:ff</span><br><span class="line">6: eno2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT qlen 1000</span><br><span class="line">    link/ether f6:a5:73:ed:7c:61 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">8: br1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT</span><br><span class="line">    link/ether 4e:ea:9e:33:ac:ca brd ff:ff:ff:ff:ff:ff</span><br><span class="line"></span><br><span class="line">$ brctl show</span><br><span class="line">bridge name    bridge id     STP enabledinterfaces</span><br><span class="line">br1        8000.4eea9e33acca yes    eno1</span><br><span class="line"></span><br><span class="line">$ ping -I br1 -c 1 192.168.0.254</span><br><span class="line">PING 192.168.0.254 (192.168.0.254) from 192.168.0.100 br1: 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.0.254: icmp_seq=1 ttl=64 time=0.054 ms</span><br><span class="line"></span><br><span class="line">--- 192.168.0.254 ping statistics ---</span><br><span class="line">1 packets transmitted, 1 received, 0% packet loss, time 0ms</span><br><span class="line">rtt min/avg/max/mdev = 0.054/0.054/0.054/0.000 ms</span><br></pre></td></tr></table></figure><hr><h1 id="Lab-Configuration-Link-Aggregation-and-Bridging"><a href="#Lab-Configuration-Link-Aggregation-and-Bridging" class="headerlink" title="Lab: Configuration Link Aggregation and Bridging"></a>Lab: Configuration Link Aggregation and Bridging</h1><h2 id="目標-3"><a href="#目標-3" class="headerlink" title="目標"></a>目標</h2><ol><li><p>建立一個 network teaming interface <code>team0</code>，runner 為 <code>activebackup</code>，使用 <code>eno1</code> &amp; <code>eno2</code> 兩個實體 NIC</p></li><li><p>建立一個 bridge <code>brteam0</code>，連接步驟一設定好的 team0，並設定 IP 為 <code>192.168.0.100/24</code></p></li></ol><h3 id="實作過程-3"><a href="#實作過程-3" class="headerlink" title="實作過程"></a>實作過程</h3><p>設定 network teaming interface：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ sudo nmcli connection add con-name team0 <span class="built_in">type</span> team ifname team0 config <span class="string">'&#123;"runner": &#123;"name": "activebackup"&#125;&#125;'</span></span><br><span class="line">Connection <span class="string">'team0'</span> (064b65f0-a794-41a1-819f-ead0ba4f03c5) successfully added.</span><br><span class="line"></span><br><span class="line">$ sudo nmcli connection add con-name team0-eno1 <span class="built_in">type</span> team-slave ifname eno1 master team0</span><br><span class="line">Connection <span class="string">'team0-eno1'</span> (93004100-b241-4aa4-81d4-393995cb2147) successfully added.</span><br><span class="line">$ sudo nmcli connection add con-name team0-eno2 <span class="built_in">type</span> team-slave ifname eno2 master team0</span><br><span class="line">Connection <span class="string">'team0-eno2'</span> (1b171dbd-2de4-4cdb-b7dc-5c597ba59797) successfully added.</span><br><span class="line"></span><br><span class="line">$ sudo teamdctl team0 state</span><br><span class="line">setup:</span><br><span class="line">  runner: activebackup</span><br><span class="line">ports:</span><br><span class="line">  eno1</span><br><span class="line">    link watches:</span><br><span class="line">      link summary: up</span><br><span class="line">      instance[link_watch_0]:</span><br><span class="line">        name: ethtool</span><br><span class="line">        link: up</span><br><span class="line">  eno2</span><br><span class="line">    link watches:</span><br><span class="line">      link summary: up</span><br><span class="line">      instance[link_watch_0]:</span><br><span class="line">        name: ethtool</span><br><span class="line">        link: up</span><br><span class="line">runner:</span><br><span class="line">  active port: eno1</span><br></pre></td></tr></table></figure><p>建立 bridge <code>brteam0</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo nmcli connection add con-name brteam0 <span class="built_in">type</span> bridge ifname brteam0 ip4 192.168.0.100/24</span><br></pre></td></tr></table></figure><p>接著停止 network teaming interface &amp; NetworkManager 服務：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo nmcli connection down team0</span><br><span class="line"></span><br><span class="line">$ sudo systemctl stop NetworkManager.service</span><br><span class="line">$ sudo systemctl <span class="built_in">disable</span> NetworkManager.service</span><br><span class="line">rm <span class="string">'/etc/systemd/system/multi-user.target.wants/NetworkManager.service'</span></span><br><span class="line">rm <span class="string">'/etc/systemd/system/dbus-org.freedesktop.NetworkManager.service'</span></span><br><span class="line">rm <span class="string">'/etc/systemd/system/dbus-org.freedesktop.nm-dispatcher.service'</span></span><br></pre></td></tr></table></figure><p>修改 <code>/etc/sysconfig/network-scripts/ifcfg-*</code> 相關設定檔：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"BRIDGE=brteam0"</span> | sudo tee --append /etc/sysconfig/network-scripts/ifcfg-team0</span><br><span class="line"></span><br><span class="line">$ sudo sed -e <span class="string">'/^BOOTPROTO.*/d'</span> -e <span class="string">'/^DEFROUTE.*/d'</span> -e <span class="string">'/^PEER.*/d'</span> -e <span class="string">'/^IPV.*/d'</span> -i /etc/sysconfig/network-scripts/ifcfg-team0-eno1</span><br><span class="line"></span><br><span class="line">$ sudo sed -e <span class="string">'/^BOOTPROTO.*/d'</span> -e <span class="string">'/^DEFROUTE.*/d'</span> -e <span class="string">'/^PEER.*/d'</span> -e <span class="string">'/^IPV.*/d'</span> -i /etc/sysconfig/network-scripts/ifcfg-team0-eno2</span><br></pre></td></tr></table></figure><p>最後重啟網路並重開機：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart network</span><br><span class="line"></span><br><span class="line">$ reboot</span><br><span class="line"></span><br><span class="line"><span class="comment"># 驗證是否成功</span></span><br><span class="line">$ ping -I brteam0 -c 3 192.168.0.254</span><br><span class="line">PING 192.168.0.254 (192.168.0.254) from 192.168.0.100 brteam0: 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.0.254: icmp_seq=1 ttl=64 time=0.146 ms</span><br><span class="line">64 bytes from 192.168.0.254: icmp_seq=2 ttl=64 time=3.44 ms</span><br><span class="line">64 bytes from 192.168.0.254: icmp_seq=3 ttl=64 time=0.148 ms</span><br><span class="line"></span><br><span class="line">--- 192.168.0.254 ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 2003ms</span><br><span class="line">rtt min/avg/max/mdev = 0.146/1.245/3.442/1.553 ms</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RHCE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH254 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[RHCE7] RH254 Chapter 2 Managing IPv6 Networking Learning Notes</title>
      <link href="/blog/2016/05/23/RHCE/RHCE7-RH254-LearningNotes-CH02_ManagingIPv6Networking/"/>
      <url>/blog/2016/05/23/RHCE/RHCE7-RH254-LearningNotes-CH02_ManagingIPv6Networking/</url>
      <content type="html"><![CDATA[<h1 id="老師補充"><a href="#老師補充" class="headerlink" title="老師補充"></a>老師補充</h1><h3 id="設定網路卡以舊的方式呈現-eth0-eth1…"><a href="#設定網路卡以舊的方式呈現-eth0-eth1…" class="headerlink" title="設定網路卡以舊的方式呈現(eth0, eth1…)"></a>設定網路卡以舊的方式呈現(eth0, eth1…)</h3><ol><li><p>編輯 <code>/boot/grub2/grub.cfg</code></p></li><li><p>尋找 kernel 參數列：尋找 <code>linux16</code> 開頭的設定</p></li><li><p>加上參數 <code>biosdevname=0 net.ifnames=0</code>，重開機後即完成</p></li></ol><h3 id="ip-指令可達成的功能"><a href="#ip-指令可達成的功能" class="headerlink" title="ip 指令可達成的功能"></a>ip 指令可達成的功能</h3><ul><li><p>不考慮 network namespace 的前提下，Linux kernel 有 256 個 routing table</p></li><li><p>設定 tc(traffic control) 的功能</p></li><li><p><code>ip route show</code>：可查詢 default gateway</p></li><li><p>查詢 network namespace：<code>ip netns show</code></p></li><li><p>切換到指定的 network namespace(<strong>hidden</strong>)：<code>ip exec netns hidden bash</code></p></li></ul><h3 id="nmcli"><a href="#nmcli" class="headerlink" title="nmcli"></a>nmcli</h3><ul><li><p>沒有加上 ip 資訊則表示設定為 DHCP：<code>nmcli connection add con-name office type ethernet ifname eth1</code></p></li><li><p>把跟 eth1 相關的 connection 全部停掉：<code>nmcli device disconnect eth1</code></p></li><li><p>把 DHCP 改為 static 的示範：<code>nmcli connection modify office ipv4.method manual ipv4.addresses &quot;192.168.0.1/24 192.168.0.254&quot;</code></p></li></ul><h3 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h3><ul><li><p><code>::1/128</code>：等同於 ipv4 的 <strong>127.0.0.1/8</strong></p></li><li><p><code>::</code>：等同於 ipv4 的 <strong>0.0.0.0</strong>(for listen port check)</p></li><li><p><code>::/0</code>：default gateway ipv4 的 <strong>0.0.0.0/0</strong></p></li><li><p><code>2000::/3</code>：<code>2000::/16</code> ~ <code>3ffff::/16</code>：為 ipv6 的 public ip</p></li><li><p><code>fd00::/8</code>：ipv6 所使用的 private ip</p></li><li><p><code>fe80::/64</code>：link local address，沒有 DHCP service 的時候會用這一段的 ip(避免 ip 衝突，Linux 會把 MAC address 嵌入到 ip 內)</p></li><li><p><code>ff00::/8</code>：作為 multicast 之用，等同 ipv4 的 <strong>224.0.0.0/4</strong></p></li><li><p>顯示 ipv6 address：<code>ip -6 addr show</code></p></li><li><p>顯示 ipv6 routing table：<code>ip -6 route show</code></p></li><li><p>指定網卡 ping 其他 ipv6 ip(<strong>%</strong> 之後帶網卡名稱)：<code>ping6 ff02:;1%eth0</code></p></li><li><p>持續監控傳遞延遲時間：<code>mtr 8.8.8.8</code></p></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><p>參數補齊功能要安裝 <code>bash-completion</code> 套件才會有</p></li><li><p>查詢 hostname 對應的 ip：<code>dig server0.example.com</code></p></li><li><p>查詢 ip 對應的 hostname：<code>dig -x 172.25.0.11</code></p><ul><li>client 向 DHCP 要求 ip</li><li>client 取得 ip</li><li>client 拿 ip 向 DNS server 作反向名稱解析</li><li>DNS server 給 client 對應的 hostname</li><li>client 使用上一個步驟給的 hostname 作為自己的 hostname</li></ul></li></ul><blockquote><p>透過 DHCP 取得 ip 的狀況下不會有 <code>/etc/hostname</code> 這個檔案</p></blockquote><hr><h1 id="2-1-Reviewing-of-IPv4-Networking-Configuration"><a href="#2-1-Reviewing-of-IPv4-Networking-Configuration" class="headerlink" title="2.1 Reviewing of IPv4 Networking Configuration"></a>2.1 Reviewing of IPv4 Networking Configuration</h1><h2 id="關於-autoconnect"><a href="#關於-autoconnect" class="headerlink" title="關於 autoconnect"></a>關於 autoconnect</h2><p>若透過 nmcli 設定的 connection 有加上 <code>autoconnect yes</code> 的屬性，當執行 <code>sudo nmcli connection down [CONNECTION_NAME]</code> 時，nmcli 會自動帶起其他有 autoconnect yes 屬性的 connection。</p><h2 id="關於-nmcli-的設定參數"><a href="#關於-nmcli-的設定參數" class="headerlink" title="關於 nmcli 的設定參數"></a>關於 nmcli 的設定參數</h2><ul><li><p>設定好的 connection 會有相對應的檔案存放在 <code>/etc/sysconfig/network-scripts/ifcfg-[CONNECTION_NAME]</code> 中</p></li><li><p>詳細設定可以參考 man page <code>nm-settings(5)</code></p></li><li><p>若要將原本為 DHCP 設定改成 static IP 指定，要特別加上 <code>ipv4.method manual</code>，並附上 IP 相關資訊，以下為範例：</p></li></ul><blockquote><p>sudo nmcli connection modify “System eth0” ipv4.addresses “192.168.0.10/24 192.168.0.1” ipv4.method manual</p></blockquote><ul><li><code>nm-settings</code> 與 <code>ifcfg-*</code> 的對應：</li></ul><table><thead><tr><th>nmcli con mod</th><th>ifcfg-* file</th><th>效果</th></tr></thead><tbody><tr><td>ipv4.method manual</td><td>BOOTPROTO=none</td><td>IPv4 IP 以固定的方式指定</td></tr><tr><td>ipv4.method auto</td><td>BOOTPROTO=dhcp</td><td>以 DHCP 方式取得 ip</td></tr><tr><td>ipv4.addresses “192.168.0.10/24 192.168.0.1”</td><td>IPADDR0=192.168.0.10<br>PREFIX0=24<br>GATEWAY0=192.168.0.1</td><td>指定 IP, Netmask, and Gateway</td></tr><tr><td>ipv4.dns 8.8.8.8</td><td>DNS0=8.8.8.8</td><td>修改 <code>/etc/resolv.conf</code> 中的設定，加入 <code>nameserver 8.8.8.8</code></td></tr><tr><td>ipv4.dns-search example.com</td><td>DOMAIN=example.com</td><td>修改 <code>/etc/resolv.conf</code> 中的 <code>search</code> 設定</td></tr><tr><td>ipv4.ignore-auto-dns true</td><td>PEERDNS=no</td><td>忽略來自 DHCP 的 DNS server 資訊</td></tr><tr><td>connection.autoconnect yes</td><td>ONBOOT=yes</td><td>開機自動啟動</td></tr><tr><td>connection.id eth0</td><td>NAME=eth0</td><td>指定 connection 名稱</td></tr><tr><td>connection.interface-name eth0</td><td>DEVICE=eth0</td><td>指定 connection 所要綁定的裝置名稱</td></tr><tr><td>802-3-ethernet.mac-address xxxxx</td><td>HWADDR=xxxxx</td><td>指定 connection 所要綁定裝置的 MAC address</td></tr></tbody></table><blockquote><p>因為 nmcli 都會直接去改 <code>/etc/resolv.conf</code> 的設定，因此若是每個 connection 有不同的DNS 設定，建議直接去 <code>/etc/sysconfig/network-scripts/ifcfg-*</code> 檔案中修改 <code>DNSn</code> &amp; <code>DOMAIN</code> 的設定值</p></blockquote><h2 id="2-1-6-Deleting-a-network-connection"><a href="#2-1-6-Deleting-a-network-connection" class="headerlink" title="2.1.6 Deleting a network connection"></a>2.1.6 Deleting a network connection</h2><p>移除 connection 的指令為 <code>sudo nmcli connection delete [CONNECTION_NAME]</code></p><p>同時間也會將此 connection 斷線，並移除 /etc/sysconfig/network-scripts 目錄中相對應的 ifcfg 檔案</p><h2 id="2-1-7-Modifying-the-system-host-name"><a href="#2-1-7-Modifying-the-system-host-name" class="headerlink" title="2.1.7 Modifying the system host name"></a>2.1.7 Modifying the system host name</h2><p>hostname 相關指令：</p><ul><li><p><code>hostnamectl status</code>：查詢 host 狀態</p></li><li><p><code>sudo hostnamectl set-hostname [HOSTNAME]</code>：變更 hostname</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查詢 host 狀態</span></span><br><span class="line">[student@server0 ~]$ hostnamectl status</span><br><span class="line">   Static hostname: server5.example.com</span><br><span class="line">         Icon name: computer</span><br><span class="line">           Chassis: n/a</span><br><span class="line">        Machine ID: 946cb0e817ea4adb916183df8c4fc817</span><br><span class="line">           Boot ID: 87802c89e9a54f7087857bf5e6de16de</span><br><span class="line">  Operating System: Red Hat Enterprise Linux Server 7.0 (Maipo)</span><br><span class="line">       CPE OS Name: cpe:/o:redhat:enterprise_linux:7.0:GA:server</span><br><span class="line">            Kernel: Linux 3.10.0-123.el7.x86_64</span><br><span class="line">      Architecture: x86_64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 hostname</span></span><br><span class="line">[student@server0 ~]$ sudo hostnamectl <span class="built_in">set</span>-hostname server1.example.com</span><br><span class="line">[student@server0 ~]$ hostnamectl status</span><br><span class="line">   Static hostname: server1.example.com</span><br><span class="line">         Icon name: computer</span><br><span class="line">           Chassis: n/a</span><br><span class="line">        Machine ID: 946cb0e817ea4adb916183df8c4fc817</span><br><span class="line">           Boot ID: 87802c89e9a54f7087857bf5e6de16de</span><br><span class="line">  Operating System: Red Hat Enterprise Linux Server 7.0 (Maipo)</span><br><span class="line">       CPE OS Name: cpe:/o:redhat:enterprise_linux:7.0:GA:server</span><br><span class="line">            Kernel: Linux 3.10.0-123.el7.x86_64</span><br><span class="line">      Architecture: x86_64</span><br><span class="line"></span><br><span class="line">$ cat /etc/hostname</span><br><span class="line">server1.example.com</span><br></pre></td></tr></table></figure><blockquote><p>透過 hostnamectl 修改 hostname 之後，會反映到 /etc/hostname 的內容上</p></blockquote><hr><h1 id="Practice-Configuring-IPv4-Networking"><a href="#Practice-Configuring-IPv4-Networking" class="headerlink" title="Practice: Configuring IPv4 Networking"></a>Practice: Configuring IPv4 Networking</h1><h2 id="目標"><a href="#目標" class="headerlink" title="目標"></a>目標</h2><ol><li><p>透過 nmcli 建立一個 connection，名稱為 <code>eno1</code></p></li><li><p>設定 connection 使用的網路介面為 <code>eno1</code>，IP <code>192.168.0.1/24</code>，沒有 Gateway</p></li><li><p>進行 DNS 查詢時，會把 <code>otherhost</code> 解析為 <code>192.168.0.254</code></p></li></ol><h2 id="實作過程"><a href="#實作過程" class="headerlink" title="實作過程"></a>實作過程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ sudo nmcli connection add con-name eno1 ifname eno1 <span class="built_in">type</span> ethernet autoconnect yes ip4 192.168.0.1/24</span><br><span class="line">Connection <span class="string">'eno1'</span> (4b182e51-8798-406c-a07c-c63289733543) successfully added.</span><br><span class="line">$ sudo nmcli connection up eno1</span><br><span class="line"> successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/2)</span><br><span class="line"></span><br><span class="line"> [student@server0 ~]$ ip addr show eno1</span><br><span class="line"> 6: eno1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000</span><br><span class="line">     link/ether f6:0f:ec:b7:98:e1 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">     inet 192.168.0.1/24 brd 192.168.0.255 scope global eno1</span><br><span class="line">        valid_lft forever preferred_lft forever</span><br><span class="line">     inet6 fe80::f40f:ecff:feb7:98e1/64 scope link</span><br><span class="line">        valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"192.168.0.254 otherhost"</span> | sudo tee --append /etc/hosts</span><br><span class="line">192.168.0.254 otherhost</span><br><span class="line"></span><br><span class="line">$ ping otherhost</span><br><span class="line">PING otherhost (192.168.0.254) 56(84) bytes of data.</span><br><span class="line">64 bytes from otherhost (192.168.0.254): icmp_seq=1 ttl=64 time=0.055 ms</span><br><span class="line">♥</span><br><span class="line">--- otherhost ping statistics ---</span><br><span class="line">1 packets transmitted, 1 received, 0% packet loss, time 0ms</span><br><span class="line">rtt min/avg/max/mdev = 0.055/0.055/0.055/0.000 ms</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示目前有那些額外的 network namespace</span></span><br><span class="line">$ ip netns show</span><br><span class="line">hidden</span><br><span class="line"><span class="comment"># 切換到指定的 network namespace</span></span><br><span class="line">$ ip <span class="built_in">exec</span> netns hidden bash</span><br></pre></td></tr></table></figure><hr><h1 id="2-2-IPv6-Networking-Concepts"><a href="#2-2-IPv6-Networking-Concepts" class="headerlink" title="2.2 IPv6 Networking Concepts"></a>2.2 IPv6 Networking Concepts</h1><h2 id="2-2-1-IPv6-overview"><a href="#2-2-1-IPv6-overview" class="headerlink" title="2.2.1 IPv6 overview"></a>2.2.1 IPv6 overview</h2><p>IPv6 目的是要解決 IPv4 IP 不足的問題，但因為沒有一個簡單的方式可以直接讓 IPv6 獨立運作，因此目前屬於過渡時期的方式，稱為 <code>dual-stack</code>，即是讓 IPv4 與 IPv6 同時存在</p><h2 id="2-2-2-Interpreting-IPv6-addresses"><a href="#2-2-2-Interpreting-IPv6-addresses" class="headerlink" title="2.2.2 Interpreting IPv6 addresses"></a>2.2.2 Interpreting IPv6 addresses</h2><p>IPv6 address 長度為 128 bits，以 16 進位顯示，每 16 個 bits 會用冒號隔開，格式大概如下：</p><blockquote><p>2001:0DB8:02de:0000:0000:0000:0000:0e13</p></blockquote><p>但這樣太難記了，所以可以用較簡單的表示方式：(<strong>都以小寫表示</strong>)</p><ul><li>2001:db8:2de:0000:0000:0000:0000:e13</li><li>2001:db8:2de:000:000:000:000:e13</li><li>2001:db8:2de:00:00:00:00:e13</li><li>2001:db8:2de:0:0:0:0:e13</li><li><p>2001:db8:2de::e13</p><p>以上這幾種所表示的 IPv6 address 都是同一個(<strong>每個由冒號區隔的 group，開頭的 0 都可以省略不寫</strong>)</p></li></ul><blockquote><p>雙冒號不能同時出現兩個，這樣會無法推斷出正確的 IPv6 address</p></blockquote><blockquote><p>若要指定特定的 port，則會以類似這樣的形式表示：<code>[2001:DB8:2de::e13]:80</code></p></blockquote><h3 id="IPv6-subnets"><a href="#IPv6-subnets" class="headerlink" title="IPv6 subnets"></a>IPv6 subnets</h3><ul><li><p>IPv6 同樣也有 subnet 的概念，標準的 IPv6 <code>network prefix</code> 長度為 64 bits(<code>/64</code>)，其餘 64 bits 則是屬於 <code>interface ID</code></p></li><li><p>從上面可知，每個 subnet 可包含的網路裝置數量是很驚人的…..(<code>2^64</code>)</p></li><li><p>實際應用上，64 bits 真是太大了，而且一個 subnet 當然也不夠用，因此使用上還是會切成 <code>/48</code> 居多，這樣就可以從只有一個 subnet 變成有 <code>65536(2^16)</code> 個 subnet 可用</p></li></ul><p><img src="https://lh3.googleusercontent.com/M6--ZzzQCdXEj7HPZ2HNgI304o4xkBiUwCq0WAKL8pNQSHyvWs9fRiOgjCV32b2AkoMwNmYXU5umlO9TVWL-CeQ6Kh4tZEXfhYQ8_f60JDc7bHwgt6wFGSoYRyRex7_UmYLL9HAoofc_5wi5P7p3aEhQVJds1ZVEjgdmF-2g6ZTQ2DMloS0R0s3vJelc7QG8j7unlYjRf8QEuzF-mRSwU5xcYtfy3yn66ytEoiE0eIxJDlPrzDKHiLmk1M6-RPlCJJHMmEO9Bd7mAweT4TKMkO6o4lB8QLjwkDSODKf_hOpBls_AvmVWJMrTrFD-9JV-KuYp5o5LSr18Hp5cwm4N4NkUrJgwGpf2bLBdshT0AHgt3k6863PVTSAkbZJyKqKP4_6Ot1rg5RZehlJnRqEEZFnXUaJbTZJZc4G3fd7w5zOjvmYIuYW6wUKz3Pu2-6ttyWFCzGbgqMytn1XOelwbUEkgP4WxV3IpZ-Ou3eQmfZROn1FHh9jZ84UgoYspcHRptpPgoxUP710J3OhVEDFOz825EUL3U4Huhcc_gPqSchZf27Hr1AoCsw48zMmwa66oCyDgBA2Ey2sY4DeDLPQF82l0-vR666c=w650-h232-no" alt="IPv6"></p><h2 id="2-2-3-IPv6-address-allocation"><a href="#2-2-3-IPv6-address-allocation" class="headerlink" title="2.2.3 IPv6 address allocation"></a>2.2.3 IPv6 address allocation</h2><p>IPv6 跟 IPv4 相同也有一些特定的位址，作為特定目的使用，例如：<code>localhost</code>、<code>multicast</code>、<code>unitcast</code>….等等。</p><p>詳細資料可參考<a href="https://zh.wikipedia.org/wiki/IPv6#IPv6.E4.BD.8D.E5.9D.80.E7.9A.84.E5.88.86.E9.A1.9E" target="_blank" rel="noopener">IPv6 - 維基百科，自由的百科全書</a></p><h3 id="Link-local-addresses"><a href="#Link-local-addresses" class="headerlink" title="Link-local addresses"></a>Link-local addresses</h3><p>IPv6 中，Link-local address 是用來讓 host 指定的網路中互相交流之用(<strong>僅在內部</strong>)，以 <code>fe80::</code> 為開頭，完整的位址還包含了網路介面卡的名稱，例如：<code>fe80::211:22ff:fwaa:bbcc%eth0</code></p><h3 id="Multicast"><a href="#Multicast" class="headerlink" title="Multicast"></a>Multicast</h3><p>在 IPv6 中已經沒有 broadcast，因此 multicast 扮演了一個更重要的角色，而 multicast 的位址為 <code>ff02::1</code>，後面還會帶上網路介面卡名稱，因此完整位址寫法是：<code>ff02::1%eth0</code></p><h2 id="2-2-4-IPv6-address-configuration"><a href="#2-2-4-IPv6-address-configuration" class="headerlink" title="2.2.4 IPv6 address configuration"></a>2.2.4 IPv6 address configuration</h2><p>IPv6 位址同樣也可以透過靜態指定 or 動態指定(使用 <code>DHCPv6</code> 服務)</p><h3 id="Static-addressing"><a href="#Static-addressing" class="headerlink" title="Static addressing"></a>Static addressing</h3><p>跟 IPv4 相同，每個 IPv6 subnet 會有保留位址供特定目的使用，因此在設定時要避開：</p><ol><li><p><code>0000:0000:0000:0000</code>：這位址是作為 routing 之用，以 <strong>2001:db8::/64</strong> 為例，此位址就是 <code>2001:db8::</code></p></li><li><p>從 <code>fdff:ffff:ffff:ff80</code> ~ <code>fdff:ffff:ffff:ffff</code> 這一段位址</p></li></ol><h3 id="DHCPv6-configuration"><a href="#DHCPv6-configuration" class="headerlink" title="DHCPv6 configuration"></a>DHCPv6 configuration</h3><p>因為 IPv6 沒有 broadcast，因此 DHCPv6 的運作原理跟 DHCPv4 就不太一樣。</p><p>DHCP client 會從自己的 link-local address 送出 DHCP request 到 all-dhcp-servers link-local multicast group 中(<code>ff02::1:2</code> port <code>547/UDP</code>)，而 DHCPv6 server 則會回到 DHCP client 的 link-local address port <code>546/UDP</code></p><h3 id="SLAAC-configuration"><a href="#SLAAC-configuration" class="headerlink" title="SLAAC configuration"></a>SLAAC configuration</h3><p>這是另一種透過 router 協助來完成位址配發的技術，詳細的資訊可以參考下列網址：</p><ul><li><p><a href="http://www.myhome.net.tw/2012_09/p03.htm" target="_blank" rel="noopener">2012台網中心電子報─IPv6位址配發技術介紹</a></p></li><li><p><a href="http://www.lijyyh.com/2012/04/ipv6ipv6-auto-configuration.html" target="_blank" rel="noopener">傲笑紅塵路: IPv6自動組態配置(IPv6 Auto configuration)</a></p></li></ul><hr><h1 id="2-3-IPv6-Networking-Configuration"><a href="#2-3-IPv6-Networking-Configuration" class="headerlink" title="2.3 IPv6 Networking Configuration"></a>2.3 IPv6 Networking Configuration</h1><h2 id="2-3-2-Adding-an-IPv6-network-connection"><a href="#2-3-2-Adding-an-IPv6-network-connection" class="headerlink" title="2.3.2 Adding an IPv6 network connection"></a>2.3.2 Adding an IPv6 network connection</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo nmcli connection add con-name <span class="string">"eth2-ipv6"</span> <span class="built_in">type</span> ethernet ifname eth2 ip6 2001:db8:0:1::c000:207/64 gw6 2001:db8:0:1::1 ip4 192.168.2.7/24 gw4 192.168.2.1</span><br><span class="line">Connection <span class="string">'eth2-ipv6'</span> (e7c97cdd-efea-43c2-a4d7-52b3bb4be4e2) successfully added.</span><br><span class="line"></span><br><span class="line">$ sudo nmcli connection modify eth2-ipv6 +ipv6.dns 2001:4860:4860::8888</span><br></pre></td></tr></table></figure><h2 id="2-3-3-Modifying-network-connection-settings-for-IPv6"><a href="#2-3-3-Modifying-network-connection-settings-for-IPv6" class="headerlink" title="2.3.3 Modifying network connection settings for IPv6"></a>2.3.3 Modifying network connection settings for IPv6</h2><p>修改的方式跟 IPv4 幾乎一模一樣：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改 IP 資訊</span></span><br><span class="line">$ sudo nmcli connection modify eth2-ipv6 ipv6.addresses <span class="string">"2001:db8:0:1::a00:1/64 2001:db8:0:1::1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加 DNS 資訊</span></span><br><span class="line">$[student@server0 ~]$ sudo nmcli connection modify eth2-ipv6 +ipv6.dns 2001:4860:4860::8888</span><br></pre></td></tr></table></figure><table><thead><tr><th>nmcli con mod</th><th>ifcfg-* file</th><th>效果</th></tr></thead><tbody><tr><td>ipv6.method manual</td><td>IPV6_AUTOCONF=none</td><td>IPv6 IP 以固定的方式指定</td></tr><tr><td>ipv6.method auto</td><td>IPV6_AUTOCONF=yes</td><td>透過 SLAAC，從 router advertisements 取得 ip</td></tr><tr><td>ipv6.method dhcp</td><td>IPV6_AUTOCONF=no<br>DHCPV6C=yes</td><td>使用 DHCPv6 取得 ip</td></tr><tr><td>ipv6.addresses “2001:db8::a/64 2001:db8::1”</td><td>IPV6ADDR=2001:db8::a/64<br>IPV6_DEFAULTGW=2001:db8::1</td><td>指定 IP, Netmask, and Gateway</td></tr><tr><td>ipv6.dns 8.8.8.8</td><td>DNS0=8.8.8.8</td><td>修改 <code>/etc/resolv.conf</code> 中的設定，加入 <code>nameserver 8.8.8.8</code>(與 IPv4 相同)</td></tr><tr><td>ipv6.dns-search example.com</td><td>DOMAIN=example.com</td><td>修改 <code>/etc/resolv.conf</code> 中的 <code>search</code> 設定(與 IPv4 相同)</td></tr><tr><td>ipv4.ignore-auto-dns true</td><td>IPV6_PEERDNS=no</td><td>忽略來自 DHCP 的 DNS server 資訊</td></tr><tr><td>connection.autoconnect yes</td><td>ONBOOT=yes</td><td>開機自動啟動</td></tr><tr><td>connection.id eth0</td><td>NAME=eth0</td><td>指定 connection 名稱</td></tr><tr><td>connection.interface-name eth0</td><td>DEVICE=eth0</td><td>指定 connection 所要綁定的裝置名稱</td></tr><tr><td>802-3-ethernet.mac-address xxxxx</td><td>HWADDR=xxxxx</td><td>指定 connection 所要綁定裝置的 MAC address</td></tr></tbody></table><h2 id="其他：IPv6-相關指令"><a href="#其他：IPv6-相關指令" class="headerlink" title="其他：IPv6 相關指令"></a>其他：IPv6 相關指令</h2><p>檢視 IPv6 網路資訊：</p><ul><li><p><code>ip addr show eth0</code>：可檢視 eth0 上 IPv6 相關資訊，尋找關鍵字 <code>inet6</code> 即可</p></li><li><p><code>ip -6 route show</code>：顯示 IPv6 部分的 routing table</p></li></ul><p>trouble shooting 相關指令：</p><ul><li><p><code>ping6 ff02::1%eth1</code>：ping <strong>link-local address</strong> &amp; <strong>link-local all-nodes multicast group</strong>，需要帶上 network interface name</p></li><li><p><code>tracepath6 2001:db8:0:2::451</code>：查詢連線到指定 host 所走的路徑</p></li><li><p><code>ss -A inet -n</code> &amp; <code>netstat -46n</code>：查詢目前 network socket 的狀態</p></li></ul><hr><h1 id="Practice-Configuration-IPv6-Networking"><a href="#Practice-Configuration-IPv6-Networking" class="headerlink" title="Practice: Configuration IPv6 Networking"></a>Practice: Configuration IPv6 Networking</h1><h2 id="目標-1"><a href="#目標-1" class="headerlink" title="目標"></a>目標</h2><ul><li><p>建立一個名稱為 <code>eno1</code> 的連線</p></li><li><p>network interface 名稱為 <code>eno1</code>，設定 IP 為 <code>fddb:fe2a:ab1e::c0a8:1/64</code>，Gateway 為 <code>fddb:fe2a:ab1e::c0a8:fe</code></p></li></ul><h2 id="實作過程-1"><a href="#實作過程-1" class="headerlink" title="實作過程"></a>實作過程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新增連線</span></span><br><span class="line">$ sudo nmcli connection add con-name eno1 <span class="built_in">type</span> ethernet ifname eno1 ip6 fddb:fe2a:ab1e::c0a8:1/64 gw6 fddb:fe2a:ab1e::c0a8:fe</span><br><span class="line">Connection <span class="string">'eno1'</span> (13505591-aeb6-452d-acaa-8f32810eebb3) successfully added.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改連線設定</span></span><br><span class="line">$ sudo nmcli connection modify eno1 ipv6.method manual</span><br><span class="line"></span><br><span class="line"><span class="comment"># 啟用連線</span></span><br><span class="line">$ sudo nmcli connection up eno1</span><br><span class="line">Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/3)</span><br></pre></td></tr></table></figure><hr><h1 id="Lab-Managing-IPv6-Networking"><a href="#Lab-Managing-IPv6-Networking" class="headerlink" title="Lab: Managing IPv6 Networking"></a>Lab: Managing IPv6 Networking</h1><h2 id="目標-2"><a href="#目標-2" class="headerlink" title="目標"></a>目標</h2><ul><li><p>建立一個名稱為 <code>eno1</code> 的連線，使用 network interface 為 <code>eno1</code></p></li><li><p>IPv4 的位址為 <code>192.168.0.100/24</code>，IPv6 的位址為 <code>fddb:fe2a:ab1e::c0a8:64/64</code></p></li><li><p>啟動連線是否都有取得正確 IP</p></li><li><p>ping IPv4 gateway(<code>192.168.0.254</code>) &amp; IPv6 gateway(<code>fddb:fe2a:ab1e::c0a8:fe</code>) 確認網路設定正確</p></li></ul><h2 id="實作過程-2"><a href="#實作過程-2" class="headerlink" title="實作過程"></a>實作過程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新增連線</span></span><br><span class="line">$ sudo nmcli connection add con-name eno1 <span class="built_in">type</span> ethernet ifname eno1 ip4 192.168.0.100/24 ip6 fddb:fe2a:ab1e::c0a8:64/64</span><br><span class="line">Connection <span class="string">'eno1'</span> (82399d91-7ae1-4544-975c-ae43424de35a) successfully added.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定 ip 設定方式為 manual</span></span><br><span class="line">$ sudo nmcli connection modify eno1 ipv4.method manual ipv6.method manual\</span><br><span class="line"></span><br><span class="line"><span class="comment"># 啟動連線</span></span><br><span class="line">$ sudo nmcli connection up eno1</span><br><span class="line">Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢 IP 資訊</span></span><br><span class="line">$ ip addr show eno1</span><br><span class="line">6: eno1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000</span><br><span class="line">    link/ether da:f4:04:59:60:2c brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.0.100/24 brd 192.168.0.255 scope global eno1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fddb:fe2a:ab1e::c0a8:64/64 scope global</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::d8f4:4ff:fe59:602c/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line"><span class="comment"># ping IPv4 address</span></span><br><span class="line">[student@server0 ~]$ ping -c 1 192.168.0.254</span><br><span class="line">PING 192.168.0.254 (192.168.0.254) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.0.254: icmp_seq=1 ttl=64 time=0.085 ms</span><br><span class="line"></span><br><span class="line">--- 192.168.0.254 ping statistics ---</span><br><span class="line">1 packets transmitted, 1 received, 0% packet loss, time 0ms</span><br><span class="line">rtt min/avg/max/mdev = 0.085/0.085/0.085/0.000 ms</span><br><span class="line"></span><br><span class="line"><span class="comment"># ping IPv6 address</span></span><br><span class="line">$ ping6 -c 1 fddb:fe2a:ab1e::c0a8:fe</span><br><span class="line">PING fddb:fe2a:ab1e::c0a8:fe(fddb:fe2a:ab1e::c0a8:fe) 56 data bytes</span><br><span class="line">64 bytes from fddb:fe2a:ab1e::c0a8:fe: icmp_seq=1 ttl=64 time=0.187 ms</span><br><span class="line"></span><br><span class="line">--- fddb:fe2a:ab1e::c0a8:fe ping statistics ---</span><br><span class="line">1 packets transmitted, 1 received, 0% packet loss, time 0ms</span><br><span class="line">rtt min/avg/max/mdev = 0.187/0.187/0.187/0.000 ms</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RHCE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH254 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[RHCE7] RH254 Chapter 1 Controlling Services and Daemons Learning Notes</title>
      <link href="/blog/2016/05/21/RHCE/RHCE7-RH254-LearningNotes-CH01_ControllingServicesAndDaemons/"/>
      <url>/blog/2016/05/21/RHCE/RHCE7-RH254-LearningNotes-CH01_ControllingServicesAndDaemons/</url>
      <content type="html"><![CDATA[<h1 id="1-1-Controlling-Services-with-systemctl"><a href="#1-1-Controlling-Services-with-systemctl" class="headerlink" title="1.1 Controlling Services with systemctl"></a>1.1 Controlling Services with systemctl</h1><h2 id="1-1-1-Introduction-to-systemd"><a href="#1-1-1-Introduction-to-systemd" class="headerlink" title="1.1.1 Introduction to systemd"></a>1.1.1 Introduction to systemd</h2><p>RHEL7 已經使用 <code>systemd</code> 取代原有的 <code>init</code> &amp; <code>xinetd</code>，因此目前 ID=1 的 process 為 systemd，主要加入了下列新的特性：</p><ol><li><p>平行處理，可加速系統開機</p></li><li><p>on-demand 啟動服務的能力</p></li><li><p>service 相依性的自動處理，避免造成系統長時間等待特定服務(例如：網路不通時不會把 network service 啟動)</p></li><li><p>可透過 Linux control group 追蹤相關的 process 的狀態</p></li></ol><blockquote><p>現在大多 service 的相關設定都被移到 <code>/etc/sysconfig</code> 目錄中了，只有某些 legacy services 才依然是以 shell-based 的形式存在</p></blockquote><p>現在 RHEL7 中使用 <code>systemctl</code> 管理各式各樣的 systemd 物件，這些物件統稱為 <code>units</code>，常看到的 units 會有：</p><ol><li><p><code>Service units</code>(<strong>.service</strong>)：這就是系統服務了，通常會以 daemon 的形式存在</p></li><li><p><code>Socket Units</code>(<strong>.socket</strong>)：指的是 IPC socket，通常在有新的連線與 service 產生時，socket unit 會被傳給 daemon 處理</p></li><li><p><code>Path units</code>(<strong>.path</strong>)：用來 delay 特定 service，直到特定的檔案有所變化，例如：列印服務</p></li></ol><blockquote><p>若 system unit 狀態為 <code>static</code>，表示無法被 enable，但可以被 <code>enabled unit</code> 自動啟用</p></blockquote><h2 id="1-1-2-Starting-and-stopping-daemons-on-a-running-system"><a href="#1-1-2-Starting-and-stopping-daemons-on-a-running-system" class="headerlink" title="1.1.2 Starting and stopping daemons on a running system"></a>1.1.2 Starting and stopping daemons on a running system</h2><p><code>restart</code> 會改變 service 的 process ID；但 <code>reload</code> 則會維持 service 原有的 process ID</p><h2 id="其他：systemctl-特別的指令"><a href="#其他：systemctl-特別的指令" class="headerlink" title="其他：systemctl 特別的指令"></a>其他：systemctl 特別的指令</h2><ol><li><p><code>sudo systemctl --failed --type=service</code>：列出狀態為 failed 的 service</p></li><li><p><code>sudo systemctl list-dependencies [UNIT]</code>：列出指定 system unit 的相依關係</p></li><li><p><code>sudo systemctl list-dependencies --reverse [UNIT]</code>：列出指定 system unit 啟動所需要預先啟動的其他 system unit</p></li></ol><hr><h1 id="1-2-Controlling-the-Boot-Process"><a href="#1-2-Controlling-the-Boot-Process" class="headerlink" title="1.2 Controlling the Boot Process"></a>1.2 Controlling the Boot Process</h1><h2 id="1-2-1-Selecting-a-systemd-target"><a href="#1-2-1-Selecting-a-systemd-target" class="headerlink" title="1.2.1 Selecting a systemd target"></a>1.2.1 Selecting a systemd target</h2><p>以下列出幾個重要的 systemd target：</p><ul><li><p><code>graphical.target</code>：就是一般的圖形模式，也包含了文字介面</p></li><li><p><code>multi-user.target</code>：純文字模式</p></li><li><p><code>rescue.target</code>：要求用 root 身分登入，基本系統服務已經初始化完成</p></li><li><p><code>emergency.target</code>：要求用 root 身分登入，initramfs 已經執行完畢，並把 system root 以 read-only 的方式掛載</p></li></ul><p>每個 target 之間會有某種程度的相依關係，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可看出 graphical.target unit 與那些 target unit 有相依</span></span><br><span class="line">$ systemctl list-dependencies graphical.target | grep target</span><br><span class="line">graphical.target</span><br><span class="line">└─multi-user.target</span><br><span class="line">  ├─basic.target</span><br><span class="line">  │ ├─paths.target</span><br><span class="line">  │ ├─slices.target</span><br><span class="line">  │ ├─sockets.target</span><br><span class="line">  │ ├─sysinit.target</span><br><span class="line">  │ │ ├─cryptsetup.target</span><br><span class="line">  │ │ ├─<span class="built_in">local</span>-fs.target</span><br><span class="line">  │ │ └─swap.target</span><br><span class="line">  │ └─timers.target</span><br><span class="line">  ├─getty.target</span><br><span class="line">  ├─nfs.target</span><br><span class="line">  └─remote-fs.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有 target unit</span></span><br><span class="line">$ systemctl list-units --<span class="built_in">type</span>=target --all</span><br><span class="line">  UNIT                   LOAD   ACTIVE   SUB    DESCRIPTION</span><br><span class="line">  basic.target           loaded active   active Basic System</span><br><span class="line">  cryptsetup.target      loaded active   active Encrypted Volumes</span><br><span class="line">  emergency.target       loaded inactive dead   Emergency Mode</span><br><span class="line">  final.target           loaded inactive dead   Final Step</span><br><span class="line">  getty.target           loaded active   active Login Prompts</span><br><span class="line">  graphical.target       loaded active   active Graphical Interface</span><br><span class="line">  <span class="built_in">local</span>-fs-pre.target    loaded active   active Local File Systems (Pre)</span><br><span class="line">  <span class="built_in">local</span>-fs.target        loaded active   active Local File Systems</span><br><span class="line">  multi-user.target      loaded active   active Multi-User System</span><br><span class="line">  network-online.target  loaded inactive dead   Network is Online</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure><p>透過 <code>systemctl isolate [TARGET_UNIT]</code> 可以馬上變換不同的 target unit，假設目前在圖形模式下，執行指令 <code>sudo systemctl isolate multi-user.target</code> 可以切換到文字模式</p><h3 id="Setting-a-default-target"><a href="#Setting-a-default-target" class="headerlink" title="Setting a default target"></a>Setting a default target</h3><p><code>default.target</code> 為開機時所啟動的 target unit，這是個 symbolic link，指向真正的 target unit</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 目前指向 graphical.target，因此開機會是圖形介面</span></span><br><span class="line">$ ls -al /etc/systemd/system/default.target</span><br><span class="line">lrwxrwxrwx. 1 root root 40 Jul 11  2014 /etc/systemd/system/default.target -&gt; /usr/lib/systemd/system/graphical.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以用另外一個指令取得 default target unit</span></span><br><span class="line">$ systemctl get-default</span><br><span class="line">graphical.target</span><br></pre></td></tr></table></figure><p>當然也有指令可以設定 default target unit：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl <span class="built_in">set</span>-default multi-user.target</span><br><span class="line">rm <span class="string">'/etc/systemd/system/default.target'</span></span><br><span class="line">ln -s <span class="string">'/usr/lib/systemd/system/multi-user.target'</span> <span class="string">'/etc/systemd/system/default.target'</span></span><br><span class="line"></span><br><span class="line">$ systemctl get-default</span><br><span class="line">multi-user.target</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">&gt; 開機時編輯開機設定，在 `linux16` 那一行的最後面加上 `systemd.unit=[TARGET_UNIT]` 也可以直接進入所指定的 target unit</span><br><span class="line"></span><br><span class="line">----------------------------------------------------</span><br><span class="line"></span><br><span class="line">Lab: Controlling Services and Daemons</span><br><span class="line">=====================================</span><br><span class="line"></span><br><span class="line"><span class="comment">## 目標</span></span><br><span class="line"></span><br><span class="line">- 設定開機時同時支援文字介面登入 &amp; 圖形介面登入</span><br><span class="line"></span><br><span class="line">- 設定 `rsyslog` service 開機時啟動</span><br><span class="line"></span><br><span class="line"><span class="comment">## 實作步驟</span></span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line"><span class="comment"># 檢查目前的 target unit</span></span><br><span class="line">$ systemctl get-default</span><br><span class="line">multi-user.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定 target unit 為 graphical.target (同時支援文字介面登入 &amp; 圖形介面登入)</span></span><br><span class="line">[student@server0 ~]$ sudo systemctl <span class="built_in">set</span>-default graphical.target</span><br><span class="line">rm <span class="string">'/etc/systemd/system/default.target'</span></span><br><span class="line">ln -s <span class="string">'/usr/lib/systemd/system/graphical.target'</span> <span class="string">'/etc/systemd/system/default.target'</span></span><br><span class="line"></span><br><span class="line">[student@server0 ~]$ systemctl get-default</span><br><span class="line">graphical.target</span><br><span class="line"></span><br><span class="line">[student@server0 ~]$ systemctl status rsyslog</span><br><span class="line">rsyslog.service - System Logging Service</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/rsyslog.service; disabled)</span><br><span class="line">   Active: inactive (dead)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定 rsyslog.service 開機啟動</span></span><br><span class="line">[student@server0 ~]$ sudo systemctl <span class="built_in">enable</span> rsyslog.service</span><br><span class="line">ln -s <span class="string">'/usr/lib/systemd/system/rsyslog.service'</span> <span class="string">'/etc/systemd/system/multi-user.target.wants/rsyslog.service'</span></span><br><span class="line">[student@server0 ~]$ sudo systemctl restart rsyslog.service</span><br><span class="line">[student@server0 ~]$ systemctl status rsyslog</span><br><span class="line">rsyslog.service - System Logging Service</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/rsyslog.service; enabled)</span><br><span class="line">   Active: active (running) since Sat 2016-05-21 17:21:24 JST; 2s ago</span><br><span class="line"> Main PID: 31841 (rsyslogd)</span><br><span class="line">   CGroup: /system.slice/rsyslog.service</span><br><span class="line">           └─31841 /usr/sbin/rsyslogd -n</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RHCE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH254 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[RHCE7] RH134 Chapter 13. Controlling and Troubleshooting the RHEL Boot Process 學習筆記</title>
      <link href="/blog/2016/05/13/RHCE/RHCE7-RH134-LearningNotes-CH13_ControllingAndTroubleshootingTheRHELBootProcess/"/>
      <url>/blog/2016/05/13/RHCE/RHCE7-RH134-LearningNotes-CH13_ControllingAndTroubleshootingTheRHELBootProcess/</url>
      <content type="html"><![CDATA[<h1 id="13-1-The-RHEL-Boot-Process"><a href="#13-1-The-RHEL-Boot-Process" class="headerlink" title="13.1 The RHEL Boot Process"></a>13.1 The RHEL Boot Process</h1><h2 id="13-1-1-The-RHCE-7-boot-process"><a href="#13-1-1-The-RHCE-7-boot-process" class="headerlink" title="13.1.1 The RHCE 7 boot process"></a>13.1.1 The RHCE 7 boot process</h2><ol><li><p>電腦開機從 BIOS 開始</p></li><li><p>進行 POST 檢查</p></li><li><p>stage-1：載入 Boot Loader 並開始執行</p></li><li><p>stage-2：讀取 <code>/boot/grub2/grub.cfg</code> 並執行</p></li><li><p><code>grub.cfg</code> 解壓縮 <code>initramfs-xxxx</code>(很小的 gzip + cpio 的 Linux，若要額外加上 HW driver 就要包到這裡)，並載入記憶體中</p></li><li><p><code>grub.cfg</code> 執行 <code>vmlinuz-xxx</code>(可執行的 Linux kernel 映像檔)，將記憶體的內容掛載到 <code>/</code></p></li><li><p>執行 <code>/init</code> (已經變成 soft link) 指向其他地方</p></li><li><p><code>init</code> 會 <code>mount -o ro [HD root partition] /sysroot</code></p></li><li><p><code>chroot /sysroot</code></p></li><li><p>執行 <code>/lib/systemd/systemd</code></p></li></ol><p>boot load 解壓縮 initramfs-xxx 到記憶體中</p><p>第 8 個步驟 <code>-o ro</code> 的原因是開機時會作 fsck，因為無法 unmount 根目錄，因此只能用 read only 的方式</p><h2 id="13-1-3-Selecting-a-systemd-target"><a href="#13-1-3-Selecting-a-systemd-target" class="headerlink" title="13.1.3 Selecting a systemd target"></a>13.1.3 Selecting a systemd target</h2><p><strong>systemd target</strong> 是由一組 systemd unit 所組成，可以讓 user 進入到某一個特定狀態(例如：圖形介面)，比較常用的包含了：</p><ul><li><p>graphical.target：圖形 &amp; 文字介面</p></li><li><p>multi-user.target：文字介面</p></li><li><p>rescue.target：初始化完成，會提示輸入 root 密碼</p></li><li><p>emergency.target：initramfs 掛載 / 完成，只有 read only 權限，且會提示輸入 root 密碼</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 啟動 graphic.target 需要由那些 systemd target unit 所組成</span></span><br><span class="line">$ systemctl list-dependencies graphical.target | grep target</span><br><span class="line">graphical.target</span><br><span class="line">└─multi-user.target</span><br><span class="line">  ├─basic.target</span><br><span class="line">  │ ├─paths.target</span><br><span class="line">  │ ├─slices.target</span><br><span class="line">  │ ├─sockets.target</span><br><span class="line">  │ ├─sysinit.target</span><br><span class="line">  │ │ ├─cryptsetup.target</span><br><span class="line">  │ │ ├─<span class="built_in">local</span>-fs.target</span><br><span class="line">  │ │ └─swap.target</span><br><span class="line">  │ └─timers.target</span><br><span class="line">  ├─getty.target</span><br><span class="line">  ├─nfs.target</span><br><span class="line">  └─remote-fs.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出系統中所有的 systemd target unit</span></span><br><span class="line">$ systemctl list-units --<span class="built_in">type</span>=target --all</span><br><span class="line">UNIT                   LOAD   ACTIVE   SUB    DESCRIPTION</span><br><span class="line">basic.target           loaded active   active Basic System</span><br><span class="line">cryptsetup.target      loaded active   active Encrypted Volumes</span><br><span class="line">emergency.target       loaded inactive dead   Emergency Mode</span><br><span class="line">.......</span><br><span class="line">umount.target          loaded inactive dead   Unmount All Filesystems</span><br><span class="line"></span><br><span class="line">LOAD   = Reflects whether the unit definition was properly loaded.</span><br><span class="line">ACTIVE = The high-level unit activation state, i.e. generalization of SUB.</span><br><span class="line">SUB    = The low-level unit activation state, values depend on unit <span class="built_in">type</span>.</span><br><span class="line"></span><br><span class="line">27 loaded units listed.</span><br><span class="line">To show all installed unit files use <span class="string">'systemctl list-unit-files'</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 線上直接切換不同的 target (但這會停掉指定 target 中不需要的服務)</span></span><br><span class="line">$ sudo systemctl isolate multi-user.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將 graphical.target 設定為預設值</span></span><br><span class="line">$ $ sudo systemctl <span class="built_in">set</span>-default graphical.target</span><br><span class="line">rm <span class="string">'/etc/systemd/system/default.target'</span></span><br><span class="line">ln -s <span class="string">'/usr/lib/systemd/system/graphical.target'</span> <span class="string">'/etc/systemd/system/default.target'</span></span><br></pre></td></tr></table></figure><blockquote><p>也可以在開機時，修改開機設定，在 <code>linux16</code> 那一行最後面，加上 <code>systemd.unit=graphical.target</code>，也可以進入圖形模式</p></blockquote><hr><h1 id="13-2-Repairing-Common-Boot-Issues"><a href="#13-2-Repairing-Common-Boot-Issues" class="headerlink" title="13.2 Repairing Common Boot Issues"></a>13.2 Repairing Common Boot Issues</h1><h2 id="13-2-1-Recovering-the-root-password"><a href="#13-2-1-Recovering-the-root-password" class="headerlink" title="13.2.1 Recovering the root password"></a>13.2.1 Recovering the root password</h2><blockquote><p>透過修改開機設定，加上 <code>rd.break</code> 進入可救援的模式來修改 root 密碼，但這樣會破壞 SELinux security context</p></blockquote><ol><li><p>修改 linux16 開頭的設定，從最後面移除設定直到 <code>ro</code> 前，並在該行最後加上 <code>rd.break</code>，按下 <code>Ctrl+x</code> 使用此設定開機 (開機完成後會位於 initramfs 的 <strong>/</strong>，並包含了 <strong>real-only</strong> 的 <strong>/sysroot</strong>)</p></li><li><p>重新掛載 /sysroot 目錄為可讀寫：<code>mount -o remount,rw /sysroot</code></p></li><li><p>切換根目錄到 /sysroot 上：<code>chroot /sysroot</code></p></li><li><p>修改 root 密碼：<code>passwd root</code></p></li><li><p>產生 <code>/.autorelabel</code> 檔案，讓開機過程可以重新 relabel：<code>touch /.autorelabel</code></p></li><li><p>連續輸入兩次 <code>exit</code>，回到開機程序</p></li></ol><p><code>/.autorelabel</code>：此檔案用途會讓 SELinux 進行 relabel 的動作，將 security context 恢復到正確的狀態</p><h3 id="Using-journalctl"><a href="#Using-journalctl" class="headerlink" title="Using journalctl"></a>Using journalctl</h3><p>預設 log 儲存在記憶體中，只要 <code>sudo mkdir -p -m2775 /var/log/journal</code> 就可以將 systemd journal 放到硬碟中</p><p>顯示上一次開機的過程中，Level ERROR 的 log：<code>sudo journalctl -b -1 -p err</code></p><h3 id="Diagnose-and-repair-systemd-boot-issues"><a href="#Diagnose-and-repair-systemd-boot-issues" class="headerlink" title="Diagnose and repair systemd boot issues"></a>Diagnose and repair systemd boot issues</h3><p><code>sudo systemctl enable debug-shell.service</code>：重開機後可以透過 Ctrl + Alt + F9 得到一個 root shell</p><p>開機流程中，得到 shell 的順序是：</p><ol><li><p>rd.break</p></li><li><p>emergency.target</p></li><li><p>rescue.target</p></li></ol><blockquote><p>所以其實使用 rd.break 就可以解決所有開機的相關問題</p></blockquote><p><code>systemctl list-job</code>：可用來觀察開機時的 stuck job</p><hr><h1 id="13-3-Repairing-File-System-Issues-at-Boot"><a href="#13-3-Repairing-File-System-Issues-at-Boot" class="headerlink" title="13.3 Repairing File System Issues at Boot"></a>13.3 Repairing File System Issues at Boot</h1><ul><li><p>每次開機 fsck 都會嘗試自動修復，若無法自動處理則會進入 emergency shell</p></li><li><p>設備不存在，systemd 會等一段時間，若依然沒有就會進入 emergency shell 給管理者除錯</p></li><li><p>mount point 不存在，systemd 會嘗試自動建立，否則就進入 emergency shell</p></li><li><p>/etc/fstab 錯誤，直接進入 emergency shell</p></li></ul><hr><h1 id="13-4-Repairing-Boot-Loader-Issues"><a href="#13-4-Repairing-Boot-Loader-Issues" class="headerlink" title="13.4 Repairing Boot Loader Issues"></a>13.4 Repairing Boot Loader Issues</h1><ul><li><p>GRUB2 同時支援 BIOS &amp; UEFI</p></li><li><p>主要設定檔位於 <code>/boot/grub2/grub.cfg</code>；但若是要設定 UEFI 時，grub.conf 就要到 <code>/boot/efi</code> 找</p></li><li><p>在 linux16 那一行，再最後加上 <code>net.ifnames=0</code> 後，網卡就會以傳統的方式命名(eth0, eth1 … etc)</p></li><li><p><code>set root</code> 是描述開機相關的檔案(vmlinuz-xxx / initramfs-xxx … etc)存在於哪個 partition</p></li><li><p>linux16 設定中，<code>root=UUID=xxxx</code> 則是用來指定 root partition</p></li></ul>]]></content>
      
      <categories>
          
          <category> RHCE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH134 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[RHCE7] RH134 Chapter 11. Accessing Network Storage with Network File System (NFS) 學習筆記</title>
      <link href="/blog/2016/05/12/RHCE/RHCE7-RH134-LearningNotes-CH11_AccessingNetworkStorageWithNetworkFileSystem(NFS)/"/>
      <url>/blog/2016/05/12/RHCE/RHCE7-RH134-LearningNotes-CH11_AccessingNetworkStorageWithNetworkFileSystem(NFS)/</url>
      <content type="html"><![CDATA[<h1 id="11-1-Mounting-Network-Storage-with-NFS"><a href="#11-1-Mounting-Network-Storage-with-NFS" class="headerlink" title="11.1 Mounting Network Storage with NFS"></a>11.1 Mounting Network Storage with NFS</h1><h2 id="11-1-1-Manualling-mouting-and-unmouting-NFS-shares"><a href="#11-1-1-Manualling-mouting-and-unmouting-NFS-shares" class="headerlink" title="11.1.1 Manualling mouting and unmouting NFS shares"></a>11.1.1 Manualling mouting and unmouting NFS shares</h2><h3 id="NFS-4-0-之前："><a href="#NFS-4-0-之前：" class="headerlink" title="NFS 4.0 之前："></a>NFS 4.0 之前：</h3><ul><li><p>NFS 啟動時會向 rpcbind 註冊</p></li><li><p>NFS 的 port 是 rpcbind(TCP 111) 所配發的</p></li><li><p>rpcbind restart，NFS 也要跟著 restart</p></li><li><p>查詢遠端主機開放的目錄：<code>sudo showmount -e [remote_host_name or IP]</code></p></li><li><p>掛載：<code>sudo mount -t nfs [remote_host_name or IP]:/content /mnt</code></p></li></ul><h3 id="NFS-4-0："><a href="#NFS-4-0：" class="headerlink" title="NFS 4.0："></a>NFS 4.0：</h3><ul><li><p>固定使用 TCP port 2049</p></li><li><p>無法使用 <strong>showmount</strong>，因此必須預先知道開放的目錄</p></li><li><p>同時掛載所有開放的目錄：<code>mount -t nfs [remote_host_name or IP]:/ /mnt</code> (確定路徑也可以 mount 特定目錄)</p></li></ul><blockquote><p>NFSv2, NFSv3, NFSv4 預設是同時開啟的</p></blockquote><p>RHEL 7 預設會使用 NFSv4，若不支援才會往下降；NFSv4 使用 TCP，舊版本則會用 TCP or UDP</p><p>掛載 NFS 方式：</p><ul><li><p>手動下命令</p></li><li><p>加到 <code>/etc/fstab</code> 中：<code>[remote_host_name]:/content  /mnt  nfs   default,sync,sec=xxx   0 0</code></p></li></ul><blockquote><p>網路磁碟機建議使用 sync 選項，確保資料完整性 (另外了解 soft &amp; hard 的差異)</p></blockquote><blockquote><p>使用 fsck 檢查的設備，必須是 umount or readonly 的狀態所，所出來的結果才是正確的</p></blockquote><h2 id="11-1-2-Security-methods"><a href="#11-1-2-Security-methods" class="headerlink" title="11.1.2 Security methods"></a>11.1.2 Security methods</h2><ul><li><p><code>none</code>：client 匿名存取(送來的身份會被忽略)，身份全部都會轉成 <strong>nfsnobody</strong></p></li><li><p><code>sys</code>：client 存取時會把身份送進來(例如：UID 1000)，NFS server 會找到對應的身份 &amp; 權限 (<strong><font color="red">預設值</font></strong>，但其實不安全)</p></li><li><p><code>krb5</code>：使用 kerberos ticket，但通訊時以明碼傳遞</p></li><li><p><code>krb5i</code>：同上，但加上完整性驗證，可判斷傳輸的資料是否被修改</p></li><li><p><code>krb5p</code>：同上，但傳輸的資料會被加密</p></li></ul><blockquote><p>若要讓 NFS 可以向 Kerberos 進行驗證，也同時需要有 <code>nfs-secure</code> 服務(在 <code>nfs-utils</code> 套件中)</p></blockquote><blockquote><p>使用 <code>klist</code> 可以查詢目前所擁有的 kerberos ticket</p></blockquote><hr><h1 id="Practice-Mounting-and-Unmounting-NFS"><a href="#Practice-Mounting-and-Unmounting-NFS" class="headerlink" title="Practice: Mounting and Unmounting NFS"></a>Practice: Mounting and Unmounting NFS</h1><h2 id="目前已存在設定"><a href="#目前已存在設定" class="headerlink" title="目前已存在設定"></a>目前已存在設定</h2><ol><li><p>server1 分享 <code>/shares/manual</code> &amp; <code>/shares/public</code> 兩個目錄</p></li><li><p>desktop1 掛載點為 <code>/mnt/manual</code> &amp; <code>/mnt/public</code></p></li><li><p><code>public</code> 分享目錄需要使用 <code>krb5p</code> 認證，<code>manual</code> 分享目錄則是使用 <code>sys</code> 認證</p></li><li><p><code>krb5.keytab</code> 位置位於 <code>http://classroom.example.com/pub/keytabs/desktop1.keytab</code></p></li></ol><h2 id="實作過程"><a href="#實作過程" class="headerlink" title="實作過程"></a>實作過程</h2><p>1、取得 krb5.keytab</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo wget -O /etc/krb5.keytab http://classroom.example.com/pub/keytabs/desktop1.keytab</span><br><span class="line">$ ls -lZ /etc/krb5.keytab</span><br><span class="line">-rw-r--r--. root root unconfined_u:object_r:krb5_keytab_t:s0 /etc/krb5.keytab</span><br></pre></td></tr></table></figure><p>2、啟動 <code>nfs-secure.service</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl <span class="built_in">enable</span> nfs-secure.service</span><br><span class="line">ln -s <span class="string">'/usr/lib/systemd/system/nfs-secure.service'</span> <span class="string">'/etc/systemd/system/nfs.target.wants/nfs-secure.service'</span></span><br><span class="line">[student@desktop0 ~]$ sudo systemctl restart nfs-secure.service</span><br></pre></td></tr></table></figure><p>3、建立目錄並設定掛載資訊</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"server1:/shares/public /mnt/public nfs sec=krb5p,sync 0 0"</span> | sudo tee --append /etc/fstab</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"server1:/shares/manual /mnt/manual nfs sec=sys,sync 0 0"</span> | sudo tee --append /etc/fstab</span><br><span class="line"></span><br><span class="line">$ sudo mount -a</span><br><span class="line">$ $ sudo df -hT</span><br><span class="line">Filesystem             Type      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/vda1              xfs        10G  3.1G  7.0G  31% /</span><br><span class="line">devtmpfs               devtmpfs  906M     0  906M   0% /dev</span><br><span class="line">tmpfs                  tmpfs     921M   80K  921M   1% /dev/shm</span><br><span class="line">tmpfs                  tmpfs     921M   17M  904M   2% /run</span><br><span class="line">tmpfs                  tmpfs     921M     0  921M   0% /sys/fs/cgroup</span><br><span class="line">server1:/shares/public nfs4       10G  3.1G  7.0G  31% /mnt/public</span><br><span class="line">server1:/shares/manual nfs4       10G  3.1G  7.0G  31% /mnt/manual</span><br></pre></td></tr></table></figure><hr><h1 id="11-2-Automounting-Network-Storage-with-NFS"><a href="#11-2-Automounting-Network-Storage-with-NFS" class="headerlink" title="11.2 Automounting Network Storage with NFS"></a>11.2 Automounting Network Storage with NFS</h1><p>需要安裝套件 <code>autofs</code>，會在系統中提供一個 autofs system service</p><p><strong>優點：</strong></p><ul><li><p>使用者不需要 root 權限來執行 mount &amp; unmount 指令</p></li><li><p>automounter 的設定對所有使用者皆有效，主要是著重在存取權限的調整</p></li><li><p>不會與 NFS server 一直持續保持連線，節省網路 &amp; 系統資源</p></li><li><p>與原本 mount 所使用的設定參數相同</p></li><li><p>提供 direct &amp; indirect 兩種目錄 mapping 模式，以提供 mount point 一定程度的彈性</p></li><li><p>indirect 模式下，目錄會被自動生成，降低手動的需求</p></li><li><p>automounter 其實可以用在 NFS 之外的其他檔案系統上</p></li></ul><h2 id="direct-map"><a href="#direct-map" class="headerlink" title="direct-map"></a>direct-map</h2><p>目錄 <code>/etc/auto.master.d</code>，檔名不拘，副檔名必須是 <code>.autofs</code></p><p><code>/etc/sysconfig/autofs</code> 中有 <code>TIMEOUT</code> 參數可以用，表示離開目錄多久會自動 unmount</p><p>自動掛載光碟機：<code>/mnt/cdrom   -ro,iso9660   :/dev/sr0</code></p><h2 id="indirect-map"><a href="#indirect-map" class="headerlink" title="indirect-map"></a>indirect-map</h2><p>掛載的目錄都會在同一個目錄下</p><p>可用萬用字元</p><h2 id="掛載方式"><a href="#掛載方式" class="headerlink" title="掛載方式"></a>掛載方式</h2><h3 id="1、安裝套件"><a href="#1、安裝套件" class="headerlink" title="1、安裝套件"></a>1、安裝套件</h3><p>首先要安裝 <code>autofs</code> 套件</p><h3 id="2、編輯-master-map-檔案"><a href="#2、編輯-master-map-檔案" class="headerlink" title="2、編輯 master-map 檔案"></a>2、編輯 master-map 檔案</h3><p>master-map 檔案名稱必須是 <code>.autofs</code> 結尾，並存放於 <code>/etc/auto.master.d</code> 目錄中，以下舉例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cat /etc/auto.master.d/demo.autofs</span><br><span class="line"><span class="comment"># indirect-map，並以 "/share" 目錄作為掛載目錄的基底，詳細設定檔內容位於 /etc/auto.demo 檔案中</span></span><br><span class="line">/shares   /etc/auto.demo</span><br><span class="line"><span class="comment"># direct-map，以 "/-" 作為掛載基底，詳細設定檔內容位於 /etc/auto.direct 檔案中</span></span><br><span class="line">/-        /etc/auto.direct</span><br></pre></td></tr></table></figure><h3 id="3、設定-mapping-檔案"><a href="#3、設定-mapping-檔案" class="headerlink" title="3、設定 mapping 檔案"></a>3、設定 mapping 檔案</h3><p>mapping 檔案則是要撰寫詳細的設定內容：</p><p><code>/etc/auto.demo</code> indirect-map 設定檔內容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用本地目錄 /shares/work，掛載遠端目錄 serverX:/shares/work</span></span><br><span class="line">work  -rw,sync  serverX:/shares/work</span><br><span class="line"><span class="comment"># 使用本地目錄 /shares，掛載遠端目錄 serverX:/shares 下的所有目錄(會一一取得對應)</span></span><br><span class="line">*     -rw,sync  serverX:/shares/&amp;</span><br></pre></td></tr></table></figure><blockquote><p>indirect-map 設定使用的是相對路徑的設計概念</p></blockquote><p><code>/etc/auto.direct</code> direct-map 設定檔內容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用本地目錄 /mnt/docs，掛載遠端目錄 serverX:/shares/docs</span></span><br><span class="line">/mnt/docs   -rw,sync  serverX:/shares/docs</span><br></pre></td></tr></table></figure><blockquote><p>由此可看出 direct-map 就是很明確的指定完整路徑</p></blockquote><h3 id="4、啟動-autofs-服務"><a href="#4、啟動-autofs-服務" class="headerlink" title="4、啟動 autofs 服務"></a>4、啟動 autofs 服務</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl <span class="built_in">enable</span> autofs</span><br><span class="line"></span><br><span class="line">$ sudo systemctl start autofs</span><br></pre></td></tr></table></figure><hr><h1 id="Practice-Automounting-NFS"><a href="#Practice-Automounting-NFS" class="headerlink" title="Practice: Automounting NFS"></a>Practice: Automounting NFS</h1><h2 id="環境設定"><a href="#環境設定" class="headerlink" title="環境設定"></a>環境設定</h2><ol><li><p>遠端主機 <code>server1</code> 使用 NFS 分享了 <code>/shares/{docs,work,public}</code> 三個目錄</p></li><li><p>存取遠端主機必須使用 Kerberos 協定，使用的是 <code>krb5p</code></p></li><li><p>本地主機 <code>desktop1</code> 使用 <code>/shares/{docs,work}</code> &amp; <code>/mnt/public</code> 目錄進行掛載</p></li><li><p><code>krb5.keytab</code> 檔案可到 <code>http://classroom.example.com/pub/keytabs/desktop1.keytab</code> 下載</p></li><li><p>必須要設定成永久性掛載</p></li></ol><h2 id="設定方式"><a href="#設定方式" class="headerlink" title="設定方式"></a>設定方式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安裝 autofs 套件</span></span><br><span class="line">$ sudo yum -y install autofs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立掛載用目錄</span></span><br><span class="line">$ sudo mkdir /shares</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取得 krb5.keytab</span></span><br><span class="line">$ sudo wget -O /etc/krb5.keytab http://classroom.example.com/pub/keytabs/desktop0.keytab</span><br><span class="line"><span class="comment"># 驗證 SElinux context 是否正確</span></span><br><span class="line">$ ls -lZ /etc/krb5.keytab</span><br><span class="line">-rw-r--r--. root root unconfined_u:object_r:krb5_keytab_t:s0 /etc/krb5.keytab</span><br><span class="line"></span><br><span class="line"><span class="comment"># 編輯 master-map 檔案</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"/shares   /etc/autofs.indirect"</span> | sudo tee --append /etc/auto.master.d/practice.autofs</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"/-   /etc/autofs.direct"</span> | sudo tee --append /etc/auto.master.d/practice.autofs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 編輯 indrect-map 檔案</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"docs  -rx,sync,sec=krb5p  server1:/shares/docs"</span> | sudo tee --append /etc/autofs.indirect</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"work  -rx,sync,sec=krb5p  server1:/shares/work"</span> | sudo tee --append /etc/autofs.indirect</span><br><span class="line"></span><br><span class="line"><span class="comment"># 編輯 direct-map 檔案</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"/mnt/public  -rx,sync,sec=krb5p  server1:/shares/public"</span> | sudo tee --append /etc/autofs.direct</span><br><span class="line"></span><br><span class="line"><span class="comment"># 啟動 nfs-secure 服務(為了進行 Kerberos 認證)</span></span><br><span class="line">$ sudo systemctl start nfs-secure.service</span><br><span class="line">$ sudo systemctl restart autofs.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 啟動 autofs 服務</span></span><br><span class="line">$ sudo systemctl <span class="built_in">enable</span> autofs.service</span><br><span class="line">$ sudo systemctl start autofs.service</span><br></pre></td></tr></table></figure><hr><h1 id="Lab-Accessing-Network-Storage-with-Network-File-System-NFS"><a href="#Lab-Accessing-Network-Storage-with-Network-File-System-NFS" class="headerlink" title="Lab: Accessing Network Storage with Network File System(NFS)"></a>Lab: Accessing Network Storage with Network File System(NFS)</h1><h2 id="目標"><a href="#目標" class="headerlink" title="目標"></a>目標</h2><ol><li><p><code>desktop1</code> 已經設定好 LDAP &amp; Kerberos 認証，遠端主機為 <code>classroom.example.com</code></p></li><li><p>遠端主機分享了 <code>ldapuserX</code> 所有的家目錄，分享路徑為 <code>/home/guests</code> 底下</p></li><li><p>掛載於本地端的 <code>/home/guests</code> 下</p></li><li><p>ldapuserX 登入後會位於 <code>/home/guests/ldapuserX</code> 家目錄中</p></li></ol><h2 id="實作過程-1"><a href="#實作過程-1" class="headerlink" title="實作過程"></a>實作過程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mkdir /home/guests</span><br><span class="line">$ sudo yum -y install autofs</span><br><span class="line"></span><br><span class="line"><span class="comment"># autofs 設定</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"/home/guests    /etc/autofs.indirect"</span> | sudo tee --append /etc/auto.master.d/lab.autofs</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"*   -rw,sync    classroom.example.com:/home/guests/&amp;"</span> | sudo tee --append /etc/autofs.indirect</span><br><span class="line"></span><br><span class="line"><span class="comment"># 啟用服務</span></span><br><span class="line">$ sudo systemctl <span class="built_in">enable</span> autofs.service</span><br><span class="line">$ sudo systemctl restart autofs.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登入驗證</span></span><br><span class="line">$ ssh ldapuser1@localhost</span><br><span class="line">[ldapuser1@desktop1 ~]$ <span class="built_in">pwd</span></span><br><span class="line">/home/guests/ldapuser1</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RHCE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH134 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[RHCE7] RH134 Chapter 12. Accessing Network Storage with SMB 學習筆記</title>
      <link href="/blog/2016/05/12/RHCE/RHCE7-RH134-LearningNotes-CH12_AccessingNetworkStorageWithSMB/"/>
      <url>/blog/2016/05/12/RHCE/RHCE7-RH134-LearningNotes-CH12_AccessingNetworkStorageWithSMB/</url>
      <content type="html"><![CDATA[<h1 id="12-1-Accessing-Network-Storage-with-SMB"><a href="#12-1-Accessing-Network-Storage-with-SMB" class="headerlink" title="12.1 Accessing Network Storage with SMB"></a>12.1 Accessing Network Storage with SMB</h1><h2 id="Manually-mounting-and-unmouting-SMB-file-systems"><a href="#Manually-mounting-and-unmouting-SMB-file-systems" class="headerlink" title="Manually mounting and unmouting SMB file systems"></a>Manually mounting and unmouting SMB file systems</h2><p>要裝 <code>cifs-utils</code> &amp; <code>samba-client</code> 兩個套件</p><h3 id="查詢"><a href="#查詢" class="headerlink" title="查詢"></a>查詢</h3><p>查詢 server 分享了什麼資源(匿名)：<code>smbclient -L //server0</code></p><p>查詢 server 分享了什麼資源：<code>smbclient -L //server0 -U [UserName] -W [DomainName]</code> (<code>-U</code> 指定使用者，<code>-W</code> 指定網域)</p><h3 id="掛載"><a href="#掛載" class="headerlink" title="掛載"></a>掛載</h3><p>匿名掛載：<code>sudo mount -t cifs -o guest //server0/public /mnt</code></p><p>指定使用者掛載：<code>sudo mount -t cifs -o username=[UserName],password=[Password],workgroup=[DomainName] //server0/public /mnt</code> (若不加 <code>password</code> 會被要求手動輸入密碼)</p><h2 id="透過-etc-fstab-掛載"><a href="#透過-etc-fstab-掛載" class="headerlink" title="透過 /etc/fstab 掛載"></a>透過 /etc/fstab 掛載</h2><p>加入 <code>/etc/fstab</code> 中：<code>//server0/pubilic  /mnt  cifs  defaults,username=[UserName],password=[Password],workgroup=[DomainName] 0 0</code></p><h2 id="指定-credential-掛載"><a href="#指定-credential-掛載" class="headerlink" title="指定 credential 掛載"></a>指定 credential 掛載</h2><p>以 credential 的方式設定：<code>//server0/pubilic  /mnt  cifs  defaults,credentials=/root/smb.txt 0 0</code></p><p><code>/root/smb.txt</code> 的內容如下：(<strong>only root access, chmod 600</strong>)</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">username</span>=[UserName]</span><br><span class="line"><span class="attr">password</span>=[Password]</span><br><span class="line"><span class="attr">domain</span>=[DomainName]</span><br></pre></td></tr></table></figure><h2 id="Mounting-SMB-file-systems-with-the-automounter"><a href="#Mounting-SMB-file-systems-with-the-automounter" class="headerlink" title="Mounting SMB file systems with the automounter"></a>Mounting SMB file systems with the automounter</h2><p>除了 NFS 之外，SMB 也可以使用 automounter 來協助自動掛載，差別只有掛載參數上的不同，以下是設定範例：</p><ul><li><p>本地目錄：<code>/bakerst/cases</code></p></li><li><p>遠端目錄：<code>//serverX/cases</code></p></li></ul><p>1、安裝 <code>autofs</code> 套件</p><p>2、新增檔案 <strong>/etc/auto.master.d/bakerst.autofs</strong>，內容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bakerst  /etc/auto.bakerst</span><br></pre></td></tr></table></figure><p>3、新增檔案 <strong>/etc/auto.bakerst</strong>，內容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cases   -fstype=cifs,credentials=/secure/sherlock   ://serverX/cases</span><br></pre></td></tr></table></figure><p>4、新增檔案 <strong>/secure/sherlock</strong>，內容如下：(<strong>only root access</strong>, permission <strong>600</strong>)</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">username</span>=[UserName]</span><br><span class="line"><span class="attr">password</span>=[Password]</span><br><span class="line"><span class="attr">domain</span>=[DomainName]</span><br></pre></td></tr></table></figure><p>5、啟動 autofs：<code>sudo systemctl enable autofs &amp;&amp; sudo systemctl restart autofs</code></p><hr><h1 id="Practice-Mounting-a-SMB-File-System"><a href="#Practice-Mounting-a-SMB-File-System" class="headerlink" title="Practice: Mounting a SMB File System"></a>Practice: Mounting a SMB File System</h1><h2 id="目標"><a href="#目標" class="headerlink" title="目標"></a>目標</h2><ol><li><p>掛載遠端目錄 <code>//server1/student</code> 到本地端 <code>~/work</code> 中</p></li><li><p>連線帳號/密碼/Domain = student/student/MYGROUP</p></li><li><p>永久性掛載</p></li></ol><h2 id="實作過程"><a href="#實作過程" class="headerlink" title="實作過程"></a>實作過程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum -y install cifs-utils</span><br><span class="line"></span><br><span class="line">$ sudo bash -c <span class="string">'cat &lt;&lt; EOF &gt; /root/student.smb</span></span><br><span class="line"><span class="string">username=student</span></span><br><span class="line"><span class="string">password=student</span></span><br><span class="line"><span class="string">domain=MYGROUP</span></span><br><span class="line"><span class="string">EOF'</span></span><br><span class="line"></span><br><span class="line">$ mkdir ~/work</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"//server0/student  /home/student/work  cifs  credentials=/root/student.smb  0 0"</span> | sudo tee --append /etc/fstab</span><br><span class="line">$ sudo mount -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 驗證連線結果</span></span><br><span class="line">[student@desktop0 ~]$ df -hT | grep work</span><br><span class="line">//server0/student cifs       10G  3.1G  7.0G  31% /home/student/work</span><br></pre></td></tr></table></figure><hr><h1 id="Lab-Accessing-Network-Storage-with-SMB"><a href="#Lab-Accessing-Network-Storage-with-SMB" class="headerlink" title="Lab: Accessing Network Storage with SMB"></a>Lab: Accessing Network Storage with SMB</h1><h2 id="目標-1"><a href="#目標-1" class="headerlink" title="目標"></a>目標</h2><h3 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h3><ol><li><p>遠端主機：<code>server1</code></p></li><li><p>DOMAIN：<code>MYGROUP</code></p></li><li><p>使用者帳號密碼：<code>student</code> / <code>student</code></p></li></ol><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ol><li><p>自動掛載遠端主機的 <code>student</code> 到本地端的家目錄 <code>/shares/work</code></p></li><li><p>自動掛載遠端主機的 <code>public</code> 到本地端目錄 <code>/shares/docs</code> 公開分享的目錄，允許任何人存取，權限為 <code>read-only</code></p></li><li><p>自動掛載遠端主機的 <code>/shares/cases</code> 到本地端目錄 <code>/shares/cases</code>，並限制只有 <code>bakerst</code>(GID=10221) 群組可以存取，權限為 <code>read-write</code></p></li><li><p>要設定為永久性掛載(重開機之後要依然生效)</p></li></ol><h2 id="實作過程-1"><a href="#實作過程-1" class="headerlink" title="實作過程"></a>實作過程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安裝套件</span></span><br><span class="line">$ sudo yum -y install cifs-utils autofs</span><br><span class="line"></span><br><span class="line">$ sudo bash -c <span class="string">'cat &lt;&lt; EOF &gt; /root/student.smb</span></span><br><span class="line"><span class="string">username=student</span></span><br><span class="line"><span class="string">password=student</span></span><br><span class="line"><span class="string">domain=MYGROUP</span></span><br><span class="line"><span class="string">EOF'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立本地掛載目錄</span></span><br><span class="line">[student@desktop0 ~]$ sudo mkdir -p /shares/&#123;work,docs,cases&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定 autofs</span></span><br><span class="line">[student@desktop0 ~]$ <span class="built_in">echo</span> <span class="string">"/shares /etc/autofs.indirect"</span> | sudo tee --append /etc/auto.master.d/smb.autofs</span><br><span class="line">[student@desktop0 ~]$ <span class="built_in">echo</span> <span class="string">"work -fstype=cifs,credentials=/root/student.smb ://server0/student"</span> | sudo tee --append /etc/autofs.indirect</span><br><span class="line">[student@desktop0 ~]$ <span class="built_in">echo</span> <span class="string">"docs -fstype=cifs,guest ://server0/public"</span> | sudo tee --append /etc/autofs.indirect</span><br><span class="line">[student@desktop0 ~]$ <span class="built_in">echo</span> <span class="string">"cases -fstype=cifs,credentials=/root/student.smb ://server0/bakerst"</span> | sudo tee --append /etc/autofs.indirect</span><br><span class="line"></span><br><span class="line"><span class="comment"># 啟動 autofs 服務</span></span><br><span class="line">[student@desktop0 ~]$ sudo systemctl <span class="built_in">enable</span> autofs.service</span><br><span class="line">[student@desktop0 ~]$ sudo systemctl start autofs.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 backerst 群組，並將 student 帳號加入</span></span><br><span class="line">[student@desktop0 ~]$ sudo groupadd -g 10221 bakerst</span><br><span class="line">[student@desktop0 ~]$ sudo usermod -aG bakerst student</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RHCE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH134 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[RHCE7] RH134 Chapter 10. Managing Logical Volume Management(LVM) Storage 學習筆記</title>
      <link href="/blog/2016/05/11/RHCE/RHCE7-RH134-LearningNotes-CH10_ManagingLogicalVolumeManagement(LVM)Storage/"/>
      <url>/blog/2016/05/11/RHCE/RHCE7-RH134-LearningNotes-CH10_ManagingLogicalVolumeManagement(LVM)Storage/</url>
      <content type="html"><![CDATA[<h1 id="10-1-Logical-Volume-Management-Concepts"><a href="#10-1-Logical-Volume-Management-Concepts" class="headerlink" title="10.1 Logical Volume Management Concepts"></a>10.1 Logical Volume Management Concepts</h1><p>可以從下圖很清楚看出 Physical Drivers / Partitions / PV(Physical Volume) / VG(Volume Group) / LV(Logical Volume) 的相互關係</p><p><img src="http://mo.morsi.org/blog/files/lvm1.png" alt="LVM"></p><p>此外，還有 PE(Physical Extent) &amp; LE(Logical Extent) 與上述其他概念的組成關係：</p><p><img src="https://camo.githubusercontent.com/d8809c16fe3e3f5532e87165dfe4012346b3b13e/687474703a2f2f73332e353163746f2e636f6d2f7779667330322f4d30302f37322f33352f774b696f4c31586574513777746d7a6641414a364d4351464339303134332e6a7067" alt="PE_LE_1"></p><p><img src="http://www.linux-tips-and-tricks.de/images/stories/lvm.jpg" alt="PE_LE_2"></p><hr><h1 id="10-2-Managing-Logical-Volumes"><a href="#10-2-Managing-Logical-Volumes" class="headerlink" title="10.2 Managing Logical Volumes"></a>10.2 Managing Logical Volumes</h1><h2 id="10-2-1-Create-PV"><a href="#10-2-1-Create-PV" class="headerlink" title="10.2.1 Create PV"></a>10.2.1 Create PV</h2><ol><li><p>在 /dev/sda 中建立一個 partition，使用所有空間，partition type = 8e</p></li><li><p>第一個硬碟建立 PV：<code>sudo pvcreate /dev/sda1</code></p></li><li><p>第二個硬碟建立 PV：<code>sudo pvcreate /dev/sdb</code>(沒有 partition 的狀況下)</p></li></ol><h3 id="其他相關指令"><a href="#其他相關指令" class="headerlink" title="其他相關指令"></a>其他相關指令</h3><ul><li><p><code>pvscan</code>：目前有哪些 PV</p></li><li><p><code>pvdisplay [pv_name]</code>：顯示 PV 的詳細資訊</p></li></ul><h2 id="10-2-2-Create-VG"><a href="#10-2-2-Create-VG" class="headerlink" title="10.2.2 Create VG"></a>10.2.2 Create VG</h2><ol><li><p>建立 Volume Group：<code>sudo vgcreate -s 16M vg0 /dev/sda1 /dev/sdb</code> (<strong><font color="red">設定 PE 大小為 16M</font></strong>)</p><blockquote><p>相同 VG 中的 PE 都一樣大</p></blockquote></li><li><p>檢查 PV：<code>sudo pvscan</code> (顯示 PV 被使用中)</p></li><li><p>檢查 VG：<code>sudo vgscan</code></p></li><li><p>檢視 VG 詳細資料：<code>sudo vgdisplay [vg_name]</code></p></li></ol><h2 id="10-2-3-Create-LV"><a href="#10-2-3-Create-LV" class="headerlink" title="10.2.3 Create LV"></a>10.2.3 Create LV</h2><ol><li><p>建立 LV(從 vg0 切割 200M 空間，給 LV 使用，並命名為 lv-1)：<code>sudo lvcreate -L 200M -n lv-1 vg0</code></p></li><li><p>建立 LV(使用 PE 個數指定大小)：<code>sudo lvcreate -l 13 -n lv-2 vg0</code></p></li><li><p>檢查 LV：<code>sudo lvscan</code></p></li><li><p>檢視 LV 詳細資料：<code>sudo lvdisplay /dev/vg0/lv-1</code> &amp; <code>sudo lvdisplay /dev/vg0/lv-2</code></p></li></ol><blockquote><p>要使用 LV 前要記得進行 format 的動作</p></blockquote><hr><h1 id="Practice-Adding-a-Logical-Volume"><a href="#Practice-Adding-a-Logical-Volume" class="headerlink" title="Practice: Adding a Logical Volume"></a>Practice: Adding a Logical Volume</h1><h2 id="目標"><a href="#目標" class="headerlink" title="目標"></a>目標</h2><ol><li><p>建立一個 volume group，名稱為 <code>shazam</code>，由兩個大小為 <code>256 MB</code> 的 physical partition 組成(來源為 <code>/dev/vdb</code>)</p></li><li><p>從 volume group 中建立一個 <code>400 MB</code> 的 logical volume，名稱為 <code>storage</code></p></li><li><p>將 logical volume 掛載在 <code>/storage</code> 目錄</p></li></ol><h2 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h2><h3 id="1、建立一個-volume-group，名稱為-shazam，由兩個大小為-256-MB-的-physical-partition-組成-來源為-dev-vdb"><a href="#1、建立一個-volume-group，名稱為-shazam，由兩個大小為-256-MB-的-physical-partition-組成-來源為-dev-vdb" class="headerlink" title="1、建立一個 volume group，名稱為 shazam，由兩個大小為 256 MB 的 physical partition 組成(來源為 /dev/vdb)"></a>1、建立一個 volume group，名稱為 <code>shazam</code>，由兩個大小為 <code>256 MB</code> 的 physical partition 組成(來源為 <code>/dev/vdb</code>)</h3><p>1.1 分割硬碟：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">$ sudo fdisk /dev/vdb</span><br><span class="line">Welcome to fdisk (util-linux 2.23.2).</span><br><span class="line"></span><br><span class="line">Changes will remain <span class="keyword">in</span> memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write <span class="built_in">command</span>.</span><br><span class="line"></span><br><span class="line">Device does not contain a recognized partition table</span><br><span class="line">Building a new DOS disklabel with disk identifier 0xa2e37afd.</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Partition <span class="built_in">type</span>:</span><br><span class="line">   p   primary (0 primary, 0 extended, 4 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p):</span><br><span class="line">Partition number (1-4, default 1):</span><br><span class="line">First sector (2048-20971519, default 2048):</span><br><span class="line">Using default value 2048</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (2048-20971519, default 20971519): +256M</span><br><span class="line">Partition 1 of <span class="built_in">type</span> Linux and of size 256 MiB is <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Partition <span class="built_in">type</span>:</span><br><span class="line">   p   primary (1 primary, 0 extended, 3 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p):</span><br><span class="line">Using default response p</span><br><span class="line">Partition number (2-4, default 2):</span><br><span class="line">First sector (526336-20971519, default 526336):</span><br><span class="line">Using default value 526336</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (526336-20971519, default 20971519): +256M</span><br><span class="line">Partition 2 of <span class="built_in">type</span> Linux and of size 256 MiB is <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): t</span><br><span class="line">Partition number (1,2, default 2): 1</span><br><span class="line">Hex code (<span class="built_in">type</span> L to list all codes): 8e</span><br><span class="line">Changed <span class="built_in">type</span> of partition <span class="string">'Linux'</span> to <span class="string">'Linux LVM'</span></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): t</span><br><span class="line">Partition number (1,2, default 2): 2</span><br><span class="line">Hex code (<span class="built_in">type</span> L to list all codes): 8e</span><br><span class="line">Changed <span class="built_in">type</span> of partition <span class="string">'Linux'</span> to <span class="string">'Linux LVM'</span></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): w</span><br><span class="line">The partition table has been altered!</span><br><span class="line"></span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line">Syncing disks.</span><br><span class="line"></span><br><span class="line">$ sudo partprobe -s</span><br><span class="line">/dev/vda: msdos partitions 1</span><br><span class="line">/dev/vdb: msdos partitions 1 2</span><br></pre></td></tr></table></figure><p>1.2 建立 physical volume</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pvcreate /dev/vdb1 /dev/vdb2</span><br><span class="line">  Physical volume <span class="string">"/dev/vdb1"</span> successfully created</span><br><span class="line">  Physical volume <span class="string">"/dev/vdb2"</span> successfully created</span><br></pre></td></tr></table></figure><p>1.3 建立 volume group</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vgcreate shazam /dev/vdb1 /dev/vdb2</span><br><span class="line">  Volume group <span class="string">"shazam"</span> successfully created</span><br></pre></td></tr></table></figure><h3 id="2、從-volume-group-中建立一個-400-MB-的-logical-volume，名稱為-storage"><a href="#2、從-volume-group-中建立一個-400-MB-的-logical-volume，名稱為-storage" class="headerlink" title="2、從 volume group 中建立一個 400 MB 的 logical volume，名稱為 storage"></a>2、從 volume group 中建立一個 <code>400 MB</code> 的 logical volume，名稱為 <code>storage</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ sudo lvcreate -n storage -L 400M shazam</span><br><span class="line">  Logical volume <span class="string">"storage"</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化 LV</span></span><br><span class="line">$ sudo mkfs.ext4 /dev/shazam/storage</span><br><span class="line">  mke2fs 1.42.9 (28-Dec-2013)</span><br><span class="line">  Filesystem label=</span><br><span class="line">  OS <span class="built_in">type</span>: Linux</span><br><span class="line">  Block size=1024 (<span class="built_in">log</span>=0)</span><br><span class="line">  Fragment size=1024 (<span class="built_in">log</span>=0)</span><br><span class="line">  Stride=0 blocks, Stripe width=0 blocks</span><br><span class="line">  102400 inodes, 409600 blocks</span><br><span class="line">  20480 blocks (5.00%) reserved <span class="keyword">for</span> the super user</span><br><span class="line">  First data block=1</span><br><span class="line">  Maximum filesystem blocks=34078720</span><br><span class="line">  50 block groups</span><br><span class="line">  8192 blocks per group, 8192 fragments per group</span><br><span class="line">  2048 inodes per group</span><br><span class="line">  Superblock backups stored on blocks:</span><br><span class="line">          8193, 24577, 40961, 57345, 73729, 204801, 221185, 401409</span><br><span class="line"></span><br><span class="line">  Allocating group tables: <span class="keyword">done</span></span><br><span class="line">  Writing inode tables: <span class="keyword">done</span></span><br><span class="line">  Creating journal (8192 blocks): <span class="keyword">done</span></span><br><span class="line">  Writing superblocks and filesystem accounting information: <span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="3、將-logical-volume-掛載在-storage-目錄"><a href="#3、將-logical-volume-掛載在-storage-目錄" class="headerlink" title="3、將 logical volume 掛載在 /storage 目錄"></a>3、將 logical volume 掛載在 <code>/storage</code> 目錄</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ sudo blkid</span><br><span class="line">/dev/vda1: UUID=<span class="string">"9bf6b9f7-92ad-441b-848e-0257cbb883d1"</span> TYPE=<span class="string">"xfs"</span></span><br><span class="line">/dev/vdb1: UUID=<span class="string">"MxwktT-fxCb-KjzV-muCq-Dk7z-IHZU-WdclEG"</span> TYPE=<span class="string">"LVM2_member"</span></span><br><span class="line">/dev/vdb2: UUID=<span class="string">"mQaiiR-3LEA-XhT4-cd36-gT4T-7jjR-HrQreq"</span> TYPE=<span class="string">"LVM2_member"</span></span><br><span class="line">/dev/mapper/shazam-storage: UUID=<span class="string">"4b5e590a-10af-4e44-8619-aba91e436d17"</span> TYPE=<span class="string">"ext4"</span></span><br><span class="line"></span><br><span class="line">$ sudo mkdir /storage</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"UUID=4b5e590a-10af-4e44-8619-aba91e436d17 /storage ext4 defaults 0 2"</span> | sudo tee --append /etc/fstab</span><br><span class="line">$ sudo mount -a</span><br><span class="line">$ sudo mount | grep storage</span><br><span class="line">/dev/mapper/shazam-storage on /storage <span class="built_in">type</span> ext4 (rw,relatime,seclabel,data=ordered)</span><br></pre></td></tr></table></figure><hr><h1 id="10-3-Extending-Logical-Volumes"><a href="#10-3-Extending-Logical-Volumes" class="headerlink" title="10.3 Extending Logical Volumes"></a>10.3 Extending Logical Volumes</h1><h2 id="10-3-1-Extending-and-reducing-a-volume-group"><a href="#10-3-1-Extending-and-reducing-a-volume-group" class="headerlink" title="10.3.1 Extending and reducing a volume group"></a>10.3.1 Extending and reducing a volume group</h2><ol><li><p>建立新的 PV：<code>sudo pvcreate /dev/sdc</code></p></li><li><p>將新的 PV(/dev/sdc) 加到 VG 中：<code>sudo vgextend vg0 /dev/sdc</code></p></li></ol><blockquote><p>若要把 PV 移出 VG 可以使用類似的指令：<code>sudo vgreduce vg0 /dev/sda1</code></p></blockquote><h2 id="10-3-2-Extend-a-logical-volume-and-XFS-file-system"><a href="#10-3-2-Extend-a-logical-volume-and-XFS-file-system" class="headerlink" title="10.3.2 Extend a logical volume and XFS file system"></a>10.3.2 Extend a logical volume and XFS file system</h2><p>目標：<strong>將 LV 容量加大到 300M</strong></p><ol><li><p>LV 放大可以 online，縮小需要 offline：<code>sudo lvextend -L +100M /dev/vg0/lv-1</code> or <code>sudo lvextend -L 300M /dev/vg0/lv-1</code></p></li><li><p>也可以用指定 PE 的個數來放大：<code>sudo lvextend -l +7 /dev/vg0/lv-2</code> or <code>sudo lvextend -l 19 /dev/vg0/lv-2</code></p></li><li><p>檢查 LV 狀態：<code>sudo lvscan</code></p></li><li><p>放大 XFS 檔案系統：<code>sudo xfs_growfs /dev/vg0/lv-1</code></p></li><li><p>放大 EXT4 檔案系統：<code>sudo resize2fs /dev/vg0/lv-2</code></p></li></ol><h3 id="如何縮小-LV"><a href="#如何縮小-LV" class="headerlink" title="如何縮小 LV"></a>如何縮小 LV</h3><p><strong><font color="red">【註】</font></strong> XFS 檔案系統僅能放大，不能縮小(上面的 lv-1 已經無法縮小)</p><p>目標：縮小 EXT4 到 200M</p><ol><li><p>umount EXT4 partition：<code>sudo umount /lv-2</code></p></li><li><p>檢查 LV：<code>sudo fsck -f /dev/vg0/lv-2</code></p></li><li><p>縮小 EXT4 檔案系統：<code>sudo resize2fs /dev/vg0/lv-2 200M</code></p></li><li><p>縮小 LV：<code>sudo lvreduce -L 200M /dev/vg0/lv-2</code></p></li><li><p>重新掛載磁區：<code>sudo mount -a</code></p></li></ol><h3 id="如何縮小-VG-amp-移除-PV-硬碟"><a href="#如何縮小-VG-amp-移除-PV-硬碟" class="headerlink" title="如何縮小 VG &amp; 移除 PV(硬碟)"></a>如何縮小 VG &amp; 移除 PV(硬碟)</h3><p>目標：移除第一個 PV(<code>/dev/sda1</code>)</p><ol><li><p>移動指定 PV 中的檔案到其他 PV 上：<code>pvscan</code> -&gt; <code>sudo pvmove /dev/sda1 /dev/sdc</code>(也可以不指定目的裝置)</p></li><li><p>移除 VG 中的 PV：<code>sudo vgreduce vg0 /dev/sda1</code> -&gt; <code>pvscan</code></p></li><li><p>徹底移除 PV：<code>sudo pvremove /dev/sda1</code></p></li></ol><p>最後就可以把電腦關機並移除硬碟 /dev/sda 囉!</p><h3 id="移除-LV"><a href="#移除-LV" class="headerlink" title="移除 LV"></a>移除 LV</h3><p>目標：<strong>移除 /dev/vg0/lv-1</strong></p><ol><li>卸載檔案系統：<code>sudo umount /lv-1</code></li><li>移除 LV：<code>sudo lvremove /dev/vg0/lv-1</code> -&gt; <code>sudo lvscan</code></li></ol><hr><h1 id="Practice-Extending-a-Logical-Volume"><a href="#Practice-Extending-a-Logical-Volume" class="headerlink" title="Practice: Extending a Logical Volume"></a>Practice: Extending a Logical Volume</h1><h2 id="目標-1"><a href="#目標-1" class="headerlink" title="目標"></a>目標</h2><ol><li><p>以上一個練習為基礎，增加一個容量為 <code>800MB</code> 的 physical volume</p></li><li><p>把原有的 logical volume(<code>storage</code>)大小增加為 1GB</p></li></ol><h3 id="1、以上一個練習為基礎，增加一個容量為-800MB-的-physical-volume"><a href="#1、以上一個練習為基礎，增加一個容量為-800MB-的-physical-volume" class="headerlink" title="1、以上一個練習為基礎，增加一個容量為 800MB 的 physical volume"></a>1、以上一個練習為基礎，增加一個容量為 <code>800MB</code> 的 physical volume</h3><p>1.1 分割硬碟</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">$ sudo fdisk /dev/vdb</span><br><span class="line">[sudo] password <span class="keyword">for</span> student:</span><br><span class="line">Welcome to fdisk (util-linux 2.23.2).</span><br><span class="line"></span><br><span class="line">Changes will remain <span class="keyword">in</span> memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write <span class="built_in">command</span>.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Partition <span class="built_in">type</span>:</span><br><span class="line">   p   primary (2 primary, 0 extended, 2 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p):</span><br><span class="line">Using default response p</span><br><span class="line">Partition number (3,4, default 3):</span><br><span class="line">First sector (1050624-20971519, default 1050624):</span><br><span class="line">Using default value 1050624</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (1050624-20971519, default 20971519): +800M</span><br><span class="line">Partition 3 of <span class="built_in">type</span> Linux and of size 800 MiB is <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): t</span><br><span class="line">Partition number (1-3, default 3):</span><br><span class="line">Hex code (<span class="built_in">type</span> L to list all codes): 8e</span><br><span class="line">Changed <span class="built_in">type</span> of partition <span class="string">'Linux'</span> to <span class="string">'Linux LVM'</span></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): w</span><br><span class="line">The partition table has been altered!</span><br><span class="line"></span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line"></span><br><span class="line">WARNING: Re-reading the partition table failed with error 16: Device or resource busy.</span><br><span class="line">The kernel still uses the old table. The new table will be used at</span><br><span class="line">the next reboot or after you run partprobe(8) or kpartx(8)</span><br><span class="line">Syncing disks.</span><br><span class="line"></span><br><span class="line">$ sudo partprobe -s</span><br><span class="line">/dev/vda: msdos partitions 1</span><br><span class="line">/dev/vdb: msdos partitions 1 2 3</span><br></pre></td></tr></table></figure><p>1.2 加入 physical volume</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pvcreate /dev/vdb3</span><br><span class="line">  Physical volume <span class="string">"/dev/vdb3"</span> successfully created</span><br></pre></td></tr></table></figure><p>1.3 擴充 volume group 空間</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vgextend shazam /dev/vdb3</span><br><span class="line">  Volume group <span class="string">"shazam"</span> successfully extended</span><br><span class="line">$ sudo vgdisplay shazam</span><br><span class="line">  --- Volume group ---</span><br><span class="line">  VG Name               shazam</span><br><span class="line">  System ID</span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        3</span><br><span class="line">  Metadata Sequence No  3</span><br><span class="line">  VG Access             <span class="built_in">read</span>/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                1</span><br><span class="line">  Open LV               1</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                3</span><br><span class="line">  Act PV                3</span><br><span class="line">  VG Size               1.27 GiB</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              325</span><br><span class="line">  Alloc PE / Size       100 / 400.00 MiB</span><br><span class="line">  Free  PE / Size       225 / 900.00 MiB</span><br><span class="line">  VG UUID               s4g8vT-JCW9-p84f-wVU1-0dsn-xkrh-vytTVc</span><br></pre></td></tr></table></figure><h3 id="2、把原有的-logical-volume-storage-大小增加為-1GB"><a href="#2、把原有的-logical-volume-storage-大小增加為-1GB" class="headerlink" title="2、把原有的 logical volume(storage)大小增加為 1GB"></a>2、把原有的 logical volume(<code>storage</code>)大小增加為 1GB</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ sudo lvextend -L 1G /dev/shazam/storage</span><br><span class="line">  Extending logical volume storage to 1.00 GiB</span><br><span class="line">  Logical volume storage successfully resized</span><br><span class="line"></span><br><span class="line">$ sudo resize2fs /dev/shazam/storage</span><br><span class="line">resize2fs 1.42.9 (28-Dec-2013)</span><br><span class="line">Filesystem at /dev/shazam/storage is mounted on /storage; on-line resizing required</span><br><span class="line">old_desc_blocks = 4, new_desc_blocks = 8</span><br><span class="line">The filesystem on /dev/shazam/storage is now 1048576 blocks long.</span><br><span class="line"></span><br><span class="line">$ df -hT | grep storage</span><br><span class="line">/dev/mapper/shazam-storage ext4      984M  2.8M  932M   1% /storage</span><br></pre></td></tr></table></figure><hr><h1 id="10-4-Snapshot-補充"><a href="#10-4-Snapshot-補充" class="headerlink" title="10.4 Snapshot (補充)"></a>10.4 Snapshot (補充)</h1><p>假設：有個 20T 的 MySQL 資料庫，需要備份</p><ol><li><p>停掉 MySQL 服務</p></li><li><p>建立 Snapshop：<code>sudo lvcreate -L 100M -s -n backup /dev/vg0/lv-2</code> -&gt; ‘sudo lvscan’</p></li><li><p>啟動 MySQL 服務</p></li><li><p>檢查 LV 之間的關聯：<code>sudo lvs</code></p></li></ol><blockquote><p>只有在 PE 中的資料異動前，才會有資料複製的動作發生</p></blockquote><h2 id="老師設計的實驗"><a href="#老師設計的實驗" class="headerlink" title="老師設計的實驗"></a>老師設計的實驗</h2><ol><li><p>reset server</p></li><li><p>幫 server 加上 200M/300M/500M IDE 硬碟共三顆</p></li><li><p>開機，按 F12 選擇 virtio(4) 開機</p></li></ol>]]></content>
      
      <categories>
          
          <category> RHCE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH134 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[RHCE7] RH134 Chapter 08. Connecting to Network-defined Users and Groups 學習筆記</title>
      <link href="/blog/2016/05/09/RHCE/RHCE7-RH134-LearningNotes-CH08_ConnectingToNetwork-DefinedUsersAndGroups/"/>
      <url>/blog/2016/05/09/RHCE/RHCE7-RH134-LearningNotes-CH08_ConnectingToNetwork-DefinedUsersAndGroups/</url>
      <content type="html"><![CDATA[<h1 id="老師補充"><a href="#老師補充" class="headerlink" title="老師補充"></a>老師補充</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取得使用者資訊(跟 /etc/passwd 沒有絕對關係)</span></span><br><span class="line">[vagrant@server tmp]$ getent passwd user1</span><br><span class="line">user1:x:1001:1001::/home/user1:/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取得群組資訊</span></span><br><span class="line">[vagrant@server tmp]$ getent group user1</span><br><span class="line">user1:x:1001:</span><br></pre></td></tr></table></figure><p>驗證是否通過：</p><ol><li><p>帳號 &amp; 密碼正確</p></li><li><p>可以正確取得使用者資訊</p></li></ol><p>NIS &amp; LDAP 單獨可做到：</p><ol><li><p>可提供使用者資訊</p></li><li><p>可提供帳號密碼的驗證方法</p></li></ol><blockquote><p>但 Kerberos 僅能提供帳號密碼驗證，無法提供使用者資訊，因此一般會與 LDAP 搭配來解決提供使用者資訊的問題，Windows AD 目前就是依照這種方式達成，安全性提高，且提供了 SSO 的能力)</p></blockquote><blockquote><p>目前使用 LDAP + Kerberos 架構的產品有 Windows AD, SAMBA 4.x, RedHat IDM(IPA)</p></blockquote><hr><h1 id="8-1-Using-Identity-Management-Services"><a href="#8-1-Using-Identity-Management-Services" class="headerlink" title="8.1 Using Identity Management Services"></a>8.1 Using Identity Management Services</h1><h2 id="8-1-1-User-information-and-authentication-services"><a href="#8-1-1-User-information-and-authentication-services" class="headerlink" title="8.1.1 User information and authentication services"></a>8.1.1 User information and authentication services</h2><p>中央認證系統會包含兩個部分：</p><h3 id="1-Account-information"><a href="#1-Account-information" class="headerlink" title="1. Account information"></a>1. Account information</h3><p>此部分用來存放使用者帳號的資訊，以及使用者權限等相關資訊。(例如：<strong>/etc/passwd</strong>)</p><h3 id="2-Authentication-information"><a href="#2-Authentication-information" class="headerlink" title="2. Authentication information"></a>2. Authentication information</h3><p>此部分的目的則是驗證使用者是否為其所宣稱的使用者，因此會包含密碼資訊，但這些密碼資訊通常會透過密碼學的技術輔助來加密，避免以明碼的方式呈現。(例如：<strong>/etc/shadow</strong>)</p><h3 id="其他補充"><a href="#其他補充" class="headerlink" title="其他補充"></a>其他補充</h3><p>Kerberos 僅能提供安全的驗證功能，無法提供使用者資訊；若需要使用者資訊，需要搭配 LDAP/NIS …. 等服務來提供。</p><p>目前 LDAP + Kerberos 的選擇有 Windows AD / SAMBA 4.x / RedHat IDM … 等。</p><p>透過調整 <code>/etc/nsswitch.conf</code>，可以調整驗證的順序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@localhost ~]$ cat /etc/nsswitch.conf | grep <span class="string">'^[^#]'</span></span><br><span class="line">passwd:     files sss</span><br><span class="line">shadow:     files sss</span><br><span class="line">group:      files sss</span><br><span class="line">hosts:      files dns</span><br><span class="line">bootparams: nisplus [NOTFOUND=<span class="built_in">return</span>] files</span><br><span class="line">ethers:     files</span><br><span class="line">netmasks:   files</span><br><span class="line">networks:   files</span><br><span class="line">protocols:  files</span><br><span class="line">rpc:        files</span><br><span class="line">services:   files sss</span><br><span class="line">netgroup:   files sss</span><br><span class="line">publickey:  nisplus</span><br><span class="line">automount:  files</span><br><span class="line">aliases:    files nisplus</span><br></pre></td></tr></table></figure><blockquote><p>NSS 設定中的 sss 表示指向系統中的 sssd(security system daemon, for cache)，即使在沒網路的狀態下也還是可以進行認証</p></blockquote><p>RedHat 設計的工具大多以 <code>system-config</code> 開頭：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@localhost ~]$ system-config-</span><br><span class="line">system-config-authentication  system-config-firewall-tui    system-config-kickstart       system-config-printer-applet  </span><br><span class="line">system-config-date            system-config-kdump           system-config-language        system-config-users           </span><br><span class="line">system-config-firewall        system-config-keyboard        system-config-printer</span><br></pre></td></tr></table></figure><p>安裝 <code>system-config-authentication</code> 相關的工具：<code>sudo yum -y install authconfig-gtk sssd krb5-workstation</code></p><p>若 LDAP 過程中要加密，LDAP server 設定時就不能使用 IP，必須使用 domain name，否則 CA 憑證檢查不會過</p><blockquote><p>設定 Kerneros 要把 <code>Use DNS to resolve hosts to realm</code> &amp; <code>Use DNS to locate KDCs for realm</code> 兩個選項拿掉</p></blockquote><h2 id="8-1-2-Attaching-a-system-to-centralized-LDAP-and-Kerberos-servers"><a href="#8-1-2-Attaching-a-system-to-centralized-LDAP-and-Kerberos-servers" class="headerlink" title="8.1.2 Attaching a system to centralized LDAP and Kerberos servers"></a>8.1.2 Attaching a system to centralized LDAP and Kerberos servers</h2><p>設定時建議安裝套件：<code>authconfig-gtk</code>, <code>sssd</code>, <code>krb5-workstation</code></p><h3 id="Authconfig"><a href="#Authconfig" class="headerlink" title="Authconfig"></a>Authconfig</h3><p>RHCE 中的示範以 LDAP + Kerberos 為組合，有一些設定資訊是必須了解的：</p><ul><li><p><strong>/etc/ldap.conf</strong>：提供 LDAP 服務的 server 的相關設定</p></li><li><p><strong>/etc/krb5.conf</strong>：Kerberos 的相關設定</p></li><li><p><strong>/etc/sssd/sssd.conf</strong>：system security services daemon(sssd) 的設定，負責用來取得 &amp; 快取使用者的認證資訊</p></li><li><p><strong>/etc/nsswitch.conf</strong>：用來設定認證使用者所要使用的服務 or 系統</p></li><li><p><strong>/etc/pam.d</strong>：此目錄包含了提供了不同驗證機制的模組</p></li><li><p>/etc/openldap/cacerts：儲存 certificate 用</p></li></ul><blockquote><p>認證設定的過程建議使用 <code>authconfig-gtk</code>(提供 <strong>system-config-authentication</strong> 指令) or <code>authconfig-tui</code> 套件來協助，有圖形介面較為容易設定；不建議使用 <code>authconfig</code> 套件</p></blockquote><h3 id="LDAP"><a href="#LDAP" class="headerlink" title="LDAP"></a>LDAP</h3><p>LDAP 帳號描述範例：<code>cn=kevin,ou=sales,ou=tp,ou=tw,dc=example,dc=com</code> (DN, Distinguish Name)</p><p>LDAP 認証可用 SSL/TLS 加密</p><p><strong>要使用 LDAP 服務，要提供以下必要資訊</strong>：</p><ol><li><p>LDAP server hostname</p></li><li><p>base DN(即是上面的 <code>ou=tp,ou=tw,dc=example,dc=com</code>，依據要認證到的層級而定)</p></li><li><p>若要加密則必須 CA</p></li></ol><h3 id="Kerberos"><a href="#Kerberos" class="headerlink" title="Kerberos"></a>Kerberos</h3><p>兩大訴求：</p><ol><li><p>SSO (Single Sign On)</p></li><li><p>安全性高(驗證過程中，帳號密碼不會在網路上傳遞)</p></li></ol><p>密碼儲存 &amp; 認証方式：</p><ol><li><p>Server 儲存 hash 過後的密碼</p></li><li><p>client 認証時，會將輸入的密碼 hash 後的結果作為加密帳號資訊的對稱式金鑰，將資訊(user_account,time,….)加密後傳到 server 驗證</p></li><li><p>server 收到加密結果後，會拿資料庫中的 hash value 並進行解密，若是有符合則通過</p></li><li><p>為防止重送攻擊，被加密的資料有包含時間資訊(因此系統時間很重要)</p></li><li><p>假設驗證通過，server 會發送一個 ticket 給 client，之後 client 要存取其他 resource 只要提供 account &amp; ticket 即可，resource owner 會自動去找 KDC(Kerberos Key Distribution Center) 驗證 ticket 是否有效</p></li></ol><p><strong>要使用 Kerberos 服務，要提供以下必要資訊</strong>：</p><ol><li><p>Kerberos realm，類似 domain name 的概念</p></li><li><p>至少一個 key distribution center(KDC)，即為 Kerberos hostname</p></li><li><p>Admin server hostname(用來協助使用者密碼及其他資訊變更之用)，通常與 KDC 會是相同一台機器</p></li></ol><h2 id="8-1-3-Attaching-a-System-to-an-IPA-Server"><a href="#8-1-3-Attaching-a-System-to-an-IPA-Server" class="headerlink" title="8.1.3 Attaching a System to an IPA Server"></a>8.1.3 Attaching a System to an IPA Server</h2><p>在 RHEL 7 中提供了方便工具設定，安裝 <code>ipa-client</code> 套件即可。</p><p>以 non-interactive 的方式設定 IPA server 認証：<code>sudo ipa-client-install --domain=serverX.example.com --no-ntp --mkhomedir -p admin -w redhat123 -U</code></p><hr><h1 id="Practice-Connecting-to-a-Central-LDAP-and-Kerberos-Server"><a href="#Practice-Connecting-to-a-Central-LDAP-and-Kerberos-Server" class="headerlink" title="Practice: Connecting to a Central LDAP and Kerberos Server"></a>Practice: Connecting to a Central LDAP and Kerberos Server</h1><p>設定 LDAP + Kerberos 驗證的步驟：</p><p>1、安裝相關套件：<code>sudo yum -y install sssd authconfig-gtk krb5-workstation</code></p><p>2、使用圖形工具進行設定(設定如下)</p><p><img src="https://lh3.googleusercontent.com/yrIOq6ZotETj8rEMxH3hnoBqJzUmaF4A_aYQQlvMTuqU6u2-xBCA7aUMIkVBUi_uwjiSOcEr5V_TXrlv0jYDX_ikqhPjZVWPiXo5XKIoWUovuYNtbyPu4nibuVU1sZ150Y43kME_1dExiLtYF3cowhoHA_ex4CbHBDGULMGkfPJQnJkoWM_PVlb-xk1ENpKjElCw0If4VUMnyk6QsSjWTeKrUt6gl8A9Szi-DEWgh2FuhnXFFfL2BOlUmcvLeUDDDu7cT1v09QRqQI1usK3bDKIjrmNUaSAYQ8hPoxDqZaT0-KMycPnDwc8SWJXmm4En8uQMHSGMqFKlx1LmJqufLKZMaFZgF3rM1BN8pCYFxkUkws2nNuG-tmzHi0yxVq7T0vYFerWX66XTvhrOHiReMjLKp3IEm7ue4-AUNY9bcwlPgyjoOBJXId1vT4AgyHeR7sivsMFvwfw2jTwZdEEp2723scmSxiYoO0baKp7rrSnls11b9SI_ZIPd7gAD_42AqnstDCEWWsKzXCpGLXuAXFFjk14lO5g0MHtCd73J2aJmsz8QN_rMZK_Hd9YW44VJ6AEQF3rB4Sxq09bT6q8HPF9ht-ak_qg=w474-h710-no" alt="system-config-authentication"></p><p>3、驗證設定結果：<code>sudo getent passwd ldapuser1</code> or <code>ssh ldapuser1@server1</code>(密碼 <code>kerberos</code>)</p><hr><h1 id="Lab-Connecting-to-Network-defined-Users-and-Groups"><a href="#Lab-Connecting-to-Network-defined-Users-and-Groups" class="headerlink" title="Lab: Connecting to Network-defined Users and Groups"></a>Lab: Connecting to Network-defined Users and Groups</h1><p>Lab 設計為連線到 IPA server 進行驗證，步驟如下：</p><p>1、安裝相關套件：<code>sudo yum -y install ipa-client</code></p><p>2、設定連線：<code>sudo ipa-client-install --domain=server1.example.com --no-ntp --mkhomedir</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ipa-client-install --domain=server0.example.com --no-ntp --mkhomedir</span><br><span class="line"></span><br><span class="line">Discovery was successful!</span><br><span class="line">Hostname: desktop1.example.com</span><br><span class="line">Realm: SERVER0.EXAMPLE.COM</span><br><span class="line">DNS Domain: server1.example.com</span><br><span class="line">IPA Server: server1.example.com</span><br><span class="line">BaseDN: dc=server1,dc=example,dc=com</span><br><span class="line"></span><br><span class="line">Continue to configure the system with these values? [no]: yes</span><br><span class="line">User authorized to enroll computers: admin</span><br><span class="line">Synchronizing time with KDC...</span><br><span class="line">Unable to sync time with IPA NTP server, assuming the time is <span class="keyword">in</span> sync. Please check that 123 UDP port is opened.</span><br><span class="line">Password <span class="keyword">for</span> admin@SERVER1.EXAMPLE.COM:</span><br><span class="line">Successfully retrieved CA cert</span><br><span class="line">    Subject:     CN=Certificate Authority,O=SERVER1.EXAMPLE.COM</span><br><span class="line">    Issuer:      CN=Certificate Authority,O=SERVER1.EXAMPLE.COM</span><br><span class="line">    Valid From:  Tue May 17 20:31:07 2016 UTC</span><br><span class="line">    Valid Until: Sat May 17 20:31:07 2036 UTC</span><br><span class="line"></span><br><span class="line">Enrolled <span class="keyword">in</span> IPA realm SERVER1.EXAMPLE.COM</span><br><span class="line">Created /etc/ipa/default.conf</span><br><span class="line">New SSSD config will be created</span><br><span class="line">Configured /etc/sssd/sssd.conf</span><br><span class="line">Configured /etc/krb5.conf <span class="keyword">for</span> IPA realm SERVER1.EXAMPLE.COM</span><br><span class="line">trying https://server1.example.com/ipa/xml</span><br><span class="line">Forwarding <span class="string">'ping'</span> to server <span class="string">'https://server1.example.com/ipa/xml'</span></span><br><span class="line">Forwarding <span class="string">'env'</span> to server <span class="string">'https://server1.example.com/ipa/xml'</span></span><br><span class="line">Adding SSH public key from /etc/ssh/ssh_host_rsa_key.pub</span><br><span class="line">Adding SSH public key from /etc/ssh/ssh_host_ecdsa_key.pub</span><br><span class="line">Forwarding <span class="string">'host_mod'</span> to server <span class="string">'https://server1.example.com/ipa/xml'</span></span><br><span class="line">Could not update DNS SSHFP records.</span><br><span class="line">SSSD enabled</span><br><span class="line">Configured /etc/openldap/ldap.conf</span><br><span class="line">Configured /etc/ssh/ssh_config</span><br><span class="line">Configured /etc/ssh/sshd_config</span><br><span class="line">Client configuration complete.</span><br></pre></td></tr></table></figure><p>3、驗證設定結果：<code>sudo getent passwd ipauser</code> &amp; <code>ssh ipauser@localhost</code>(原本密碼為 <code>password</code>，改為 <code>redhat123</code>)</p><p>4、程式驗證：<code>lab ipaclient grade</code> (@desktop)</p>]]></content>
      
      <categories>
          
          <category> RHCE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH134 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[RHCE7] RH134 Chapter 09. Adding Disks, Partitions, and File Systems to a Linux System 學習筆記</title>
      <link href="/blog/2016/05/09/RHCE/RHCE7-RH134-LearningNotes-CH09_AddingDisksPartitionAndFileSystemsToALinuxSystem/"/>
      <url>/blog/2016/05/09/RHCE/RHCE7-RH134-LearningNotes-CH09_AddingDisksPartitionAndFileSystemsToALinuxSystem/</url>
      <content type="html"><![CDATA[<h1 id="9-1-Adding-Partitions-File-Systems-and-Persistent-Mounts"><a href="#9-1-Adding-Partitions-File-Systems-and-Persistent-Mounts" class="headerlink" title="9.1 Adding Partitions, File Systems, and Persistent Mounts"></a>9.1 Adding Partitions, File Systems, and Persistent Mounts</h1><h2 id="9-1-1-Disk-partitioning"><a href="#9-1-1-Disk-partitioning" class="headerlink" title="9.1.1 Disk partitioning"></a>9.1.1 Disk partitioning</h2><p>Hard Disk 的分割結構：(從頭到尾)</p><ol><li>MBR(512 bytes) = Boot Loader(446 byte) + Partition Table(64 bytes)</li></ol><p>Partition Type：</p><ul><li><p><code>Primary</code>：一個硬碟最多可以切 4 個 primary partition (系統要啟動必須裝載 Primary Partition)</p></li><li><p><code>Extended</code>：若要超過 4 個 partition，則要將 primary partition 來換成 extended partition</p></li><li><p><code>Logical</code>：在 extended partition 中的 partition (Logical Partition Table 存在 Extended Partition 的前面)，且<strong><font color="red">代碼從 5 開始(/dev/sda5)</font></strong></p></li></ul><p>備份 /dev/sda1：<code>dd if=/dev/sda1 of=/tmp/sda1.dd</code></p><p>還原 /dev/sda1：<code>dd if=/tmp/sda1.dd of=/dev/sda1</code></p><h3 id="MBR-Partition"><a href="#MBR-Partition" class="headerlink" title="MBR Partition"></a>MBR Partition</h3><ul><li><p>支援 2^32 個定址空間</p></li><li><p>傳統硬碟最大容量為 2T：2^32 x 512 bytes / 1024 / 1024 /1024 / 1024 = 2T</p></li><li><p>超過 2T 的硬碟 -&gt; Advanced Format(block size 從 512 bytes 變成 4K) = 最大可支援到 16T (過渡時期的解決方案)</p></li><li><p>備份 MBR：<code>dd if=/dev/sda of=/tmp/mbr.dd bs=512 count=1</code></p></li></ul><h3 id="GPT-Partition"><a href="#GPT-Partition" class="headerlink" title="GPT Partition"></a>GPT Partition</h3><ul><li><p>若 OS 裝在 GPT Partition 上，沒辦法在舊電腦上用(因為傳統的 int 13h 問題)；但開機後，OS level 可以認得超過 2T 的硬碟</p></li><li><p>UEFI BIOS 上的 int 13h 改寫過，因此同時支援 MBR &amp; GPT 兩種 partition</p></li><li><p>最多支援 128 個 partition，支援 2^64 個定址空間，因此最大可以支援到 8ZB(512 bytes block size)，若是使用 4K block size 則可支援到 64ZB</p></li><li><p>GPT 為每一個 partition 提供 128 bits GUID 作為辨識之用</p></li><li><p>GPT partition table 在硬碟的頭尾各有一個，並搭配 CRC checksum，因此有備援的機制</p></li></ul><h2 id="9-1-2-Managing-MBR-partitions-with-fdisk-gdisk"><a href="#9-1-2-Managing-MBR-partitions-with-fdisk-gdisk" class="headerlink" title="9.1.2 Managing MBR partitions with fdisk/gdisk"></a>9.1.2 Managing MBR partitions with fdisk/gdisk</h2><ul><li>若沒有使用 <code>w</code> 儲存 partition 分割設定，就不會實際切割硬碟</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查詢目前的 partition table</span></span><br><span class="line">[vagrant@localhost ~]$ cat /proc/partitions</span><br><span class="line">major minor  <span class="comment">#blocks  name</span></span><br><span class="line"></span><br><span class="line">   8        0   83886080 sda</span><br><span class="line">   8        1     512000 sda1</span><br><span class="line">   8        2   83373056 sda2</span><br><span class="line"> 253        0   52428800 dm-0</span><br><span class="line"> 253        1    1048576 dm-1</span><br><span class="line"> 253        2   29827072 dm-2</span><br></pre></td></tr></table></figure><p>切割完 partition 後，記得執行 <code>sudo partprobe [device name]</code> or <code>sudo partprobe -s</code> 強制 kernel 重新讀取最新的 partition table</p><h2 id="9-1-4-Creating-file-systems"><a href="#9-1-4-Creating-file-systems" class="headerlink" title="9.1.4 Creating file systems"></a>9.1.4 Creating file systems</h2><p>硬碟分割完後需要進行格式化，一般會使用 <code>mkfs</code> 指令：</p><p><code>sudo mkfs -t xfs /dev/vdb1</code>：格式化成 XFS，也可以寫成 <code>sudo mkfs.xfs /dev/vdb1</code></p><h2 id="9-1-4-Mounting-file-systems"><a href="#9-1-4-Mounting-file-systems" class="headerlink" title="9.1.4 Mounting file systems"></a>9.1.4 Mounting file systems</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mkdir /XFS</span><br><span class="line"></span><br><span class="line">$ sudo mkdir /EXT4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 掛載 XFS partition</span></span><br><span class="line">$ sudo mount /dev/vdb1 /XFS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 掛載 EXT4 partition</span></span><br><span class="line">$ sudo mount /dev/vdb2 /EXT4-t</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示 partition type(-T) &amp; human readable(-h)</span></span><br><span class="line">$ df -T -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢目前在 mount point 的 user 有哪些</span></span><br><span class="line">$ sudo fuser -v /XFS</span><br><span class="line">                     USER        PID ACCESS COMMAND</span><br><span class="line">/mnt:                root     kernel mount /XFS</span><br><span class="line">                     student    1663 ..c.. bash</span><br><span class="line">                     root       1936 ..c.. sudo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 踢掉目前在指定 mount point 的 user</span></span><br><span class="line">$ sudo fuser -km /NFS</span><br></pre></td></tr></table></figure><h3 id="etc-fstab"><a href="#etc-fstab" class="headerlink" title="/etc/fstab"></a>/etc/fstab</h3><p>若要讓 partition 開機後就固定掛載在指定目錄，就要使用 <strong>/etc/fstab</strong> 來達成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server ~]$ cat /etc/fstab | grep <span class="string">'^[^#]'</span></span><br><span class="line"><span class="comment"># 1. partition = /dev/mapper/centos-root (也可以用 partition UUID)</span></span><br><span class="line"><span class="comment"># 2. mount point = /</span></span><br><span class="line"><span class="comment"># 3. partition type = xfs</span></span><br><span class="line"><span class="comment"># 4. mount options = defaults (rw,suid,dev,exec,auto,nouser,async)</span></span><br><span class="line"><span class="comment"># 5. 指定是否需要 dump = 0 (不需 dump)</span></span><br><span class="line"><span class="comment"># 6. 系統開機時進行 fsck 檢查的順序</span></span><br><span class="line">/dev/mapper/centos-root /                       xfs     defaults        0 0</span><br><span class="line">UUID=cb6b4419-b7cc-4315-b5bd-5926d21e944e   /boot    xfs     defaults        0 0</span><br><span class="line">/dev/mapper/centos-home /home                   xfs     defaults        0 0</span><br><span class="line">/dev/mapper/centos-swap swap                    swap    defaults        0 0</span><br><span class="line"></span><br><span class="line">/dev/vdb1   /XFS    xfs   defaults    1   2</span><br><span class="line">/dev/vdb2   /EXT4   ext4  defaults    1   2</span><br></pre></td></tr></table></figure><p>編輯完 <code>/etc/fstab</code> 後，必須執行 <code>sudo mount -a</code> 檢查是否 partition 可以正確掛載</p><blockquote><p>建議 partition 透過 UUID 指定，可使用 <code>blkid [partition_name]</code> 來取得 partition UUID 的資訊(但似乎只對已經 mount 到特定目錄的 partition 有效)</p></blockquote><p>也可以使用 LABEL 的方式設定在 /etc/fstab 中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 為 XFS partition 命名</span></span><br><span class="line">$ sudo xfs_admin -L XFS /dev/vdb1</span><br><span class="line"><span class="comment"># 為 EXT4 partition 命名</span></span><br><span class="line">$ sudo e2label /dev/vdb2 EXT4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢結果</span></span><br><span class="line">$ sudo blkid</span><br><span class="line"></span><br><span class="line">$ sudo mount -L XFS /XFS</span><br><span class="line">$ sudo mount -L EXT4 /EXT4</span><br><span class="line"></span><br><span class="line"><span class="comment"># /etc/fstab 的設定可以改成如下</span></span><br><span class="line">LABEL=XFS   /XFS    xfs   defaults    1   2</span><br><span class="line">LABEL=EXT4  /EXT4   ext4  defaults    1   2</span><br></pre></td></tr></table></figure><blockquote><p>Label 還是有可能重複，因此原廠建議用上面的 UUID 掛載，是最保險沒問題的</p></blockquote><hr><h1 id="Practice-Adding-Partitions-File-Systems-and-Persistent-Mounts"><a href="#Practice-Adding-Partitions-File-Systems-and-Persistent-Mounts" class="headerlink" title="Practice: Adding Partitions, File Systems, and Persistent Mounts"></a>Practice: Adding Partitions, File Systems, and Persistent Mounts</h1><h2 id="目標：從-dev-vdb-中切割-1GB-的空間，並掛載在-archive-目錄"><a href="#目標：從-dev-vdb-中切割-1GB-的空間，並掛載在-archive-目錄" class="headerlink" title="目標：從 /dev/vdb 中切割 1GB 的空間，並掛載在 /archive 目錄"></a>目標：從 <code>/dev/vdb</code> 中切割 1GB 的空間，並掛載在 <code>/archive</code> 目錄</h2><h3 id="1、切割-1GB-partition"><a href="#1、切割-1GB-partition" class="headerlink" title="1、切割 1GB partition"></a>1、切割 1GB partition</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 從 /dev/vdb 中切割出 1GB 空間</span></span><br><span class="line">$ sudo fdisk /dev/vdb</span><br><span class="line">Welcome to fdisk (util-linux 2.23.2).</span><br><span class="line"></span><br><span class="line">Changes will remain <span class="keyword">in</span> memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write <span class="built_in">command</span>.</span><br><span class="line"></span><br><span class="line">Device does not contain a recognized partition table</span><br><span class="line">Building a new DOS disklabel with disk identifier 0x1825a331.</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): bn</span><br><span class="line">Partition <span class="built_in">type</span>:</span><br><span class="line">   p   primary (0 primary, 0 extended, 4 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): p</span><br><span class="line">Partition number (1-4, default 1):</span><br><span class="line">First sector (2048-20971519, default 2048):</span><br><span class="line">Using default value 2048</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (2048-20971519, default 20971519): +1G</span><br><span class="line">Partition 1 of <span class="built_in">type</span> Linux and of size 1 GiB is <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): w</span><br><span class="line">The partition table has been altered!</span><br><span class="line"></span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line">Syncing disks.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 強制 kernel 重新讀取 partition Table</span></span><br><span class="line">$ sudo partprobe -s</span><br><span class="line">/dev/vda: msdos partitions 1</span><br><span class="line">/dev/vdb: msdos partitions 1</span><br><span class="line"></span><br><span class="line">$ cat /proc/partitions</span><br><span class="line">major minor  <span class="comment">#blocks  name</span></span><br><span class="line"></span><br><span class="line"> 253        0   10485760 vda</span><br><span class="line"> 253        1   10484142 vda1</span><br><span class="line"> 253       16   10485760 vdb</span><br><span class="line"> 253       17    1048576 vdb1</span><br></pre></td></tr></table></figure><h3 id="2、格式化-partition"><a href="#2、格式化-partition" class="headerlink" title="2、格式化 partition"></a>2、格式化 partition</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式化 partition</span></span><br><span class="line">$ sudo mkfs.ext4 /dev/vdb1</span><br><span class="line">$ sudo blkid /dev/vdb1</span><br><span class="line">/dev/vdb1: UUID=<span class="string">"200ad7d4-aeef-4ffc-ac27-25fbcef5d5b2"</span> TYPE=<span class="string">"ext4"</span></span><br></pre></td></tr></table></figure><h3 id="3、建立目錄並掛載"><a href="#3、建立目錄並掛載" class="headerlink" title="3、建立目錄並掛載"></a>3、建立目錄並掛載</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立掛載目錄</span></span><br><span class="line">$ sudo mkdir /archive</span><br><span class="line"></span><br><span class="line"><span class="comment"># 編輯 /etc/fstab 以達成永久掛載的目的</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"UUID=200ad7d4-aeef-4ffc-ac27-25fbcef5d5b2 /archive ext4 defaults 0 2"</span> | sudo tee --append /etc/fstab</span><br><span class="line">$ sudo mount -a</span><br><span class="line">$ df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">......</span><br><span class="line">/dev/vdb1       976M  2.6M  907M   1% /archive</span><br><span class="line">$ mount</span><br><span class="line">.....</span><br><span class="line">/dev/vdb1 on /archive <span class="built_in">type</span> ext4 (rw,relatime,seclabel,data=ordered)</span><br></pre></td></tr></table></figure><hr><h1 id="9-2-Managing-Swap-Space"><a href="#9-2-Managing-Swap-Space" class="headerlink" title="9.2 Managing Swap Space"></a>9.2 Managing Swap Space</h1><p>以下以切割 /dev/vdb 為例：</p><ol><li><p>使用 <code>fdisk</code>(82) or <code>gdisk</code>(8200) 進行硬碟分割</p></li><li><p>將 partition 格式化為 swap：<code>sudo mkswap /dev/vdb1</code></p></li><li><p>掛載 swap partition：<code>sudo swapon /dev/vdb1</code></p></li></ol><p>若是要在 <strong>/etc/fstab</strong> 中掛載 fstab，在 dump &amp; fsck 的欄位都要給 0，標準設定方式如下：</p><p><code>UUID=e02aae2f-70a9-4b1b-a1e1-9016b0acc3e4  swap  swap  defaults  0 0</code></p><h3 id="其他-swap-相關指令"><a href="#其他-swap-相關指令" class="headerlink" title="其他 swap 相關指令"></a>其他 swap 相關指令</h3><ul><li><p><code>sudo swapon -a</code>：檢查 <code>/etc/fstab</code> 中的 swap partition 設定並掛載</p></li><li><p><code>sudo swapon -s</code>：檢視目前系統中 swap partition 的資訊以及使用優先權</p></li></ul><hr><h1 id="Practice-Adding-and-Enabling-Swap-Space"><a href="#Practice-Adding-and-Enabling-Swap-Space" class="headerlink" title="Practice: Adding and Enabling Swap Space"></a>Practice: Adding and Enabling Swap Space</h1><h2 id="目標：在第二個硬碟中切割出-500-MB-的空間作為-swap"><a href="#目標：在第二個硬碟中切割出-500-MB-的空間作為-swap" class="headerlink" title="目標：在第二個硬碟中切割出 500 MB 的空間作為 swap"></a>目標：在第二個硬碟中切割出 500 MB 的空間作為 swap</h2><h3 id="1、切割-500MB-partition"><a href="#1、切割-500MB-partition" class="headerlink" title="1、切割 500MB partition"></a>1、切割 500MB partition</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">$ sudo fdisk /dev/vdb</span><br><span class="line">Welcome to fdisk (util-linux 2.23.2).</span><br><span class="line"></span><br><span class="line">Changes will remain <span class="keyword">in</span> memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write <span class="built_in">command</span>.</span><br><span class="line"></span><br><span class="line">Device does not contain a recognized partition table</span><br><span class="line">Building a new DOS disklabel with disk identifier 0x7db6d48a.</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Partition <span class="built_in">type</span>:</span><br><span class="line">   p   primary (0 primary, 0 extended, 4 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): p</span><br><span class="line">Partition number (1-4, default 1):</span><br><span class="line">First sector (2048-20971519, default 2048):</span><br><span class="line">Using default value 2048</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (2048-20971519, default 20971519): +500MB</span><br><span class="line">Partition 1 of <span class="built_in">type</span> Linux and of size 500 MiB is <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): t</span><br><span class="line">Selected partition 1</span><br><span class="line">Hex code (<span class="built_in">type</span> L to list all codes): 82</span><br><span class="line">Changed <span class="built_in">type</span> of partition <span class="string">'Linux'</span> to <span class="string">'Linux swap / Solaris'</span></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): p</span><br><span class="line"></span><br><span class="line">Disk /dev/vdb: 10.7 GB, 10737418240 bytes, 20971520 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0x7db6d48a</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/vdb1            2048     1026047      512000   82  Linux swap / Solaris</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): w</span><br><span class="line">The partition table has been altered!</span><br><span class="line"></span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line">Syncing disks.</span><br></pre></td></tr></table></figure><h3 id="2、格式化-partition-1"><a href="#2、格式化-partition-1" class="headerlink" title="2、格式化 partition"></a>2、格式化 partition</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mkswap /dev/vdb1</span><br><span class="line">Setting up swapspace version 1, size = 511996 KiB</span><br><span class="line">no label, UUID=ffb162b9-c1e6-4ce9-bde7-964b3ce9c43a</span><br></pre></td></tr></table></figure><h3 id="3、編輯-etc-fstab-並掛載"><a href="#3、編輯-etc-fstab-並掛載" class="headerlink" title="3、編輯 /etc/fstab 並掛載"></a>3、編輯 /etc/fstab 並掛載</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mkswap /dev/vdb1</span><br><span class="line">Setting up swapspace version 1, size = 511996 KiB</span><br><span class="line">no label, UUID=ffb162b9-c1e6-4ce9-bde7-964b3ce9c43a</span><br><span class="line"></span><br><span class="line">$ sudo blkid /dev/vdb1</span><br><span class="line">/dev/vdb1: UUID=<span class="string">"ffb162b9-c1e6-4ce9-bde7-964b3ce9c43a"</span> TYPE=<span class="string">"swap"</span></span><br><span class="line"></span><br><span class="line">[student@desktop0 ~]$ <span class="built_in">echo</span> <span class="string">"UUID=ffb162b9-c1e6-4ce9-bde7-964b3ce9c43a swap swap defaults 0 0"</span> | sudo tee --append /etc/fstab</span><br><span class="line">UUID=ffb162b9-c1e6-4ce9-bde7-964b3ce9c43a swap swap defaults 0 0</span><br><span class="line"></span><br><span class="line">$ sudo mount -a</span><br><span class="line">$ sudo swapon /dev/vdb1</span><br><span class="line">$ sudo swapon -s</span><br><span class="line">Filename                                Type            Size    Used    Priority</span><br><span class="line">/dev/vdb1                               partition       511996  0       -1</span><br></pre></td></tr></table></figure><hr><h1 id="Lab-Adding-Disks-Partitions-and-File-Systems-to-a-Linux-System"><a href="#Lab-Adding-Disks-Partitions-and-File-Systems-to-a-Linux-System" class="headerlink" title="Lab: Adding Disks, Partitions, and File Systems to a Linux System"></a>Lab: Adding Disks, Partitions, and File Systems to a Linux System</h1><h2 id="目標："><a href="#目標：" class="headerlink" title="目標："></a>目標：</h2><ol><li><p>在第二個硬碟中新增一個 2GB 的 XFS partition，並永久掛載於 /backup 目錄</p></li><li><p>在第二個硬碟中新增 512MB swap，擁有預設的 priority</p></li><li><p>在第二個硬碟中新增 512MB swap，priority 為 1</p></li></ol><h3 id="1、建立三個-partition"><a href="#1、建立三個-partition" class="headerlink" title="1、建立三個 partition"></a>1、建立三個 partition</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gdisk /dev/vdb</span><br><span class="line">Command (? <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Partition number (1-128, default 1):</span><br><span class="line">First sector (34-20971486, default = 2048) or &#123;+-&#125;size&#123;KMGTP&#125;:</span><br><span class="line">Last sector (2048-20971486, default = 20971486) or &#123;+-&#125;size&#123;KMGTP&#125;: +2G</span><br><span class="line">Current <span class="built_in">type</span> is <span class="string">'Linux filesystem'</span></span><br><span class="line">Hex code or GUID (L to show codes, Enter = 8300):</span><br><span class="line">Changed <span class="built_in">type</span> of partition to <span class="string">'Linux filesystem'</span></span><br><span class="line"></span><br><span class="line">Command (? <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Partition number (2-128, default 2):</span><br><span class="line">First sector (34-20971486, default = 4196352) or &#123;+-&#125;size&#123;KMGTP&#125;:</span><br><span class="line">Last sector (4196352-20971486, default = 20971486) or &#123;+-&#125;size&#123;KMGTP&#125;: +512M</span><br><span class="line">Current <span class="built_in">type</span> is <span class="string">'Linux filesystem'</span></span><br><span class="line">Hex code or GUID (L to show codes, Enter = 8300): 8200</span><br><span class="line">Changed <span class="built_in">type</span> of partition to <span class="string">'Linux swap'</span></span><br><span class="line"></span><br><span class="line">Command (? <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Partition number (3-128, default 3):</span><br><span class="line">First sector (34-20971486, default = 5244928) or &#123;+-&#125;size&#123;KMGTP&#125;:</span><br><span class="line">Last sector (5244928-20971486, default = 20971486) or &#123;+-&#125;size&#123;KMGTP&#125;: +512M</span><br><span class="line">Current <span class="built_in">type</span> is <span class="string">'Linux filesystem'</span></span><br><span class="line">Hex code or GUID (L to show codes, Enter = 8300): 8200</span><br><span class="line">Changed <span class="built_in">type</span> of partition to <span class="string">'Linux swap'</span></span><br><span class="line"></span><br><span class="line">Command (? <span class="keyword">for</span> <span class="built_in">help</span>): w</span><br><span class="line"></span><br><span class="line">Final checks complete. About to write GPT data. THIS WILL OVERWRITE EXISTING</span><br><span class="line">PARTITIONS!!</span><br><span class="line"></span><br><span class="line">Do you want to proceed? (Y/N): y</span><br><span class="line">OK; writing new GUID partition table (GPT) to /dev/vdb.</span><br><span class="line">The operation has completed successfully.</span><br></pre></td></tr></table></figure><h3 id="2、格式化硬碟"><a href="#2、格式化硬碟" class="headerlink" title="2、格式化硬碟"></a>2、格式化硬碟</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">$ sudo partprobe -s</span><br><span class="line">/dev/vda: msdos partitions 1</span><br><span class="line">/dev/vdb: gpt partitions 1 2 3</span><br><span class="line"></span><br><span class="line">$ cat /proc/partitions</span><br><span class="line">major minor  <span class="comment">#blocks  name</span></span><br><span class="line"></span><br><span class="line"> 253        0   10485760 vda</span><br><span class="line"> 253        1   10484142 vda1</span><br><span class="line"> 253       16   10485760 vdb</span><br><span class="line"> 253       17    2097152 vdb1</span><br><span class="line"> 253       18     524288 vdb2</span><br><span class="line"> 253       19     524288 vdb3</span><br><span class="line"></span><br><span class="line"> $ sudo mkfs.xfs /dev/vdb1</span><br><span class="line">meta-data=/dev/vdb1              isize=256    agcount=4, agsize=131072 blks</span><br><span class="line">         =                       sectsz=512   attr=2, projid32bit=1</span><br><span class="line">         =                       crc=0</span><br><span class="line">data     =                       bsize=4096   blocks=524288, imaxpct=25</span><br><span class="line">         =                       sunit=0      swidth=0 blks</span><br><span class="line">naming   =version 2              bsize=4096   ascii-ci=0 ftype=0</span><br><span class="line"><span class="built_in">log</span>      =internal <span class="built_in">log</span>           bsize=4096   blocks=2560, version=2</span><br><span class="line">         =                       sectsz=512   sunit=0 blks, lazy-count=1</span><br><span class="line">realtime =none                   extsz=4096   blocks=0, rtextents=0</span><br><span class="line"></span><br><span class="line">$ sudo mkswap /dev/vdb2</span><br><span class="line">Setting up swapspace version 1, size = 524284 KiB</span><br><span class="line">no label, UUID=a875704a-d0ba-4542-98a6-f201f1b3a539</span><br><span class="line"></span><br><span class="line">$ sudo mkswap /dev/vdb3</span><br><span class="line">Setting up swapspace version 1, size = 524284 KiB</span><br><span class="line">no label, UUID=9a906cce-e50e-44ee-a880-b3811252e5e1</span><br><span class="line"></span><br><span class="line">$ sudo blkid</span><br><span class="line">/dev/vda1: UUID=<span class="string">"9bf6b9f7-92ad-441b-848e-0257cbb883d1"</span> TYPE=<span class="string">"xfs"</span></span><br><span class="line">/dev/vdb1: UUID=<span class="string">"796676d5-0e5c-4023-82e3-3417e8d00952"</span> TYPE=<span class="string">"xfs"</span> PARTLABEL=<span class="string">"Linux filesystem"</span> PARTUUID=<span class="string">"bf36a837-22e7-44c5-8c74-9d9fe8161aa3"</span></span><br><span class="line">/dev/vdb2: UUID=<span class="string">"a875704a-d0ba-4542-98a6-f201f1b3a539"</span> TYPE=<span class="string">"swap"</span> PARTLABEL=<span class="string">"Linux swap"</span> PARTUUID=<span class="string">"794f5ef2-2fec-410d-a72d-9195ded90386"</span></span><br><span class="line">/dev/vdb3: UUID=<span class="string">"9a906cce-e50e-44ee-a880-b3811252e5e1"</span> TYPE=<span class="string">"swap"</span> PARTLABEL=<span class="string">"Linux swap"</span> PARTUUID=<span class="string">"ff0fe2fa-a946-4d83-9290-4a0629767548"</span></span><br></pre></td></tr></table></figure><h3 id="3、建立目錄並掛載-partition"><a href="#3、建立目錄並掛載-partition" class="headerlink" title="3、建立目錄並掛載 partition"></a>3、建立目錄並掛載 partition</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mkdir /backup</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"UUID=796676d5-0e5c-4023-82e3-3417e8d00952 /backup xfs defaults 0 2"</span> | sudo tee --append /etc/fstab</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"UUID=a875704a-d0ba-4542-98a6-f201f1b3a539 swap swap defaults 0 0"</span> | sudo tee --append /etc/fstab</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"UUID=9a906cce-e50e-44ee-a880-b3811252e5e1 swap swap pri=1 0 0"</span> | sudo tee --append /etc/fstab</span><br><span class="line"></span><br><span class="line">$ sudo mount -a</span><br><span class="line">$ sudo swapon -a</span><br></pre></td></tr></table></figure><h3 id="4、驗證是否設定完成"><a href="#4、驗證是否設定完成" class="headerlink" title="4、驗證是否設定完成"></a>4、驗證是否設定完成</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo swapon -s</span><br><span class="line">Filename                                Type            Size    Used    Priority</span><br><span class="line">/dev/vdb2                               partition       524284  0       -1</span><br><span class="line">/dev/vdb3                               partition       524284  0       1</span><br><span class="line"></span><br><span class="line">$ sudo mount</span><br><span class="line">...</span><br><span class="line">/dev/vdb1 on /backup <span class="built_in">type</span> xfs (rw,relatime,seclabel,attr2,inode64,noquota)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RHCE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH134 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[KVM] Linux KVM 基本觀念</title>
      <link href="/blog/2016/05/09/KVM/Linux-KVM-GettingStart/"/>
      <url>/blog/2016/05/09/KVM/Linux-KVM-GettingStart/</url>
      <content type="html"><![CDATA[<h1 id="1、libvirt-and-libvirt-tools"><a href="#1、libvirt-and-libvirt-tools" class="headerlink" title="1、libvirt and libvirt tools"></a>1、libvirt and libvirt tools</h1><h2 id="libvirt"><a href="#libvirt" class="headerlink" title="libvirt"></a>libvirt</h2><p><code>libvirt</code> 是一組獨立於 hypervisor 之外的 API：</p><ol><li><p>提供一個標準，一般化且穩定的虛擬層，且可安全的管理主機上的虛擬機器</p></li><li><p>可用來管理本地系統以及透過網路相連主機的標準介面</p></li><li><p>提供的 API 包含了 provision, create, modify, monitor, control, migrate, stop 虛擬主機等相關功能，但也必須要 hypervisor 支援的前提下才可使用，但這些 API 緊限定於單一主機上的操作</p></li></ol><h2 id="virsh"><a href="#virsh" class="headerlink" title="virsh"></a>virsh</h2><p>virsh 是一個基於 libvirt management API 所打造出來的 CLI，提供非常多管理 hypervisor &amp; guest VM 的指令，且相當方便搭配 script 一起使用，同時也是 <code>virt-manager</code> GUI tool 的基礎。</p><blockquote><p>若不想用 virsh，也可以直接使用 <code>qemu-kvm</code> 指令</p></blockquote><h2 id="virt-manager"><a href="#virt-manager" class="headerlink" title="virt-manager"></a>virt-manager</h2><p>圖形介面的管理工具，也是提供了很多管理 VM 的功能(基於 virsh 為基礎所開發出來的)，包含了 provision VM, 管理 virtual network, 存取 VM console, 檢視效能統計資訊….等等。</p><h2 id="virt-install"><a href="#virt-install" class="headerlink" title="virt-install"></a>virt-install</h2><p>virt-install 是專門用來協助 provision VM 的 CLI，支援純文字 &amp; 圖形安裝(可透過 serial, SPICE or VNC 等不同協定)，且可指定 local or remote(NFS, HTTP or FTP) 的安裝媒體，搭配 Kickstart 作大量自動化安裝很好用。</p><hr><h1 id="2、Virtualized-hardware-devices"><a href="#2、Virtualized-hardware-devices" class="headerlink" title="2、Virtualized hardware devices"></a>2、Virtualized hardware devices</h1><h2 id="Para-virtualized-devices"><a href="#Para-virtualized-devices" class="headerlink" title="Para-virtualized devices"></a>Para-virtualized devices</h2><p>para-virtualized 技術提供了 VM 一個更快速且有效率的方式跟 host 主機溝通；而 KVM 透過 <code>virtio</code> API 作為中介層，提供 para-virtualized devices 給 VM 使用，</p><p>對於 I/O 工作頻繁的 VM 來說，建議使用 para-virtualized devices 來取代 emulated devices。</p><p>所有的 virtio device 都包含兩個部份：<code>host device</code> &amp; <code>guest driver</code>，而 Para-virtualized device drivers 的目的是在於協助 guest VM 可以直接存取 host 主機上的實體裝置而不需要再經過模擬轉換。</p><p>目前有 virtio-net, virtio-blk(block device), virtio-scsi(效能比 virtio-blk 好很多), virtio-balloon ….. 等等。</p><h2 id="VFIO"><a href="#VFIO" class="headerlink" title="VFIO"></a>VFIO</h2><p>Virtual Function I/O (VFIO) 是個 kernel driver，讓 guest VM 可直接高效率的存取 host 主機上的硬體裝置；VFIO 將 device assignment 的工作移出 KVM hypervisor 中，並將實體裝置在 kernel level 中獨立出來以達成直接被 VM 存取的目的。</p><h2 id="SR-IOV"><a href="#SR-IOV" class="headerlink" title="SR-IOV"></a>SR-IOV</h2><p>SR-IOV (Single Root I/O Virtualization) 是用在 PCI-e 的裝置上，讓裝置可以分享自身的 virtual fcuntion(VF) 出來直接給 guest VM 使用的一種技術。</p><h2 id="NPIV"><a href="#NPIV" class="headerlink" title="NPIV"></a>NPIV</h2><p>N_Port ID Virtualization (NPIV) 是種應用在高速企業級儲存裝置的功能(例如：SAN)，功能類似 SR-IOV，都是讓 VM 可以直接存取硬體支援的技術。</p><hr><h1 id="3、Storage"><a href="#3、Storage" class="headerlink" title="3、Storage"></a>3、Storage</h1><h2 id="Disk-Images-的存在型式"><a href="#Disk-Images-的存在型式" class="headerlink" title="Disk Images 的存在型式"></a>Disk Images 的存在型式</h2><p>Disk Image 會根據在本地 or 遠端存放的不同，而已不同的型式存在：</p><ol><li>Image files</li></ol><p>直接以 image 檔案的方式存在，這又可分為 raw &amp; qcow2 兩種格式，其中 raw 格式速度快，但功能少；而 qcow2 則提供很多其他功能(例如：snapshot, compression, encryption, 從 template image 啟動 VM …. 等等)。</p><ol start="2"><li>LVM volumes</li></ol><p>Logical volume 可以直接作為 disk image 使用，同時也提供了 thin provision, snapshot 等功能。</p><ol start="3"><li>Host devices</li></ol><p>可以直接使用 CD-ROM, 或是透過 SAN or iSCSI 掛載的 LUN 作為 image</p><ol start="4"><li>Distributed storage systems</li></ol><p>在 RHEL7 中甚至支援把 disk image 放在 GlusterFS 上</p><hr><h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul><li><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Virtualization_Getting_Started_Guide/index.html" target="_blank" rel="noopener">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Virtualization_Getting_Started_Guide/index.html</a></li></ul>]]></content>
      
      <categories>
          
          <category> KVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> KVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[RHCE7] RH134 Chapter 7. Managing SELinux Security 學習筆記</title>
      <link href="/blog/2016/05/08/RHCE/RHCE7-RH134-LearningNotes-CH07_ManagingSELinuxSecurity/"/>
      <url>/blog/2016/05/08/RHCE/RHCE7-RH134-LearningNotes-CH07_ManagingSELinuxSecurity/</url>
      <content type="html"><![CDATA[<p><a name="ch7.1"></a></p><h1 id="7-1-Enabling-and-Monitoring-Security-Enhanced-Linux-SELinux"><a href="#7-1-Enabling-and-Monitoring-Security-Enhanced-Linux-SELinux" class="headerlink" title="7.1 Enabling and Monitoring Security Enhanced Linux (SELinux)"></a>7.1 Enabling and Monitoring Security Enhanced Linux (SELinux)</h1><h2 id="7-1-1-Basic-SELinux-security-concepts"><a href="#7-1-1-Basic-SELinux-security-concepts" class="headerlink" title="7.1.1 Basic SELinux security concepts"></a>7.1.1 Basic SELinux security concepts</h2><p>SELinux 為系統安全提供了多一層的保護，目的在於當系統服務被攻陷後，還有另外一層機制(object-based)可以保護使用者的資料。</p><p><img src="https://lh3.googleusercontent.com/bR6HlmRdHb9TosMXahqB3BxjdVdlFnfgpHh3bYbHeOmr2xGY_tvnAd7YBE4S4UWVzO_DX56XWwh6ytRqH1V27HhfcgRVlSHI5il3oCrJDaq0CRj_SBKElh8LLtCi4oDh3X1YXTK0gRX3p39i0soYp_ILkDBUku85ao5bYgFwmADGGN7S4Hd2FCQaREgbk9SFKgXQRJgMsvpfwmCg3KBKR6yEhG9T9iiQZg2cxZdXxELuzOFLx0jjrbgn84jxtXNnkNJJlWaOKQKtq8qGReElZkvZy2F1ZaJTcJtO208xPgEtoHHbI4N9GJyGUIcQzDhQ3rlXBuPbcuo0TT_W1yULLmLxA-uGR_JnA4cm9wv16tJZs3zMdeUKsFNxALBFZptxtOkOcpi1jopCJUEvCw4NAHhExPVHVHkVdFS2a-KUjRMBRyrFX-sa-xC5Ey3l7dbgKgjHjYta11VozADz7WIUV1FUVkR2tUmdXv6_XJVwVpclaD2PXnd7tHbOmM8Mnf4mwMP4E6yjjWiuTk9YVpoGx_2_8Nyw3xzzJ9CHYJy-WVPgSI1Q-m0Co6ZcR2bK_6p02bE8h9nft0354PiugpLIqV6dKQ0SW6g=w888-h225-no" alt="SELinux"></p><p>在傳統架構下，當 web server 被攻陷後，駭客取得 <strong>apache</strong> 使用者的權限，就可以自由地存取 <strong>/var/www/html</strong>, <strong>/tmp</strong>, <strong>/var/tmp</strong> 等目錄；但若是在 SELinux 的限制下，就僅有 <strong>/var/www/html</strong> 可以存取。</p><p>從上面就不難看出，SELinux 定義了特定服務可以存取的特定 file、directory、port …. 等資訊，用以限縮 service owner 可以存取檔案的範圍；而方法就在於每一個 file, directory, process, port 都有所謂的 <code>SELinux context</code>。</p><p>而 context 大概長這樣 =&gt; <code>system_u:object_r:httpd_sys_content_t:s0</code></p><p>以 <strong>:</strong> 作為分隔，分別是 user(system_u), role(object_r), type(httpd_sys_content_t), sensitvity(s0)；而 SELinux rule 的制定則是以 type 為主來設計的。</p><p>舉例來說，與 Apache 相關的檔案位於 <strong>/var/www/html</strong> 中，而這裡檔案的 context type 則為 <code>httpd_sys_content_t</code> or <code>httpd_t</code>，與 Apache 服務運行相關的檔案則為 <code>http_port_t</code>，這些 context type　的檔案都可以讓 Apache service 存取；但若是 <strong>/tmp</strong> 與 <strong>/var/tmp</strong> 中的檔案，其 context type 則為 <code>tmp_t</code>，而 Apache service 要嘗試存取時就會被拒絕。</p><p>許多指令都可以透過 <code>-Z</code> 參數取得 SELinux context 資訊，例如：<code>ps axZ</code>, <code>ps -ZC httpd</code>, <code>ls -Z /var/www</code> … 等等。</p><h2 id="7-1-2-SELinux-modes"><a href="#7-1-2-SELinux-modes" class="headerlink" title="7.1.2 SELinux modes"></a>7.1.2 SELinux modes</h2><p>預設為 <strong>enforcing</strong> mode，但若是基於臨時性的需求而需要關掉 SELinux，可轉換成 <strong>permissive</strong> mode，此時只會有警告 &amp; Log，但不會被安全機制阻擋，且可以 online 切換，不須 reboot；但如果要完全 disable SELinux ，就需要重開機。</p><blockquote><p>使用 <code>getenforce</code> 指令就可以知道目前的 SELinux mode</p></blockquote><h2 id="7-1-3-SELinux-Booleans"><a href="#7-1-3-SELinux-Booleans" class="headerlink" title="7.1.3 SELinux Booleans"></a>7.1.3 SELinux Booleans</h2><p><strong>SELinux Booleans</strong> 是用來設定 SELinux Rules 是否啟用，可以用來調整 SELinux 的原始設定；若要檢視 SELinux Booleans 目前的設定值，可使用 <code>getsebool -a</code> 取得。</p><hr><p><a name="ch7.2"></a></p><h1 id="7-2-Changing-SELinux-Modes"><a href="#7-2-Changing-SELinux-Modes" class="headerlink" title="7.2 Changing SELinux Modes"></a>7.2 Changing SELinux Modes</h1><h2 id="7-2-1-Changing-the-current-SELinux-mode"><a href="#7-2-1-Changing-the-current-SELinux-mode" class="headerlink" title="7.2.1 Changing the current SELinux mode"></a>7.2.1 Changing the current SELinux mode</h2><p>檢視目前 SELinux 狀態：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ getenforce</span><br><span class="line">Permissive</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1(enforcing), 0(permissive)</span></span><br><span class="line">[vagrant@server tmp]$ sudo setenforce 1</span><br><span class="line">[vagrant@server tmp]$ getenforce</span><br><span class="line">Enforcing</span><br></pre></td></tr></table></figure><h2 id="7-2-2-Setting-the-default-SELinux-mode"><a href="#7-2-2-Setting-the-default-SELinux-mode" class="headerlink" title="7.2.2 Setting the default SELinux mode"></a>7.2.2 Setting the default SELinux mode</h2><p>SELinux 的設定檔位於 <code>/etc/selinux/config</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ cat /etc/selinux/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># This file controls the state of SELinux on the system.</span></span><br><span class="line"><span class="comment"># SELINUX= can take one of these three values:</span></span><br><span class="line"><span class="comment">#     enforcing - SELinux security policy is enforced.</span></span><br><span class="line"><span class="comment">#     permissive - SELinux prints warnings instead of enforcing.</span></span><br><span class="line"><span class="comment">#     disabled - No SELinux policy is loaded.</span></span><br><span class="line">SELINUX=permissive</span><br><span class="line"><span class="comment"># SELINUXTYPE= can take one of three two values:</span></span><br><span class="line"><span class="comment">#     targeted - Targeted processes are protected,</span></span><br><span class="line"><span class="comment">#     minimum - Modification of targeted policy. Only selected processes are protected.</span></span><br><span class="line"><span class="comment">#     mls - Multi Level Security protection.</span></span><br><span class="line">SELINUXTYPE=targeted</span><br></pre></td></tr></table></figure><p><code>permissive</code>：僅會 log 不會限制存取</p><p><code>enforcing</code>：會 log &amp; 限制存取</p><blockquote><p>SELINUXTYPE 預設為 targeted, 也許在少數狀況下會使用另外兩個</p></blockquote><blockquote><p>變更完設定後必須重新啟動，設定才會生效</p></blockquote><hr><p><a name="ch7.3"></a></p><h2 id="7-3-Chaging-SELinux-Contexts"><a href="#7-3-Chaging-SELinux-Contexts" class="headerlink" title="7.3 Chaging SELinux Contexts"></a>7.3 Chaging SELinux Contexts</h2><p>在開始這個部分之前，需要先安裝兩個必要套件，分別是 <code>policycoreutils</code> &amp; <code>policycoreutils-python</code>(semanage)</p><h3 id="7-3-1-Initial-SELinux-context"><a href="#7-3-1-Initial-SELinux-context" class="headerlink" title="7.3.1 Initial SELinux context"></a>7.3.1 Initial SELinux context</h3><p>在 RHEL7 中，檔案預設的 SELinux context 會由其所在的目錄所決定，新產生的檔案都會繼承目錄的 context(<code>vim</code>, <code>cp</code>, <code>touch</code> 適用)，但若是非新建的或是特別情況則不會(<code>mv</code>, <code>cp -a</code>)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># context =&gt; httpd_sys_content_t</span></span><br><span class="line">[student@server0 ~]$ ls -Zd /var/www/html</span><br><span class="line">drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 /var/www/html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 產生兩個檔案</span></span><br><span class="line">[student@server0 ~]$ sudo touch /var/www/html/index.html</span><br><span class="line">[student@server0 ~]$ sudo cp -a /tmp/rht /var/www/html/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建的繼承目錄的 context，透過 cp -a 的則保留原有的 context</span></span><br><span class="line">[student@server0 ~]$ ls -laZ /var/www/html/</span><br><span class="line">drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 .</span><br><span class="line">drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 ..</span><br><span class="line">-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 index.html</span><br><span class="line">-rw-r--r--. root root system_u:object_r:init_tmp_t:s0  rht</span><br></pre></td></tr></table></figure><h3 id="7-3-2-Changing-the-SELinux-context-of-a-file"><a href="#7-3-2-Changing-the-SELinux-context-of-a-file" class="headerlink" title="7.3.2 Changing the SELinux context of a file"></a>7.3.2 Changing the SELinux context of a file</h3><p>有兩種方式可以改變 SELinux context：</p><ol><li><p><code>chcon</code>：搭配 <code>-t</code> 參數指定所要變更的 context</p></li><li><p><code>restorecon</code>：直接將 context 改為預設 context (根據檔案 or 目錄所在的位置而定)</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 顯示目錄(/var/www/html)的預設 SELinux context</span></span><br><span class="line">[student@server0 ~]$ ls -laZ /var/www/html/</span><br><span class="line">drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 .</span><br><span class="line">drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 ..</span><br><span class="line">-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 index.html</span><br><span class="line">-rw-r--r--. root root system_u:object_r:init_tmp_t:s0  rht</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 chcon 變更檔案的 context</span></span><br><span class="line">[student@server0 ~]$ sudo chcon -t tmp_t /var/www/html/index.html</span><br><span class="line">[student@server0 ~]$ ls -laZ /var/www/html/</span><br><span class="line">drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 .</span><br><span class="line">drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 ..</span><br><span class="line">-rw-r--r--. root root unconfined_u:object_r:tmp_t:s0   index.html</span><br><span class="line">-rw-r--r--. root root system_u:object_r:init_tmp_t:s0  rht</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 restorecon 直接將檔案變成為預設值</span></span><br><span class="line">[student@server0 ~]$ sudo restorecon -vR /var/www/html</span><br><span class="line">restorecon reset /var/www/html/index.html context unconfined_u:object_r:tmp_t:s0-&gt;unconfined_u:object_r:httpd_sys_content_t:s0</span><br><span class="line">restorecon reset /var/www/html/rht context system_u:object_r:init_tmp_t:s0-&gt;system_u:object_r:httpd_sys_content_t:s0</span><br><span class="line">[student@server0 ~]$ ls -laZ /var/www/html/</span><br><span class="line">drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 .</span><br><span class="line">drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 ..</span><br><span class="line">-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 index.html</span><br><span class="line">-rw-r--r--. root root system_u:object_r:httpd_sys_content_t:s0 rht</span><br></pre></td></tr></table></figure><h3 id="7-3-3-Defining-SELinux-default-file-context-rules"><a href="#7-3-3-Defining-SELinux-default-file-context-rules" class="headerlink" title="7.3.3 Defining SELinux default file context rules"></a>7.3.3 Defining SELinux default file context rules</h3><p>使用 <code>semanage fcontext</code> 可以顯示(<code>-l</code>) or 修改(<code>-a</code>) 目錄的預設 SELinux context：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 / 建立新的目錄，其預設 SELinux context 為 default_t</span></span><br><span class="line">[student@server0 ~]$ sudo mkdir /virtual</span><br><span class="line"><span class="comment"># 在此目錄建立的檔案，context 也會變成 default_t</span></span><br><span class="line">[student@server0 ~]$ sudo touch /virtual/index.html</span><br><span class="line">[student@server0 ~]$ ls -alZ /virtual</span><br><span class="line">drwxr-xr-x. root root unconfined_u:object_r:default_t:s0 .</span><br><span class="line">drwxr-xr-x. root root system_u:object_r:root_t:s0      ..</span><br><span class="line">-rw-r--r--. root root unconfined_u:object_r:default_t:s0 index.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 semanage fcontext 修改 /virtual 目錄的預設 SELinux context</span></span><br><span class="line">[student@server0 ~]$ sudo semanage fcontext -a -t httpd_sys_content_t <span class="string">'/virtual(/.*)?'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過 restorecon 將 /virtual 目錄下的檔案還原為預設值</span></span><br><span class="line">[student@server0 ~]$ sudo restorecon -Rv /virtual</span><br><span class="line">restorecon reset /virtual context unconfined_u:object_r:default_t:s0-&gt;unconfined_u:object_r:httpd_sys_content_t:s0</span><br><span class="line">restorecon reset /virtual/index.html context unconfined_u:object_r:default_t:s0-&gt;unconfined_u:object_r:httpd_sys_content_t:s0</span><br><span class="line">[student@server0 ~]$ ls -alZ /virtual</span><br><span class="line">drwxr-xr-x. root root unconfined_u:object_r:httpd_sys_content_t:s0 .</span><br><span class="line">drwxr-xr-x. root root system_u:object_r:root_t:s0      ..</span><br><span class="line">-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 index.html</span><br></pre></td></tr></table></figure><hr><p><a name="ch7.3"></a></p><h1 id="7-4-Chaging-SELinux-Booleans"><a href="#7-4-Chaging-SELinux-Booleans" class="headerlink" title="7.4 Chaging SELinux Booleans"></a>7.4 Chaging SELinux Booleans</h1><p>安裝 <code>selinux-policy-devel</code> 套件可取得與 SELinux Booleans 相關的說明資訊，位於 <strong>selinux(8)</strong>，可使用 <code>man -k _selinux</code> 來查詢目前系統中存在的文件。</p><p>SELinux Booleans 是用來決定 rule 是否啟用的設定值，可透過 <code>getsebool</code> &amp; <code>setsebool</code> 兩個指令來設定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取得 SELinux Booleans 資訊('-a' 參數表示顯示全木)</span></span><br><span class="line">[student@server0 ~]$ getsebool -a | grep httpd_enable_homedir</span><br><span class="line">httpd_enable_homedirs --&gt; off</span><br><span class="line">[student@server0 ~]$ getsebool httpd_enable_homedirs</span><br><span class="line">httpd_enable_homedirs --&gt; off</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 SELinux Boolean</span></span><br><span class="line">[student@server0 ~]$ sudo setsebool httpd_enable_homedirs on</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過 'semanage boolean -l' 可以查詢 SELinux Boolean 是否永久被更改(第二個結果)</span></span><br><span class="line">[student@server0 ~]$ sudo semanage boolean -l | grep httpd_enable_homedirs</span><br><span class="line">httpd_enable_homedirs          (on   ,  off)  Allow httpd to <span class="built_in">read</span> home directories</span><br><span class="line">[student@server0 ~]$ getsebool -a | grep httpd_enable_homedir</span><br><span class="line">httpd_enable_homedirs --&gt; on</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過 '-P' 參數永久變更 SELinux Boolean 的設定</span></span><br><span class="line">[student@server0 ~]$ sudo setsebool -P httpd_enable_homedirs on</span><br><span class="line">[student@server0 ~]$ getsebool -a | grep httpd_enable_homedir</span><br><span class="line">httpd_enable_homedirs --&gt; on</span><br><span class="line">[student@server0 ~]$ sudo semanage boolean -l | grep httpd_enable_homedirs</span><br><span class="line">httpd_enable_homedirs          (on   ,   on)  Allow httpd to <span class="built_in">read</span> home directories</span><br></pre></td></tr></table></figure><hr><p><a name="ch7.3"></a></p><h1 id="7-5-Troublshooting-SELinux"><a href="#7-5-Troublshooting-SELinux" class="headerlink" title="7.5 Troublshooting SELinux"></a>7.5 Troublshooting SELinux</h1><h2 id="7-5-1-Troubleshooting-SELinux-issues"><a href="#7-5-1-Troubleshooting-SELinux-issues" class="headerlink" title="7.5.1 Troubleshooting SELinux issues"></a>7.5.1 Troubleshooting SELinux issues</h2><p>關於 SELinux 會造成的 issue，大概會有幾個原因 &amp; 方向可以思考：</p><ol><li><p>服務是否有特定目錄 or 檔案的存取權限</p></li><li><p>可能是錯誤的 file context 造成的，此時可用 <code>restorecon</code> 解決</p></li><li><p>可能是太嚴格的 SELinux Boolean 設定所造成(例如 <code>ftpd_anon_write</code> 限制了匿名使用者對 FTP 服務的存取)</p></li><li><p>可能是 SELinux policy 的 bug 所造成</p></li></ol><h2 id="7-5-2-Monitoring-SELinux-violations"><a href="#7-5-2-Monitoring-SELinux-violations" class="headerlink" title="7.5.2 Monitoring SELinux violations"></a>7.5.2 Monitoring SELinux violations</h2><p>套件 <code>setroubleshoot-server</code> 必須安裝，才有辦法紀錄 SELinux 所產生的相關 log 資訊(存在於 <strong>/var/log/audit/audit.log</strong>)。</p><ul><li><p><code>sealert -l UUID</code>：檢視指定 UUID 的報告</p></li><li><p><code>sealert -a /var/log/audit/audit.log</code>：檢視 log 中所有的稽核報告</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">[student@server0 ~]$ sudo systemctl start httpd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 /root 下新增檔案，並移到 /var/www/html 目錄</span></span><br><span class="line">[student@server0 ~]$ sudo touch /root/file3</span><br><span class="line">[student@server0 ~]$ sudo mv /root/file3 /var/www/html/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 嘗試透過瀏覽器存取 file3</span></span><br><span class="line">[student@server0 ~]$ curl http://localhost/file3</span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC <span class="string">"-//IETF//DTD HTML 2.0//EN"</span>&gt;</span><br><span class="line">&lt;html&gt;&lt;head&gt;</span><br><span class="line">&lt;title&gt;403 Forbidden&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Forbidden&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;You don\<span class="string">'t have permission to access /file3</span></span><br><span class="line"><span class="string">on this server.&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;&lt;/html&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 從 /var/log/audit/audit.log 中尋找相關的錯誤資訊</span></span><br><span class="line"><span class="string">[student@server0 ~]$ sudo tail /var/log/audit/audit.log</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="string">type=AVC msg=audit(1462720907.786:517): avc:  denied  &#123; getattr &#125; for  pid=1754 comm="httpd" path="/var/www/html/file3" dev="vda1" ino=8846767 scontext=system_u:system_r:httpd_t:s0 tcontext=unconfined_u:object_r:admin_home_t:s0 tclass=file</span></span><br><span class="line"><span class="string">type=SYSCALL msg=audit(1462720907.786:517): arch=c000003e syscall=4 success=no exit=-13 a0=7fd102869b48 a1=7fff0049e4f0 a2=7fff0049e4f0 a3=7fd0f7202752 items=0 ppid=1751 pid=1754 auid=4294967295 uid=48 gid=48 euid=48 suid=48 fsuid=48 egid=48 sgid=48 fsgid=48 tty=(none) ses=4294967295 comm="httpd" exe="/usr/sbin/httpd" subj=system_u:system_r:httpd_t:s0 key=(null)</span></span><br><span class="line"><span class="string">type=AVC msg=audit(1462720907.786:518): avc:  denied  &#123; getattr &#125; for  pid=1754 comm="httpd" path="/var/www/html/file3" dev="vda1" ino=8846767 scontext=system_u:system_r:httpd_t:s0 tcontext=unconfined_u:object_r:admin_home_t:s0 tclass=file</span></span><br><span class="line"><span class="string">type=SYSCALL msg=audit(1462720907.786:518): arch=c000003e syscall=6 success=no exit=-13 a0=7fd102869c18 a1=7fff0049e4f0 a2=7fff0049e4f0 a3=0 items=0 ppid=1751 pid=1754 auid=4294967295 uid=48 gid=48 euid=48 suid=48 fsuid=48 egid=48 sgid=48 fsgid=48 tty=(none) ses=4294967295 comm="httpd" exe="/usr/sbin/httpd" subj=system_u:system_r:httpd_t:s0 key=(null)</span></span><br><span class="line"><span class="string">.......</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 找到 SELinux 相關的 UUID</span></span><br><span class="line"><span class="string">[student@server0 ~]$ sudo tail -50 /var/log/messages</span></span><br><span class="line"><span class="string">.....</span></span><br><span class="line"><span class="string">May  8 11:21:48 localhost setroubleshoot: Plugin Exception restorecon_source</span></span><br><span class="line"><span class="string">May  8 11:21:48 localhost setroubleshoot: SELinux is preventing /usr/sbin/httpd from getattr access on the file . For complete SELinux messages. run sealert -l 26a423d9-3dbd-413b-8048-3e7abec01df1</span></span><br><span class="line"><span class="string">May  8 11:21:48 localhost python: SELinux is preventing /usr/sbin/httpd from getattr access on the file .</span></span><br><span class="line"><span class="string">.....</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 透過 sealert -l 檢視詳細的報告內容</span></span><br><span class="line"><span class="string">[student@server0 ~]$ sudo sealert -l 26a423d9-3dbd-413b-8048-3e7abec01df1</span></span><br><span class="line"><span class="string">SELinux is preventing /usr/sbin/httpd from getattr access on the file .</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">*****  Plugin catchall (100. confidence) suggests   **************************</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">If you believe that httpd should be allowed getattr access on the  file by default.</span></span><br><span class="line"><span class="string">Then you should report this as a bug.</span></span><br><span class="line"><span class="string">You can generate a local policy module to allow this access.</span></span><br><span class="line"><span class="string">Do</span></span><br><span class="line"><span class="string">allow this access for now by executing:</span></span><br><span class="line"><span class="string"># grep httpd /var/log/audit/audit.log | audit2allow -M mypol</span></span><br><span class="line"><span class="string"># semodule -i mypol.pp</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Additional Information:</span></span><br><span class="line"><span class="string">Source Context                system_u:system_r:httpd_t:s0</span></span><br><span class="line"><span class="string">Target Context                unconfined_u:object_r:admin_home_t:s0</span></span><br><span class="line"><span class="string">Target Objects                 [ file ]</span></span><br><span class="line"><span class="string">Source                        httpd</span></span><br><span class="line"><span class="string">Source Path                   /usr/sbin/httpd</span></span><br><span class="line"><span class="string">Port                          &lt;Unknown&gt;</span></span><br><span class="line"><span class="string">Host                          localhost</span></span><br><span class="line"><span class="string">Source RPM Packages           httpd-2.4.6-17.el7.x86_64</span></span><br><span class="line"><span class="string">Target RPM Packages</span></span><br><span class="line"><span class="string">Policy RPM                    selinux-policy-3.12.1-153.el7.noarch</span></span><br><span class="line"><span class="string">Selinux Enabled               True</span></span><br><span class="line"><span class="string">Policy Type                   targeted</span></span><br><span class="line"><span class="string">Enforcing Mode                Enforcing</span></span><br><span class="line"><span class="string">Host Name                     server0.example.com</span></span><br><span class="line"><span class="string">Platform                      Linux server0.example.com 3.10.0-123.el7.x86_64 #1</span></span><br><span class="line"><span class="string">                              SMP Mon May 5 11:16:57 EDT 2014 x86_64 x86_64</span></span><br><span class="line"><span class="string">Alert Count                   1</span></span><br><span class="line"><span class="string">First Seen                    2016-05-09 00:21:47 JST</span></span><br><span class="line"><span class="string">Last Seen                     2016-05-09 00:21:47 JST</span></span><br><span class="line"><span class="string">Local ID                      26a423d9-3dbd-413b-8048-3e7abec01df1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Raw Audit Messages</span></span><br><span class="line"><span class="string">type=AVC msg=audit(1462720907.786:518): avc:  denied  &#123; getattr &#125; for  pid=1754 comm="httpd" path="/var/www/html/file3" dev="vda1" ino=8846767 scontext=system_u:system_r:httpd_t:s0 tcontext=unconfined_u:object_r:admin_home_t:s0 tclass=file</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">type=SYSCALL msg=audit(1462720907.786:518): arch=x86_64 syscall=lstat success=no exit=EACCES a0=7fd102869c18 a1=7fff0049e4f0 a2=7fff0049e4f0 a3=0 items=0 ppid=1751 pid=1754 auid=4294967295 uid=48 gid=48 euid=48 suid=48 fsuid=48 egid=48 sgid=48 fsgid=48 tty=(none) ses=4294967295 comm=httpd exe=/usr/sbin/httpd subj=system_u:system_r:httpd_t:s0 key=(null)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Hash: httpd,httpd_t,admin_home_t,file,getattr</span></span><br></pre></td></tr></table></figure><hr><h1 id="補充教材"><a href="#補充教材" class="headerlink" title="補充教材"></a>補充教材</h1><h2 id="初階篇"><a href="#初階篇" class="headerlink" title="初階篇"></a>初階篇</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ id -Z</span><br><span class="line">unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</span><br><span class="line"></span><br><span class="line">[vagrant@server tmp]$ ls</span><br><span class="line">ABC  hosts  passwd  vagrant-shell</span><br><span class="line"></span><br><span class="line">[vagrant@server tmp]$ ls -Z</span><br><span class="line">drwxrwxrwx+ vagrant vagrant unconfined_u:object_r:user_tmp_t:s0 ABC</span><br><span class="line">-rw-r--r--. vagrant vagrant unconfined_u:object_r:user_tmp_t:s0 hosts</span><br><span class="line">-rw-r-xr--+ vagrant vagrant unconfined_u:object_r:user_tmp_t:s0 passwd</span><br><span class="line">-rwx--x--x. vagrant vagrant unconfined_u:object_r:user_tmp_t:s0 vagrant-shell</span><br></pre></td></tr></table></figure><p>以上權限對應 =&gt; system_r:object_r:var_t:s0</p><ol><li>User</li><li>Role</li><li>Type<br>若 SELinux 設定為 enforcing，只要看 type 即可</li></ol><p>SELinux 的 check policy 存放於 <code>/etc/selinux/targeted/policy/policy.29</code></p><p>安裝 <code>setools-console</code> 後就可以查詢 SELinux policy</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ ps auxZ | grep httpd</span><br><span class="line">system_u:system_r:httpd_t:s0    root     14773  0.0  0.2 221904  4968 ?        Ss   05:44   0:00 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">system_u:system_r:httpd_t:s0    apache   14774  0.0  0.1 221904  2972 ?        S    05:44   0:00 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">system_u:system_r:httpd_t:s0    apache   14775  0.0  0.1 221904  2972 ?        S    05:44   0:00 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">system_u:system_r:httpd_t:s0    apache   14776  0.0  0.1 221904  2972 ?        S    05:44   0:00 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">system_u:system_r:httpd_t:s0    apache   14777  0.0  0.1 221904  2972 ?        S    05:44   0:00 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">system_u:system_r:httpd_t:s0    apache   14778  0.0  0.1 221904  2972 ?        S    05:44   0:00 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可查詢來源端為 httpd_t 相關的權限設定</span></span><br><span class="line">[vagrant@server tmp]$ sesearch -A -s httpd_t</span><br><span class="line">....more</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢來源端為 httpd_t，目的端為 lib_t 的權限設定</span></span><br><span class="line">[vagrant@server tmp]$ sesearch -A -s httpd_t -t lib_t</span><br><span class="line">Found 13 semantic av rules:</span><br><span class="line">   allow domain base_ro_file_type : file \&#123; ioctl <span class="built_in">read</span> getattr lock open \&#125; ;</span><br><span class="line">   allow domain base_ro_file_type : dir \&#123; ioctl <span class="built_in">read</span> getattr lock search open \&#125; ;</span><br><span class="line">   allow domain base_ro_file_type : lnk_file \&#123; <span class="built_in">read</span> getattr \&#125; ;</span><br><span class="line">.... more</span><br></pre></td></tr></table></figure><h2 id="進階篇"><a href="#進階篇" class="headerlink" title="進階篇"></a>進階篇</h2><h3 id="限制-Process-對檔案目錄的存取"><a href="#限制-Process-對檔案目錄的存取" class="headerlink" title="限制 Process 對檔案目錄的存取"></a>限制 Process 對檔案目錄的存取</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ ls -ldZ /var/www/html</span><br><span class="line">drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 /var/www/html</span><br><span class="line"></span><br><span class="line">[vagrant@server tmp]$ ls -lZ passwd</span><br><span class="line">-rw-r--r--. vagrant vagrant unconfined_u:object_r:user_tmp_t:s0 passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 變更 SELinux context user/role/type</span></span><br><span class="line">[vagrant@server tmp]$ chcon -u system_u passwd</span><br><span class="line">[vagrant@server tmp]$ chcon -r object_r passwd</span><br><span class="line">[vagrant@server tmp]$ chcon -t httpd_sys_content_t passwd</span><br><span class="line">[vagrant@server tmp]$ ls -lZ passwd</span><br><span class="line">-rw-r--r--. vagrant vagrant system_u:object_r:httpd_sys_content_t:s0 passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同時變更 SELinux context user/role/type</span></span><br><span class="line">[vagrant@server tmp]$ chcon system_u:object_r:httpd_sys_content_t:s0 passwd</span><br></pre></td></tr></table></figure><p><code>policycoreutils-python</code> 套件是用來尋找正確的 SELinux Context type 之用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 尋找系統中已經存在的檔案 or 目錄的 context type</span></span><br><span class="line">[vagrant@server tmp]$ sudo semanage fcontext -l | grep /var/www</span><br><span class="line">/var/www(/.*)?                                     all files          system_u:object_r:httpd_sys_content_t:s0</span><br><span class="line">/var/www(/.*)?/logs(/.*)?                          all files          system_u:object_r:httpd_log_t:s0</span><br><span class="line">/var/www/[^/]*/cgi-bin(/.*)?                       all files          system_u:object_r:httpd_sys_script_exec_t:s0</span><br><span class="line">/var/www/svn(/.*)?                                 all files          system_u:object_r:httpd_sys_rw_content_t:s0</span><br><span class="line">/var/www/git(/.*)?                                 all files          system_u:object_r:git_content_t:s0</span><br><span class="line">/var/www/perl(/.*)?                                all files          system_u:object_r:httpd_sys_script_exec_t:s0</span><br><span class="line">.... more</span><br><span class="line"></span><br><span class="line"><span class="comment"># 參考同性質檔案 or 目錄的 context type</span></span><br><span class="line">[vagrant@server tmp]$ ls -ldZ /var/www</span><br><span class="line">drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 /var/www</span><br></pre></td></tr></table></figure><p><code>policycoreutils</code> 中的 <code>restorecon</code> 工具可幫助恢復成原有的標籤：例如：<code>restorecon -Rv /var/www/html/</code></p><blockquote><p>前提是資料庫必須要有相關資料</p></blockquote><h3 id="修改資料庫"><a href="#修改資料庫" class="headerlink" title="修改資料庫"></a>修改資料庫</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ sudo mkdir /WWW</span><br><span class="line">[vagrant@server tmp]$ ls -ldZ /WWW</span><br><span class="line">drwxr-xr-x. root root unconfined_u:object_r:default_t:s0 /WWW</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過 semanage fcontext 修改目錄預設的 SELinux context</span></span><br><span class="line">[vagrant@server tmp]$ sudo semanage fcontext -a -f a -t httpd_sys_content_t <span class="string">'/WWW(/.*)?'</span></span><br><span class="line">[vagrant@server tmp]$ sudo semanage fcontext -l | grep WWW</span><br><span class="line">/WWW(/.*)?                                         all files          system_u:object_r:httpd_sys_content_t:s0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢復原有設定</span></span><br><span class="line">[vagrant@server tmp]$ sudo restorecon -Rv /WWW</span><br><span class="line">restorecon reset /WWW context unconfined_u:object_r:default_t:s0-&gt;unconfined_u:object_r:httpd_sys_content_t:s0</span><br><span class="line">restorecon reset /WWW/aaa context unconfined_u:object_r:default_t:s0-&gt;unconfined_u:object_r:httpd_sys_content_t:s0</span><br><span class="line">[vagrant@server tmp]$ ls -ldZ /WWW</span><br><span class="line">drwxr-xr-x. root root unconfined_u:object_r:httpd_sys_content_t:s0 /WWW</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ sudo cp /etc/shadow /WWW/</span><br><span class="line">[vagrant@server tmp]$ ls -ldZ /WWW/</span><br><span class="line">drwxr-xr-x. root root unconfined_u:object_r:httpd_sys_content_t:s0 /WWW/</span><br><span class="line"></span><br><span class="line">[vagrant@server tmp]$ ls -ldZ /WWW/*</span><br><span class="line">----------. root root unconfined_u:object_r:httpd_sys_content_t:s0 /WWW/shadow</span><br><span class="line"></span><br><span class="line"><span class="comment"># -a 會保留原檔案的相關 metadata，因此不會被 dest dir 的 SELinux context 複寫</span></span><br><span class="line">[vagrant@server tmp]$ sudo cp -a /etc/shadow /WWW/shadow_a</span><br><span class="line">[vagrant@server tmp]$ ls -ldZ /WWW/*</span><br><span class="line">----------. root root unconfined_u:object_r:httpd_sys_content_t:s0 /WWW/shadow</span><br><span class="line">----------. root root system_u:object_r:shadow_t:s0    /WWW/shadow_a</span><br></pre></td></tr></table></figure><p>查詢 SELinux 相關的 log 可到 /var/log/audit/audit.log 查詢</p><h3 id="限制應用程式的特定功能是否能夠啟用"><a href="#限制應用程式的特定功能是否能夠啟用" class="headerlink" title="限制應用程式的特定功能是否能夠啟用"></a>限制應用程式的特定功能是否能夠啟用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ sudo semanage boolean -l | grep ftp</span><br><span class="line">ftp_home_dir                   (off  ,  off)  Allow ftp to home dir</span><br><span class="line">ftpd_use_cifs                  (off  ,  off)  Allow ftpd to use cifs</span><br><span class="line">sftpd_write_ssh_home           (off  ,  off)  Allow sftpd to write ssh home</span><br><span class="line">ftpd_use_fusefs                (off  ,  off)  Allow ftpd to use fusefs</span><br><span class="line">..... more</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加了 -P 會永久儲存，沒加就只會存到記憶體中</span></span><br><span class="line">[vagrant@server tmp]$ sudo setsebool -P ftp_home_dir 1</span><br><span class="line">[vagrant@server tmp]$ sudo semanage boolean -l | grep ftp</span><br><span class="line">ftp_home_dir                   (on   ,   on)  Allow ftp to home dir</span><br></pre></td></tr></table></figure><h3 id="限制應用程式所能夠存取的-port"><a href="#限制應用程式所能夠存取的-port" class="headerlink" title="限制應用程式所能夠存取的 port"></a>限制應用程式所能夠存取的 port</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ sudo semanage port -l | grep http</span><br><span class="line">http_cache_port_t              tcp      8080, 8118, 8123, 10001-10010</span><br><span class="line">http_cache_port_t              udp      3130</span><br><span class="line">http_port_t                    tcp      80, 81, 443, 488, 8008, 8009, 8443, 9000</span><br><span class="line">pegasus_http_port_t            tcp      5988</span><br><span class="line">pegasus_https_port_t           tcp      5989</span><br><span class="line"></span><br><span class="line"><span class="comment"># -a 增加 port, -d 刪除 port</span></span><br><span class="line">[vagrant@server tmp]$ sudo semanage port -a -t http_port_t -p tcp 5678</span><br><span class="line">[vagrant@server tmp] manage port -l | grep http_port_t</span><br><span class="line">http_port_t                    tcp      5678, 80, 81, 443, 488, 8008, 8009, 8443, 9000</span><br><span class="line">pegasus_http_port_t            tcp      5988</span><br></pre></td></tr></table></figure><hr><h1 id="Practice-Changing-SELinux-Booleans"><a href="#Practice-Changing-SELinux-Booleans" class="headerlink" title="Practice: Changing SELinux Booleans"></a>Practice: Changing SELinux Booleans</h1><p>啟用 web server 的使用者家目錄 web 功能</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安裝 apache</span></span><br><span class="line">$ sudo yum -y install httpd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 啟動 apache server</span></span><br><span class="line">$ sudo systemctl <span class="built_in">enable</span> httpd.service</span><br><span class="line">ln -s <span class="string">'/usr/lib/systemd/system/httpd.service'</span> <span class="string">'/etc/systemd/system/multi-user.target.wants/httpd.service'</span></span><br><span class="line">$ sudo systemctl start httpd.service</span><br><span class="line">$ sudo systemctl status httpd.service</span><br><span class="line">httpd.service - The Apache HTTP Server</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled)</span><br><span class="line">   Active: active (running) since Mon 2016-05-16 17:55:59 JST; 5s ago</span><br><span class="line">.......</span><br><span class="line"></span><br><span class="line"><span class="comment"># 開啟使用者 web 目錄為 ~/public_html</span></span><br><span class="line">$ sudo sed -i <span class="string">'s/^\s*#\(UserDir public_html\)/    \1/g'</span> /etc/httpd/conf.d/userdir.conf</span><br><span class="line">$ sudo sed -i <span class="string">'s/^\s*\(UserDir\sdisabled\)/    # \1/g'</span> /etc/httpd/conf.d/userdir.conf</span><br><span class="line">$ sudo systemctl restart httpd.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 index.html，但還是沒有權限可以存取</span></span><br><span class="line">$ mkdir ~/public_html</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"Hello Internet"</span> | sudo tee /home/student/public_html/index.html</span><br><span class="line">Hello Internet</span><br><span class="line">$ chmod 711 /home/student</span><br><span class="line">$ curl http://localhost/~student/index.html</span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC <span class="string">"-//IETF//DTD HTML 2.0//EN"</span>&gt;</span><br><span class="line">&lt;html&gt;&lt;head&gt;</span><br><span class="line">&lt;title&gt;403 Forbidden&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Forbidden&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;You don\<span class="string">'t have permission to access /~student/index.html</span></span><br><span class="line"><span class="string">on this server.&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;&lt;/html&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 檢視 SELinux Boolean 設定</span></span><br><span class="line"><span class="string">$ getsebool -a | grep httpd | grep home</span></span><br><span class="line"><span class="string">httpd_enable_homedirs --&gt; off</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 開啟 httpd_enable_homedirs</span></span><br><span class="line"><span class="string">$ sudo setsebool -P httpd_enable_homedirs on</span></span><br><span class="line"><span class="string">$ getsebool -a | grep httpd | grep home</span></span><br><span class="line"><span class="string">httpd_enable_homedirs --&gt; on</span></span><br><span class="line"><span class="string">$ curl http://localhost/~student/index.html</span></span><br><span class="line"><span class="string">Hello Internet</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RHCE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH134 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[RHCE7] RH134 Chapter 6. Controlling Access to Files with Access Control Lists(ACLs) 學習筆記</title>
      <link href="/blog/2016/05/07/RHCE/RHCE7-RH134-LearningNotes-CH06_ControllingAccessToFilesWithAccessControlLists/"/>
      <url>/blog/2016/05/07/RHCE/RHCE7-RH134-LearningNotes-CH06_ControllingAccessToFilesWithAccessControlLists/</url>
      <content type="html"><![CDATA[<p>透過 ACL 的機制，可以讓一個檔案同時有多個 Owner or Group</p><p><a name="ch6.1"></a></p><h1 id="6-1-POSIX-Access-Control-Lists-ACLs"><a href="#6-1-POSIX-Access-Control-Lists-ACLs" class="headerlink" title="6.1 POSIX Access Control Lists (ACLs)"></a>6.1 POSIX Access Control Lists (ACLs)</h1><p>若 partition 格式為 ext4，mount 的時候必須加上 <code>-o acl</code> 參數：(以下為範例)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mount -o acl /dev/vdb1 /mnt</span><br></pre></td></tr></table></figure><blockquote><p>或是在 /etc/fstab 上的參數設定加上 acl 也行</p></blockquote><p>也可以透過指令 <code>sudo tune2fs -o user_xattr,acl /dev/vdb1</code> 直接把屬性加入到 partition 的 superblock 中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取得 ACL 資訊</span></span><br><span class="line">[vagrant@server tmp]$ getfacl acl_test.txt</span><br><span class="line"><span class="comment"># file: acl_test.txt</span></span><br><span class="line"><span class="comment"># owner: vagrant</span></span><br><span class="line"><span class="comment"># group: vagrant</span></span><br><span class="line">user::rw-</span><br><span class="line">group::rw-</span><br><span class="line">other::r--</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入 User(user1) 權限 (使用 -m)</span></span><br><span class="line">[vagrant@server tmp]$ setfacl -m u:user1:r-x acl_test.txt</span><br><span class="line">[vagrant@server tmp]$ getfacl acl_test.txt</span><br><span class="line"><span class="comment"># file: acl_test.txt</span></span><br><span class="line"><span class="comment"># owner: vagrant</span></span><br><span class="line"><span class="comment"># group: vagrant</span></span><br><span class="line">user::rw-</span><br><span class="line">user:user1:r-x</span><br><span class="line">group::rw-</span><br><span class="line">mask::rwx</span><br><span class="line">other::r--</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入 User(user2 &amp; user3) 權限 (使用 -m)</span></span><br><span class="line">[vagrant@server tmp]$ setfacl -m u:user2:r-- acl_test.txt</span><br><span class="line">[vagrant@server tmp]$ setfacl -m u:user3:rwx acl_test.txt</span><br><span class="line">[vagrant@server tmp]$ getfacl acl_test.txt</span><br><span class="line"><span class="comment"># file: acl_test.txt</span></span><br><span class="line"><span class="comment"># owner: vagrant</span></span><br><span class="line"><span class="comment"># group: vagrant</span></span><br><span class="line">user::rw-</span><br><span class="line">user:user1:r-x</span><br><span class="line">user:user2:r--</span><br><span class="line">user:user3:rwx</span><br><span class="line">group::rw-</span><br><span class="line">mask::rwx</span><br><span class="line">other::r--</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入 Group(user4) 權限 (使用 -m)</span></span><br><span class="line">[vagrant@server tmp]$ setfacl -m g:user4:r-x acl_test.txt</span><br><span class="line">[vagrant@server tmp]$ getfacl acl_test.txt</span><br><span class="line"><span class="comment"># file: acl_test.txt</span></span><br><span class="line"><span class="comment"># owner: vagrant</span></span><br><span class="line"><span class="comment"># group: vagrant</span></span><br><span class="line">user::rw-</span><br><span class="line">user:user1:r-x</span><br><span class="line">user:user2:r--</span><br><span class="line">user:user3:rwx</span><br><span class="line">group::rw-</span><br><span class="line">group:user4:r-x</span><br><span class="line">mask::rwx</span><br><span class="line">other::r--</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除 User(user1 &amp; user2) 權限 (使用 -x)</span></span><br><span class="line">[vagrant@server tmp]$ setfacl -x u:user1 acl_test.txt</span><br><span class="line">[vagrant@server tmp]$ setfacl -x u:user2 acl_test.txt</span><br><span class="line">[vagrant@server tmp]$ getfacl acl_test.txt</span><br><span class="line"><span class="comment"># file: acl_test.txt</span></span><br><span class="line"><span class="comment"># owner: vagrant</span></span><br><span class="line"><span class="comment"># group: vagrant</span></span><br><span class="line">user::rw-</span><br><span class="line">user:user3:rwx</span><br><span class="line">group::rw-</span><br><span class="line">group:user4:r-x</span><br><span class="line">mask::rwx</span><br><span class="line">other::r--</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除 User(user3) &amp; Group(user4) 權限 (使用 -x)</span></span><br><span class="line">[vagrant@server tmp]$ setfacl -x u:user3 acl_test.txt</span><br><span class="line">[vagrant@server tmp]$ setfacl -x g:user4 acl_test.txt</span><br><span class="line">[vagrant@server tmp]$ getfacl acl_test.txt</span><br><span class="line"><span class="comment"># file: acl_test.txt</span></span><br><span class="line"><span class="comment"># owner: vagrant</span></span><br><span class="line"><span class="comment"># group: vagrant</span></span><br><span class="line">user::rw-</span><br><span class="line">group::rw-</span><br><span class="line">mask::rw-</span><br><span class="line">other::r--</span><br><span class="line"></span><br><span class="line"><span class="comment"># 複製指定檔案的 ACL 權限到另外一個檔案</span></span><br><span class="line">$ getfacl acl_test.txt | setfacl --<span class="built_in">set</span>-file=- acl_clone.txt</span><br></pre></td></tr></table></figure><h2 id="補充-使用-setfacl-變更檔案的傳統權限"><a href="#補充-使用-setfacl-變更檔案的傳統權限" class="headerlink" title="補充 (使用 setfacl 變更檔案的傳統權限)"></a>補充 (使用 setfacl 變更檔案的傳統權限)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ ll</span><br><span class="line">total 8</span><br><span class="line">-rw-rw-r--+ 1 vagrant vagrant  0 Feb 23 03:09 acl_test.txt</span><br><span class="line">-rwx--x--x. 1 vagrant vagrant 22 Feb 23 01:45 vagrant-shell</span><br><span class="line"></span><br><span class="line">[vagrant@server tmp]$ setfacl -m u::rwx acl_test.txt</span><br><span class="line">[vagrant@server tmp]$ setfacl -m g::rwx acl_test.txt</span><br><span class="line">[vagrant@server tmp]$ setfacl -m o::rwx acl_test.txt</span><br><span class="line">[vagrant@server tmp]$ ll</span><br><span class="line">total 8</span><br><span class="line">-rwxrwxrwx+ 1 vagrant vagrant  0 Feb 23 03:09 acl_test.txt</span><br><span class="line">-rwx--x--x. 1 vagrant vagrant 22 Feb 23 01:45 vagrant-shell</span><br></pre></td></tr></table></figure><p><code>flags</code> 表示 SUID, SGID, StickyBit：(下面的範例表示檔案有 SUID 的屬性)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ getfacl /bin/passwd</span><br><span class="line">getfacl: Removing leading <span class="string">'/'</span> from absolute path names</span><br><span class="line"><span class="comment"># file: bin/passwd</span></span><br><span class="line"><span class="comment"># owner: root</span></span><br><span class="line"><span class="comment"># group: root</span></span><br><span class="line"><span class="comment"># flags: s--</span></span><br><span class="line">user::rwx</span><br><span class="line">group::r-x</span><br><span class="line">other::r-x</span><br></pre></td></tr></table></figure><h2 id="補充-使用-setfacl-修改-mask-設定"><a href="#補充-使用-setfacl-修改-mask-設定" class="headerlink" title="補充(使用 setfacl 修改 mask 設定)"></a>補充(使用 setfacl 修改 mask 設定)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ getfacl acl_test.txt</span><br><span class="line"><span class="comment"># file: acl_test.txt</span></span><br><span class="line"><span class="comment"># owner: vagrant</span></span><br><span class="line"><span class="comment"># group: vagrant</span></span><br><span class="line">user::rwx</span><br><span class="line">group::rwx</span><br><span class="line">mask::rwx</span><br><span class="line">other::rwx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過 mask 可以限制 group 僅剩下 rw 的權限</span></span><br><span class="line">[vagrant@server tmp]$ setfacl -m m::r-x acl_test.txt</span><br><span class="line">[vagrant@server tmp]$ getfacl acl_test.txt</span><br><span class="line"><span class="comment"># file: acl_test.txt</span></span><br><span class="line"><span class="comment"># owner: vagrant</span></span><br><span class="line"><span class="comment"># group: vagrant</span></span><br><span class="line">user::rwx</span><br><span class="line">group::rwx<span class="comment">#effective:r-x</span></span><br><span class="line">mask::r-x</span><br><span class="line">other::rwx</span><br></pre></td></tr></table></figure><h2 id="補充-已經有-ACL-的設定就不要再用-chmod"><a href="#補充-已經有-ACL-的設定就不要再用-chmod" class="headerlink" title="補充(已經有 ACL 的設定就不要再用 chmod)"></a>補充(已經有 ACL 的設定就不要再用 chmod)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ ll</span><br><span class="line">total 8</span><br><span class="line">-rwxr-xrwx+ 1 vagrant vagrant  0 Feb 23 03:09 acl_test.txt</span><br><span class="line">-rwx--x--x. 1 vagrant vagrant 22 Feb 23 01:45 vagrant-shell</span><br><span class="line">[vagrant@server tmp]$ chmod 123 acl_test.txt</span><br><span class="line">[vagrant@server tmp]$ ll</span><br><span class="line">total 8</span><br><span class="line">---x-w--wx+ 1 vagrant vagrant  0 Feb 23 03:09 acl_test.txt</span><br><span class="line">-rwx--x--x. 1 vagrant vagrant 22 Feb 23 01:45 vagrant-shell</span><br><span class="line">[vagrant@server tmp]$ getfacl acl_test.txt</span><br><span class="line"><span class="comment"># file: acl_test.txt</span></span><br><span class="line"><span class="comment"># owner: vagrant</span></span><br><span class="line"><span class="comment"># group: vagrant</span></span><br><span class="line">user::--x</span><br><span class="line">group::rwx<span class="comment">#effective:-w-</span></span><br><span class="line">mask::-w-</span><br><span class="line">other::-wx</span><br></pre></td></tr></table></figure><h2 id="補充-若要稽核使用者使用檔案的狀況"><a href="#補充-若要稽核使用者使用檔案的狀況" class="headerlink" title="補充(若要稽核使用者使用檔案的狀況)"></a>補充(若要稽核使用者使用檔案的狀況)</h2><p>可使用 kernel 中的 Audit 功能，設定可參考 <code>/etc/audit</code> 目錄中的設定</p><h2 id="補充-其他"><a href="#補充-其他" class="headerlink" title="補充(其他)"></a>補充(其他)</h2><p>tar 打包時要包含 ACL &amp; SELinux 的權限，要加入 <code>-xattr</code> 參數</p><hr><p><a name="ch6.2"></a></p><h1 id="6-2-Securing-Files-with-ACLs"><a href="#6-2-Securing-Files-with-ACLs" class="headerlink" title="6.2 Securing Files with ACLs"></a>6.2 Securing Files with ACLs</h1><p>透過 <code>-b</code> 參數可回復沒有 ACL 權限設定的狀態，例如 <code>setfacl -b filename</code></p><h2 id="Setting-an-explicit-ACL-mask"><a href="#Setting-an-explicit-ACL-mask" class="headerlink" title="Setting an explicit ACL mask"></a>Setting an explicit ACL mask</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ setfacl -m u:user1:rwx passwd</span><br><span class="line">[vagrant@server tmp]$ setfacl -m u:user2:r-x passwd</span><br><span class="line">[vagrant@server tmp]$ setfacl -m g:user3:rwx passwd</span><br><span class="line">[vagrant@server tmp]$ setfacl -m g:user4:r-x passwd</span><br><span class="line">[vagrant@server tmp]$ getfacl passwd</span><br><span class="line"><span class="comment"># file: passwd</span></span><br><span class="line"><span class="comment"># owner: vagrant</span></span><br><span class="line"><span class="comment"># group: vagrant</span></span><br><span class="line">user::rw-</span><br><span class="line">user:user1:rwx</span><br><span class="line">user:user2:r-x</span><br><span class="line">group::r--</span><br><span class="line">group:user3:rwx</span><br><span class="line">group:user4:r-x</span><br><span class="line">mask::rwx</span><br><span class="line">other::r--</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 mask，限定所能設定的最大權限(注意 rwx 實際只有 r-x 可用)</span></span><br><span class="line">[vagrant@server tmp]$ setfacl -m m::r-x passwd</span><br><span class="line">[vagrant@server tmp]$ getfacl passwd</span><br><span class="line"><span class="comment"># file: passwd</span></span><br><span class="line"><span class="comment"># owner: vagrant</span></span><br><span class="line"><span class="comment"># group: vagrant</span></span><br><span class="line">user::rw-</span><br><span class="line">user:user1:rwx<span class="comment">#effective:r-x</span></span><br><span class="line">user:user2:r-x</span><br><span class="line">group::r--</span><br><span class="line">group:user3:rwx<span class="comment">#effective:r-x</span></span><br><span class="line">group:user4:r-x</span><br><span class="line">mask::r-x</span><br><span class="line">other::r--</span><br></pre></td></tr></table></figure><h2 id="設定檔案建立時的預設-ACL-權限-d"><a href="#設定檔案建立時的預設-ACL-權限-d" class="headerlink" title="設定檔案建立時的預設 ACL 權限(d)"></a>設定檔案建立時的預設 ACL 權限(<code>d</code>)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ mkdir ABC</span><br><span class="line">[vagrant@server tmp]$ chmod 777 ABC/</span><br><span class="line">[vagrant@server tmp]$ touch ABC/file.txt</span><br><span class="line">[vagrant@server tmp]$ getfacl ABC/file.txt</span><br><span class="line"><span class="comment"># file: ABC/file.txt</span></span><br><span class="line"><span class="comment"># owner: vagrant</span></span><br><span class="line"><span class="comment"># group: vagrant</span></span><br><span class="line">user::rw-</span><br><span class="line">group::rw-</span><br><span class="line">other::r--</span><br><span class="line"></span><br><span class="line">[vagrant@server tmp]$ setfacl -m d:u:user1:rwx ABC/</span><br><span class="line">[vagrant@server tmp]$ touch ABC/file2.txt</span><br><span class="line">[vagrant@server tmp]$ getfacl ABC/file2.txt</span><br><span class="line"><span class="comment"># file: ABC/file2.txt</span></span><br><span class="line"><span class="comment"># owner: vagrant</span></span><br><span class="line"><span class="comment"># group: vagrant</span></span><br><span class="line">user::rw-</span><br><span class="line">user:user1:rwx<span class="comment">#effective:rw-</span></span><br><span class="line">group::rwx<span class="comment">#effective:rw-</span></span><br><span class="line">mask::rw-</span><br><span class="line">other::rw-</span><br><span class="line"></span><br><span class="line">[vagrant@server tmp]$ ls -l ABC/</span><br><span class="line">total 4</span><br><span class="line">-rw-rw-rw-+ 1 vagrant vagrant 0 Feb 23 03:50 file2.txt</span><br><span class="line">-rw-rw-r--. 1 vagrant vagrant 0 Feb 23 03:50 file.txt</span><br></pre></td></tr></table></figure><h2 id="遞迴設定-ACL-權限-R-X"><a href="#遞迴設定-ACL-權限-R-X" class="headerlink" title="遞迴設定 ACL 權限(-R + X)"></a>遞迴設定 ACL 權限(-R + X)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 大寫 X =&gt; 表示 user1 對於檔案沒有 exec 的權限，但目錄則有 exec 的權限(才可瀏覽)</span></span><br><span class="line"><span class="comment"># -R =&gt; recusive</span></span><br><span class="line">$ setfacl -R -m u:user1:rX /dir</span><br></pre></td></tr></table></figure><h2 id="移除-ACL-權限-x"><a href="#移除-ACL-權限-x" class="headerlink" title="移除 ACL 權限(-x)"></a>移除 ACL 權限(<code>-x</code>)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ getfacl acl_clone.txt</span><br><span class="line"><span class="comment"># file: acl_clone.txt</span></span><br><span class="line"><span class="comment"># owner: student</span></span><br><span class="line"><span class="comment"># group: student</span></span><br><span class="line">user::rw-</span><br><span class="line">user:user1:r-x</span><br><span class="line">group::rw-</span><br><span class="line">group:group1:rw-</span><br><span class="line">group:group2:r-x</span><br><span class="line">mask::rwx</span><br><span class="line">other::---</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過 -x 參數，指定移除 user1 &amp; group2 的權限</span></span><br><span class="line">$ setfacl -x u:user1,g:group2 acl_clone.txt</span><br><span class="line">$ getfacl acl_clone.txt</span><br><span class="line"><span class="comment"># file: acl_clone.txt</span></span><br><span class="line"><span class="comment"># owner: student</span></span><br><span class="line"><span class="comment"># group: student</span></span><br><span class="line">user::rw-</span><br><span class="line">group::rw-</span><br><span class="line">group:group1:rw-</span><br><span class="line">mask::rw-</span><br><span class="line">other::---</span><br></pre></td></tr></table></figure><hr><h1 id="Practice-Using-ACLs-to-Grant-and-Limit-Access"><a href="#Practice-Using-ACLs-to-Grant-and-Limit-Access" class="headerlink" title="Practice: Using ACLs to Grant and Limit Access"></a>Practice: Using ACLs to Grant and Limit Access</h1><p>實作結果：</p><ol><li>讓 <strong>sodor</strong> group 與 <strong>controller</strong> group 在 <strong>/shares/steamies</strong> 目錄有相同的權限，但 user <strong>james</strong> 則是例外沒有任何權限</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 確認 controller 的 ACL 權限</span></span><br><span class="line">[student@server0 ~]$ sudo getfacl /shares/steamies/</span><br><span class="line">getfacl: Removing leading <span class="string">'/'</span> from absolute path names</span><br><span class="line"><span class="comment"># file: shares/steamies/</span></span><br><span class="line"><span class="comment"># owner: root</span></span><br><span class="line"><span class="comment"># group: controller</span></span><br><span class="line"><span class="comment"># flags: -s-</span></span><br><span class="line">user::rwx</span><br><span class="line">group::rwx</span><br><span class="line">other::---</span><br><span class="line">default:user::rwx</span><br><span class="line">default:group::rwx</span><br><span class="line">default:other::---</span><br><span class="line"></span><br><span class="line"><span class="comment"># 讓 sodor group 與 controller group 有相同的權限</span></span><br><span class="line">[student@server0 ~]$ sudo setfacl -Rm g:sodor:rwX /shares/steamies</span><br><span class="line">[student@server0 ~]$ sudo getfacl /shares/steamies/</span><br><span class="line">getfacl: Removing leading <span class="string">'/'</span> from absolute path names</span><br><span class="line"><span class="comment"># file: shares/steamies/</span></span><br><span class="line"><span class="comment"># owner: root</span></span><br><span class="line"><span class="comment"># group: controller</span></span><br><span class="line"><span class="comment"># flags: -s-</span></span><br><span class="line">user::rwx</span><br><span class="line">group::rwx</span><br><span class="line">group:sodor:rwx</span><br><span class="line">mask::rwx</span><br><span class="line">other::---</span><br><span class="line">default:user::rwx</span><br><span class="line">default:group::rwx</span><br><span class="line">default:other::---</span><br><span class="line"></span><br><span class="line"><span class="comment"># 讓 user james 沒有任何權限</span></span><br><span class="line">[student@server0 ~]$ sudo setfacl -Rm u:james:- /shares/steamies</span><br><span class="line">[student@server0 ~]$ sudo getfacl /shares/steamies/</span><br><span class="line">getfacl: Removing leading <span class="string">'/'</span> from absolute path names</span><br><span class="line"><span class="comment"># file: shares/steamies/</span></span><br><span class="line"><span class="comment"># owner: root</span></span><br><span class="line"><span class="comment"># group: controller</span></span><br><span class="line"><span class="comment"># flags: -s-</span></span><br><span class="line">user::rwx</span><br><span class="line">user:james:---</span><br><span class="line">group::rwx</span><br><span class="line">group:sodor:rwx</span><br><span class="line">mask::rwx</span><br><span class="line">other::---</span><br><span class="line">default:user::rwx</span><br><span class="line">default:group::rwx</span><br><span class="line">default:other::---</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>/shares/steamies</strong> 目錄底下的現有檔案都需要設定成上面的 ACL 權限</li></ol><blockquote><p>因為上面已經使用 <code>-R</code> 參數，因此這個部分已經完成</p></blockquote><ol start="3"><li>新增的目錄 &amp; 檔案也會有相同的 ACL 權限</li></ol><p>表示 <strong>sodor</strong> group 還是會有 rwx 權限，<strong>james</strong> user 也是同樣沒權限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[student@server0 ~]$ sudo setfacl -m d:g:sodor:rwx /shares/steamies</span><br><span class="line">[student@server0 ~]$ sudo setfacl -m d:u:james:- /shares/steamies</span><br><span class="line">[student@server0 ~]$ sudo getfacl /shares/steamies</span><br><span class="line">getfacl: Removing leading <span class="string">'/'</span> from absolute path names</span><br><span class="line"><span class="comment"># file: shares/steamies</span></span><br><span class="line"><span class="comment"># owner: root</span></span><br><span class="line"><span class="comment"># group: controller</span></span><br><span class="line"><span class="comment"># flags: -s-</span></span><br><span class="line">user::rwx</span><br><span class="line">user:james:---</span><br><span class="line">group::rwx</span><br><span class="line">group:sodor:rwx</span><br><span class="line">mask::rwx</span><br><span class="line">other::---</span><br><span class="line">default:user::rwx</span><br><span class="line">default:user:james:---</span><br><span class="line">default:group::rwx</span><br><span class="line">default:group:sodor:rwx</span><br><span class="line">default:mask::rwx</span><br><span class="line">default:other::---</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RHCE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH134 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[RHCE7] RH134 Chapter 5 Managing Priority of Linux Processes 學習筆記</title>
      <link href="/blog/2016/05/04/RHCE/RHCE7-RH134-LearningNotes-CH05_ManagingPriorityOfLinuxProcesses/"/>
      <url>/blog/2016/05/04/RHCE/RHCE7-RH134-LearningNotes-CH05_ManagingPriorityOfLinuxProcesses/</url>
      <content type="html"><![CDATA[<p><a name="ch5.1"></a></p><h1 id="5-1-Process-Priority-and-“nice”-Concepts"><a href="#5-1-Process-Priority-and-“nice”-Concepts" class="headerlink" title="5.1 Process Priority and “nice” Concepts"></a>5.1 Process Priority and “nice” Concepts</h1><p>nice 值範圍 <code>-20</code> ~ <code>19</code>，沒指定預設就是 0，愈小表示 priority 愈高</p><blockquote><p>root 可以調大 or 調小 nice value，但一般使用者只能調大</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加上參數 -l 可取得 nice value(NI)</span></span><br><span class="line">[vagrant@server ~]$ ps -l</span><br><span class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">0 S  1000 11502 11501  0  80   0 - 28845 <span class="built_in">wait</span>   pts/0    00:00:00 bash</span><br><span class="line">0 R  1000 11572 11502  0  80   0 - 34343 -      pts/0    00:00:00 ps</span><br></pre></td></tr></table></figure><blockquote><p>PR 20 = nice 0</p></blockquote><hr><p><a name="ch5.2"></a></p><h1 id="5-2-Using-nice-and-renice-to-Influence-Process-Priority"><a href="#5-2-Using-nice-and-renice-to-Influence-Process-Priority" class="headerlink" title="5.2 Using nice and renice to Influence Process Priority"></a>5.2 Using nice and renice to Influence Process Priority</h1><p>★★★★★★★★★ Very Important! ★★★★★★★★★ (start)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># o format =&gt; 使用者自訂顯示欄位</span></span><br><span class="line">$ ps axo pid,comm,nice --sort=-nice</span><br><span class="line"> PID COMMAND          NI</span><br><span class="line">   26 khugepaged       19</span><br><span class="line">  476 alsactl          19</span><br><span class="line">   25 ksmd              5</span><br><span class="line">  537 rtkit-daemon      1</span><br><span class="line">    1 systemd           0</span><br><span class="line">......</span><br><span class="line">   11 rcuos/0           0</span><br><span class="line">   12 watchdog/0        -</span><br><span class="line">......</span><br><span class="line">29921 ps                0</span><br><span class="line">  449 auditd           -4</span><br><span class="line">  467 sedispatch       -4</span><br><span class="line">  462 audispd          -8</span><br><span class="line"> 1583 pulseaudio      -11</span><br><span class="line">    5 kworker/0:0H    -20</span><br><span class="line">.......</span><br></pre></td></tr></table></figure><p>★★★★★★★★★ Very Important! ★★★★★★★★★ (end)</p><p>啟動程式時指定 nice 值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nice 示範</span></span><br><span class="line">$ nice -n 10 top</span><br><span class="line">$ ps -al</span><br><span class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">0 S  1000 11626 11502  0  90  10 - 36537 poll_s pts/0    00:00:00 top</span><br><span class="line">0 R  1000 11627 11604  0  80   0 - 34343 -      pts/1    00:00:00 ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># renice 示範</span></span><br><span class="line">$ renice -n 15 11604</span><br><span class="line">11604 (process ID) old priority 0, new priority 15</span><br><span class="line">$ ps -al</span><br><span class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">0 S  1000 11626 11502  0  90  10 - 36537 poll_s pts/0    00:00:00 top</span><br><span class="line">0 R  1000 11630 11604  0  95  15 - 34343 -      pts/1    00:00:00 ps</span><br></pre></td></tr></table></figure><hr><h1 id="補充：Hash-Algorithm-特性"><a href="#補充：Hash-Algorithm-特性" class="headerlink" title="補充：Hash Algorithm 特性"></a>補充：Hash Algorithm 特性</h1><ol><li><p>計算的資料來源沒有長度限制</p></li><li><p>雜湊長度永遠固定</p></li><li><p>雜湊演算法為單向運算</p></li><li><p>不同的資料來源不會產出相同的雜湊值</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sha1sum /etc/passwd</span><br><span class="line">524dab4b600e8d87cb7aa5b21e4d57f8996a4374  /etc/passwd</span><br><span class="line"></span><br><span class="line">$ echo &quot;1234&quot; | sha1sum</span><br><span class="line">1be168ff837f043bde17c0314341c84271047b31  -</span><br></pre></td></tr></table></figure><hr><h1 id="Practice-Discovery-Process-Properties"><a href="#Practice-Discovery-Process-Properties" class="headerlink" title="Practice: Discovery Process Properties"></a>Practice: Discovery Process Properties</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根據 cpu 的核心數，執行兩倍數量的運算工作</span></span><br><span class="line">$ <span class="keyword">for</span> i <span class="keyword">in</span> $( seq $(($(grep -c <span class="string">'^processor'</span> /proc/cpuinfo) * 2)) ); <span class="keyword">do</span> sha1sum /dev/zero &amp; <span class="keyword">done</span></span><br><span class="line">[1] 31701</span><br><span class="line">[2] 31702</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">jobs</span></span><br><span class="line">[1]-  Running                 sha1sum /dev/zero &amp;</span><br><span class="line">[2]+  Running                 sha1sum /dev/zero &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用參數 u 可檢視資源使用率</span></span><br><span class="line">$ ps u $(pgrep sha1sum)</span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">student  31701 50.0  0.0 116096  1044 pts/0    R    14:26   1:29 sha1sum /dev/zero</span><br><span class="line">student  31702 50.0  0.0 116096  1044 pts/0    R    14:26   1:29 sha1sum /dev/zero</span><br><span class="line"></span><br><span class="line">$ nice -n 10 sha1sum /dev/zero &amp;</span><br><span class="line">[3] 31764</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過參數 o 指定顯示欄位 (nice value = 10 的 process 所佔的資源相對低)</span></span><br><span class="line">$ ps o pid,pcpu,nice,comm $(pgrep sha1sum)</span><br><span class="line">  PID %CPU  NI COMMAND</span><br><span class="line">31701 49.8   0 sha1sum</span><br><span class="line">31702 49.8   0 sha1sum</span><br><span class="line">31764  4.0  10 sha1sum</span><br><span class="line"></span><br><span class="line"><span class="comment"># 調整 process nice value，可看出資源使用率有提升</span></span><br><span class="line">$ sudo renice -n 5 31764</span><br><span class="line">$ ps o pid,pcpu,nice,comm $(pgrep sha1sum)</span><br><span class="line">  PID %CPU  NI COMMAND</span><br><span class="line">31701 48.8   0 sha1sum</span><br><span class="line">31702 48.8   0 sha1sum</span><br><span class="line">31764  6.2   5 sha1sum</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除所有使用 sha1sum 指令產生的 process</span></span><br><span class="line">$ killall sha1sum</span><br><span class="line">$ ps o pid,pcpu,nice,comm $(pgrep sha1sum)</span><br><span class="line">  PID %CPU  NI COMMAND</span><br><span class="line"> 2052  0.0   0 bash</span><br><span class="line">31825  0.0   0 ps</span><br><span class="line">[1]   Terminated              sha1sum /dev/zero</span><br><span class="line">[2]-  Terminated              sha1sum /dev/zero</span><br><span class="line">[3]+  Terminated              nice -n 10 sha1sum /dev/zero</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RHCE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH134 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[RHCE7] RH134 Chapter 4 Scheduling Future Linux Tasks 學習筆記</title>
      <link href="/blog/2016/05/04/RHCE/RHCE7-RH134-LearningNotes-CH04_SchedulingFutureLinuxTasks/"/>
      <url>/blog/2016/05/04/RHCE/RHCE7-RH134-LearningNotes-CH04_SchedulingFutureLinuxTasks/</url>
      <content type="html"><![CDATA[<p><a name="ch4.1"></a></p><h1 id="4-1-Scheduling-One-Time-Tasks-with-at"><a href="#4-1-Scheduling-One-Time-Tasks-with-at" class="headerlink" title="4.1 Scheduling One-Time Tasks with at"></a>4.1 Scheduling One-Time Tasks with at</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server ~]$ at now+5minutes</span><br><span class="line">at&gt; cp /etc/yum.conf /tmp</span><br><span class="line">at&gt; &lt;EOT&gt;</span><br><span class="line">job 1 at Mon Feb 22 08:23:00 2016</span><br><span class="line"></span><br><span class="line"><span class="comment"># 看目前的排程</span></span><br><span class="line">$ atq</span><br><span class="line"></span><br><span class="line"><span class="comment"># 看指定排程的內容</span></span><br><span class="line">$ at -c 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刪除</span></span><br><span class="line">$ atrm 1</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ <span class="built_in">echo</span> <span class="string">"cp /etc/passwd /tmp"</span> &gt; file.txt</span><br><span class="line"></span><br><span class="line">[vagrant@server tmp]$ at now+10minutes &lt; file.txt</span><br><span class="line">job 2 at Mon Feb 22 08:31:00 2016</span><br><span class="line"></span><br><span class="line">[vagrant@server tmp]$ atq</span><br><span class="line">1Mon Feb 22 08:23:00 2016 a vagrant</span><br><span class="line">2Mon Feb 22 08:31:00 2016 a vagrant</span><br></pre></td></tr></table></figure><h3 id="Practice"><a href="#Practice" class="headerlink" title="Practice"></a>Practice</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ <span class="built_in">echo</span> <span class="string">"date &gt; ~/myjob"</span> | at now+3min</span><br><span class="line">job 3 at Mon Feb 22 08:33:00 2016</span><br><span class="line"></span><br><span class="line">[vagrant@server tmp]$ atq</span><br><span class="line">3Mon Feb 22 08:33:00 2016 a vagrant</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意 while 的條件式中左右各要帶一個 space</span></span><br><span class="line">[vagrant@server tmp]$ <span class="keyword">while</span> [ $(atq | wc -l) -gt 0 ]; <span class="keyword">do</span> sleep 1s; <span class="keyword">done</span></span><br><span class="line">[vagrant@server tmp]$ cat ~/myjob</span><br><span class="line">Mon Feb 22 08:33:00 UTC 2016</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定 queue</span></span><br><span class="line">[vagrant@server tmp]$ at -q g teatime tomorrow</span><br><span class="line">at&gt; touch ~/cookies</span><br><span class="line">at&gt; &lt;EOT&gt;</span><br><span class="line">job 4 at Tue Feb 23 16:00:00 2016</span><br><span class="line"></span><br><span class="line">[vagrant@server tmp]$ at -q b 16:05 tomorrow</span><br><span class="line">at&gt; touch ~/cookies</span><br><span class="line">at&gt; &lt;EOT&gt;</span><br><span class="line">job 5 at Tue Feb 23 16:05:00 2016</span><br><span class="line"></span><br><span class="line">[vagrant@server tmp]$ atq</span><br><span class="line">4Tue Feb 23 16:00:00 2016 g vagrant</span><br><span class="line">5Tue Feb 23 16:05:00 2016 b vagrant</span><br></pre></td></tr></table></figure><hr><p><a name="ch4.2"></a></p><h1 id="4-2-Scheduling-Recurring-Jobs-with-cron-User-cron"><a href="#4-2-Scheduling-Recurring-Jobs-with-cron-User-cron" class="headerlink" title="4.2 Scheduling Recurring Jobs with cron (User cron)"></a>4.2 Scheduling Recurring Jobs with cron (User cron)</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 透過 crontab -e 來設定 user cron jobs</span></span><br><span class="line">[vagrant@server tmp]$ crontab -e</span><br><span class="line">01 * * * *  ~/test.sh</span><br><span class="line">30 2 * * *  run-parts   ~/cron.d</span><br><span class="line"></span><br><span class="line">[vagrant@server tmp]$ sudo ls /var/spool/cron/</span><br><span class="line">vagrant</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 root 身份檢視 vagrant 使用者的 cron jobs</span></span><br><span class="line">[vagrant@server tmp]$ sudo crontab -u vagrant -l</span><br><span class="line">01 * * * *  ~/test.sh</span><br><span class="line">30 2 * * *  run-parts   ~/cron.d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除 vagrant 的 user cron jobs</span></span><br><span class="line">[vagrant@server tmp]$ sudo crontab -u vagrant -r</span><br><span class="line">[vagrant@server tmp]$ sudo crontab -u vagrant -l</span><br><span class="line">no crontab <span class="keyword">for</span> vagrant</span><br></pre></td></tr></table></figure><h3 id="Practice-1"><a href="#Practice-1" class="headerlink" title="Practice"></a>Practice</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server ~]$ crontab -e</span><br><span class="line">*/2 9-16 * * 1-5 date &gt;&gt; /home/vagrant/my_first_cron_job</span><br><span class="line"></span><br><span class="line">[vagrant@server ~]$ crontab -l</span><br><span class="line">*/2 9-16 * * 1-5 date &gt;&gt; /home/vagrant/my_first_cron_job</span><br><span class="line"></span><br><span class="line">[vagrant@server ~]$ cat ~/my_first_cron_job</span><br><span class="line">Mon Feb 22 09:12:01 UTC 2016</span><br><span class="line"></span><br><span class="line">[vagrant@server ~]$ crontab -r</span><br><span class="line">[vagrant@server ~]$ crontab -l</span><br><span class="line">no crontab <span class="keyword">for</span> vagrant</span><br></pre></td></tr></table></figure><hr><p><a name="ch4.3"></a></p><h1 id="4-3-Scheduling-System-cron-Jobs"><a href="#4-3-Scheduling-System-cron-Jobs" class="headerlink" title="4.3 Scheduling System cron Jobs"></a>4.3 Scheduling System cron Jobs</h1><p>cron job 設定存在於 <code>/etc/crontab</code> 中，可透過 <code>man 5 crontab</code> 查詢格式 &amp; 設定方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每個小時的第 1 分鐘</span></span><br><span class="line">01 * * * * *    root  /tmp/aa.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 星期天 02:01</span></span><br><span class="line">01 2 * * * 0    vagrant   /tmp/bb.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每個小時的第 2 分鐘，執行指定目錄中的所有檔案</span></span><br><span class="line">02 * * * * *    root  run-parts   /root/cron.d</span><br></pre></td></tr></table></figure><blockquote><p>指定的檔案都必須要有 <strong>execute</strong>(chmod +x) 的權限才會正確執行</p></blockquote><p><code>/etc/anacrontab</code> &amp; <code>/var/spool/anacron</code>(目錄)：用來處理未執行的 cron job</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ sudo cat /etc/anacrontab</span><br><span class="line"><span class="comment"># /etc/anacrontab: configuration file for anacron</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See anacron(8) and anacrontab(5) for details.</span></span><br><span class="line"></span><br><span class="line">SHELL=/bin/sh</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">MAILTO=root</span><br><span class="line"><span class="comment"># the maximal random delay added to the base delay of the jobs</span></span><br><span class="line">RANDOM_DELAY=45</span><br><span class="line"><span class="comment"># the jobs will be started during the following hours only</span></span><br><span class="line">START_HOURS_RANGE=3-22</span><br><span class="line"></span><br><span class="line"><span class="comment">#period in days   delay in minutes   job-identifier   command</span></span><br><span class="line">15cron.dailynice run-parts /etc/cron.daily</span><br><span class="line">725cron.weeklynice run-parts /etc/cron.weekly</span><br><span class="line">@monthly 45cron.monthlynice run-parts /etc/cron.monthly</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過比較日期的方式，判斷有哪些該執行的 cron job 未執行</span></span><br><span class="line">[vagrant@server tmp]$ ls /var/spool/anacron/</span><br><span class="line">cron.daily  cron.monthly  cron.weekly</span><br><span class="line">[vagrant@server tmp]$ sudo cat /var/spool/anacron/cron.daily</span><br><span class="line">20160222</span><br><span class="line">[vagrant@server tmp]$ sudo cat /var/spool/anacron/cron.monthly</span><br><span class="line">20160222</span><br><span class="line">[vagrant@server tmp]$ sudo cat /var/spool/anacron/cron.weekly</span><br><span class="line">20160222</span><br></pre></td></tr></table></figure><hr><p><a name="ch4.4"></a></p><h1 id="4-4-Managing-Temporary-Files"><a href="#4-4-Managing-Temporary-Files" class="headerlink" title="4.4 Managing Temporary Files"></a>4.4 Managing Temporary Files</h1><p>從 RHEL 7 開始，<code>init</code> 已經被 <code>systemd</code> 所取代</p><p>在 RHEL 7 之前，暫存檔的監控 &amp; 移除由 <code>tmpwatch</code> 套件來管理；但在 RHEL 7，systemd 提供了一個稱為 <code>systemd-tmpfiles</code> 的服務來監控 &amp; 管理所指定的目錄</p><p>透過 <code>stat filename</code> 可以檢視 inode 的內容，與 systemd-tmpfiles 相關的為 <code>Access Time</code>(atime)、<code>Modify Time</code>(mtime)、以及 <code>Change Time</code>(ctime)</p><h3 id="4-4-1-Managing-temporary-files-with-systemd-tmpfiles"><a href="#4-4-1-Managing-temporary-files-with-systemd-tmpfiles" class="headerlink" title="4.4.1 Managing temporary files with systemd-tmpfiles"></a>4.4.1 Managing temporary files with systemd-tmpfiles</h3><p><code>systemd-tmpfiles</code> 的功能在於定期(並非依賴 system cron，而是透過自身的 Timer 機制)的清除指定的目錄內容，或是恢復指定監控的目錄下被務刪的檔案，以下是設定範例(<code>/usr/lib/systemd/system/systemd-tmpfiles-clean.timer</code>)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Timer]</span><br><span class="line">OnBootSec=15min   # 開機後的 15 分鐘執行一次</span><br><span class="line">OnUnitActiveSec=1d  # 之後每天執行一次</span><br></pre></td></tr></table></figure><p><code>systemd-tmpfiles</code> 的設定檔有 3 個地方：</p><ul><li><p>/etc/tmpfiles.d/*.conf</p></li><li><p>/run/tmpfiles.d/*.conf</p></li><li><p>/usr/lib/tmpfiles.d/*.conf</p></li></ul><blockquote><p>下面兩個是屬於預設的設定檔，建議從下面兩個複製到第一個目錄後再修改，因為系統讀取到第一個目錄中有設定後，就不會執行下面兩個目錄的設定檔</p></blockquote><p>以上設定表示 <code>systemd-tmpfiles-clean.service</code> 會在 systemd 啟動後的 15 分鐘後啟動執行，並在每 24 小時後重新執行一次，並根據上面三個目錄中的 <code>*.conf</code> 的設定，執行 <code>systemd-tmpfiles --clean</code> 來清除不需要的檔案(藉由比對檔案的 atime/mtime/ctime)。</p><p>以下是設定檔範例說明：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 若 /run/tuned 目錄不存在，則建立，user/group 皆為 root，權限為 0755</span></span><br><span class="line">d /run/tuned 0755 root root -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除 /var/run/lsm 目錄中的內容</span></span><br><span class="line">D /var/run/lsm 0755 libstoragemgmt libstoragemgmt -</span><br></pre></td></tr></table></figure><blockquote><p>tmpfiles.d 詳細的設定檔撰寫方式可參考 tmpfiles.d(5), systemd-tmpfiles(8) 等文件</p></blockquote><h3 id="補充"><a href="#補充" class="headerlink" title="補充"></a>補充</h3><p>RHEL 7 之前：standalone(daemon) service + xinetd(短暫式服務)</p><p>RHEL 7 之後：systemd service unit = service(對應到原先的 daemon) + socket(對應到原先的 xinetd) + path(監控目錄中檔案的變化，來決定執行的程式，例如：cups.path)</p><hr><h1 id="Practice-Managing-Temporary-Files"><a href="#Practice-Managing-Temporary-Files" class="headerlink" title="Practice: Managing Temporary Files"></a>Practice: Managing Temporary Files</h1><p>RHEL7 中，暫存檔由 <code>systemd-tmpfiles</code> 這個服務來進行管理。</p><p>將 /tmp 中的自動清除設定由 10 天改為 5 天：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 複製 template</span></span><br><span class="line">$ sudo cp /usr/lib/tmpfiles.d/tmp.conf /etc/tmpfiles.d/</span><br><span class="line">$ cat /etc/tmpfiles.d/tmp.conf</span><br><span class="line">.......</span><br><span class="line">d /tmp 1777 root root 5d</span><br><span class="line">d /var/tmp 1777 root root 30d</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 /etc/tmpfiles.d/tmp.conf 檔案，將 10d 改為 5d</span></span><br><span class="line">$ sudo sed -i <span class="string">'/^d .tmp /s/10d/5d/'</span> /etc/tmpfiles.d/tmp.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 測試設定是否成功</span></span><br><span class="line">$ sudo systemd-tmpfiles --clean tmp.conf</span><br></pre></td></tr></table></figure><p>設定 <strong>/run/gallifrey</strong> 每 30 秒清空一次：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 編輯設定檔</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"d /run/gallifrey 0700 root root 30s"</span> | sudo tee /etc/tmpfiles.d/gallifrey.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立規則</span></span><br><span class="line">$ sudo systemd-tmpfiles create gallifrey.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 測試是否有效</span></span><br><span class="line">$ sudo touch /run/gallifrey/helloworld</span><br><span class="line">$ sudo systemd-tmpfiles --clean gallifrey.conf</span><br><span class="line">$ sudo ls -l /run/gallifrey/</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RHCE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH134 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[RHCE7] RH134 Chapter 3 Creating and Editing Text Files with vim 學習筆記</title>
      <link href="/blog/2016/05/04/RHCE/RHCE7-RH134-LearningNotes-CH03_CreatingAndEditingTextFilesWithVim/"/>
      <url>/blog/2016/05/04/RHCE/RHCE7-RH134-LearningNotes-CH03_CreatingAndEditingTextFilesWithVim/</url>
      <content type="html"><![CDATA[<h1 id="3-3-Basic-vim-Workflow"><a href="#3-3-Basic-vim-Workflow" class="headerlink" title="3.3 Basic vim Workflow"></a>3.3 Basic vim Workflow</h1><h2 id="Editor-basics"><a href="#Editor-basics" class="headerlink" title="Editor basics"></a>Editor basics</h2><p><code>i</code>：進入 insert mode</p><p><code>I</code>：進入 insert mode，從游標所在行首插入新字元(<code>i</code> + <code>HOME</code>)</p><p><code>A</code>：<code>i</code> + <code>END</code></p><p><code>R</code>：replace mode，所輸入的會取代原本的內容</p><p><code>o</code>：在游標上方插入新的一行，並進入 insert mode</p><p><code>O</code>：在游標下方插入新的一行，並進入 insert mode</p><p><code>:n</code>：移到第 n 行</p><p><code>:$</code>：移到最後一行</p><p><code>u</code>：undo</p><p><code>Ctrl + r</code>： redo</p><p><code>w</code>(往後移動一個 word) &amp; <code>b</code>(往前移動一個 word)：可用 Ctrl + 左右鍵 取代</p><p><code>DEL</code> or <code>x</code>：刪除一個字元</p><p><code>20dd</code>：刪除 20 行</p><p><code>5yy</code>：複製 5 行</p><hr><h1 id="3-4-Editing-with-Vim"><a href="#3-4-Editing-with-Vim" class="headerlink" title="3.4 Editing with Vim"></a>3.4 Editing with Vim</h1><h2 id="Search-and-Replace"><a href="#Search-and-Replace" class="headerlink" title="Search and Replace"></a>Search and Replace</h2><p>簡單來說，就是在 vim 中使用 sed 的功能</p><p><code>:1,$s/the/*****/g</code>：將檔案中的 then 全部換成星號</p>]]></content>
      
      <categories>
          
          <category> RHCE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH134 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[RHCE7] RH134 Chapter 1 Automating Installation with Kickstart 學習筆記</title>
      <link href="/blog/2016/04/29/RHCE/RHCE7-RH134-LearningNotes-CH01_AutomatingInstallationWithKickstart/"/>
      <url>/blog/2016/04/29/RHCE/RHCE7-RH134-LearningNotes-CH01_AutomatingInstallationWithKickstart/</url>
      <content type="html"><![CDATA[<p><code>dmesg</code> 觀察由 Linux Kernel 所產生的 log 檔</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 製作 USB 安裝裝置</span></span><br><span class="line"><span class="comment"># /dev/sr0 為光碟機裝置</span></span><br><span class="line"><span class="comment"># /dev/sdb1 為 USB 裝置</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/sr0 of=/dev/sdb1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將 DVD 光碟轉成 iso 檔</span></span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/sr0 of=/tmp/rhel_dvd.iso</span><br></pre></td></tr></table></figure><p>安裝 Linux 方式：</p><ul><li>DVD/USB</li><li>Hard Disk</li><li>Network (必須先安裝 YUM server)<ul><li>FTP</li><li>HTTP</li><li>NFS</li></ul></li><li>PXE boot (找 CentOS PXE server)</li></ul><p>Kickstart:</p><ol><li>使用 boot.iso 開機</li><li>準備好 <code>ks.cfg</code>(安裝中需要的設定參數)</li><li>會進入到 <code>Boot:</code>，並輸入 <code>Boot: linux ks=floppy</code>，接著程式就會去找 <strong><font color="red">ks.cfg</font></strong> 並開始安裝</li></ol><blockquote><p>ks.cfg 也可以放置於其他地方，不一定要放在磁碟片中</p></blockquote><p><a name="ch1.1"></a></p><h1 id="1-1-Defining-the-Anaconda-Kickstart-System"><a href="#1-1-Defining-the-Anaconda-Kickstart-System" class="headerlink" title="1.1 Defining the Anaconda Kickstart System"></a>1.1 Defining the Anaconda Kickstart System</h1><h2 id="1-1-1-Introduction-to-Kickstart-installations"><a href="#1-1-1-Introduction-to-Kickstart-installations" class="headerlink" title="1.1.1 Introduction to Kickstart installations"></a>1.1.1 Introduction to Kickstart installations</h2><p>每個 seciton 由 <code>%</code> 開頭，並用 <code>%end</code> 結尾</p><p><code>%package</code> section 指定要所安裝的軟體</p><p><code>@</code> 開頭的設定表示指定 <code>package group</code>，可指定安裝 RedHat 預先設定的軟體群組，例如 core、Web Server …. 等等</p><p><code>@^</code>開頭表示指定 <code>enrironmental group</code>(group in package group)</p><p>其他客製化的需求可以放到 <code>%pre</code> &amp; <code>%post</code> script 中</p><h2 id="1-1-2-Kickstart-configuration-file-commands"><a href="#1-1-2-Kickstart-configuration-file-commands" class="headerlink" title="1.1.2 Kickstart configuration file commands"></a>1.1.2 Kickstart configuration file commands</h2><h3 id="Installation-commands"><a href="#Installation-commands" class="headerlink" title="Installation commands:"></a>Installation commands:</h3><ul><li><p><code>url</code>：用來指定安裝媒體的位置(FTP/HTTP/NFS …. etc)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 --url 指定來源</span></span><br><span class="line">url --url=<span class="string">"ftp://installserver.example.com/pub/RHEL7/dvd"</span></span><br></pre></td></tr></table></figure></li><li><p><code>repo</code>：用來指定要額外安裝的 package repository</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --name 指定名稱，--baseurl 指定 repository 位置</span></span><br><span class="line">repo --name=<span class="string">"Custom Packages"</span> --baseurl=<span class="string">"ftp://repo.example.com/custom"</span></span><br></pre></td></tr></table></figure></li><li><p><code>text</code>：預設以圖形模式顯示，用 text 可改成強制文字模式顯示</p></li><li><p><code>vnc</code>：設定 vnc 密碼</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vnc --password=redhat</span><br></pre></td></tr></table></figure></li></ul><h3 id="Partition-commands"><a href="#Partition-commands" class="headerlink" title="Partition commands"></a>Partition commands</h3><ul><li><p><code>clearpart</code>：安裝前清除硬碟上所有的 partition</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定清除 sda, sdb 兩顆硬碟</span></span><br><span class="line">clearpart --all --drivers=sda,sdb --initlabel</span><br></pre></td></tr></table></figure></li><li><p><code>part</code>：設定 partition 要如何分割</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定 partition 目錄、檔案型態、大小....等資訊</span></span><br><span class="line">part /home --fstype=ext4 --label=homes --size=4096 --maxsize=8192 --grow</span><br></pre></td></tr></table></figure></li><li><p><code>ignoredisk</code>：安裝時忽略特定硬碟</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 忽略 sdc</span></span><br><span class="line">ignoredisk --drivers=sdc</span><br></pre></td></tr></table></figure></li><li><p><code>bootloader</code>：指定安裝 bootloader 的地方</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 sda 上的 mbr 位置安裝 bootloader</span></span><br><span class="line">bootloader --location=mbr --boot-driver=sda</span><br></pre></td></tr></table></figure></li><li><p><code>volgroup</code>, <code>logvol</code>：建立 LVM volume groups &amp; logical volumes</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">part pv.01 --size=8192</span><br><span class="line">volgroup myvg pv.01</span><br><span class="line">logvol / --vgname=myvg --fstype=xfs --size=2048 --name=rootvol -grow</span><br><span class="line">logvol /var --vgname=myvg --fstype=xfs --size=4096 --name=varvol</span><br></pre></td></tr></table></figure></li><li><p><code>zerombr</code>：清除原有的 mbr 設定</p></li></ul><h3 id="Network-commands"><a href="#Network-commands" class="headerlink" title="Network commands"></a>Network commands</h3><ul><li><p><code>network</code>：設定網路</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 設定 eth0 為 DHCP</span></span><br><span class="line">network --device=eth0 --bootproto=dhcp</span><br></pre></td></tr></table></figure></li><li><p><code>firewall</code>：設定防火牆，指定開啟(or 關閉)特定服務</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall --enabled --services=ssh,cups</span><br></pre></td></tr></table></figure></li><li><p><code>lang</code>：語系設定</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lang en_US.UTF-8</span><br></pre></td></tr></table></figure></li><li><p><code>keyboard</code>：鍵盤設定</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keyboard --vckeymap=us --xlayouts=<span class="string">'us'</span></span><br></pre></td></tr></table></figure></li><li><p><code>timezon</code>：設定時區、NTP server 以及是否使用 UTC</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 UTC, 指定 NTP server, 並設定時區</span></span><br><span class="line">timezon --utc --ntpservers=time.example.com Asia/Taipei</span><br></pre></td></tr></table></figure></li><li><p><code>auth</code>：認證方式的設定</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 設定使用一般登入方式 &amp; 加密強度</span></span><br><span class="line">auth --useshadow --enablemd5 --passalgo=sha512</span><br></pre></td></tr></table></figure></li><li><p><code>rootpw</code>：設定 root 密碼</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 也可以使用 "--uscrypted" 參數搭配加密過的密碼</span></span><br><span class="line">rootpwd --plaintext redhat</span><br></pre></td></tr></table></figure></li><li><p><code>selinux</code>：設定 SELinux 的狀態</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selinux --enforcing</span><br></pre></td></tr></table></figure></li><li><p><code>services</code>：設定各種 service 的預設狀態</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services --disabled=network,iptables,ip6tables</span><br></pre></td></tr></table></figure></li><li><p><code>group</code>, <code>user</code>：建立指定的群組與使用者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">group --name=admins --gid=10001</span><br><span class="line">user --name=jdoe --gecos=<span class="string">"John Doe"</span> --group=admins --password=changeme --plaintext</span><br></pre></td></tr></table></figure></li></ul><h3 id="Miscelaneous-commands"><a href="#Miscelaneous-commands" class="headerlink" title="Miscelaneous commands"></a>Miscelaneous commands</h3><ul><li><p><code>logging</code>：定義安裝時的 log 如何處理，可指定 remote logging server</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定 log level &amp; 要儲存的地方</span></span><br><span class="line">logging --host=loghost.example.com --level=INFO</span><br></pre></td></tr></table></figure></li><li><p><code>reboot</code>, <code>poweroff</code>, <code>halt</code>：系統安裝完執行的動作</p></li></ul><blockquote><p>一堆設定不用記，需要的時候再到 <a href="https://access.redhat.com/documentation" target="_blank" rel="noopener">RedHat 官方網站</a> 查詢(Getting Started -&gt; Installation Guide)就好</p></blockquote><p>產生 ks.cfg 方式：</p><ol><li><p>透過 <code>system-config-kickstart</code> 可以透過圖形介面產生 ks.cfg</p><blockquote><p>必須在 /etc/yum.repos.d/rhel-dvd.repo 中要有 <code>rawhide</code> section 的設定，不然出來的圖形介面會沒有 package 可以選</p></blockquote></li><li><p>安裝好一台新的 RHEL，並找到 <code>/root/anaconda-ks.cfg</code> 檔案，拿出來用</p></li></ol><hr><p><a name="ch1.2"></a></p><h1 id="1-2-Deploying-a-New-Virtual-System-with-Kickstart"><a href="#1-2-Deploying-a-New-Virtual-System-with-Kickstart" class="headerlink" title="1.2 Deploying a New Virtual System with Kickstart"></a>1.2 Deploying a New Virtual System with Kickstart</h1><p><code>ksvalidator</code> 可用來檢查 ks.cfg 的格式是否正確 (什麼都結果都沒有表示正確)</p><h3 id="Publish-the-Kickstart-configuration-file-to-Anaconda"><a href="#Publish-the-Kickstart-configuration-file-to-Anaconda" class="headerlink" title="Publish the Kickstart configuration file to Anaconda"></a>Publish the Kickstart configuration file to Anaconda</h3><p>ks.cfg 可以放在很多不同的地方：</p><ul><li><p>可放在 FTP/HTTP/NFS … 等服務上</p></li><li><p>DHCP/TFTP server</p></li><li><p>USB disk or CD-ROM</p></li><li><p>Local disk</p></li><li><p>與 PXE server 結合</p></li></ul><h2 id="補充說明"><a href="#補充說明" class="headerlink" title="補充說明"></a>補充說明</h2><h3 id="遠端安裝-scenario-1"><a href="#遠端安裝-scenario-1" class="headerlink" title="遠端安裝 scenario 1"></a>遠端安裝 scenario 1</h3><ul><li><p>client: private/puiblic IP</p></li><li><p>remote server: public IP</p></li></ul><p>在 remote server 端執行如下：(光碟開機 -&gt; ESC 跳到 boot 選項)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 光碟開機 -&gt; ESC 跳到 boot 選項：</span></span><br><span class="line">boot: linux vncpassword=redhat ip=172.25.0.11 netmask=255.255.255.0 gateway=172.25.0.254</span><br></pre></td></tr></table></figure><blockquote><p>以上 IP 組態設定會根據不同的地點而不同</p></blockquote><h3 id="遠端安裝-scenario-2"><a href="#遠端安裝-scenario-2" class="headerlink" title="遠端安裝 scenario 2"></a>遠端安裝 scenario 2</h3><ul><li><p>client: public IP</p></li><li><p>remote server: private IP</p></li></ul><p>在 client 端下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vncviewer --listen</span><br></pre></td></tr></table></figure><p>在 remote server 端執行如下：(光碟開機 -&gt; ESC 跳到 boot 選項)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boot: linux vnc vncconnect=172.25.254.250 ip=172.25.0.11 netmask=255.255.255.0 gateway=172.25.0.254 dns=8.8.8.8</span><br></pre></td></tr></table></figure><p>按下 Enter 後，client 會自動跑一個 VNC console 出來，並顯示 remote server 的安裝畫面。</p><blockquote><p>也可以通過 direct TCP port 5901 達成第一個方式</p></blockquote>]]></content>
      
      <categories>
          
          <category> RHCE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH134 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[RHCE7] RH134 Chapter 2 Using Regular Expressions with grep 學習筆記</title>
      <link href="/blog/2016/04/29/RHCE/RHCE7-RH134-LearningNotes-CH02_UsingRegularExpressionsWithGrep/"/>
      <url>/blog/2016/04/29/RHCE/RHCE7-RH134-LearningNotes-CH02_UsingRegularExpressionsWithGrep/</url>
      <content type="html"><![CDATA[<p><a name="ch2.2"></a></p><h1 id="2-2-Matching-Text-with-grep"><a href="#2-2-Matching-Text-with-grep" class="headerlink" title="2.2 Matching Text with grep"></a>2.2 Matching Text with grep</h1><p><code>.</code>(單一任何字元) &amp; <code>\</code>(跳脫字元) 的用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 尋找 rcx.d</span><br><span class="line">[vagrant@server etc]$ ls | grep &apos;rc.\.d&apos;</span><br><span class="line">rc0.d</span><br><span class="line">rc1.d</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p><code>[]</code>(中括號，符合其中一個字元) &amp; <code>[^]</code> 的用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server etc]$ ls | grep <span class="string">'rc[134]\.d'</span></span><br><span class="line">rc1.d</span><br><span class="line">rc3.d</span><br><span class="line">rc4.d</span><br><span class="line"></span><br><span class="line">[vagrant@server etc]$ ls | grep <span class="string">'rc[1-3]\.d'</span></span><br><span class="line">rc1.d</span><br><span class="line">rc2.d</span><br><span class="line">rc3.d</span><br><span class="line"></span><br><span class="line">[vagrant@server etc]$ ls | grep <span class="string">'rc[^1-5]\.d'</span></span><br><span class="line">rc0.d</span><br><span class="line">rc6.d</span><br></pre></td></tr></table></figure><p><code>*</code>(零個或多個前面的字元) &amp; <code>\+</code>(一個或多個前面的字元) &amp; <code>\?</code>(零個或一個前面的字元) 的用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ cat file.txt</span><br><span class="line">ac</span><br><span class="line">abc</span><br><span class="line">abbc</span><br><span class="line">abbbc</span><br><span class="line">abbbbc</span><br><span class="line">abbbbbc</span><br><span class="line">abbbbbbc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到全部</span></span><br><span class="line">[vagrant@server tmp]$ cat file.txt | grep <span class="string">'ab*c'</span></span><br><span class="line">ac</span><br><span class="line">abc</span><br><span class="line">abbc</span><br><span class="line">abbbc</span><br><span class="line">abbbbc</span><br><span class="line">abbbbbc</span><br><span class="line">abbbbbbc</span><br><span class="line"></span><br><span class="line">[vagrant@server tmp]$ cat file.txt | grep <span class="string">'ab\+c'</span></span><br><span class="line">abc</span><br><span class="line">abbc</span><br><span class="line">abbbc</span><br><span class="line">abbbbc</span><br><span class="line">abbbbbc</span><br><span class="line">abbbbbbc</span><br><span class="line"></span><br><span class="line">[vagrant@server tmp]$ cat file.txt | grep <span class="string">'ab\?c'</span></span><br><span class="line">ac</span><br><span class="line">abc</span><br></pre></td></tr></table></figure><p><code>\{i\}</code>(i 個前面的字元) &amp; <code>\{i,\}</code>(大於等於 i 個前面的字元) &amp; <code>\{i,j\}</code>(i 到 j 的前面的字元) 的用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ cat file.txt | grep <span class="string">'ab\&#123;3\&#125;c'</span></span><br><span class="line">abbbc</span><br><span class="line"></span><br><span class="line">[vagrant@server tmp]$ cat file.txt | grep <span class="string">'ab\&#123;3,\&#125;c'</span></span><br><span class="line">abbbc</span><br><span class="line">abbbbc</span><br><span class="line">abbbbbc</span><br><span class="line">abbbbbbc</span><br><span class="line"></span><br><span class="line">[vagrant@server tmp]$ cat file.txt | grep <span class="string">'ab\&#123;3,4\&#125;c'</span></span><br><span class="line">abbbc</span><br><span class="line">abbbbc</span><br></pre></td></tr></table></figure><h3 id="練習：尋找包含-IP-address-的行"><a href="#練習：尋找包含-IP-address-的行" class="headerlink" title="練習：尋找包含 IP address 的行"></a>練習：尋找包含 IP address 的行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 尋找 IP address</span></span><br><span class="line">[vagrant@server ~]$ ip addr | grep <span class="string">'[0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125;'</span></span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">    inet 10.0.2.15/24 brd 10.0.2.255 scope global dynamic enp0s3</span><br><span class="line">    inet 172.25.25.11/24 brd 172.25.25.255 scope global enp0s8</span><br></pre></td></tr></table></figure><p><code>^</code>(一行的開頭) &amp; <code>$</code>(一行的結尾)的用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ cat passwd | grep <span class="string">'root'</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">operator:x:11:0:operator:/root:/sbin/nologin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 root 為開頭</span></span><br><span class="line">[vagrant@server tmp]$ cat passwd | grep <span class="string">'^root'</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 bsah 為結尾</span></span><br><span class="line">[vagrant@server tmp]$ cat passwd | grep <span class="string">'bash$'</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">vagrant:x:1000:1000:vagrant:/home/vagrant:/bin/bash</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ cat ff</span><br><span class="line">aaaaa cataaa aaaa</span><br><span class="line">aaaaa cat aaaaa</span><br><span class="line">aaaaa aaaacat aaaa</span><br><span class="line"></span><br><span class="line">[vagrant@server tmp]$ cat ff | grep <span class="string">'\&lt;cat\&gt;'</span></span><br><span class="line">aaaaa cat aaaaa</span><br></pre></td></tr></table></figure><p><code>-v</code>：反向(<strong>顯示沒符合的</strong>)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 搜尋沒有 root 的行</span></span><br><span class="line">[vagrant@server tmp]$ grep -v <span class="string">'root'</span> passwd</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br></pre></td></tr></table></figure><p><code>-n</code>：搜尋結果加上行號</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ grep -n <span class="string">'nologin'</span> passwd</span><br><span class="line">2:bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">3:daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">4:adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br></pre></td></tr></table></figure><p><code>-c</code>：列出符合條件的數量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 搜尋 /etc 有多少個目錄</span></span><br><span class="line">[vagrant@server tmp]$ sudo ls -lR /etc | grep -c <span class="string">'^d'</span></span><br><span class="line">179</span><br></pre></td></tr></table></figure><p><code>-l</code>：只列出符合條件的檔名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server etc]$ grep <span class="string">'password'</span> /etc/* 2&gt;/dev/null</span><br><span class="line">/etc/dnsmasq.conf:<span class="comment">#dhcp-option=encap:175, 191, pass     # iSCSI password</span></span><br><span class="line">/etc/login.defs:<span class="comment">#PASS_MAX_DAYSMaximum number of days a password may be used.</span></span><br><span class="line">/etc/login.defs:<span class="comment">#PASS_MIN_DAYSMinimum number of days allowed between password changes.</span></span><br><span class="line">....</span><br><span class="line">/etc/login.defs:<span class="comment"># Use SHA512 to encrypt password.</span></span><br><span class="line">/etc/services:shell           514/tcp         cmd             <span class="comment"># no passwords used</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[vagrant@server etc]$ grep -l <span class="string">'password'</span> /etc/* 2&gt;/dev/null</span><br><span class="line">/etc/dnsmasq.conf</span><br><span class="line">/etc/login.defs</span><br><span class="line">/etc/services</span><br></pre></td></tr></table></figure><p><code>-r</code>：搜尋整個路徑下的檔案</p><p><code>-i</code>：不區分大小寫</p><p><code>-e</code>：可同時給多個搜尋條件</p><h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><ol><li><p><code>sed &#39;s/cat/dog/&#39; file.txt</code>：將檔案中每一行左邊的第一個 cat 換成 dog</p></li><li><p><code>sed &#39;s/cat/dog/gi&#39; file.txt</code>：同上，但全部一起置換，且不區分大小寫</p></li><li><p><code>sed &#39;s/[Cc]at/dog/gi&#39; file.txt</code>：Cat or cat 都會置換</p></li><li><p><code>sed &#39;s/\&lt;[Cc]at\&gt;/dog/gi&#39; file.txt</code>：只有精準的 Cat or cat 會被置換</p></li><li><p><code>sed &#39;1,30s/cat/dog/gi&#39; file.txt</code>：同 2，但僅處理 1~30 行</p></li><li><p><code>sed &#39;/begin/,/end/s/cat/dog/gi&#39; file.txt</code>：同 2，但僅處理 begin 開頭的行到 end 開頭的行</p></li><li><p><code>sed -e &#39;s/cat/dog/g&#39; -e &#39;s/Cat/dog/g&#39; file.txt</code>：同時給多個條件</p></li><li><p><code>set &#39;/^root/d&#39; file.txt</code>：開頭為 root 的行刪除</p></li><li><p><code>set &#39;/^root/!d&#39; file.txt</code>：開頭為 root 的行不刪除</p></li></ol><blockquote><p>加上 <strong><font color="red">-i</font></strong> 參數會將實際的改變反應到檔案中(原本預設是不會變更檔案內容)</p></blockquote>]]></content>
      
      <categories>
          
          <category> RHCE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH134 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[RHCE] RH124 Chapter 14 Accessing Linux File Systems 學習筆記</title>
      <link href="/blog/2016/04/28/RHCE/RHCE7-RH124-LearningNotes-CH14_AccessingLinuxFileSystems/"/>
      <url>/blog/2016/04/28/RHCE/RHCE7-RH124-LearningNotes-CH14_AccessingLinuxFileSystems/</url>
      <content type="html"><![CDATA[<p><a name="ch14.1"></a></p><h1 id="14-1-Identifying-File-Systems-and-Devices"><a href="#14-1-Identifying-File-Systems-and-Devices" class="headerlink" title="14.1 Identifying File Systems and Devices"></a>14.1 Identifying File Systems and Devices</h1><p>常用指令：</p><ul><li><code>sudo du -h / --max-depth=1 2&gt;/dev/null | sort -h</code>：檢查 root directory 每個目錄所使用的容量</li></ul><hr><p><a name="ch14.2"></a></p><h1 id="14-2-Mounting-and-Unmounting-File-Systems"><a href="#14-2-Mounting-and-Unmounting-File-Systems" class="headerlink" title="14.2 Mounting and Unmounting File Systems"></a>14.2 Mounting and Unmounting File Systems</h1><p>常用指令：</p><ul><li><p><code>blkid</code>：顯示所有 block device 資訊</p></li><li><p><code>mount source_device destination_dir</code>：透過 device name 掛載</p></li><li><p><code>mount UUID destination_dir</code>：透過 UUID 掛載</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查詢機器上的 block device</span></span><br><span class="line">$ sudo blkid</span><br><span class="line">/dev/vda1: UUID=<span class="string">"9bf6b9f7-92ad-441b-848e-0257cbb883d1"</span> TYPE=<span class="string">"xfs"</span> </span><br><span class="line">/dev/vdb1: UUID=<span class="string">"bffdaa4a-34f2-4a74-8455-a11aca40a6e1"</span> TYPE=<span class="string">"xfs"</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定 UUID 掛載 block device</span></span><br><span class="line">$ sudo mkdir /mnt/newspace &amp;&amp; sudo mount UUID=<span class="string">"bffdaa4a-34f2-4a74-8455-a11aca40a6e1"</span> /mnt/newspace</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸離 block device</span></span><br><span class="line">$ sudo umount /mnt/newspace</span><br></pre></td></tr></table></figure><hr><p><a name="ch14.3"></a></p><h1 id="14-3-Making-Links-Between-Files"><a href="#14-3-Making-Links-Between-Files" class="headerlink" title="14.3 Making Links Between Files"></a>14.3 Making Links Between Files</h1><h2 id="Partition-UUID-amp-inode"><a href="#Partition-UUID-amp-inode" class="headerlink" title="Partition UUID &amp; inode"></a>Partition UUID &amp; inode</h2><blockquote><p>UUID 存於 super block 中</p></blockquote><p>inode block -&gt; inode table 結構：</p><ol><li>inode number</li><li>Permission</li><li>Hard Link Subdirectory 數量</li><li>UID</li><li>GID</li><li>Size</li><li>Timestamp</li><li>Filename</li><li>Pointer</li></ol><h2 id="Hard-Link"><a href="#Hard-Link" class="headerlink" title="Hard Link"></a>Hard Link</h2><p><strong><font color="red">inode 在 Linux 中是真正指向檔案實際內容的指標</font></strong></p><p>透過 <code>ln</code> 可建立 Hard Link，這是個指向 inode 的連結</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 產生檔案</span></span><br><span class="line">[student@server0 ~]$ <span class="built_in">echo</span> <span class="string">"Hello World"</span> &gt; newfile.txt</span><br><span class="line">[student@server0 ~]$ ls -l</span><br><span class="line">total 4</span><br><span class="line">-rw-rw-r--. 1 student student 12  4月 28 15:05 newfile.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 hard link (注意數字從 1 變成 2, inode number 相同)</span></span><br><span class="line">[student@server0 ~]$ ln newfile.txt ~/newfile-hlink.txt</span><br><span class="line">[student@server0 ~]$ ls -li</span><br><span class="line">total 8</span><br><span class="line">12889 -rw-rw-r--. 2 student student 12  4月 28 15:05 newfile-hlink.txt</span><br><span class="line">12889 -rw-rw-r--. 2 student student 12  4月 28 15:05 newfile.txt</span><br></pre></td></tr></table></figure><p>Hard Link 特性 &amp; 說明：</p><ul><li>上面建立 Hard Link 的示範，可看出指向同一個 inode 的連結，從一個變成兩個(可防止檔案誤刪)</li><li>增加 hard link 不會增加磁碟空間</li><li>不能跨 File System</li><li>不能 link 目錄，只能建立在檔案上</li></ul><h2 id="Symbolic-Link"><a href="#Symbolic-Link" class="headerlink" title="Symbolic Link"></a>Symbolic Link</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立 symbolic link</span></span><br><span class="line">$ ln -s newfile.txt ~/newfile-symlink.txt</span><br><span class="line">$ ls -l</span><br><span class="line">total 8</span><br><span class="line">-rw-rw-r--. 2 student student 12  4月 28 15:05 newfile-hlink.txt</span><br><span class="line">lrwxrwxrwx. 1 student student 11  4月 28 15:19 newfile-symlink.txt -&gt; newfile.txt</span><br><span class="line">-rw-rw-r--. 2 student student 12  4月 28 15:05 newfile.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除 symbolic link 指向的檔案(系統會標示連結失效)</span></span><br><span class="line">$ rm newfile.txt </span><br><span class="line">$ ls -l</span><br><span class="line">total 4</span><br><span class="line">-rw-rw-r--. 1 student student 12  4月 28 15:05 newfile-hlink.txt</span><br><span class="line">lrwxrwxrwx. 1 student student 11  4月 28 15:19 newfile-symlink.txt -&gt; newfile.txt (這裡會有底色標記連結失效)</span><br><span class="line"></span><br><span class="line"><span class="comment"># link 目錄</span></span><br><span class="line">$ ln -s /etc ~/config_files</span><br></pre></td></tr></table></figure><p>特色：</p><ol><li>類似捷徑</li><li>不能防止檔案誤刪</li></ol><hr><p><a name="ch14.4"></a></p><h1 id="14-4-Locating-Files-on-the-System"><a href="#14-4-Locating-Files-on-the-System" class="headerlink" title="14.4 Locating Files on the System"></a>14.4 Locating Files on the System</h1><h2 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h2><p>要使用 locate 之前必須先執行 <code>sudo updatedb</code>，才會有檔案資料庫可用，若要搜尋最新的檔案，也必須要執行 updatedb</p><ul><li><p><code>sudo locate passwd</code>：尋找檔名為 passwd 的檔案</p></li><li><p><code>sudo locate -n 5 passwd</code>：同上，但只列出 5 筆資料</p></li><li><p><code>sudo locate -i messages</code>：以 case-insensitive 的方式搜尋</p></li></ul><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>即時搜尋，可找到剛新增的檔案</p><ul><li><p><code>sudo find / -name sshd_config</code>：搜尋檔名為 sshd_config 的檔案</p></li><li><p><code>sudo find / -name &#39;*.txt&#39;</code>：在 / 目錄下尋找副檔名為 txt 的檔案</p></li><li><p><code>sudo find / -iname &#39;*messages*&#39;</code>：在 / 目錄下以 case-insensitive 的方式檔名尋找 <em>messages</em> 的檔案</p></li><li><p><code>sudo find -user student</code>：尋找 /home 目錄中，user 為 student 的檔案</p></li><li><p><code>sudo find -group student</code>：尋找 /home 目錄中，group 為 student 的檔案</p></li><li><p><code>sudo find / -user root -group mail</code>：在 / 目錄中尋找 user=root, group=mail 的檔案</p></li><li><p><code>sudo find /home -perm 764</code>：尋找 /home 中 permission=764 檔案</p></li><li><p><code>sudo find /home -perm -324</code>：尋找 /home 中，<strong><font color="red">至少</font></strong>有指定權限的檔案</p></li><li><p><code>sudo find /home -perm /442</code>：尋找 /home 中，user(read)/group(read)/others(write) 至少其中一個符合指定權限的檔案</p></li><li><p><code>sudo find / -perm /7000</code>：搜尋檔案當中含有 SGID 或 SUID 或 SBIT 的屬性</p></li><li><p><code>sudo find /run -type s</code>：找出 /run 目錄中，檔案類型為 Socket 的檔名有哪些</p><blockquote><p>type 選項可以有 f(一般檔案) / d(目錄) / l(symbolic link) / b(block device)</p></blockquote></li><li><p><code>sudo find -size -10M</code>：尋找小於 10MB 的檔案</p></li><li><p><code>sudo find / -type f -links +1</code>：尋找擁有超過 1 個 hard link 的一般檔案</p></li></ul><h3 id="find-的特別功能"><a href="#find-的特別功能" class="headerlink" title="find 的特別功能"></a>find 的特別功能</h3><p>find 還可以針對搜尋結果加上 action：</p><p><code>sudo find /etc/yum.repos.d/ -type f -exec mv {} {}1 \;</code></p><p>以上指令表示：</p><ol><li><p>搜尋 /etc/yum.repos.d/ 目錄中的一般檔案</p></li><li><p>將每個檔案進行改名，在檔名後面多加一個 1</p></li></ol><hr><h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul><li><a href="http://linux.vbird.org/linux_basic/0230filesystem.php#link" target="_blank" rel="noopener">鳥哥的 Linux 私房菜 – 第七章、Linux 磁碟與檔案系統管理 &gt;&gt; 7.2.2 實體連結與符號連結： ln</a></li><li><a href="http://linux.vbird.org/linux_basic/0220filemanager.php#file_find" target="_blank" rel="noopener">鳥哥的 Linux 私房菜 – 第六章、Linux 檔案與目錄管理 &gt;&gt; 6.5 指令與檔案的搜尋</a></li></ul>]]></content>
      
      <categories>
          
          <category> RHCE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH124 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[RHCE] RH124 Chapter 13 Installing and Updating Software Packages 學習筆記</title>
      <link href="/blog/2016/04/27/RHCE/RHCE7-RH124-LearningNotes-CH13_InstallingAndUpdatingSoftwarePackages/"/>
      <url>/blog/2016/04/27/RHCE/RHCE7-RH124-LearningNotes-CH13_InstallingAndUpdatingSoftwarePackages/</url>
      <content type="html"><![CDATA[<p><a name="ch13.2"></a></p><h1 id="13-2-RPM-Software-Packages-and-YUM"><a href="#13-2-RPM-Software-Packages-and-YUM" class="headerlink" title="13.2 RPM Software Packages and YUM"></a>13.2 RPM Software Packages and YUM</h1><table><thead><tr><th>功能</th><th>yum</th><th>rpm</th></tr></thead><tbody><tr><td>查詢</td><td>yum list &#124; grep <font color="blue"><em>KEYWORD</em></font> <br>yum search <font color="blue"><em>KEYWORD</em></font> <br>yum info <font color="blue"><em>PACKAGE_NAME</em></font> <br>yum provides <font color="blue"><em>FILE_PATH_NAME</em></font></td><td>rpm -qa &#124; grep <font color="blue"><em>KEYWORD</em></font> <br>rpm [ -qi &#124; -ql &#124; -qc &#124; -gd &#124; -q –scripts &#124; -q –changelog ] <font color="blue"><em>PACKAGE_NAME</em></font> <br> rpm -qf <font color="blue"><em>FILE_PATH</em></font></td></tr><tr><td>查詢(Group)</td><td>yum groups [ list &#124; info ]</td><td>rpm [ -qpi &#124; -qpl &#124; -qpc &#124; -qpd &#124; -qp –scripts &#124; -qp –changelog] <font color="blue"><em>PACKAGE_NAME</em></font></td></tr><tr><td>安裝</td><td>yum -y [group] install <font color="blue"><em>PACKAGE_NAME</em></font></td><td>rpm -ivh <font color="blue"><em>PACKAGE_NAME</em></font> <br>yum -y localinstall <font color="blue"><em>PACKAGE_NAME</em></font></td></tr><tr><td>更新</td><td>yum -y update <font color="blue"><em>PACKAGE_NAME</em></font></td><td>rpm -Uvh <font color="blue"><em>PACKAGE_NAME</em></font></td></tr><tr><td>移除</td><td>yum -y [group] remove <font color="blue"><em>PACKAGE_NAME</em></font></td><td>rpm -e <font color="blue"><em>PACKAGE_NAME</em></font></td></tr></tbody></table><hr><p><a name="ch13.3"></a></p><h1 id="13-3-Managing-Software-Updates-with-yum"><a href="#13-3-Managing-Software-Updates-with-yum" class="headerlink" title="13.3 Managing Software Updates with yum"></a>13.3 Managing Software Updates with yum</h1><ul><li><p><code>sudo yum group install &quot;Development Tools&quot;</code>：安裝整包 Development Tools</p></li><li><p><code>yum list kernel</code>：列出 kernel 清單 (包含已經安裝 &amp; 可安裝的)</p></li><li><p><code>uname -r</code>：列出 kenal 版本</p></li><li><p><code>uname -a</code>：列出 kernel 詳細資訊</p></li><li><p><code>sudo yum history</code>：檢視 yum 歷程記錄</p></li><li><p><code>sudo yum undo 5</code>：取消 ID=5 所紀錄的 yum 工作</p></li></ul><hr><p><a name="ch13.4"></a></p><h1 id="13-4-Enabling-yum-Software-Repositories"><a href="#13-4-Enabling-yum-Software-Repositories" class="headerlink" title="13.4 Enabling yum Software Repositories"></a>13.4 Enabling yum Software Repositories</h1><p><code>/etc/yum.repos.d/*.repo</code>：此目錄內的附檔名必須都是 <strong>repo</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[ID]</span></span><br><span class="line"><span class="attr">name</span>=</span><br><span class="line"><span class="attr">baseurl</span>= YUM server 上的容器</span><br><span class="line"><span class="attr">enabled</span>=</span><br><span class="line"><span class="attr">gpgcheck</span>=</span><br></pre></td></tr></table></figure><p>常用指令：</p><ul><li><p><code>yum repolist all</code>：列出目前所有 repository</p></li><li><p><code>sudo yum-config-manager --disable rhel_dvd</code>：停用 “rhel_dvd” repository</p></li><li><p><code>sudo yum-config-manager --add-repo=&quot;http://content.example.com/rhel7.0/x86_64/rht/&quot;</code>：直接指定路徑增加 repository</p></li><li><p><code>sudo rpm --import http://dl.fedoraproject.org/pub/epel/RPM-GPG-KEY-EPEL-7</code>：加入 GPG Key</p></li><li><p><code>sudo yum -y install http://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm</code>：透過 rpm 安裝方式加入 repository</p></li></ul><p>其他：</p><ul><li><p><code>EPEL</code>：Extra Package for Enterprise Linux</p></li><li><p>使用 yum-config-manager 搭配 <code>--nogpgcheck</code> 表示忽略 GPG key 的檢查，可能會有安全性上的風險</p></li></ul><h3 id="非常重要-Practice-非常重要"><a href="#非常重要-Practice-非常重要" class="headerlink" title="(非常重要) ===== Practice ====== (非常重要)"></a>(<strong><font color="red">非常重要</font></strong>) ===== Practice ====== (<strong><font color="red">非常重要</font></strong>)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum-config-manager --add-repo=<span class="string">"http://content.example.com/rhel7.0/x86_64/rht"</span></span><br><span class="line">[content.example.com_rhel7.0_x86_64_rht]</span><br><span class="line">name=added from: http://content.example.com/rhel7.0/x86_64/rht</span><br><span class="line">baseurl=http://content.example.com/rhel7.0/x86_64/rht</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure><p>編輯 <strong><font color="red">/etc/yum.repo.d/errata.repo</font></strong> 內容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[updates]</span><br><span class="line">name=RedHat updates</span><br><span class="line">baseurl=http://content.example.com/rhel7.0/x86_64/errata</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 檢查詢所有的 repository (包含 enabled &amp; disabled)</span></span><br><span class="line">$ yum repolist all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停用指定 repository</span></span><br><span class="line">$ sudo yum-config-manager --<span class="built_in">disable</span> content.example.com_rhel7.0_x86_64_rht</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次確認 repository 狀態</span></span><br><span class="line">$ yum repolist all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 套件升級(會發現有個 kernel 的 update 來自剛剛的 errata repo)</span></span><br><span class="line">$ sudo yum -y update</span><br><span class="line"><span class="comment"># 檢視目前系統中所有的 kernel 清單</span></span><br><span class="line">$ yum list kernel</span><br></pre></td></tr></table></figure><hr><p><a name="ch13.5"></a></p><h1 id="13-5-Examining-RPM-Package-Files"><a href="#13-5-Examining-RPM-Package-Files" class="headerlink" title="13.5 Examining RPM Package Files"></a>13.5 Examining RPM Package Files</h1><p>rpm 常用參數：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查詢指定套件</span></span><br><span class="line">$ rpm -q yum</span><br><span class="line">yum-3.4.3-118.el7.noarch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢指定檔案(or 目錄)屬於哪個套件</span></span><br><span class="line">$ rpm -q -f /etc/yum.repos.d</span><br><span class="line">yum-3.4.3-118.el7.noarch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢套件資訊，類似 "yum info" 的功能</span></span><br><span class="line">$ rpm -q -i yum</span><br><span class="line">Name        : yum</span><br><span class="line">Version     : 3.4.3</span><br><span class="line">Release     : 118.el7</span><br><span class="line">Architecture: noarch</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出安裝指定套件所產生的檔案列表</span></span><br><span class="line">$ rpm -q -l yum</span><br><span class="line">.....</span><br><span class="line">/etc/yum.conf</span><br><span class="line">/etc/yum.repos.d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出指定套件相關的文件資訊</span></span><br><span class="line">$ rpm -q -d yum</span><br><span class="line">/usr/share/doc/yum-3.4.3/AUTHORS</span><br><span class="line">/usr/share/doc/yum-3.4.3/COPYING</span><br><span class="line">/usr/share/doc/yum-3.4.3/ChangeLog</span><br><span class="line">/usr/share/doc/yum-3.4.3/INSTALL</span><br><span class="line">.......</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出安裝指定套件所會執行的相關 script 內容</span></span><br><span class="line">$ rpm -q --scripts openssh-server</span><br><span class="line">preinstall scriptlet (using /bin/sh):</span><br><span class="line">getent group sshd &gt;/dev/null || groupadd -g 74 -r sshd || :</span><br><span class="line">.......</span><br><span class="line">postinstall scriptlet (using /bin/sh):</span><br><span class="line">.......</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢套件所包含的設定檔</span></span><br><span class="line">$ rpm -q -c yum</span><br><span class="line">/etc/logrotate.d/yum</span><br><span class="line">/etc/yum.conf</span><br><span class="line">/etc/yum/version-groups.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢指定套件的 changelog 資訊</span></span><br><span class="line">$ rpm -q --changelog yum</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RHCE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH124 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[RHCE] RH124 Chapter 11 Managing Red Hat Enterprise Linux Networking 學習筆記</title>
      <link href="/blog/2016/04/27/RHCE/RHCE7-RH124-LearningNotes-CH12-ArchvingAndCopyingFilesBetweenSystems/"/>
      <url>/blog/2016/04/27/RHCE/RHCE7-RH124-LearningNotes-CH12-ArchvingAndCopyingFilesBetweenSystems/</url>
      <content type="html"><![CDATA[<p><a name="ch12.1"></a></p><h1 id="12-1-Managing-Compressed-tar-Archives"><a href="#12-1-Managing-Compressed-tar-Archives" class="headerlink" title="12.1 Managing Compressed tar Archives"></a>12.1 Managing Compressed tar Archives</h1><h2 id="12-1-2-Archive-files-and-directories-with-tar"><a href="#12-1-2-Archive-files-and-directories-with-tar" class="headerlink" title="12.1.2 Archive files and directories with tar"></a>12.1.2 Archive files and directories with tar</h2><p>tar 指令要先輸入目的地檔案，後面才是來源檔案 (跟 cp &amp; mv 等指令相反)</p><p>tar 打包檔案中若包含絕對路徑檔案，則會把最開頭的 <code>/</code> 拿掉 (安全因素)</p><p>tar 打包檔案時會包含檔案的修改時間、權限 … 等資訊，但預設不儲存檔案 SELinux conext &amp; ACL 屬性(若要一起打包則要在指令最後方加上 <code>--xattrs</code> 參數)</p><p>指令參考：</p><ul><li><p><code>tar cf archive.tar file1 file2 file3</code>：將三個檔案打包為 archive.tar</p></li><li><p><code>tar tf archive.tar</code>：列出 archive.tar 中的內容</p></li><li><p><code>sudo tar cf /root/etc.tar /etc</code>：打包整個 /etc 目錄成 /root/etc.tar</p></li></ul><h2 id="12-1-3-Extract-an-archive-created-with-tar"><a href="#12-1-3-Extract-an-archive-created-with-tar" class="headerlink" title="12.1.3 Extract an archive created with tar"></a>12.1.3 Extract an archive created with tar</h2><p><code>mkdir test &amp;&amp; sudo sudo tar xf /root/etc.tar -C test/</code>：將 /root/etc.tar 解開後放到 test 目錄中</p><blockquote><p>用 tar 解開打包檔，若要保留原有檔案的權限資訊，要加上 <code>-p</code> 參數 (這是 root 預設就會包含的選項)</p></blockquote><h2 id="12-1-4-Create-a-compressed-tar-archive"><a href="#12-1-4-Create-a-compressed-tar-archive" class="headerlink" title="12.1.4 Create a compressed tar archive"></a>12.1.4 Create a compressed tar archive</h2><ul><li><p>‘z’：gzip (archive.tgz / archive.tar.gz)</p></li><li><p>‘j’：bz2 (archive.tar.bz2)</p></li><li><p>‘J’：xz (archive.tar.xz) (壓縮效率最好，但速度最慢)</p></li></ul><p>參考指令：</p><ul><li><p><code>sudo tar czf /root/etc.tar.gz /etc</code>：以 /etc 為資料來源，建立 gzip 打包壓縮檔</p></li><li><p><code>sudo tar cjf /root/etc.tar.bz2 /etc</code>：以 /etc 為資料來源，建立 bzip2 打包壓縮檔</p></li><li><p><code>sudo tar cJf /root/etc.tar.xz /etc</code>：以 /etc 為資料來源，建立 xz 打包壓縮檔</p></li></ul><h2 id="12-1-5-Extract-a-compressed-tar-archive"><a href="#12-1-5-Extract-a-compressed-tar-archive" class="headerlink" title="12.1.5 Extract a compressed tar archive"></a>12.1.5 Extract a compressed tar archive</h2><p>系統會清楚知道檔案壓縮的格式，因此解壓縮時不用加上 <code>z</code> or <code>j</code> or <code>J</code> 也沒關係</p><p>參考指令：</p><ul><li><code>sudo tar xJf /root/etc.tar.xz -C test/</code>：將上述 xz 壓縮檔解壓縮到 test 目錄下</li></ul><hr><p><a name="ch12.2"></a></p><h1 id="12-2-Copying-Files-Between-Systems-Securely"><a href="#12-2-Copying-Files-Between-Systems-Securely" class="headerlink" title="12.2 Copying Files Between Systems Securely"></a>12.2 Copying Files Between Systems Securely</h1><p><code>scp</code>：適合用於單一檔案</p><p><code>rsync</code>：可用於單一檔案，但特色是目錄的同步與屬性的保留</p><p><code>sftp</code>：互動功能，Windows 作業系統上較常用</p><p>參考指令：</p><ul><li><code>scp /etc/yum.conf /etc/hosts student@172.25.0.11:/home/student</code>：透過 scp 直接傳兩個檔案到遠端主機</li></ul><hr><p><a name="ch12.3"></a></p><h1 id="12-3-Synchronizing-Files-Between-Systems-Securely"><a href="#12-3-Synchronizing-Files-Between-Systems-Securely" class="headerlink" title="12.3 Synchronizing Files Between Systems Securely"></a>12.3 Synchronizing Files Between Systems Securely</h1><p><code>-n</code>：Dry run，不會真的執行<br><code>-a</code>：<code>-r</code> + <code>-l</code> + <code>-p</code> + <code>-t</code> + <code>-g</code> + <code>-o</code> + <code>-D</code><br><code>-H</code>：保留 Hard Link<br><code>-A</code>：保留 ACLs 設定<br><code>-X</code>：保留 SELinux context 設定</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm -rf /tmp/*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步目錄下所有檔案(只會有一個 log 目錄)</span></span><br><span class="line">$ sudo rsync -av /var/<span class="built_in">log</span> /tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步目錄下所有檔案(會跑出很多檔案 &amp; 目錄)</span></span><br><span class="line">$ sudo rsync -av /var/<span class="built_in">log</span>/ /tmp</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RHCE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH124 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[RHCE] RH124 Chapter 11 Managing Red Hat Enterprise Linux Networking 學習筆記</title>
      <link href="/blog/2016/04/26/RHCE/RHCE7-RH124-LearningNotes-CH11_ManagingRedHatEnterpriseLinuxNetworking/"/>
      <url>/blog/2016/04/26/RHCE/RHCE7-RH124-LearningNotes-CH11_ManagingRedHatEnterpriseLinuxNetworking/</url>
      <content type="html"><![CDATA[<p><a name="ch11.1"></a></p><h1 id="11-1-Network-Concepts"><a href="#11-1-Network-Concepts" class="headerlink" title="11.1 Network Concepts"></a>11.1 Network Concepts</h1><h2 id="11-1-2-Network-interface-names"><a href="#11-1-2-Network-interface-names" class="headerlink" title="11.1.2 Network interface names"></a>11.1.2 Network interface names</h2><p>網卡命名原則：</p><ul><li><p>Ethernet 介面卡，開頭為 <code>en</code></p><blockquote><p>onboard 的網卡名稱為 eno1, eno2 … etc<br>可插拔(PCI 介面)的網卡名稱為 enp2s0</p></blockquote></li><li><p>無線網路卡，開頭為 <code>wl</code></p></li><li><p>3G/4G 網路卡，開頭為 <code>ww</code></p></li></ul><blockquote><p>虛擬機則一律為 <code>eth0</code>, <code>eth1</code>, <code>eth2</code> … etc</p></blockquote><hr><p><a name="ch11.2"></a></p><h1 id="11-2-Validating-Network-Configuration"><a href="#11-2-Validating-Network-Configuration" class="headerlink" title="11.2 Validating Network Configuration"></a>11.2 Validating Network Configuration</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 顯示 enp0s8 資訊</span></span><br><span class="line">[student@server0 ~]$ ip addr show eth0</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000</span><br><span class="line">    link/ether 52:54:00:00:00:0b brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.25.0.11/24 brd 172.25.0.255 scope global dynamic eth0</span><br><span class="line">       valid_lft 16494sec preferred_lft 16494sec</span><br><span class="line">    inet6 fe80::5054:ff:fe00:b/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示網路介面的統計紀錄</span></span><br><span class="line">[student@server0 ~]$ ip -s link show eth0</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT qlen 1000</span><br><span class="line">    link/ether 52:54:00:00:00:0b brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    RX: bytes  packets  errors  dropped overrun mcast   </span><br><span class="line">    5641965    4752     0       0       0       0      </span><br><span class="line">    TX: bytes  packets  errors  dropped carrier collsns</span><br><span class="line">    611742     3112     0       0       0       0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視路由</span></span><br><span class="line">[student@server0 ~]$ ip route</span><br><span class="line">default via 172.25.0.254 dev eth0  proto static  metric 1024</span><br><span class="line">172.25.0.0/24 dev eth0  proto kernel  scope link  src 172.25.0.11</span><br><span class="line">172.25.253.254 via 172.25.0.254 dev eth0  proto static  metric 1</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有資訊</span></span><br><span class="line">$ sudo ss</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出已經建立的 connection</span></span><br><span class="line">$ sudo ss -t</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出包含 listen 的 port &amp; connection</span></span><br><span class="line">$ sudo ss -ta</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出 listening 的 tcp socket</span></span><br><span class="line">$ sudo ss -lt</span><br></pre></td></tr></table></figure><hr><p><a name="ch11.3"></a></p><h1 id="11-3-Configuring-Network-with-nmcli"><a href="#11-3-Configuring-Network-with-nmcli" class="headerlink" title="11.3 Configuring Network with nmcli"></a>11.3 Configuring Network with nmcli</h1><p>在 RHEL 7 中提供了 <strong><font color="red">nmcli</font></strong>(NetworkManager) 作為網路設定管理之用。</p><h2 id="11-3-1-Network-Manager"><a href="#11-3-1-Network-Manager" class="headerlink" title="11.3.1 Network Manager"></a>11.3.1 Network Manager</h2><p><code>nmcli</code> 命令是修改 <code>/etc/sysconfig/network-scripts/ifcfg-*</code> 中的內容，有兩個觀念必須弄清楚，分別是 <strong><font color="red">device</font></strong> &amp; <strong><font color="red">connection</font></strong>：</p><ul><li><p><code>device</code>：每一個網路卡(介面)都屬於一個 device</p></li><li><p><code>connection</code>：每一個 device 可以同時有多個 connection 設定(每次只有一種可以生效)，可快速因應在不同場景所需要的網路設定變更</p></li></ul><h2 id="11-3-2-Viewing-network-information-with-nmcli"><a href="#11-3-2-Viewing-network-information-with-nmcli" class="headerlink" title="11.3.2 Viewing network information with nmcli"></a>11.3.2 Viewing network information with nmcli</h2><ul><li><p><code>sudo systemctl status NetworkManager.service</code>：檢查 Network Manager 目前服務狀態</p></li><li><p><code>nmcli connection show</code>：列出目前所有的 connection</p></li><li><p><code>nmcli connection show --active</code>：顯示出目前狀態為 active 的 connection</p></li><li><p><code>nmcli connection show &quot;System eth0&quot;</code>：顯示指定 connection 的詳細內容 (小寫的部分可以變更、大寫的部分無法變更)</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[student@server0 ~]$ nmcli connection show --active</span><br><span class="line">NAME         UUID                                  TYPE            DEVICE</span><br><span class="line">System eth0  5fb06bd0-0bb0-7ffb-45f1-d6edd65f3e03  802-3-ethernet  eth0</span><br><span class="line">[student@server0 ~]$ nmcli connection show <span class="string">"System eth0"</span></span><br><span class="line">connection.id:                          System eth0</span><br><span class="line">connection.uuid:                        5fb06bd0-0bb0-7ffb-45f1-d6edd65f3e03</span><br><span class="line">connection.interface-name:              eth0</span><br><span class="line">connection.type:                        802-3-ethernet</span><br><span class="line">.....</span><br><span class="line">GENERAL.NAME:                           System eth0</span><br><span class="line">GENERAL.UUID:                           5fb06bd0-0bb0-7ffb-45f1-d6edd65f3e03</span><br><span class="line">GENERAL.DEVICES:                        eth0</span><br><span class="line">GENERAL.STATE:                          activated</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><ul><li><p><code>nmcli device status</code>：顯示目前 device 的狀態</p></li><li><p><code>nmcli device show eth0</code>：顯示指定 device 的詳細狀態</p></li></ul><h2 id="11-3-3-Creating-network-connections-with-nmcli"><a href="#11-3-3-Creating-network-connections-with-nmcli" class="headerlink" title="11.3.3 Creating network connections with nmcli"></a>11.3.3 Creating network connections with nmcli</h2><ul><li><p><code>sudo nmcli connection add con-name &quot;my-connect-name&quot; type ethernet ifname eth0</code></p><blockquote><p>device: eth0<br><br>connection: my-connect-name<br><br>設定內容：DHCP</p></blockquote></li><li><p><code>sudo nmcli connection add con-name &quot;static&quot; ifname eth0 type ethernet autoconnect no ip4 172.25.40.11/24 gw4 172.25.40.254</code></p><blockquote><p>device: eth0 <br><br>connection: static <br><br>設定內容: 開機時不套用 | IPv4 | IP: 172.25.40.11/24 | Gateway: 172.25.40.254 <br><br><strong><font color="red">但 connection add 無法增加 DNS 設定</font></strong></p></blockquote></li><li><p><code>sudo nmcli connection up static</code>：套用 “staic” connection 設定</p></li><li><p><code>sudo nmcli connection reload</code>：reload 所有的 connection(設定檔)，不會套用到網路介面上(設定完建議 reload 以確保設定有被 Network Manager 抓到)</p></li></ul><h2 id="11-3-4-Modifying-network-interfaces-with-nmcli"><a href="#11-3-4-Modifying-network-interfaces-with-nmcli" class="headerlink" title="11.3.4 Modifying network interfaces with nmcli"></a>11.3.4 Modifying network interfaces with nmcli</h2><ul><li><p><code>sudo nmcli connection modify &quot;static&quot; ipv4.dns 8.8.8.8</code>：在指定的 connection 中設定 DNS(作完要重新 up connection 才會生效)</p></li><li><p><code>sudo nmcli connection modify &quot;static&quot; +ipv4.dns 8.8.4.4</code>：在指定的 connection 中增加 DNS 設定</p></li><li><p><code>sudo nmcli connection modify &quot;static&quot; connection.autoconnect on</code>：設定開機自動套用指定 connection</p></li><li><p><code>sudo nmcli connection delete &quot;static&quot;</code>：刪除指定的 connection</p></li><li><p><code>sudo nmcli connection down</code>：網路斷掉後，Network Manager 會嘗試找到另外一個 autoconnect=on 的 connection 並套用其設定</p></li><li><p><code>sudo nmcli device disconnect eth0</code>：強制停用指定 device 的網路設定(不會自動套用設定)</p></li><li><p><code>sudo nmcli net off</code>：停止所有的網路介面</p></li></ul><hr><p><a name="ch11.4"></a></p><h1 id="11-4-Editing-Network-Configuration-Files"><a href="#11-4-Editing-Network-Configuration-Files" class="headerlink" title="11.4 Editing Network Configuration Files"></a>11.4 Editing Network Configuration Files</h1><p>直接修改 <code>/etc/sysconfig/network-scripts/ifcfg-*</code> 檔案中的內容，再使用 <code>sudo nmcli connection reload</code>，就可以讓 Network Manager 取得新的設定。</p><hr><p><a name="ch11.5"></a></p><h1 id="11-5-Configuring-Host-Names-and-Name-Resolution"><a href="#11-5-Configuring-Host-Names-and-Name-Resolution" class="headerlink" title="11.5 Configuring Host Names and Name Resolution"></a>11.5 Configuring Host Names and Name Resolution</h1><h2 id="11-5-1-Changing-the-System-host-name"><a href="#11-5-1-Changing-the-System-host-name" class="headerlink" title="11.5.1 Changing the System host name"></a>11.5.1 Changing the System host name</h2><p>若 <code>/etc/hostname</code> 不存在，則系統在網卡被分配到 ip 後，就會進行一個 DNS 的反向查詢</p><p>hostname 可透過 <code>hostnamectl</code> 命令來設定</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ hostname</span><br><span class="line">server5.example.com</span><br><span class="line"></span><br><span class="line">$ sudo hostnamectl <span class="built_in">set</span>-hostname sercerX.example.com</span><br><span class="line"></span><br><span class="line">$ hostnamectl status</span><br><span class="line">   Static hostname: sercerx.example.com</span><br><span class="line">   Pretty hostname: sercerX.example.com</span><br><span class="line">         Icon name: computer-vm</span><br><span class="line">           Chassis: vm</span><br><span class="line">        Machine ID: adf65a29af58497b8bb516fc6d366b8d</span><br><span class="line">           Boot ID: 963e5bc0e26a42e8acf285616ed9c9b6</span><br><span class="line">    Virtualization: kvm</span><br><span class="line">  Operating System: CentOS Linux 7 (Core)</span><br><span class="line">       CPE OS Name: cpe:/o:centos:centos:7</span><br><span class="line">            Kernel: Linux 3.10.0-327.3.1.el7.x86_64</span><br><span class="line">      Architecture: x86-64</span><br></pre></td></tr></table></figure><h2 id="11-5-2-Configuring-name-resolution"><a href="#11-5-2-Configuring-name-resolution" class="headerlink" title="11.5.2 Configuring name resolution"></a>11.5.2 Configuring name resolution</h2><blockquote><p>若查詢簡短名稱，系統會自動戴上 <code>/etc/resolv.conf</code> 中的 <code>domain</code> or <code>search</code> 的值再查詢</p></blockquote><p>使用 <code>getent</code> &amp; <code>host</code> 測試 DNS 設定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># getenv 主要以 IPv6 為主</span></span><br><span class="line">$ getent hosts tw.yahoo.com</span><br><span class="line">2406:2000:ec:601::1009 fd-fp3.wg1.b.yahoo.com tw.yahoo.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 沒有 IPv6 的設定，則回傳 IPv4</span></span><br><span class="line">$ getent hosts ptt.cc</span><br><span class="line">140.112.172.3   ptt.cc</span><br><span class="line">140.112.172.4   ptt.cc</span><br><span class="line">140.112.172.2   ptt.cc</span><br><span class="line">140.112.172.11  ptt.cc</span><br><span class="line">140.112.172.5   ptt.cc</span><br><span class="line">140.112.172.1   ptt.cc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 host 查詢 google</span></span><br><span class="line">$ host www.google.com</span><br><span class="line">www.google.com has address 210.242.127.104</span><br><span class="line">www.google.com has address 210.242.127.88</span><br><span class="line">........</span><br><span class="line">www.google.com has address 210.242.127.109</span><br><span class="line">www.google.com has IPv6 address 2404:6800:4008:c01::6a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 getent 查詢 google</span></span><br><span class="line">$ getent hosts www.google.com</span><br><span class="line">2404:6800:4008:c04::6a www.google.com</span><br></pre></td></tr></table></figure><p>另外，一般網路設定若使用 DHCP，會把原有的 DNS 設定覆蓋，若要避免此情況，可用 <code>sudo nmcli connection &quot;System eth0&quot; ipv4.ignore-auto-dns yes</code> 來避免這樣的狀況發生。</p><blockquote><p>也可以用 nslookup 來測試 DNS，但需要額外加裝 <code>bind-utils</code> 套件</p></blockquote>]]></content>
      
      <categories>
          
          <category> RHCE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH124 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[RHCE] RH124 Chapter 10 Analyzing and Storing Logs 學習筆記</title>
      <link href="/blog/2016/04/24/RHCE/RHCE7-RH124-LearningNotes-CH10_AnalyzingAndStoringLogs/"/>
      <url>/blog/2016/04/24/RHCE/RHCE7-RH124-LearningNotes-CH10_AnalyzingAndStoringLogs/</url>
      <content type="html"><![CDATA[<h1 id="10-1-System-Log-Architecture"><a href="#10-1-System-Log-Architecture" class="headerlink" title="10.1 System Log Architecture"></a>10.1 System Log Architecture</h1><h2 id="10-1-1-System-logging"><a href="#10-1-1-System-logging" class="headerlink" title="10.1.1 System logging"></a>10.1.1 System logging</h2><hr><p>RHEL 7 有兩支 daemon 管理 log：</p><ul><li>systemd-journald</li><li>rsyslog<ul><li>紀錄 message type(or facility) &amp; priority 在 <code>/var/log</code> 內</li><li>facility.severity (facility 很多種，severity 則是標準)</li></ul></li></ul><h3 id="systemd-journald"><a href="#systemd-journald" class="headerlink" title="systemd-journald"></a>systemd-journald</h3><p>systemd-journald daemon 蒐集以下的訊息:(並且會把資料寫進 structured database)</p><ul><li><p>kernel 相關的訊息</p></li><li><p>開機流程中早期的訊息</p></li><li><p>daemon 啟動時的標準輸出 &amp; 錯誤訊息</p></li><li><p>syslog (會被 forward 給 rsyslog 處理)</p></li></ul><h3 id="rsyslog"><a href="#rsyslog" class="headerlink" title="rsyslog"></a>rsyslog</h3><p>rsyslog 會把從 syslog 來的資料放到 <strong>/var/log</strong> 中，除了 <strong>/var/log/secure</strong>、<strong>/var/log/maillog</strong>、<strong>/var/log/cron</strong>、<strong>/var/log/boot.log</strong> 四類訊息，其他訊息都會放在 <strong>/var/log/messages</strong> 中</p><hr><h1 id="10-2-Reviewing-Syslog-Files"><a href="#10-2-Reviewing-Syslog-Files" class="headerlink" title="10.2 Reviewing Syslog Files"></a>10.2 Reviewing Syslog Files</h1><p>rsyslogd 使用 <code>facility</code>(type) &amp; <code>priority</code>(severity) 來決定如何處理 log message，透過設定檔 <code>/etc/rsyslog.config</code> &amp; <code>/etc/rsyslog.d/\*.conf</code> 定義處理方式</p><h2 id="10-2-2-Sample-rule-section-of-rsyslog-config"><a href="#10-2-2-Sample-rule-section-of-rsyslog-config" class="headerlink" title="10.2.2 Sample rule section of rsyslog.config"></a>10.2.2 Sample rule section of rsyslog.config</h2><p>左邊的部份指定哪些 facility.severity 要被記錄，右邊的部份則是指定 log message 要存到哪個檔案</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所有 severity INFO 以上的訊息都送往 /var/log/message</span></span><br><span class="line"><span class="comment"># 但 facility mail / authpriv / cron 除外</span></span><br><span class="line"><span class="comment"># boot log message 也會送</span></span><br><span class="line">*.info;mail.none;authpriv.none;cron.none    /var/<span class="built_in">log</span>/messages</span><br><span class="line"></span><br><span class="line"><span class="comment"># kernel facility 的 log message 會往 /dev/console 送</span></span><br><span class="line">kernel.*    /dev/console</span><br><span class="line"></span><br><span class="line"><span class="comment"># authpriv facility 相關的 log message 都會往 /var/log/secure 送</span></span><br><span class="line">authpriv.*  /var/<span class="built_in">log</span>/secure</span><br><span class="line"></span><br><span class="line"><span class="comment"># mail facility 的訊息會先存在於記憶體中，一段時間後詞才會存到檔案中</span></span><br><span class="line">mail.*      -/var/<span class="built_in">log</span>/maillog</span><br><span class="line"></span><br><span class="line"><span class="comment"># severity Emergency 的 log message 會送到目前所有登入使用者的 terminal 上</span></span><br><span class="line">*.emerg     :omusrmsg:*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 開機相關的訊息送往 /var/log/boot.log</span></span><br><span class="line">local7.*    /var/<span class="built_in">log</span>/boot.log</span><br></pre></td></tr></table></figure><p>設定完成後，可透過 <code>logger -p [facility].[severity] &quot;log message&quot;</code> 來測試，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ logger -p local7.emerg <span class="string">"boot emergency log message test"</span></span><br></pre></td></tr></table></figure><blockquote><p>可安裝 <strong><font color="red">rsyslog-doc</font></strong> 套件取得 rsyslogd 相關的 man page，很有幫助</p></blockquote><h3 id="10-2-3-Log-file-rotation"><a href="#10-2-3-Log-file-rotation" class="headerlink" title="10.2.3 Log file rotation"></a>10.2.3 Log file rotation</h3><p>透過 <code>/etc/logrotate.conf</code> 進行設定的修改</p><p><code>/etc/cron.daily</code> 目錄中有一支 logrotate 的 shell script 作為每天執行的工作</p><h3 id="10-2-6-Send-a-syslog-message-with-logger"><a href="#10-2-6-Send-a-syslog-message-with-logger" class="headerlink" title="10.2.6 Send a syslog message with logger"></a>10.2.6 Send a syslog message with logger</h3><p>若是有修改過 rsyslog 的設定後，可用 <code>logger</code> 程式手動發送 log 進行驗證，是否 log 有正確的被記錄：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[student@server0 ~]$ sudo tail -3 /var/<span class="built_in">log</span>/boot.log</span><br><span class="line">[  OK  ] Started GNOME Display Manager.</span><br><span class="line">[  OK  ] Started LSB: Start the ipr dump daemon.</span><br><span class="line">[  OK  ] Started Dynamic System Tuning Daemon.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手動產生一個 local7.notice 的 log message</span></span><br><span class="line">[student@server0 ~]$ logger -p local7.notice <span class="string">"Log entry created on server0"</span></span><br><span class="line"></span><br><span class="line">[student@server0 ~]$ tail -3 /var/<span class="built_in">log</span>/boot.log</span><br><span class="line">[  OK  ] Started LSB: Start the ipr dump daemon.</span><br><span class="line">[  OK  ] Started Dynamic System Tuning Daemon.</span><br><span class="line">Apr 23 23:26:04 server0 student: Log entry created on server0</span><br></pre></td></tr></table></figure><hr><h1 id="10-3-Reviewing-systemd-Journal-Entries"><a href="#10-3-Reviewing-systemd-Journal-Entries" class="headerlink" title="10.3 Reviewing systemd Journal Entries"></a>10.3 Reviewing systemd Journal Entries</h1><p>特點：</p><ul><li><p>存放在 <code>/run/log</code> 目錄中 (表示重開機之後就會消失)</p></li><li><p>最多使用系統 10% 的空間，超過的話，舊的 journal 就會被砍掉</p></li><li><p>使用 <code>journalctl</code> 命令來查詢 (<font color="red"><strong>只有 root 可用</strong></font>)</p></li><li><p>severity <code>notice</code> or <code>warning</code> 會以粗體顯示，<code>error</code> 以上會以紅色表示</p></li></ul><h2 id="10-3-1-Finding-events-with-journalctl"><a href="#10-3-1-Finding-events-with-journalctl" class="headerlink" title="10.3.1 Finding events with journalctl"></a>10.3.1 Finding events with journalctl</h2><p><strong><font color="red">journalctl</font></strong> 的使用方式：</p><ul><li><p><code>sudo journalctl</code>：顯示所有的 system journal</p></li><li><p><code>sudo journalctl -n 5</code>：使用 <code>-n</code> 參數，顯示最新五筆的 system journal</p></li><li><p><code>sudo journalctl -p err</code>：使用 <code>-p</code> 參數，指定要顯示 priority 為 error 的 system journal</p></li><li><p><code>sudo journalctl -f</code>：類似 <code>tail -f</code>，但持續顯示最新十筆</p></li><li><p><code>sudo journalctl --since today</code>：顯示今天發生的 system journal</p></li><li><p><code>sudo journalctl --since &#39;2016-04-24 00:00:00&#39; --until &#39;2016-04-24 01:00:00&#39;</code>：顯示特定時段內的 system journal</p></li><li><p><code>sudo journalctl --since=&quot;$(date -d &quot;-30 minutes&quot; +%F&#39; &#39;%H:%M:%S)&quot;</code>：尋找 30 分鐘前的 system journal</p></li><li><p><code>sudo journalctl -o verbose</code>：顯示完整 system journal 訊息</p></li><li><p><code>sudo journalctl _PID=1</code>：顯示 pid=1 的 system journal</p></li><li><p><code>sudo journalctl -b</code>：顯示上一次開機到目前所存在的 system journal</p></li></ul><hr><h1 id="10-4-Preserving-the-systemd-Journal"><a href="#10-4-Preserving-the-systemd-Journal" class="headerlink" title="10.4 Preserving the systemd Journal"></a>10.4 Preserving the systemd Journal</h1><p>保留 systemd journal 的方式：</p><ol><li><code>/var/log/journal</code> 目錄存在</li><li>目錄的 owner 必須為 <code>root</code>，owner_group 必須為 <code>systemd-journal</code>，並設定權限為 <code>2755</code></li></ol><hr><h1 id="10-5-Maintain-Accurate-Time"><a href="#10-5-Maintain-Accurate-Time" class="headerlink" title="10.5 Maintain Accurate Time"></a>10.5 Maintain Accurate Time</h1><h2 id="10-5-1-Set-local-clocks-and-time-zone"><a href="#10-5-1-Set-local-clocks-and-time-zone" class="headerlink" title="10.5.1 Set local clocks and time zone"></a>10.5.1 Set local clocks and time zone</h2><ul><li><p><code>timedatectl</code>：顯示目前時區設定</p></li><li><p><code>timedatectl list-timezones</code>：顯示所有時區</p></li><li><p><code>timedatectl set-timezone Asia/Taipei</code>：更改時區</p></li><li><p><code>sudo timedatectl set-ntp true</code>：設定自動 NTP 教時</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 看目前機器上的時間</span></span><br><span class="line">$ timedatectl</span><br><span class="line">      Local time: Thu 2016-01-21 06:35:27 UTC</span><br><span class="line">  Universal time: Thu 2016-01-21 06:35:27 UTC</span><br><span class="line">        RTC time: Thu 2016-01-21 06:35:26</span><br><span class="line">       Time zone: UTC (UTC, +0000)</span><br><span class="line">     NTP enabled: n/a</span><br><span class="line">NTP synchronized: no</span><br><span class="line"> RTC <span class="keyword">in</span> <span class="built_in">local</span> TZ: yes</span><br><span class="line">      DST active: n/a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定時區</span></span><br><span class="line">$ sudo timedatectl <span class="built_in">set</span>-timezone Asis/Taipei</span><br><span class="line"></span><br><span class="line"><span class="comment"># 啟用 NTP 校時</span></span><br><span class="line">$ sudo timedatectl <span class="built_in">set</span>-ntp <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過互動的方式選擇時區(Time Zone)</span></span><br><span class="line">$ tzselect</span><br></pre></td></tr></table></figure><h2 id="10-5-2-Configuring-and-monitoring-chronyd"><a href="#10-5-2-Configuring-and-monitoring-chronyd" class="headerlink" title="10.5.2 Configuring and monitoring chronyd"></a>10.5.2 Configuring and monitoring chronyd</h2><p>這個是用在沒有網路環境時，會由一台主要的 NTP server 去取得正確的資料，其他主機再透過 chronyd.service 進行時間同步。</p><p>加上 <code>iburst</code> 選項會讓網路校時更快，且更正確</p><p><code>sudo hwclock -w</code>：強制將時間資訊寫入硬體</p><h2 id="補充：設定-NTP-校時的完整步驟-很重要"><a href="#補充：設定-NTP-校時的完整步驟-很重要" class="headerlink" title="補充：設定 NTP 校時的完整步驟 (很重要)"></a>補充：設定 NTP 校時的完整步驟 (<strong>很重要</strong>)</h2><ul><li>NTP server：<code>classroom.example.com</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ sudo timedatectl <span class="built_in">set</span>-ntp <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"server classroom.example.com iburst"</span> | sudo tee --append /etc/chrony.conf</span><br><span class="line">$ sudo systemctl restart chronyd.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 驗證設定結果</span></span><br><span class="line">$ chronyc sources -v</span><br><span class="line">210 Number of sources = 1</span><br><span class="line"></span><br><span class="line">  .-- Source mode  <span class="string">'^'</span> = server, <span class="string">'='</span> = peer, <span class="string">'#'</span> = <span class="built_in">local</span> clock.</span><br><span class="line"> / .- Source state <span class="string">'*'</span> = current synced, <span class="string">'+'</span> = combined , <span class="string">'-'</span> = not combined,</span><br><span class="line">| /   <span class="string">'?'</span> = unreachable, <span class="string">'x'</span> = time may be <span class="keyword">in</span> error, <span class="string">'~'</span> = time too variable.</span><br><span class="line">||                                                 .- xxxx [ yyyy ] +/- zzzz</span><br><span class="line">||                                                /   xxxx = adjusted offset,</span><br><span class="line">||         Log2(Polling interval) -.             |    yyyy = measured offset,</span><br><span class="line">||                                  \            |    zzzz = estimated error.</span><br><span class="line">||                                   |           |                         </span><br><span class="line">MS Name/IP address         Stratum Poll Reach LastRx Last sample</span><br><span class="line">===============================================================================</span><br><span class="line">^* classroom.example.com         8   6    17    18  +2830us[+3050us] +/- 3509us</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RHCE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH124 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[RHCE] RH124 Chapter 9 Controlling and Securing OpenSSH Service 學習筆記</title>
      <link href="/blog/2016/04/19/RHCE/RHCE7-RH124-LearningNotes-CH09_ConfiguringAndSecuringOpenSSHService/"/>
      <url>/blog/2016/04/19/RHCE/RHCE7-RH124-LearningNotes-CH09_ConfiguringAndSecuringOpenSSHService/</url>
      <content type="html"><![CDATA[<h1 id="9-1-Accessing-the-Remote-Command-Line-with-SSH"><a href="#9-1-Accessing-the-Remote-Command-Line-with-SSH" class="headerlink" title="9.1 Accessing the Remote Command Line with SSH"></a>9.1 Accessing the Remote Command Line with SSH</h1><h2 id="9-1-1-SSH-Host-Keys"><a href="#9-1-1-SSH-Host-Keys" class="headerlink" title="9.1.1 SSH Host Keys"></a>9.1.1 SSH Host Keys</h2><p>server 會將 public key copy 送到 client 端，有兩個功能：</p><ol><li>用來加密 ssh connection 用</li><li>用來驗證 server</li></ol><ul><li><p>server public key 會存在於 client 端的 <code>~/.ssh/known_hosts</code> 檔案中</p></li><li><p>server 端會把 key pair 儲存在 <code>/etc/ssh/ssh_host_key*</code> 目錄下</p></li><li><p>當 client 透過 ssh 連到 server 時，會把 server 的 public 儲存在 <strong><font color="red">~/.ssh/known_hosts</font></strong> 內，且每次連線都會檢查，若發現內容不會就會警告且中斷連線!</p></li></ul><hr><h1 id="9-2-Conguring-SSH-Key-based-Authentication"><a href="#9-2-Conguring-SSH-Key-based-Authentication" class="headerlink" title="9.2 Conguring SSH Key-based Authentication"></a>9.2 Conguring SSH Key-based Authentication</h1><p><code>ssh-copy-id</code>：上傳 <font color="red"><strong>~/.ssh/id_rsa.pub</strong></font> 到 remote server 的 <font color="red"><strong>~user/.ssh/authorized_keys</strong></font> 檔案中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 將指定的 public key 加入到 remote server 的 student 帳號下</span></span><br><span class="line">[student@server0 ~]$ ssh-copy-id -i ~/.ssh/id_rsa.pub student@172.25.0.10</span><br><span class="line"><span class="comment"># 將指定的 public key 加入到 remote server 的 root 帳號下</span></span><br><span class="line">[student@server0 ~]$ ssh-copy-id -i ~/.ssh/id_rsa.pub root@172.25.0.10</span><br></pre></td></tr></table></figure><blockquote><p>若沒有使用 <code>-i</code> 指定 public key 位置，則就預設為 <code>~/.ssh/id_rsa.pub</code></p></blockquote><p>若要使用 key-based 認證但又希望在 private key 上加密碼，並達成 password-less 的效果時：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 產生一個新的 ssh agent 並將 private key 驗證加入</span></span><br><span class="line">$ ssh-agent bash</span><br><span class="line">$ ssh-add</span><br></pre></td></tr></table></figure><hr><h1 id="9-3-Customize-SSH-Service-Configuration"><a href="#9-3-Customize-SSH-Service-Configuration" class="headerlink" title="9.3 Customize SSH Service Configuration"></a>9.3 Customize SSH Service Configuration</h1><p>修改 <code>/etc/ssh/sshd_config</code> 中，調整使用者登入方式：</p><ol><li><p><code>PermitRootLogin no</code>：禁止 root 使用 ssh 登入</p></li><li><p><code>PermitRootLogin without-password</code>：root 只能透過 key-based 的方式登入</p></li><li><p><code>PasswordAuthentication no</code>：關閉密碼登入功能(只能透過 key-based 的方式登入)</p></li></ol><blockquote><p>要重新 reload sshd.service 讓設定變更生效 (<code>sudo systemctl restart sshd.service</code>)</p></blockquote>]]></content>
      
      <categories>
          
          <category> RHCE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH124 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[RHCE] RH124 Chapter 8 Controlling Services and Daemons 學習筆記</title>
      <link href="/blog/2016/04/18/RHCE/RHCE7-RH124-LearningNotes-CH08_ControllingServicesAndDaemons/"/>
      <url>/blog/2016/04/18/RHCE/RHCE7-RH124-LearningNotes-CH08_ControllingServicesAndDaemons/</url>
      <content type="html"><![CDATA[<h1 id="8-1-Identifying-Automatically-Started-System-Processes"><a href="#8-1-Identifying-Automatically-Started-System-Processes" class="headerlink" title="8.1 Identifying Automatically Started System Processes"></a>8.1 Identifying Automatically Started System Processes</h1><h2 id="8-1-1-Introduction-to-systemd"><a href="#8-1-1-Introduction-to-systemd" class="headerlink" title="8.1.1 Introduction to systemd"></a>8.1.1 Introduction to systemd</h2><p>systemd(是一個小型的 kernel) 跟開機流程很有關係</p><p>通常一個 service 是由一個或多個 daemon 提供。</p><p>多年前，Linux &amp; UNIX 系統中 PID=1 是屬於一支稱為 <code>init</code>(載入 kernel 之後執行) 的 process；當 kernel 載入後執行。</p><p>在 RHEL 7 中，PID=1 的 process 已經變成 systemd：</p><ul><li>有平行處理的能力，可提升系統開機的速度</li><li>有些先前需要的 daemon 會自動啟動</li><li>自動管理 service 相依性</li><li>LCG (Linux control group)</li></ul><blockquote><p>現在的 <code>/usr/sbin/init</code> 已經改由 symbolic link 指到 systemd</p></blockquote><p>systemd 用來管理各式各樣不同的型態的 object，稱為 <strong>systemd unit</strong>，可以用 <code>systemctl -t help</code> 查詢目前 systemd 可管理的 unit 有那些：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[student@server0 ~]$ systemctl -t <span class="built_in">help</span></span><br><span class="line">Available unit types:</span><br><span class="line">service</span><br><span class="line">socket</span><br><span class="line">target  <span class="comment"># 取代原先 Run Level 的概念</span></span><br><span class="line">device</span><br><span class="line">mount</span><br><span class="line">automount</span><br><span class="line">snapshot</span><br><span class="line">timer   <span class="comment"># 自動排程的功能</span></span><br><span class="line">.....</span><br></pre></td></tr></table></figure><ul><li><code>service</code>：用來表示系統服務</li><li><code>socket</code>：表示 IPC(inter-process communication) socket</li><li><code>timer</code>：自動排程工作是由 timer unit 來處理</li><li><code>target</code>：取代原先 Run Level 的概念</li><li><code>path</code>：通常用來以特定檔案有無變化為前提下，延遲服務發生，例如：列印服務(print pool 的概念)</li></ul><h3 id="Service-status"><a href="#Service-status" class="headerlink" title="Service status"></a>Service status</h3><p>systemd service unit 有以下幾種狀態：</p><ul><li><strong>loaded</strong>：unit 設定被處理後(套件剛裝好時，會處於此狀態)</li><li><strong>active</strong>：啟用狀態</li><li><strong>inactive</strong>：非啟用狀態</li><li><strong>enabled</strong>：開機時會自動啟動</li><li><strong>disabled</strong>：開機時不會自動啟動</li><li><strong>static</strong>：無法控管的狀態，必須由其他 unit 來自動的 enable</li></ul><h2 id="8-1-2-systemctl-使用方式"><a href="#8-1-2-systemctl-使用方式" class="headerlink" title="8.1.2 systemctl 使用方式"></a>8.1.2 systemctl 使用方式</h2><p><code>systemctl</code> 是用來管理不同 systemd unit 的指令，使用方式大概如下：</p><p>列表相關的指令：</p><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>sudo systemctl -l</code></td><td>檢視所有的 systemd unit 的狀態，但不包含狀態為 inactive 的(加上 <code>--all</code> or <code>-a</code> 可看到全部)</td></tr><tr><td><code>sudo systemctl status sshd.service</code></td><td>檢查 ssh service unit 的狀態<p>(透過 <code>systemctl status name.type</code> 可以檢視 unit 狀態，<code>type</code> 可以不輸入，則預設為 <strong>service</strong>)</p></td></tr><tr><td><code>sudo systemctl --type=service</code></td><td>檢視 type 屬於 service 的 systemd unit</td></tr><tr><td><code>sudo systemctl is-active sshd.service</code></td><td>檢視 sshd service 是否為 active 狀態</td></tr><tr><td><code>sudo systemctl is-enabled sshd.service</code></td><td>檢視 sshd service 是否為 enabled 狀態</td></tr><tr><td><code>sudo systemctl list-unit-files --type=service</code></td><td>檢視 service type 所有的 unit 設定</td></tr></tbody></table><hr><h1 id="8-2-Controlling-System-Services"><a href="#8-2-Controlling-System-Services" class="headerlink" title="8.2 Controlling System Services"></a>8.2 Controlling System Services</h1><h2 id="8-2-1-Starting-and-stopping-daemons-on-a-running-system"><a href="#8-2-1-Starting-and-stopping-daemons-on-a-running-system" class="headerlink" title="8.2.1 Starting and stopping daemons on a running system"></a>8.2.1 Starting and stopping daemons on a running system</h2><p>安裝 apache2，檢視狀態，並啟動服務：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum -y install httpd</span><br><span class="line"></span><br><span class="line"><span class="comment"># inactive + disabled</span></span><br><span class="line">$ sudo systemctl status httpd.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># active(running) + disabled</span></span><br><span class="line">$ sudo systemctl start httpd.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># active(running) + enabled</span></span><br><span class="line">$ sudo systemctl <span class="built_in">enable</span> httpd.service</span><br></pre></td></tr></table></figure><p>系統中有 exited &amp; waiting 狀態的 system unit：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 觀察 active(exited) 狀態</span></span><br><span class="line">$ sudo systemctl status network.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 觀察 active(waiting) 狀態</span></span><br><span class="line">$ sudo systemctl status cups.path</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下兩行指令相同</span></span><br><span class="line">$ sudo service sshd restart</span><br><span class="line">$ sudo /bin/systemctl restart sshd.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下兩行指令相同</span></span><br><span class="line">$ sudo systemctl --<span class="built_in">type</span>=service</span><br><span class="line">$ sudo systemctl list-unit --<span class="built_in">type</span>=service</span><br></pre></td></tr></table></figure><blockquote><p>service reload 時，PID 不會換</p></blockquote><h3 id="Unit-dependencies"><a href="#Unit-dependencies" class="headerlink" title="Unit dependencies"></a>Unit dependencies</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 檢視該 system unit 被那些 systen unit 所依賴</span></span><br><span class="line">$ sudo systemctl list-dependencies graphical.target | grep target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢視指定的 system unit 依賴那些其他的 system unit</span></span><br><span class="line">$ sudo systemctl list-dependencies multi-user.target --reverse</span><br></pre></td></tr></table></figure><h3 id="Masking-services"><a href="#Masking-services" class="headerlink" title="Masking services"></a>Masking services</h3><ul><li><p><code>disabled</code> 的 service 開機時不會自動啟動，但可以手動啟動</p></li><li><p><code>mask</code> 的 service 無法透過手動或自動的方式啟動(會在 <code>/etc/systemd/system</code> 目錄中產生指定 system unit 的 symbolic link 並指向 /dev/null)</p></li></ul>]]></content>
      
      <categories>
          
          <category> RHCE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH124 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[RHCE] RH124 Chapter 7 Monitoring and Managing Linux Processes 學習筆記</title>
      <link href="/blog/2016/04/13/RHCE/RHCE7-RH124-LearningNotes-CH07_MonitoringAndManagingLinuxProcesses/"/>
      <url>/blog/2016/04/13/RHCE/RHCE7-RH124-LearningNotes-CH07_MonitoringAndManagingLinuxProcesses/</url>
      <content type="html"><![CDATA[<h1 id="7-1-Process"><a href="#7-1-Process" class="headerlink" title="7.1 Process"></a>7.1 Process</h1><h2 id="7-1-1-What-is-a-process"><a href="#7-1-1-What-is-a-process" class="headerlink" title="7.1.1 What is a process?"></a>7.1.1 What is a process?</h2><p>每個 process 都會有個獨一無二的 PID，而 parent process ID(PPID) 則為 PID 的父程序所擁有的 ID；process 可透過 <code>fork</code> 的方式產生 child process，而這些 child process 則會繼承 parent process 的 security identifiers, file descriptors, port, resource privileges, 環境變數….等等，整個 process lifeycle 可以參考下圖：</p><p><img src="https://www.freebsd.org/doc/en_US.ISO8859-1/books/design-44bsd/fig1.png" alt="Process Lifecycle"></p><p>在 RHEL7 中，所有的 process 都是 <strong><font color="red">systemd(1)</font></strong> 的 child process。</p><h2 id="7-1-2-Process-States"><a href="#7-1-2-Process-States" class="headerlink" title="7.1.2 Process States"></a>7.1.2 Process States</h2><p><img src="http://4.bp.blogspot.com/-5jYQDgc6Z4M/UyV1ni478uI/AAAAAAAADZw/rpBf813wpbg/s1600/ProcessStates.JPG" alt="Linux Process States"></p><table><thead><tr><th>狀態</th><th>Flag</th><th>kernel-defined state and description</th></tr></thead><tbody><tr><td>Running</td><td>R</td><td><strong><font color="red">TASK_RUNNING</font></strong>：正在等待執行 or 正在執行的 process，正在執行的又包含執行 user routine &amp; kernel routine(system calls)。例如：Data -&gt; Memory</td></tr><tr><td>Sleeping</td><td>S</td><td><strong><font color="red">TASK_INTERRUPTIBLE</font></strong>：等待特定的情況(硬體要求、系統資源存取、信號….等)發生，當條件滿足時就會回到 Running 的狀態</td></tr><tr><td>Sleeping</td><td>D</td><td><strong><font color="red">TASK_UNINTERRUPTIBLE</font></strong>：與 <strong><font color="red">S</font></strong> 類似，但不會回應從其他地方送來的信號。例如：寫資料到外接儲存裝置時(Memory -&gt; USB)</td></tr><tr><td>Sleeping</td><td>K</td><td><strong><font color="red">TASK_KILLABLE</font></strong>：與 <strong><font color="red">D</font></strong> 相反，可以接收來自其他地方的信號，例如：掛載網路磁碟機</td></tr><tr><td>Stopped</td><td>T</td><td><strong><font color="red">TASK_STOPPED</font></strong>：可能因為 user 或是其他 process 送來訊號而進入 Stopped 狀態，也可能因為特定訊號而返回 Running 狀態</td></tr><tr><td>Stopped</td><td>T</td><td><strong><font color="red">TASK_TRACED</font></strong>：同上，但可 debug</td></tr><tr><td>Zombie</td><td>Z</td><td><strong><font color="red">EXIT_ZOMBIE</font></strong>：已通知 parent process 準備離開後的狀態，除了 process identity 之外的資源都會被釋放</td></tr><tr><td>Zombie</td><td>X</td><td><strong><font color="red">EXIT_DEAD</font></strong>：所有資源都被釋放，ps 也看不見了</td></tr></tbody></table><h2 id="7-1-2-Listing-processes"><a href="#7-1-2-Listing-processes" class="headerlink" title="7.1.2 Listing processes"></a>7.1.2 Listing processes</h2><p>ps 指定常用的參數：</p><ul><li><code>aux</code></li><li><code>las</code></li><li><code>afx</code> (含階層)</li><li><code>-O</code> (指定要顯示的欄位)</li><li><code>--sort</code>：排序</li></ul><p><code>ps</code> 可用來觀察目前 process 的狀態，有以下幾種格式</p><ul><li><p>UNIX(POSIX)：參數加上一個 <code>-</code></p></li><li><p>BSD：參數不加上 <code>-</code></p></li><li><p>GNU long：參數加上兩個 <code>-</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># BSD</span></span><br><span class="line">[student@server0 ~]$ ps f</span><br><span class="line">  PID TTY      STAT   TIME COMMAND</span><br><span class="line"> 1986 pts/0    Ss     0:00 -bash</span><br><span class="line"> 2072 pts/0    R+     0:00  \_ ps f</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 以階層顯示(顯示往上五階)</span></span><br><span class="line">[student@server0 ~]$ ps afx | grep -B5 ssh-agent</span><br><span class="line">  1130 ?        Ss     0:00 /usr/sbin/sshd -D</span><br><span class="line">  2823 ?        Ss     0:00  \_ sshd: student [priv]</span><br><span class="line">  2827 ?        S      0:00      \_ sshd: student@pts/0</span><br><span class="line">  2829 pts/0    Ss     0:00          \_ -bash</span><br><span class="line">  3110 pts/0    R+     0:00              \_ ps afx</span><br><span class="line">  3111 pts/0    S+     0:00              \_ grep --color=auto -B5 ssh-agent</span><br><span class="line"></span><br><span class="line"> <span class="comment"># UNIX(POSIX)</span></span><br><span class="line">[student@server0 ~]$ ps -f</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">student   1986  1983  0 05:28 pts/0    00:00:00 -bash</span><br><span class="line">student   2073  1986  0 05:30 pts/0    00:00:00 ps -f</span><br><span class="line">[student@server0 ~]$ ps --f</span><br></pre></td></tr></table></figure><p>檢視全部的 process 常用 <code>aux</code> 選項 or <code>alx</code>(較為詳細)，若想要檢視 process 之間的父子關係可使用 <code>afx</code>(關鍵是 <code>f</code> 參數)</p><p>關於 ps 還有幾個重點：</p><ul><li>若 ps 不加上任何參數，就僅會顯示與目前這個 user terminal 有關係的 process：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[student@server0 ~]$ ps</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line"> 1986 pts/0    00:00:00 bash</span><br><span class="line"> 2326 pts/0    00:00:00 ps</span><br></pre></td></tr></table></figure><ul><li>顯示結果中，若是以 <strong><font color="red">[ ]</font></strong> 包覆的，表示為 kernel thread</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[student@server0 ~]$ ps aux</span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         1  0.2  0.3  52328  6484 ?        Ss   04:55   0:06 /usr/lib/systemd/systemd --switched-root --system --deserialize 21</span><br><span class="line">root         2  0.0  0.0      0     0 ?        S    04:55   0:00 [kthreadd]</span><br><span class="line">root         3  0.0  0.0      0     0 ?        S    04:55   0:00 [ksoftirqd/0]</span><br><span class="line">root         5  0.0  0.0      0     0 ?        S&lt;   04:55   0:00 [kworker/0:0H]</span><br><span class="line">root         6  0.0  0.0      0     0 ?        S    04:55   0:00 [kworker/u2:0]</span><br></pre></td></tr></table></figure><ul><li><p>透過 <code>ps afx</code> or <code>pstree</code> 可看到 process 之間的 parent/child 關係</p></li><li><p>若要排序 ps 出來的結果，可透過 <code>--sort</code> 選項 (<a href="http://alvinalexander.com/linux/unix-linux-process-memory-sort-ps-command-cpu" target="_blank" rel="noopener">參考網址(Linux process memory usage - how to sort the ps command)</a>)</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根據 CPU 遞增排序</span></span><br><span class="line">$ ps au --sort=%cpu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根據 CPU 遞減排序</span></span><br><span class="line">$ ps au --sort=-%cpu</span><br><span class="line"></span><br><span class="line"><span class="comment"># PID 從小到大排序</span></span><br><span class="line">[student@server0 ~]$ ps aux --sort pid</span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         1  0.5  0.3  52328  6472 ?        Ss   19:53   0:09 /usr/lib/systemd/systemd --switched-root --system --deserialize 21</span><br><span class="line">root         2  0.0  0.0      0     0 ?        S    19:53   0:00 [kthreadd]</span><br><span class="line">root         3  0.0  0.0      0     0 ?        S    19:53   0:00 [ksoftirqd/0]</span><br><span class="line"></span><br><span class="line"><span class="comment"># PID 從大到小排序</span></span><br><span class="line">[student@server0 ~]$ ps aux --sort -pid</span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">student   2065  0.0  0.0 123516  1448 pts/0    R+   20:24   0:00 ps aux --sort -pid</span><br><span class="line">root      2064  0.0  0.0 107892   364 ?        S    20:24   0:00 sleep 60</span><br><span class="line">root      2001  0.0  0.0      0     0 ?        S    20:19   0:00 [kworker/0:0]</span><br></pre></td></tr></table></figure><hr><h1 id="7-2-Controlling-Jobs"><a href="#7-2-Controlling-Jobs" class="headerlink" title="7.2 Controlling Jobs"></a>7.2 Controlling Jobs</h1><p><code>jobs</code> 指令只會顯示目前 session 中的 job</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ gedit &amp;</span><br><span class="line">$ <span class="built_in">jobs</span></span><br><span class="line">$ nautilus &amp;</span><br><span class="line">$ <span class="built_in">jobs</span></span><br><span class="line">$ sleep 1000 &amp;</span><br><span class="line">$ <span class="built_in">jobs</span></span><br><span class="line">$ <span class="built_in">fg</span></span><br><span class="line">CTRL + C (終止目前前景執行的程式)</span><br><span class="line">$ <span class="built_in">jobs</span></span><br><span class="line">$ <span class="built_in">fg</span> %1</span><br><span class="line">CTRL + C (終止目前前景執行的程式)</span><br></pre></td></tr></table></figure><h2 id="7-2-1-Jobs-and-sessions"><a href="#7-2-1-Jobs-and-sessions" class="headerlink" title="7.2.1 Jobs and sessions"></a>7.2.1 Jobs and sessions</h2><p>當 terminal or console 被開啟時，會產生一個 process session，所以透過同一個 terminal or console 產生出來的 process，都會使用相同的 session ID，而每個 session 中，一次只能有一個 process 在前景執行。</p><p>service daemon 或是 kernel process thread 在 <code>ps</code> 出來的結果中，<code>TTY</code> 欄位會以 <code>?</code> 來呈現，因為此類的 background process 並沒有 controlling terminal。</p><h2 id="7-2-2-Running-jobs-in-the-background"><a href="#7-2-2-Running-jobs-in-the-background" class="headerlink" title="7.2.2 Running jobs in the background"></a>7.2.2 Running jobs in the background</h2><p><code>Ctrl + z</code>：可送出 suspend 要求，用來讓 process 進入 Stopped 狀態(T)</p><p><code>Ctrl + c</code>：中斷 process 執行</p><p><code>bg %JOB_ID</code>：可讓 process 恢復執行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一個執行中的範例</span></span><br><span class="line">$ dd &lt; /dev/zero &gt; /dev/null</span><br><span class="line"></span><br><span class="line"><span class="comment"># R(Running) 狀態</span></span><br><span class="line">$ ps au | grep dd</span><br><span class="line"></span><br><span class="line">Ctrl + Z</span><br><span class="line"></span><br><span class="line"><span class="comment"># 變成 S(Sleeping, TASK_INTERRUPTIBLE) 狀態</span></span><br><span class="line">$ ps au | grep dd</span><br><span class="line"></span><br><span class="line">$ sleep 1000</span><br><span class="line"></span><br><span class="line"><span class="comment"># S(Sleep) 狀態</span></span><br><span class="line">$ ps au | grep sleep</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用來驗證 D(Sleeping, TASK_UNINTERRUPTIBLE) 狀態</span></span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/zero bs=1M count=50 of=/run/media/...../test.txt</span><br></pre></td></tr></table></figure><hr><h1 id="7-3-Killing-Processes"><a href="#7-3-Killing-Processes" class="headerlink" title="7.3 Killing Processes"></a>7.3 Killing Processes</h1><h2 id="7-3-1-Process-control-using-signals"><a href="#7-3-1-Process-control-using-signals" class="headerlink" title="7.3.1 Process control using signals"></a>7.3.1 Process control using signals</h2><p>signal 是送到 process 的一種軟體型式的中斷，有以下幾種：</p><table><thead><tr><th>Signal number</th><th>Short name</th><th>Definition</th><th>Purpose</th></tr></thead><tbody><tr><td><code>1</code></td><td><code>HUP</code></td><td>Hangup</td><td></td></tr><tr><td><code>2</code></td><td><code>INT</code></td><td>Keyboard interrupt</td><td>讓程式中止，等同按下 <code>Ctrl + c</code></td></tr><tr><td><code>3</code></td><td><code>QUIT</code></td><td>Keyboard quit</td><td>讓 process 中止，但會執行 core dump 的動作，等同按下 <code>Ctrl + \</code></td></tr><tr><td><code>9</code></td><td><code>KILL</code></td><td>Kill, unblockable</td><td>強行中止</td></tr><tr><td><code>15</code>(default)</td><td><code>TERM</code></td><td>Terminate</td><td>通知程式中止，允許 process 完成 self-cleanup 後才中止</td></tr><tr><td><code>20</code></td><td><code>TSTP</code></td><td>Keyboard stop</td><td>讓 process 中斷執行(但可恢復)，效果等同按下 <code>Ctrl + z</code></td></tr></tbody></table><blockquote><p>詳細的 signal 列表可使用 <code>kill -l</code> 查詢</p></blockquote><blockquote><p>基本上砍掉 process 時先嘗試用 <code>SIGTERM</code>，不行的話才改用 <code>SIGKILL</code>，會是比較穩妥的作法‧</p></blockquote><blockquote><p>沒指定 SIG 則預設給 <font color="red"><strong>SIGTERM(15)</strong></font></p></blockquote><h3 id="Logging-users-out-administratively"><a href="#Logging-users-out-administratively" class="headerlink" title="Logging users out administratively"></a>Logging users out administratively</h3><p><code>w</code> 指令是用來檢視目前登入到系統的使用者以及累積到現在的資源使用狀況：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[kiosk@foundation0 ~]$ w -f</span><br><span class="line"> 06:19:29 up  1:27,  3 users,  load average: 0.04, 0.07, 0.06</span><br><span class="line">USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">kiosk    :0       :0               04:52   ?xdm?  11:36   0.20s gdm-session-worker [pam/gdm-autologin]</span><br><span class="line">kiosk    pts/3    :0               05:27   52:14   0.03s  0.03s bash</span><br><span class="line">kiosk    pts/4    192.168.1.190    06:11    1.00s  0.03s  0.01s w -f</span><br></pre></td></tr></table></figure><p><code>pkill</code> 是個強大的關閉 process 的指令，可透過以下方式過濾：</p><ul><li>command</li><li>UID</li><li>GID</li><li>parent</li><li>terminal</li></ul><p><code>pgrep</code> 指定 user 作 grep</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 刪除使用者 bboop 相關的 process</span></span><br><span class="line">$ pkill -u bboop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刪除使用者 bboop 相關的 process 並強制登出</span></span><br><span class="line">$ pkill -SIGKILL -u bboop</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[student@server0 ~]$ sleep 1000 &amp;</span><br><span class="line">[1] 2893</span><br><span class="line">[student@server0 ~]$ sleep 1000 &amp;</span><br><span class="line">[2] 2894</span><br><span class="line">[student@server0 ~]$ sleep 1000 &amp;</span><br><span class="line">[3] 2895</span><br><span class="line"><span class="comment"># pgrep 視特定使用者</span></span><br><span class="line">[student@server0 ~]$ pgrep -l -u student</span><br><span class="line">2827 sshd</span><br><span class="line">2829 bash</span><br><span class="line">2893 sleep</span><br><span class="line">2894 sleep</span><br><span class="line">2895 sleep</span><br><span class="line"><span class="comment"># pstree 檢視特定使用者，使用 PID</span></span><br><span class="line">[student@server0 ~]$ pstree -p student</span><br><span class="line">sshd(2827)───bash(2829)─┬─pstree(2896)</span><br><span class="line">                        ├─sleep(2893)</span><br><span class="line">                        ├─sleep(2894)</span><br><span class="line">                        └─sleep(2895)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定 PPID(parent ID) 刪除 process</span></span><br><span class="line">[student@server0 ~]$ pkill -SIGKILL -P 2829</span><br><span class="line">[1]   Killed                  sleep 1000</span><br><span class="line">[2]-  Killed                  sleep 1000</span><br><span class="line">[3]+  Killed                  sleep 1000</span><br><span class="line">[student@server0 ~]$ pstree -p student</span><br><span class="line">sshd(2827)───bash(2829)───pstree(2945)</span><br></pre></td></tr></table></figure><hr><h1 id="7-4-Monitoring-Process-Activity"><a href="#7-4-Monitoring-Process-Activity" class="headerlink" title="7.4 Monitoring Process Activity"></a>7.4 Monitoring Process Activity</h1><h2 id="7-4-1-Load-average"><a href="#7-4-1-Load-average" class="headerlink" title="7.4.1 Load average"></a>7.4.1 Load average</h2><p>靜態呈現，使用 <code>w -f</code> or <code>uptime</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查詢目前系統的 load average</span></span><br><span class="line">$ w -f</span><br><span class="line"> 16:37:45 up  7:29,  3 users,  load average: 0.20, 0.17, 0.14</span><br><span class="line">USER     TTY        LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">godleon  tty8      09:08    7:29m  9:30   0.37s mate-session</span><br><span class="line"></span><br><span class="line"><span class="comment"># $ uptime</span></span><br><span class="line"> 16:43:07 up  7:35,  3 users,  load average: 0.18, 0.15, 0.14</span><br></pre></td></tr></table></figure><blockquote><p>load average 超過 1 就表示系統負擔過重(要先除以 CPU 執行緒數量)</p></blockquote><h2 id="7-4-2-Real-time-process-monitoring"><a href="#7-4-2-Real-time-process-monitoring" class="headerlink" title="7.4.2 Real-time process monitoring"></a>7.4.2 Real-time process monitoring</h2><p>動態呈現，使用 <code>top</code>：</p><ul><li><p><code>VIRT</code>：process 消耗所有記憶體大小(包含實體 &amp; 虛擬)，等同 ps 指令中的 <code>VSZ</code></p></li><li><p><code>RES</code>：process 所使用的實體記憶體大小，等同 ps 指令中的 <code>RSS</code></p></li></ul><p>在 top 中常用的按鍵：</p><table><thead><tr><th>Key</th><th>Purpose</th></tr></thead><tbody><tr><td><code>l</code>, <code>t</code>, <code>m</code></td><td>開啟 or 關閉 load, thread, memory 資訊</td></tr><tr><td><code>M</code></td><td>記憶體使用量從大排到小</td></tr><tr><td><code>P</code></td><td>CPU 使用量從大排到小</td></tr><tr><td><code>k</code></td><td>指定 PID 並 TERM 該 process</td></tr><tr><td><code>r</code></td><td>renice 指定 process</td></tr><tr><td><code>W</code></td><td>記錄目前的 top 觀察設定，並可作為下次使用 top 時的預設設定</td></tr><tr><td><code>B</code></td><td>header &amp; running process 會以粗體顯示</td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> RHCE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH124 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[RHCE] RH124 Chapter 4~6 學習筆記</title>
      <link href="/blog/2016/04/03/RHCE/RHCE7-RH124-LearningNotes-CH04_06/"/>
      <url>/blog/2016/04/03/RHCE/RHCE7-RH124-LearningNotes-CH04_06/</url>
      <content type="html"><![CDATA[<h1 id="Chapter-4-Creating-Viewing-and-Editing-Text-Files"><a href="#Chapter-4-Creating-Viewing-and-Editing-Text-Files" class="headerlink" title="Chapter 4. Creating, Viewing, and Editing Text Files"></a>Chapter 4. Creating, Viewing, and Editing Text Files</h1><h2 id="4-1-Redirecting-Output-to-a-File-or-Program"><a href="#4-1-Redirecting-Output-to-a-File-or-Program" class="headerlink" title="4.1 Redirecting Output to a File or Program"></a>4.1 Redirecting Output to a File or Program</h2><h3 id="Standard-input-standard-output-and-standard-error"><a href="#Standard-input-standard-output-and-standard-error" class="headerlink" title="Standard input, standard output, and standard error"></a>Standard input, standard output, and standard error</h3><p><img src="https://upload.wikimedia.org/wikipedia/commons/7/70/Stdstreams-notitle.svg" alt="Process I/O Channel"></p><p><img src="http://cs.ucla.edu/classes/fall08/cs111/scribe/4/FDT_diagram.JPG" alt="STDIN、STDOUT &amp; STDERR"></p><h3 id="Redirecting-output-to-a-file"><a href="#Redirecting-output-to-a-file" class="headerlink" title="Redirecting output to a file"></a>Redirecting output to a file</h3><table><thead><tr><th>Usage</th><th>說明</th></tr></thead><tbody><tr><td><code>&amp;&gt;file</code></td><td>stdout &amp; stderr 各自輸出到相同的檔案中<br>會複寫指定檔案，若檔案不存在則建立新檔</td></tr><tr><td><code>&gt;&gt;file 2&gt;&amp;1</code><p><code>&amp;&gt;&gt;file</code></p></td><td>stderr 會導向變成 stdout 輸出，並附加內容於指定檔案<br><strong><font color="red">不會再有 stderr 輸出，而是全部皆為 stdout 輸出</font></strong></td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server tmp]$ find /etc -name passwd &amp;&gt;/tmp/save-both</span><br><span class="line">[vagrant@server tmp]$ cat /tmp/save-both</span><br><span class="line">....</span><br><span class="line">find: ‘/etc/lvm/backup’: Permission denied</span><br><span class="line">find: ‘/etc/lvm/cache’: Permission denied</span><br><span class="line">/etc/passwd</span><br><span class="line">find: ‘/etc/polkit-1/rules.d’: Permission denied</span><br><span class="line">find: ‘/etc/polkit-1/localauthority’: Permission denied</span><br><span class="line">....</span><br><span class="line">/etc/pam.d/passwd</span><br><span class="line">find: ‘/etc/audisp’: Permission denied</span><br><span class="line">....</span><br></pre></td></tr></table></figure><h3 id="Constructing-pipelines"><a href="#Constructing-pipelines" class="headerlink" title="Constructing pipelines"></a>Constructing pipelines</h3><p>pipeline 並沒有對 stderr 進行處理，透過以下兩個指令可以看出差別：(看有顏色的部分)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 僅有 stdout 的內容會被篩選</span></span><br><span class="line">[vagrant@server tmp]$ find /etc -name passwd | grep etc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 連同 stderr 的內容都會被篩選(因為 stderr 的內容已經導向 stdout 輸出)</span></span><br><span class="line">[vagrant@server tmp]$ find /etc -name passwd 2&gt;&amp;1 | grep etc</span><br></pre></td></tr></table></figure><p><img src="http://civilnet.cn/book/kernel/GNU.Linux.Application.Programming/images/11.1_0.jpg" alt="Linux Pipeline"></p><h4 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h4><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/24/Tee.svg/400px-Tee.svg.png" alt="tee pipeline"></p><p>tee 的使用範例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -a = append</span></span><br><span class="line">[vagrant@server ~]$ ps -f | tee -a ps_file.txt</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">vagrant   3372  3371  0 14:25 pts/0    00:00:00 -bash</span><br><span class="line">vagrant   3395  3372  0 14:25 pts/0    00:00:00 ps -f</span><br><span class="line">vagrant   3396  3372  0 14:25 pts/0    00:00:00 tee -a ps_file.txt</span><br><span class="line"></span><br><span class="line">[vagrant@server ~]$ cat ps_file.txt</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">vagrant   3372  3371  0 14:25 pts/0    00:00:00 -bash</span><br><span class="line">vagrant   3395  3372  0 14:25 pts/0    00:00:00 ps -f</span><br><span class="line">vagrant   3396  3372  0 14:25 pts/0    00:00:00 tee -a ps_file.txt</span><br></pre></td></tr></table></figure><p>以下兩種寄 mail 的方式相同：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat filename | mail -s subject username</span><br><span class="line"></span><br><span class="line">$ mail -s subject username &lt; filename</span><br></pre></td></tr></table></figure><hr><h1 id="Chapter-5-Managing-Local-Linux-Users-and-Groups"><a href="#Chapter-5-Managing-Local-Linux-Users-and-Groups" class="headerlink" title="Chapter 5. Managing Local Linux Users and Groups"></a>Chapter 5. Managing Local Linux Users and Groups</h1><h2 id="5-1-Users-and-Groups"><a href="#5-1-Users-and-Groups" class="headerlink" title="5.1 Users and Groups"></a>5.1 Users and Groups</h2><h3 id="What-is-a-user"><a href="#What-is-a-user" class="headerlink" title="What is a user?"></a>What is a user?</h3><p><code>id</code> 用來顯示目前登入的使用者資訊：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server ~]$ id</span><br><span class="line">uid=1000(vagrant) gid=1000(vagrant) groups=1000(vagrant),10(wheel) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</span><br></pre></td></tr></table></figure><blockquote><p>context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 是 SELinux 安全脈絡標籤</p></blockquote><p><strong><font color="red">/etc/passwd</font></strong> 的格式可以參考 <code>man 5 passwd</code></p><p>基本上 password 的部分已經都用 x 取代，並移到 <strong><font color="red">/etc/shadow</font></strong> 存放</p><h3 id="What-is-a-group"><a href="#What-is-a-group" class="headerlink" title="What is a group?"></a>What is a group?</h3><ol><li><p>每個使用者只會有一個 primary group，記錄在 <code>/etc/passwd</code> 內</p></li><li><p>每個使用者可以有 0 到多個 supplementary group，資訊會記錄在 <code>/etc/group</code> 內</p></li></ol><h2 id="5-2-Gaining-Superuser-Access"><a href="#5-2-Gaining-Superuser-Access" class="headerlink" title="5.2 Gaining Superuser Access"></a>5.2 Gaining Superuser Access</h2><h3 id="The-root-user"><a href="#The-root-user" class="headerlink" title="The root user"></a>The root user</h3><p>一般使用者可透過 <code>su</code>, <code>sudo</code>, <code>PolicyKit</code>(GUI 內用，類似 Windows UAC) 來取得 root 權限</p><h3 id="Switching-users-with-su"><a href="#Switching-users-with-su" class="headerlink" title="Switching users with su"></a>Switching users with su</h3><p><code>su [-] username</code>：等同於新的 user 重新登入的效果</p><p><code>su username</code>：產生新的 shell 並使用目前的環境變數</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 -c 可達到類似 windows runas 的效果</span></span><br><span class="line">[vagrant@server ~]$ su -c <span class="string">"ls /root"</span> root</span><br><span class="line">Password:</span><br><span class="line">anaconda-ks.cfg</span><br></pre></td></tr></table></figure><h3 id="Running-commands-as-root-with-sudo"><a href="#Running-commands-as-root-with-sudo" class="headerlink" title="Running commands as root with sudo"></a>Running commands as root with sudo</h3><p>su 的缺點是，一次就拿到完整的 root 權限，且切換成 root 還必須知道 root 的密碼。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server ~]$ sudo cat /etc/sudoers | grep <span class="string">'^[^#]'</span></span><br><span class="line">Defaults   !visiblepw</span><br><span class="line">Defaults    always_set_home</span><br><span class="line">Defaults    env_reset</span><br><span class="line">Defaults    env_keep =  <span class="string">"COLORS DISPLAY HOSTNAME HISTSIZE INPUTRC KDEDIR LS_COLORS"</span></span><br><span class="line">Defaults    env_keep += <span class="string">"MAIL PS1 PS2 QTDIR USERNAME LANG LC_ADDRESS LC_CTYPE"</span></span><br><span class="line">Defaults    env_keep += <span class="string">"LC_COLLATE LC_IDENTIFICATION LC_MEASUREMENT LC_MESSAGES"</span></span><br><span class="line">Defaults    env_keep += <span class="string">"LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER LC_TELEPHONE"</span></span><br><span class="line">Defaults    env_keep += <span class="string">"LC_TIME LC_ALL LANGUAGE LINGUAS _XKB_CHARSET XAUTHORITY"</span></span><br><span class="line">Defaults    secure_path = /sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">root    ALL=(ALL)       ALL</span><br><span class="line">%wheel  ALL=(ALL)       ALL   <span class="comment">#表示 wheel 群組內的擁有所有權限(% 開頭表示指定群組)</span></span><br><span class="line"></span><br><span class="line">[vagrant@server ~]$ cat /etc/group | grep wheel</span><br><span class="line">wheel:x:10:vagrant</span><br></pre></td></tr></table></figure><p>使用 <code>sudo</code> 的特點：</p><ol><li><p>執行 root 的系統命令不需要記住 root 密碼</p></li><li><p>所有 sudo 所執行的紀錄都會留在 <code>/var/log/secure</code> 中</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server ~]$ sudo tail /var/<span class="built_in">log</span>/secure</span><br><span class="line">....</span><br><span class="line">Feb 22 13:45:26 localhost sudo: vagrant : TTY=pts/0 ; PWD=/home/vagrant ; USER=root ; COMMAND=/bin/ls /root/</span><br><span class="line">Feb 22 13:45:45 localhost sudo: vagrant : TTY=pts/0 ; PWD=/home/vagrant ; USER=root ; COMMAND=/bin/cat /var/<span class="built_in">log</span>/secure</span><br><span class="line">Feb 22 13:46:10 localhost sudo: vagrant : TTY=pts/0 ; PWD=/home/vagrant ; USER=root ; COMMAND=/bin/tail /var/<span class="built_in">log</span>/secure</span><br></pre></td></tr></table></figure><h3 id="補充"><a href="#補充" class="headerlink" title="補充"></a>補充</h3><p><code>NIS</code>：集中驗證</p><p><code>IPA</code>：集中授權管理</p><p><code>sudo su -</code> or <code>sudo -s</code>：用一般的 user 切換成 root，輸入一般 user 的密碼</p><h2 id="5-3-Managing-Local-User-Accounts"><a href="#5-3-Managing-Local-User-Accounts" class="headerlink" title="5.3 Managing Local User Accounts"></a>5.3 Managing Local User Accounts</h2><h3 id="Managing-local-users"><a href="#Managing-local-users" class="headerlink" title="Managing local users"></a>Managing local users</h3><p><code>/etc/login.defs</code> 檔案中紀錄了新增使用者時的相關預設設定，例如 UID range, 密碼有效期限 … 等</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server ~]$ cat /etc/login.defs | grep <span class="string">'^[^#]'</span></span><br><span class="line">MAIL_DIR        /var/spool/mail</span><br><span class="line">PASS_MAX_DAYS   99999</span><br><span class="line">PASS_MIN_DAYS   0</span><br><span class="line">PASS_MIN_LEN    5</span><br><span class="line">PASS_WARN_AGE   7</span><br><span class="line">UID_MIN                  1000</span><br><span class="line">UID_MAX                 60000</span><br><span class="line">SYS_UID_MIN               201</span><br><span class="line">SYS_UID_MAX               999</span><br><span class="line">GID_MIN                  1000</span><br><span class="line">GID_MAX                 60000</span><br><span class="line">SYS_GID_MIN               201</span><br><span class="line">SYS_GID_MAX               999</span><br><span class="line">CREATE_HOME     yes</span><br><span class="line">UMASK           077</span><br><span class="line">USERGROUPS_ENAB yes</span><br><span class="line">ENCRYPT_METHOD SHA512</span><br></pre></td></tr></table></figure><h4 id="usermode-modifies-existing-users"><a href="#usermode-modifies-existing-users" class="headerlink" title="usermode modifies existing users"></a>usermode modifies existing users</h4><p><code>usermod</code> 用來修改使用者資訊，相關參數如下：</p><table><thead><tr><th>參數</th><th>說明</th></tr></thead><tbody><tr><td><code>-g/--gid</code> GROUP</td><td>設定 user 的 primary group</td></tr><tr><td><code>-G/--groups</code> GROUPS</td><td>設定 user 的 supplementary group</td></tr><tr><td><code>-a/--append</code></td><td>與 <code>-G</code> 搭配，用來增加 supplementary group 設定</td></tr><tr><td><code>-d/--home</code> HOME_DIR</td><td>設定 user 家目錄</td></tr><tr><td><code>-m/--move-home</code></td><td>移動 user 家目錄到新的地方，必須與 <code>-d</code> 參數同時使用</td></tr><tr><td><code>-s/--shell</code> SHELL</td><td>指定登入 shell</td></tr><tr><td><code>-L/--lock</code></td><td>鎖定 user</td></tr><tr><td><code>-U/--unlock</code></td><td>解鎖 user</td></tr></tbody></table><h4 id="userdel-deletes-users"><a href="#userdel-deletes-users" class="headerlink" title="userdel deletes users"></a>userdel deletes users</h4><p><code>userdel -r username</code>：會將 user 刪除，連同家目錄 &amp; mail 都一併移除</p><blockquote><p>userdel 命令若沒有加上 -r 參數，可能會有安全疑慮，主要是沒有 owner &amp; owner group 的檔案可能會被新增的 user 取得存取權限</p></blockquote><blockquote><p>此問題可透過 <code>sudo find / -nouser -o --nogroup 2&gt;/dev/null</code> 指令來找到if沒有 owner &amp; owner group 的檔案</p></blockquote><h4 id="id-displays-user-information"><a href="#id-displays-user-information" class="headerlink" title="id displays user information"></a>id displays user information</h4><p><code>id</code> 可用來顯示使用者資訊</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server ~]$ id</span><br><span class="line">uid=1000(vagrant) gid=1000(vagrant) groups=1000(vagrant),10(wheel) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</span><br><span class="line"></span><br><span class="line">[vagrant@server ~]$ id root</span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br></pre></td></tr></table></figure><h4 id="UID-ranges"><a href="#UID-ranges" class="headerlink" title="UID ranges"></a>UID ranges</h4><p>UID 在 RHEL 7 中的定義：(預設值可參考 <code>/etc/login.defs</code>)</p><ul><li><p><code>UID 0</code>：root</p></li><li><p><code>UID 1-200</code>：system users，通常用來啟動系統服務之用</p></li><li><p><code>UID 201-999</code>：保留的 system users，有其他額外未預先定義的系統服務需要時可使用</p></li><li><p><code>UID 1000</code>：一般使用者用的 UID</p></li></ul><blockquote><p>在 RHEL 7 之前，system user 使用 UID 1-499，一般使用者使用  UID 500+</p></blockquote><h3 id="Practice"><a href="#Practice" class="headerlink" title="Practice"></a>Practice</h3><p>使用 variable 新增 user：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server ~]$ USER=juliet</span><br><span class="line"></span><br><span class="line">[vagrant@server ~]$ <span class="built_in">echo</span> <span class="variable">$USER</span></span><br><span class="line">juliet</span><br><span class="line"></span><br><span class="line">[vagrant@server ~]$ sudo useradd <span class="variable">$&#123;USER&#125;</span>; <span class="built_in">echo</span> <span class="variable">$&#123;USER&#125;</span> | sudo passwd --stdin <span class="variable">$&#123;USER&#125;</span></span><br><span class="line">Changing password <span class="keyword">for</span> user juliet.</span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br></pre></td></tr></table></figure><h2 id="5-4-Managing-Local-Group-Accounts"><a href="#5-4-Managing-Local-Group-Accounts" class="headerlink" title="5.4 Managing Local Group Accounts"></a>5.4 Managing Local Group Accounts</h2><h3 id="5-4-1-Managing-supplementary-groups"><a href="#5-4-1-Managing-supplementary-groups" class="headerlink" title="5.4.1 Managing supplementary groups"></a>5.4.1 Managing supplementary groups</h3><h4 id="groupadd"><a href="#groupadd" class="headerlink" title="groupadd"></a>groupadd</h4><ul><li><code>-r</code>：用來增加 system group (GID &gt; 1000)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 -g 選項指定 GID</span></span><br><span class="line">$ sudo groupadd -g 5000 ateam</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 -r 選項姜群組新增成 system group</span></span><br><span class="line">$ sudo groupadd -r appusers</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢系統中預設 GID range</span></span><br><span class="line">[vagrant@server ~]$ cat /etc/login.defs | grep GID</span><br><span class="line">GID_MIN                  1000</span><br><span class="line">GID_MAX                 60000</span><br><span class="line">SYS_GID_MIN               201</span><br><span class="line">SYS_GID_MAX               999</span><br></pre></td></tr></table></figure><blockquote><p><code>/etc/login.defs</code> 檔案中紀錄了許多與使用者 &amp; 群組管理上相關的預設參數</p></blockquote><h4 id="groupmod"><a href="#groupmod" class="headerlink" title="groupmod"></a>groupmod</h4><ul><li><p><code>-n</code>：修改群組名稱</p></li><li><p><code>-g</code>：修改 GID (這會衍生非預期的問題)</p><ul><li>家目錄不會改</li><li>相對應的檔案 &amp; 目錄皆不會改</li></ul></li></ul><h4 id="usermod-alters-group-membership"><a href="#usermod-alters-group-membership" class="headerlink" title="usermod alters group membership"></a>usermod alters group membership</h4><ul><li><p><code>-g</code>：指定 primary group</p></li><li><p><code>sudo usermod -g NEW_PRIMARY_GROUPNAME USERNAME</code>：變更指定使用者的 primary group</p></li><li><p><code>-G</code>：指定 supplementary group</p></li><li><p><code>sudo uermod -aG SUPPLYMENTARY_GROUP USERNAME</code>：新增使用者的 supplementary group</p></li></ul><h2 id="5-5-Managing-User-Passwords"><a href="#5-5-Managing-User-Passwords" class="headerlink" title="5.5 Managing User Passwords"></a>5.5 Managing User Passwords</h2><h3 id="5-5-1-Shadow-passwords-and-password-policy"><a href="#5-5-1-Shadow-passwords-and-password-policy" class="headerlink" title="5.5.1 Shadow passwords and password policy"></a>5.5.1 Shadow passwords and password policy</h3><p>現在為了安全性，密碼都已經改存到只有 root 能讀取的 <code>/etc/shadow</code> 中，分為幾個欄位：</p><ol><li><code>name</code>：使用者名稱</li><li><code>password</code>：密碼</li><li><code>lastchange</code>：上次修改時間 (為單一數值，從 1970/01/01 作為第1天起算) (改為 0，強制使用者必須在下次登入時改密碼)</li><li><code>minage</code>：密碼存活的最小生命周期(0 表示馬上可以改回來)</li><li><code>maxage</code>：密碼存活的最大生命周期(最大為 99999，從 <code>lastchange</code> 開始算)</li><li><code>warning</code>：提醒使用者的時間 (default: 7，七天前提醒)</li><li><code>inactive</code>：寬限期，最多密碼可以存活 (maxage + inactive) 天；在寬限期登入會被強制要求更改密碼</li><li><code>expire</code>：密碼失效日期，不受前面欄位影響，過期就表示密碼完全失效</li><li><code>blank</code>：保留作為未來使用</li></ol><p>說明第 2 個欄位 <code>password</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@desktop ~]$ sudo tail -3 /etc/shadow</span><br><span class="line">juliet:<span class="variable">$6</span><span class="variable">$TFn6B61u</span><span class="variable">$sA</span>/maknNkUeghjzgrGkoAiLYzNa/KqDQDR5A0m0PxTZeac4gdXQAleR.sxWcWK5VZnnSIhSAsD/WnIZr51MZA/:16864:0:99999:7:::</span><br><span class="line">romeo:<span class="variable">$6</span><span class="variable">$vRE6wD1I</span><span class="variable">$4eh6QNLPzyMw9pVjr</span>.YwOia6s8y1zixFq2LpHSi/n.Q/A45J/jqiBCNXRJan2rl0p6MwuL.91mf3IkRNZQUVv.:16864:0:99999:7:::</span><br><span class="line">hamlet:<span class="variable">$6</span><span class="variable">$Nu8r</span>/BWW<span class="variable">$PqoSIv9iRx9oQEH2ziw4L2WH0HMXs2YXFvEH8SFHmmKd</span>/WxeAV0qOweqAXUN6TE375W7ShHHLxP6i7jBcHsD/1:16864:0:99999:7:::</span><br></pre></td></tr></table></figure><p>以 user juliet <code>$6$TFn6B61u$sA/maknNkUeghjz</code> 為例：(以 <strong><font color="red">$</font></strong> 作為分隔)</p><ol><li><p><code>6</code>：第一個部分，表示加密用的 hash 演算法，1 = MD5，6 = SHA-512 (RHEL 7 預設為 6)</p></li><li><p><code>TFn6B61u</code>：用來在加密密碼時用的 random 字串(salt)，加密時會一起用到，為了避免同樣密碼的使用者會有相同的 hash 結果</p></li><li><p><code>sA/maknNkUeghjz....</code>：hash(password + salt) 的結果</p></li></ol><blockquote><p><code>/etc/shadow</code> 的詳細說明，可以參考 <a href="http://linux.vbird.org/linux_basic/0410accountmanager.php#shadow_file" target="_blank" rel="noopener">鳥哥的 Linux 私房菜 – 第十三章、Linux 帳號管理與 ACL 權限設定</a></p></blockquote><ol><li><p><code>name</code>：使用者帳號</p></li><li><p><code>password</code>：上述的密碼資訊</p></li><li><p><code>lastchange</code>：從 1970/01/01 起算的日期(0 表示強制使用者下次登入時變更密碼)</p></li><li><p><code>min days</code>：</p></li><li><p><code>max days</code></p></li><li><p><code>warning</code></p></li><li><p><code>inactive</code></p></li><li><p><code>expires</code></p></li><li><p><code>blank</code></p></li></ol><h3 id="5-5-2-Password-aging"><a href="#5-5-2-Password-aging" class="headerlink" title="5.5.2 Password aging"></a>5.5.2 Password aging</h3><p><img src="https://lh3.googleusercontent.com/2bDqeWVGlV0vGtV0lm6TE-1KwHmNixd6pUAaDGh30pcFJGF3tI3WUsV6dxUzdRbSPh7dR3mzznf_EdinGaKeWQA1xrA9cdOJFajn-jQFCcgEfni4Sdpn4zd-6R4T-Rj0Cezry17a0m_hI61F1nD8TjQFomv6NltRNseZgPgHVM1JU0or0xr8Y322N7MfhzoQIXeLQgQMLTsKtLAr19avk7A3yUQiZn5m6RI6T0rVqmW2FsXYwGEiQiDQlmg9POKDIndNH9LknDoIGHK5PAL_03cmbuY5EdouDrBMQu1PCESLO5GvZgzG-UIWNXMYk692Rai3Cpw6zNbyMUdwqpzvUaCgsPFHYcRfA9C3U1VJ4p-O2Q9iIKq5-8DWzEzGb7HELfYNwAHny8QGnXBGnHa7qtzVUJseFngyW3I2T-rCD7rriDbNYep4-V_fSqMSCNFSpVcs6Xnaj9TmnmXoegWDt3p43VTQxqPPb5C1LpyOK8mwwzFJdrYEjRJNmRzz6o4tUTqfbeay_UdKTzARA4MrsP6k2X5wHPWlDOao9eh7cMtRsyQpk9KE3Mp2l44mIHs_tuIE=w657-h235-no" alt="Linux Password Aging"></p><p>RHEL7 用來加密密碼的 hash algorithm 已經預設改為 <code>SHA-512</code>(<font color="red"><strong>6</strong></font>)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 強制使用者下次登入修改密碼</span></span><br><span class="line">$ chage -d 0 USER_NAME</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 human readable 的方式顯示 /etc/shadow 的內容</span></span><br><span class="line">$ chage -l USER_NAME</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定密碼失效日期 (也可以改用數字)</span></span><br><span class="line">$ chage -E YYYY-MM-DD USER_NAME</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 檢視 juliet 目前的密碼期限相關設定</span></span><br><span class="line">[vagrant@desktop ~]$ sudo chage -l juliet</span><br><span class="line">Last password change                                    : Mar 04, 2016</span><br><span class="line">Password expires                                        : never</span><br><span class="line">Password inactive                                       : never</span><br><span class="line">Account expires                                         : never</span><br><span class="line">Minimum number of days between password change          : 0</span><br><span class="line">Maximum number of days between password change          : 99999</span><br><span class="line">Number of days of warning before password expires       : 7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 強制 juliet 在下次登入時變更密碼</span></span><br><span class="line">[vagrant@desktop ~]$ sudo chage -d 0 juliet</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 -E YYYY-MM-dd 的設定方式將帳號過期時間設定為 45 天後</span></span><br><span class="line">[vagrant@desktop ~]$ sudo chage -E $(date -d <span class="string">"+45 days"</span> +%F) juliet</span><br></pre></td></tr></table></figure><h3 id="5-5-3-Restricting-access"><a href="#5-5-3-Restricting-access" class="headerlink" title="5.5.3 Restricting access"></a>5.5.3 Restricting access</h3><p>限制使用者存取的方式：</p><ol><li>Lock USER_NAME</li><li>給 Expiration Date</li><li>把 shell 給成 /sbin/nologin</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下兩個功能相同</span></span><br><span class="line">$ sudo usermod -L USER_NAME</span><br><span class="line">$ sudo passwd -l USER_NAME</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lock user</span></span><br><span class="line">$ sudo usermod -L juliet</span><br><span class="line"></span><br><span class="line"><span class="comment"># unlock user</span></span><br><span class="line">$ sudo usermod -U juliet</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定 nologin shell 給使用者，使用者就沒有 shell 可用(例如：mail service)</span></span><br><span class="line">$ sudo usermod -s /sbin/nologin juliet</span><br></pre></td></tr></table></figure><h3 id="5-5-4-Lab-Managing-Local-Linux-Users-and-Groups"><a href="#5-5-4-Lab-Managing-Local-Linux-Users-and-Groups" class="headerlink" title="5.5.4 Lab: Managing Local Linux Users and Groups"></a>5.5.4 Lab: Managing Local Linux Users and Groups</h3><p>修改 <code>/etc/login.defs</code>(<font color="red"><strong>PASS_MAX_DAYS</strong></font>) 將密碼預設過期日改為 30</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新增一個 GID 40000，名稱為 consultants 的群組</span></span><br><span class="line">$ groupadd -g 40000 consultants</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增使用者，指定 GID 為 40000，並設定密碼為 default</span></span><br><span class="line">$ USR=sspade; useradd -G 40000 <span class="variable">$&#123;USR&#125;</span>; <span class="built_in">echo</span> <span class="string">"default"</span> | passwd --stdin <span class="variable">$&#123;USR&#125;</span></span><br><span class="line">$ USR=bboop; useradd -G 40000 <span class="variable">$&#123;USR&#125;</span>; <span class="built_in">echo</span> <span class="string">"default"</span> | passwd --stdin <span class="variable">$&#123;USR&#125;</span></span><br><span class="line">$ USR=dtracy; useradd -G 40000 <span class="variable">$&#123;USR&#125;</span>; <span class="built_in">echo</span> <span class="string">"default"</span> | passwd --stdin <span class="variable">$&#123;USR&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定 sspade, bboop, dreacy 的密碼過期日(expiration date)為 90 天後</span></span><br><span class="line">$ chage -E $(date -d <span class="string">"+90 days"</span> +%Y-%m-%d) sspade</span><br><span class="line">$ chage -E $(date -d <span class="string">"+90 days"</span> +%Y-%m-%d) bboop</span><br><span class="line">$ chage -E $(date -d <span class="string">"+90 days"</span> +%Y-%m-%d) dtracy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 限制 bboop 每 15 天要改一次密碼</span></span><br><span class="line">$ chage -M 15 bboop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 強制 sspade, bboop, dreacy 下次登入時要改密碼</span></span><br><span class="line">$ chage -d 0 sspade</span><br><span class="line">$ chage -d 0 bboop</span><br><span class="line">$ chage -d 0 dtracy</span><br></pre></td></tr></table></figure><h2 id="5-6-Practice-Managing-User-Password-Aging"><a href="#5-6-Practice-Managing-User-Password-Aging" class="headerlink" title="5.6 Practice: Managing User Password Aging"></a>5.6 Practice: Managing User Password Aging</h2><p>Lock User：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lock 使用者 romeo</span></span><br><span class="line">[vagrant@desktop ~]$ sudo usermod -L romeo</span><br><span class="line"><span class="comment"># 無法切換使用者，因為已經 lock</span></span><br><span class="line">[vagrant@desktop ~]$ su - romeo</span><br><span class="line">Password:</span><br><span class="line">su: Authentication failure</span><br><span class="line"></span><br><span class="line"><span class="comment"># unlock 之後便可登入</span></span><br><span class="line">[vagrant@desktop ~]$ sudo usermod -U romeo</span><br><span class="line">[vagrant@desktop ~]$ su - romeo</span><br><span class="line">Password:</span><br><span class="line">Last login: Wed Mar  9 14:39:24 UTC 2016 on pts/0</span><br><span class="line">Last failed login: Wed Mar  9 14:40:51 UTC 2016 on pts/0</span><br><span class="line">There were 2 failed login attempts since the last successful login.</span><br><span class="line">[romeo@desktop ~]$</span><br></pre></td></tr></table></figure><p>設定密碼過期時間 90 天 &amp; 下次登入時修改密碼：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@desktop ~]$ sudo chage -l romeo</span><br><span class="line">Last password change                                    : Mar 09, 2016</span><br><span class="line">Password expires                                        : never</span><br><span class="line">Password inactive                                       : never</span><br><span class="line">Account expires                                         : never</span><br><span class="line">Minimum number of days between password change          : 0</span><br><span class="line">Maximum number of days between password change          : 99999</span><br><span class="line">Number of days of warning before password expires       : 7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定密碼過期時間 90 天</span></span><br><span class="line">[vagrant@desktop ~]$ sudo chage -M 90 romeo</span><br><span class="line">[vagrant@desktop ~]$ sudo chage -l romeo</span><br><span class="line">Last password change                                    : Mar 09, 2016</span><br><span class="line">Password expires                                        : Jun 07, 2016</span><br><span class="line">Password inactive                                       : never</span><br><span class="line">Account expires                                         : never</span><br><span class="line">Minimum number of days between password change          : 0</span><br><span class="line">Maximum number of days between password change          : 90</span><br><span class="line">Number of days of warning before password expires       : 7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 強制使用者下次登入時變更密碼</span></span><br><span class="line">[vagrant@desktop ~]$ sudo chage -l romeo</span><br><span class="line">Last password change                                    : password must be changed</span><br><span class="line">Password expires                                        : password must be changed</span><br><span class="line">Password inactive                                       : password must be changed</span><br><span class="line">Account expires                                         : never</span><br><span class="line">Minimum number of days between password change          : 0</span><br><span class="line">Maximum number of days between password change          : 90</span><br><span class="line">Number of days of warning before password expires       : 7</span><br></pre></td></tr></table></figure><p>設定使用者密碼過期時間為 180 天後：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@desktop ~]$ sudo chage -E $(date -d <span class="string">"+180 days"</span> +%F) romeo</span><br><span class="line">[vagrant@desktop ~]$ sudo chage -l romeo</span><br><span class="line">Last password change                                    : Mar 09, 2016</span><br><span class="line">Password expires                                        : Jun 07, 2016</span><br><span class="line">Password inactive                                       : never</span><br><span class="line">Account expires                                         : Sep 05, 2016</span><br><span class="line">Minimum number of days between password change          : 0</span><br><span class="line">Maximum number of days between password change          : 90</span><br><span class="line">Number of days of warning before password expires       : 7</span><br></pre></td></tr></table></figure><hr><h1 id="Chapter-6-Controlling-Access-to-Files-with-Linux-File-System-Permissions"><a href="#Chapter-6-Controlling-Access-to-Files-with-Linux-File-System-Permissions" class="headerlink" title="Chapter 6. Controlling Access to Files with Linux File System Permissions"></a>Chapter 6. Controlling Access to Files with Linux File System Permissions</h1><h2 id="6-1-Linux-File-System-Permissions"><a href="#6-1-Linux-File-System-Permissions" class="headerlink" title="6.1 Linux File System Permissions"></a>6.1 Linux File System Permissions</h2><h3 id="6-1-1-Linux-file-system-permissions"><a href="#6-1-1-Linux-file-system-permissions" class="headerlink" title="6.1.1 Linux file system permissions"></a>6.1.1 Linux file system permissions</h3><blockquote><p>新增/刪除檔案不是看檔案本身權限，而是看上層目錄的權限</p></blockquote><p>當使用者擁有目錄的 <code>w(write)</code> &amp; <code>x(execute)</code> 權限時，可以刪除該目錄中自己也沒有權限的檔案，但這問題可以透過 <code>sticky bit</code> 來解決!</p><p>正常對目錄有存取權限的使用者，會同時有 <code>r(read)</code> &amp; <code>w(write)</code> 兩個權限：</p><ul><li><p>若沒有目錄的 <code>r(read)</code> 權限，使用者無法列出目錄中的檔案，但若知道明確檔名還是可以存取</p></li><li><p>若沒有目錄的 <code>w(write)</code> 權限，就只能列出目錄中的檔案內容，但都無法存取目錄中的任何檔案(連 timestamp 資訊都看不到)</p></li><li><p>但如果進不了目錄(<strong><font color="red">沒有 execute 權限</font></strong>)，還是無法刪除檔案</p></li></ul><h3 id="6-1-2-Viewing-file-directory-permissions-and-ownership"><a href="#6-1-2-Viewing-file-directory-permissions-and-ownership" class="headerlink" title="6.1.2 Viewing file/directory permissions and ownership"></a>6.1.2 Viewing file/directory permissions and ownership</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出目錄中所有子目錄 &amp; 檔案的相關權限資訊</span></span><br><span class="line">[vagrant@server ~]$ ls -l /home</span><br><span class="line">total 4</span><br><span class="line">drwx------. 6 vagrant vagrant 4096 Mar 30 20:23 vagrant</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過 '-d' 參數，僅列出指定目錄的權限 (權限中的最後一個 . 是作為 ACL 控制用)</span></span><br><span class="line">[vagrant@server ~]$ ls -ld /home</span><br><span class="line">drwxr-xr-x. 3 root root 20 Jan  3 04:22 /home</span><br></pre></td></tr></table></figure><h2 id="6-2-Managing-File-System-Permissions-from-the-Command-Line"><a href="#6-2-Managing-File-System-Permissions-from-the-Command-Line" class="headerlink" title="6.2 Managing File System Permissions from the Command Line"></a>6.2 Managing File System Permissions from the Command Line</h2><h3 id="6-2-1-Changing-file-directory-permissions"><a href="#6-2-1-Changing-file-directory-permissions" class="headerlink" title="6.2.1 Changing file/directory permissions"></a>6.2.1 Changing file/directory permissions</h3><p>透過 chmod -R 以遞迴的方式指定檔案 &amp; 目錄的權限時，若包含了 x(execute) 權限，會讓檔案 &amp; 目錄同時都有 x(execute) 的權限，但這通常不是我們需要的結果；一般我們只會希望只有目錄才需要 x(execute) 權限，此時只要加上大寫 <code>W</code> 參數即可：</p><p>例如：<code>chmod -R g+rwX somedir</code> 表示 somedir 目錄下所有的檔案都給 rw 權限，目錄則是給 rwx 權限。</p><h3 id="6-2-2-Changing-file-directory-user-or-group-ownership"><a href="#6-2-2-Changing-file-directory-user-or-group-ownership" class="headerlink" title="6.2.2 Changing file/directory user or group ownership"></a>6.2.2 Changing file/directory user or group ownership</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下兩個指令功能相同，都是修改檔案的 group ownership</span></span><br><span class="line">[vagrant@server ch06]$ sudo chown :vboxsf 1st/aa</span><br><span class="line">[vagrant@server ch06]$ sudo chgrp vboxsf 1st/aa</span><br></pre></td></tr></table></figure><blockquote><p>只有 root 可以修改檔案的 ownership，一般使用者儘可以針對自己所屬的群組設定 ownership</p></blockquote><p>一般 web 網站的目錄，只會開啟目錄的 execute 權限，並且讓目錄內的檔案有 others read 的權限，讓使用者可以進入目錄，可以存取目錄中檔案的內容，但卻無法列出目錄中所有的檔案</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 檔案 file1 拿掉 group &amp; others 的 read &amp; write 權限</span></span><br><span class="line">$ chmod go-rw file1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 針對多層目錄 &amp; 檔案透過遞迴的方式設定權限(group 給予所有權限)</span></span><br><span class="line">$ chmod -R g+rwx multi_layer_dir</span><br><span class="line"></span><br><span class="line"><span class="comment"># 針對多層目錄(只有目錄，沒有檔案)，使用遞迴的方式指定所有人有 execute 的權限</span></span><br><span class="line"><span class="comment"># 透過大寫 X，指定套用權限時僅會套用在目錄上，不會在檔案上</span></span><br><span class="line">$ chmod -R a+X multi_layer_dir</span><br></pre></td></tr></table></figure><p>只有 root 可以變更檔案的 ownership</p><blockquote><p>例外：檔案擁有者可以改檔案所屬群組，但只可以改成屬於自己群組</p></blockquote><h2 id="6-3-Managing-Default-Permissions-and-File-Access"><a href="#6-3-Managing-Default-Permissions-and-File-Access" class="headerlink" title="6.3 Managing Default Permissions and File Access"></a>6.3 Managing Default Permissions and File Access</h2><h3 id="6-3-1-Special-permissions"><a href="#6-3-1-Special-permissions" class="headerlink" title="6.3.1 Special permissions"></a>6.3.1 Special permissions</h3><p>若檔案的 execute 權限標示為 <code>setuid</code> or <code>setgid</code> 時(以 <code>s</code> 表示權限)，表示此檔案不論是哪個使用者執行，會以檔案 owner 的身分(<code>setgid</code> 會以群組的身分)執行，而不是執行檔案的使用者。 例如：<strong>/etc/passwd</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server ~]$ ls -al /usr/bin/passwd</span><br><span class="line">-rwsr-xr-x. 1 root root 27832 Jun 10  2014 /usr/bin/passwd</span><br></pre></td></tr></table></figure><p>若 sticky bit(以 <code>t</code> 表示權限) 位於 directory 時，以 <strong><font color="red">/tmp</font></strong> 為例，<strong>只有檔案的擁有者才可以刪除檔案</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server ~]$ ls -ld /tmp/</span><br><span class="line">drwxrwxrwt. 7 root root 88 Apr  3 01:00 /tmp/</span><br></pre></td></tr></table></figure><table><thead><tr><th>設定方式</th><th>在檔案上的效果</th><th>在目錄上的效果</th></tr></thead><tbody><tr><td><code>u+s</code>(4)</td><td>檔案執行時會以 owner user 的權限執行</td><td>N/A</td></tr><tr><td><code>g+s</code>(2)</td><td>檔案執行時會以 owner group 的權限執行</td><td>在此目錄中新建立的檔案會擁有與目錄相同的 group 權限</td></tr><tr><td><code>o+t</code>(1)</td><td>N/A</td><td>在此目錄中，使用者僅能移除他們自己所建立的檔案</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># setuid</span></span><br><span class="line">$ chmod u+s some_file</span><br><span class="line"></span><br><span class="line"><span class="comment"># setgid</span></span><br><span class="line">$ chmod g+s,o-rx some_dir</span><br><span class="line">$ chmod 2770 some_dir</span><br></pre></td></tr></table></figure><h4 id="SetUID"><a href="#SetUID" class="headerlink" title="SetUID"></a>SetUID</h4><ul><li>檔案<blockquote><p>-rwsr-xr-x 1 root root 47032 Jul 16  2015 /usr/bin/passwd -&gt; /etc/shadow<br>passwd 指令的 owner 為 root，因此執行此指令時是以 root 的權限執行</p></blockquote></li></ul><h4 id="SetGID"><a href="#SetGID" class="headerlink" title="SetGID"></a>SetGID</h4><ul><li><p>檔案</p><blockquote><p>/usr/bin/locate -&gt; /var/lib/mlocate/mlocate.db</p></blockquote></li><li><p>目錄</p><blockquote><p>SetGID 設定在目錄上，則表示在該目錄中建立的檔案 or 目錄的擁有群組都會被強制設定為該目錄的擁有群組</p></blockquote></li></ul><h4 id="Sticky-Bit"><a href="#Sticky-Bit" class="headerlink" title="Sticky Bit"></a>Sticky Bit</h4><ul><li>目錄<blockquote><p><code>o+t</code> 表示該目錄中的檔案只有擁有者可以移除</p></blockquote></li></ul><blockquote><p><strong><font color="red">T</font></strong>：表示 others 原本沒有 execute 權限</p></blockquote><blockquote><p><strong><font color="red">t</font></strong>：表示 others 原本有 execute 權限</p></blockquote><h3 id="6-3-2-Default-file-permissions"><a href="#6-3-2-Default-file-permissions" class="headerlink" title="6.3.2 Default file permissions"></a>6.3.2 Default file permissions</h3><p>Default permission (system)</p><ul><li>File: <code>666</code></li><li>Directory: <code>777</code></li></ul><p>Default Umask:</p><ul><li>root：<code>022</code></li><li>regular user：<code>002</code></li></ul><p>umask 使用 3 個數字進行修改，若少於 3 個數字，前面會被自動補 0；且更改的效果僅限於該 terminal session 中，重新登入後就會無效。</p><p>umask 的設定，若是要設定 global 的，可以到 <strong><font color="red">/etc/profile</font></strong> &amp; <strong><font color="red">/etc/bashrc</font></strong> 中進行調整</p><p>如果要進行個人化設定，則可以到 <strong><font color="red">~/.bash_profile</font></strong> &amp; <strong><font color="red">~/.bashrc</font></strong> 中進行調整</p>]]></content>
      
      <categories>
          
          <category> RHCE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH124 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[RHCE] RH124 Chapter 1~3 學習筆記</title>
      <link href="/blog/2016/02/17/RHCE/RHCE7-RH124-LearningNotes-CH01_03/"/>
      <url>/blog/2016/02/17/RHCE/RHCE7-RH124-LearningNotes-CH01_03/</url>
      <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h3 id="Internationalization"><a href="#Internationalization" class="headerlink" title="Internationalization"></a>Internationalization</h3><p>若想要讓 desktop &amp; console 環境的語系一致，可以加入以下的 script 到 ~/.bashrc 中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i=$(grep <span class="string">'Language'</span> /var/lib/AccountsService/users/<span class="variable">$&#123;USER&#125;</span> | \</span><br><span class="line">sed <span class="string">'s/Language=//'</span>)</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$i</span>"</span> != <span class="string">""</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">export</span> LANG=<span class="variable">$i</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>透過 <font color="red"><code>locale</code></font> 可以查詢目前語系相關的設定 &amp; 環境變數：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ locale</span><br><span class="line">LANG=zh_TW.UTF-8</span><br><span class="line">.....(LANG-related environment variables)</span><br><span class="line">LC_ALL=</span><br></pre></td></tr></table></figure><p>若要修改整個系統的預設語系，可以透過以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ localectl <span class="built_in">set</span>-locale LANG=zh_TW.UTF-8</span><br></pre></td></tr></table></figure><p>或是修改 <font color="red"><code>/etc/locale.conf</code></font> 檔案的內容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/locale.conf</span><br><span class="line">LANG=zh_TW.UTF-8</span><br></pre></td></tr></table></figure><hr><p><a name="ch1"></a></p><h1 id="Chapter-1-ACCESSING-THE-COMMAND-LINE"><a href="#Chapter-1-ACCESSING-THE-COMMAND-LINE" class="headerlink" title="Chapter 1. ACCESSING THE COMMAND LINE"></a>Chapter 1. ACCESSING THE COMMAND LINE</h1><h2 id="1-1-Accessing-the-Command-Line-Using-the-Local-Console"><a href="#1-1-Accessing-the-Command-Line-Using-the-Local-Console" class="headerlink" title="1.1 Accessing the Command Line Using the Local Console"></a>1.1 Accessing the Command Line Using the Local Console</h2><h3 id="Virtual-Console"><a href="#Virtual-Console" class="headerlink" title="Virtual Console"></a>Virtual Console</h3><p>在 RHEL 7 中，若有 GUI 環境，則會預設執行在第一個 virtual console，另外還會包含 5 個文字模式的 virtual console，可使用 <code>Ctrl + Alt + F[1-6]</code> 在不同的 virtual console 間切換。</p><p>若沒有 GUI 環境，則 6 個 virtual console 都會是純文字模式。</p><p>要調整 virtual console 的數量，可修改 <code>/etc/systemd/login.conf</code> 中的 <strong><font color="red">NAutoVTs</font></strong> 的選項，</p><h2 id="1-2-Accrssing-the-Command-Line-Using-the-Desktop"><a href="#1-2-Accrssing-the-Command-Line-Using-the-Desktop" class="headerlink" title="1.2 Accrssing the Command Line Using the Desktop"></a>1.2 Accrssing the Command Line Using the Desktop</h2><h3 id="Windows-連線至-Linux-GUI"><a href="#Windows-連線至-Linux-GUI" class="headerlink" title="Windows 連線至 Linux GUI"></a>Windows 連線至 Linux GUI</h3><p>要從 Windows 連線到 Linux GUI，可使用 <a href="http://ntu.csie.org/~piaip/pietty/" target="_blank" rel="noopener">pietty</a> + <a href="http://sourceforge.net/projects/xming/" target="_blank" rel="noopener">Xming</a></p><p>使用說明可參考 =&gt; <a href="http://blog.jangmt.com/2009/11/xming.html" target="_blank" rel="noopener">八克里: 使用 xming 從windows 系統登入 Linux 系統</a></p><h3 id="Auto-Login"><a href="#Auto-Login" class="headerlink" title="Auto Login"></a>Auto Login</h3><p>要在 RHEL 7 作到 Auto Login，要修改 <code>/etc/gdm/custom.conf</code>，並調整 <font color="blue"><strong>daemon</strong></font> section 中的 <strong><font color="red">AutomaticLoginEnable</font></strong> &amp; <strong><font color="red">AutomaticLogin</font></strong> 兩個參數</p><h2 id="1-3-Executing-Commands-Using-the-Bash-Shell"><a href="#1-3-Executing-Commands-Using-the-Bash-Shell" class="headerlink" title="1.3 Executing Commands Using the Bash Shell"></a>1.3 Executing Commands Using the Bash Shell</h2><h3 id="Examples-of-simple-commands"><a href="#Examples-of-simple-commands" class="headerlink" title="Examples of simple commands"></a>Examples of simple commands</h3><p><strong><font color="red">file</font></strong> 可用來檢查檔案的型態 &amp; 格式 (也可以用 <strong><a href="http://www.computerhope.com/unix/stat.htm" target="_blank" rel="noopener">stat</a></strong>)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ file /etc/passwd</span><br><span class="line">/etc/passwd: ASCII text</span><br><span class="line"></span><br><span class="line">$ file /bin/passwd</span><br><span class="line">/bin/passwd: setuid ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), <span class="keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=0x91a7160a019b7f5f754264d920e257522c5bce67, stripped</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">stat</span> /etc/passwd</span><br><span class="line">  File: ‘/etc/passwd’</span><br><span class="line">  Size: 961             Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: fd01h/64769d    Inode: 1573453     Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Context: system_u:object_r:passwd_file_t:s0</span><br><span class="line">Access: 2016-01-20 07:38:22.557000000 -0500</span><br><span class="line">Modify: 2015-10-02 10:38:00.710867846 -0400</span><br><span class="line">Change: 2015-10-02 10:38:00.710867846 -0400</span><br><span class="line"> Birth: -</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">stat</span> /bin/passwd</span><br><span class="line">  File: ‘/bin/passwd’</span><br><span class="line">  Size: 27832           Blocks: 56         IO Block: 4096   regular file</span><br><span class="line">Device: fd01h/64769d    Inode: 2234382     Links: 1</span><br><span class="line">Access: (4755/-rwsr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Context: system_u:object_r:passwd_exec_t:s0</span><br><span class="line">Access: 2014-06-10 02:27:56.000000000 -0400</span><br><span class="line">Modify: 2014-06-10 02:27:56.000000000 -0400</span><br><span class="line">Change: 2015-10-02 10:30:36.743867846 -0400</span><br><span class="line"> Birth: -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 甚至可以直接針對目錄來檢查</span></span><br><span class="line">$ file /home</span><br><span class="line">/home: directory</span><br></pre></td></tr></table></figure><h3 id="Editing-the-command-Line"><a href="#Editing-the-command-Line" class="headerlink" title="Editing the command Line"></a>Editing the command Line</h3><p>使用 command line 的實用快速鍵：</p><table><thead><tr><th>快速鍵</th><th>說明</th></tr></thead><tbody><tr><td><code>Ctrl + a</code></td><td>游標跳至最前</td></tr><tr><td><code>Ctrl + e</code></td><td>游標跳至最後</td></tr><tr><td><code>Ctrl + u</code></td><td>清除整個命令中，從游標到最前面的內容</td></tr><tr><td><code>Ctrl + k</code></td><td>清除整個命令中，從游標到最後面的內容</td></tr><tr><td>`ESC + .</td><td>複製上一個命令中的最後一個參數到目前的命令中</td></tr><tr><td>`Alt + .</td><td>同上</td></tr><tr><td><code>Ctrl + r</code></td><td>可用 keyword 來尋找最近使用過的命令</td></tr><tr><td><code>Ctrl + l(小寫 L)</code></td><td>清除螢幕內容(效果等同 <code>clear</code>)</td></tr></tbody></table><hr><p><a name="ch2"></a></p><h1 id="Chapter-2-MANAGING-FILES-FROM-THE-COMMAND-LINE"><a href="#Chapter-2-MANAGING-FILES-FROM-THE-COMMAND-LINE" class="headerlink" title="Chapter 2. MANAGING FILES FROM THE COMMAND LINE"></a>Chapter 2. MANAGING FILES FROM THE COMMAND LINE</h1><h2 id="2-1-The-file-system-hierarchy"><a href="#2-1-The-file-system-hierarchy" class="headerlink" title="2.1 The file system hierarchy"></a>2.1 The file system hierarchy</h2><p>RHEL 中的重要目錄：</p><table><thead><tr><th>路徑</th><th>目的</th></tr></thead><tbody><tr><td><code>/usr</code><br>(Unix Software Resource)</td><td>安裝的軟體、shared library … 等資料都會放在此處，其中幾個重要目錄：<br><code>/usr/bin</code>：使用者用指令<br><code>/usr/sbin</code>：系統管理者用指令<br><code>/usr/local</code>：使用者自行安裝的軟體</td></tr><tr><td><code>/etc</code></td><td>設定檔存放路徑</td></tr><tr><td><code>/var</code></td><td>持續不斷變動的資料，例如 log、print spool、資料庫檔案 … 等等</td></tr><tr><td><code>/run</code></td><td>從上次開機以來的 runtime 資訊(<strong><font color="red">此目錄的資料在每次重開機都會清空</font></strong>)</td></tr><tr><td><code>/tmp</code></td><td>所有人都有權限存取的站存資料目錄(<strong><font color="red">此目錄中日期大於 10 天的資料會被自動清除</font></strong>)，若是在目錄 <code>/var/tmp</code> 中的資料，則是超過 30 天的資料會被清除</td></tr><tr><td><code>/boot</code></td><td>系統開機所需要的檔案</td></tr><tr><td><code>/dev</code></td><td>存放系統用來存取硬體裝置所需要的檔案</td></tr></tbody></table><blockquote><p>原本在 <code>/</code> 下的某些目錄，在 RHEL 7 後都被移到 <code>/usr</code> 下了，包含 <code>/bin</code>(=&gt; <code>/usr/bin</code>)、<code>/sbin</code>(=&gt; <code>/usr/sbin</code>)、<code>/lib</code>(=&gt; <code>/usr/lib</code>)、<code>/lib64</code>(=&gt; <code>/usr/lib64</code>)<br>但原本在 <code>/</code> 的以上四個目錄都還存在，只是改成用 symbolic link 的方式連到 <code>/usr</code> 中的子目錄</p></blockquote><p>詳細資料可查詢 <font color="blue"><strong>hier(7)</strong></font> man page</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ man 7 hier</span><br></pre></td></tr></table></figure><h2 id="2-2-Locating-Files-by-name"><a href="#2-2-Locating-Files-by-name" class="headerlink" title="2.2 Locating Files by name"></a>2.2 Locating Files by name</h2><p>檔名限制 &amp; 特性：</p><ol><li><p>完整檔案路徑長度不能超過 4095 bytes (含 <code>/</code>)</p></li><li><p>兩個 <code>/</code> 之間的長度不能超過 255 bytes</p></li><li><p>檔名可以是任意的 UTF-8 字元，但不能是 <code>/</code> &amp; <code>NUL</code></p></li><li><p>Case-Sensative</p></li></ol><h3 id="Navigating-paths"><a href="#Navigating-paths" class="headerlink" title="Navigating paths"></a>Navigating paths</h3><ul><li><strong>touch</strong><blockquote><p>touch 會更新檔案的 timestamp 到目前的時間，而不會改變檔案內容<br>若是不存在的檔案，則會建立一個空白檔案</p></blockquote></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server ~]$ touch /tmp/<span class="built_in">test</span>&#123;1,2&#125;.txt</span><br><span class="line">[vagrant@server ~]$ ls -l /tmp/</span><br><span class="line">total 0</span><br><span class="line">-rw-rw-r--. 1 vagrant vagrant 0 Jan 30 00:23 test1.txt</span><br><span class="line">-rw-rw-r--. 1 vagrant vagrant 0 Jan 30 00:23 test2.txt</span><br></pre></td></tr></table></figure><h2 id="2-3-Managing-Files-Using-command-Line-Tools"><a href="#2-3-Managing-Files-Using-command-Line-Tools" class="headerlink" title="2.3 Managing Files Using command-Line Tools"></a>2.3 Managing Files Using command-Line Tools</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保留複製檔案的屬性</span></span><br><span class="line">$ cp -a</span><br></pre></td></tr></table></figure><h2 id="2-4-Matching-File-Names-Using-Path-Name-Expansion"><a href="#2-4-Matching-File-Names-Using-Path-Name-Expansion" class="headerlink" title="2.4 Matching File Names Using Path Name Expansion"></a>2.4 Matching File Names Using Path Name Expansion</h2><h3 id="File-globbing-path-name-Expansion"><a href="#File-globbing-path-name-Expansion" class="headerlink" title="File globbing: path name Expansion"></a>File globbing: path name Expansion</h3><table><thead><tr><th>Pattern</th><th>Matches</th></tr></thead><tbody><tr><td><code>~+</code></td><td>目前工作目錄</td></tr><tr><td><code>~-</code></td><td>上一個工作目錄</td></tr><tr><td><code>[abc...]</code></td><td>任何在中括號中的字母都符合</td></tr><tr><td><code>[!abc...]</code></td><td>不包含中括號中的任何一個字母</td></tr><tr><td><code>[^abc...]</code></td><td>同上</td></tr><tr><td><code>[[:punct:]]</code></td><td>任何可印出來的字元(但不包含空白 or 英文字母)</td></tr></tbody></table><h4 id="Brace-Expansion"><a href="#Brace-Expansion" class="headerlink" title="Brace Expansion"></a>Brace Expansion</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server ~]$ <span class="built_in">echo</span> &#123;Sunday,Month,Tuesday&#125;.lo</span><br><span class="line">Sunday.log Month.log Tuesday.log</span><br><span class="line"></span><br><span class="line">[vagrant@server ~]$ <span class="built_in">echo</span> file&#123;a..c&#125;.txt</span><br><span class="line">filea.txt fileb.txt filec.txt</span><br><span class="line"></span><br><span class="line">[vagrant@server ~]$ <span class="built_in">echo</span> file&#123;a,b&#125;&#123;1,2&#125;.txt</span><br><span class="line">filea1.txt filea2.txt fileb1.txt fileb2.txt</span><br><span class="line"></span><br><span class="line">[vagrant@server ~]$ <span class="built_in">echo</span> file&#123;a&#123;1,2&#125;,b,c&#125;.txt</span><br><span class="line">filea1.txt filea2.txt fileb.txt filec.txt</span><br></pre></td></tr></table></figure><h4 id="Command-Substitution"><a href="#Command-Substitution" class="headerlink" title="Command Substitution"></a>Command Substitution</h4><ul><li><p>單引號中的變數 $ 無效</p></li><li><p>雙引號中的變數 $ 有效</p></li><li><p>較推薦加大括號確定變數名稱的方式，比較不容易跟單引號混淆</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server ~]$ <span class="built_in">echo</span> Today is `date +%A`</span><br><span class="line">Today is Saturday</span><br><span class="line"></span><br><span class="line">[vagrant@server ~]$ <span class="built_in">echo</span> The time is $(date +%M) minutes past $(date +%l%p)</span><br><span class="line">The time is 33 minutes past 8AM</span><br></pre></td></tr></table></figure><h2 id="2-5-Lab-Managing-Files-with-Shell-Expansion"><a href="#2-5-Lab-Managing-Files-with-Shell-Expansion" class="headerlink" title="2.5 Lab: Managing Files with Shell Expansion"></a>2.5 Lab: Managing Files with Shell Expansion</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server lab]$ touch tv_season&#123;1,2&#125;_episode&#123;1..6&#125;.ogg</span><br><span class="line">[vagrant@server lab]$ ls</span><br><span class="line">tv_season1_episode1.ogg  tv_season1_episode3.ogg  tv_season1_episode5.ogg  tv_season2_episode1.ogg  tv_season2_episode3.ogg  tv_season2_episode5.ogg</span><br><span class="line">tv_season1_episode2.ogg  tv_season1_episode4.ogg  tv_season1_episode6.ogg  tv_season2_episode2.ogg  tv_season2_episode4.ogg  tv_season2_episode6.ogg</span><br><span class="line"></span><br><span class="line">[vagrant@server lab]$ touch mystery_chapter&#123;1..8&#125;.odf</span><br><span class="line">[vagrant@server lab]$ ls</span><br><span class="line">mystery_chapter1.odf  mystery_chapter4.odf  mystery_chapter7.odf     tv_season1_episode2.ogg  tv_season1_episode5.ogg  tv_season2_episode2.ogg  tv_season2_episode5.ogg</span><br><span class="line">mystery_chapter2.odf  mystery_chapter5.odf  mystery_chapter8.odf     tv_season1_episode3.ogg  tv_season1_episode6.ogg  tv_season2_episode3.ogg  tv_season2_episode6.ogg</span><br><span class="line">mystery_chapter3.odf  mystery_chapter6.odf  tv_season1_episode1.ogg  tv_season1_episode4.ogg  tv_season2_episode1.ogg  tv_season2_episode4.ogg</span><br><span class="line"></span><br><span class="line">[vagrant@server lab]$ mkdir -p Videos/season&#123;1,2&#125;</span><br><span class="line">[vagrant@server lab]$ ls Videos/</span><br><span class="line">season1  season2</span><br><span class="line"></span><br><span class="line">[vagrant@server lab]$ mv tv_season1* Videos/season1/</span><br><span class="line">[vagrant@server lab]$ mv tv_season2* Videos/season2/</span><br><span class="line">[vagrant@server lab]$ ls -R Videos/</span><br><span class="line">Videos/:</span><br><span class="line">season1  season2</span><br><span class="line"></span><br><span class="line">Videos/season1:</span><br><span class="line">tv_season1_episode1.ogg  tv_season1_episode2.ogg  tv_season1_episode3.ogg  tv_season1_episode4.ogg  tv_season1_episode5.ogg  tv_season1_episode6.ogg</span><br><span class="line"></span><br><span class="line">Videos/season2:</span><br><span class="line">tv_season2_episode1.ogg  tv_season2_episode2.ogg  tv_season2_episode3.ogg  tv_season2_episode4.ogg  tv_season2_episode5.ogg  tv_season2_episode6.ogg</span><br><span class="line"></span><br><span class="line">[vagrant@server lab]$ mkdir -p ./my_bestseller ./chapters</span><br><span class="line"></span><br><span class="line">[vagrant@server lab]$ mkdir ./my_bestseller/&#123;editor,plot_change,vacation&#125;</span><br><span class="line">[vagrant@server lab]$ ls ./my_bestseller/</span><br><span class="line">editor  plot_change  vacation</span><br><span class="line"></span><br><span class="line">[vagrant@server lab]$ <span class="built_in">cd</span> chapters/</span><br><span class="line">[vagrant@server chapters]$ mv ../*chapter*.odf ./</span><br><span class="line"></span><br><span class="line">[vagrant@server chapters]$ mv mystery_chapter&#123;1,2&#125;.odf ../my_bestseller/editor/</span><br><span class="line"></span><br><span class="line">[vagrant@server chapters]$ mv mystery_chapter&#123;7,8&#125;.odf ../my_bestseller/vacation/</span><br><span class="line"></span><br><span class="line">[vagrant@server chapters]$ <span class="built_in">cd</span> ../Videos/season2/</span><br><span class="line">[vagrant@server season2]$ cp tv_season2_episode1.ogg ../../my_bestseller/vacation/</span><br><span class="line"></span><br><span class="line">[vagrant@server season2]$ <span class="built_in">cd</span> /tmp/lab/my_bestseller/vacation/</span><br><span class="line">[vagrant@server vacation]$ ls</span><br><span class="line">mystery_chapter7.odf  mystery_chapter8.odf  tv_season2_episode1.ogg</span><br><span class="line">[vagrant@server vacation]$ <span class="built_in">cd</span> ~-</span><br><span class="line">[vagrant@server season2]$ cp tv_season2_episode2.ogg ~-</span><br><span class="line">[vagrant@server season2]$ <span class="built_in">cd</span> ~-</span><br><span class="line">[vagrant@server vacation]$ ls</span><br><span class="line">mystery_chapter7.odf  mystery_chapter8.odf  tv_season2_episode1.ogg  tv_season2_episode2.ogg</span><br><span class="line"></span><br><span class="line">[vagrant@server vacation]$ cp /tmp/lab/chapters/mystery_chapter5.odf /tmp/lab/my_bestseller/plot_change/mystery_chapter5_$(date +%F).odf</span><br><span class="line">[vagrant@server vacation]$ cp /tmp/lab/chapters/mystery_chapter5.odf /tmp/lab/my_bestseller/plot_change/mystery_chapter5_$(date +%s).odf</span><br><span class="line">[vagrant@server vacation]$ cp /tmp/lab/chapters/mystery_chapter5.odf /tmp/lab/my_bestseller/plot_change/mystery_chapter5_<span class="variable">$USER</span>.odf</span><br><span class="line">[vagrant@server vacation]$ ls /tmp/lab/my_bestseller/plot_change/</span><br><span class="line">mystery_chapter5_1455368579.odf  mystery_chapter5_2016-02-13.odf  mystery_chapter5_vagrant.odf</span><br></pre></td></tr></table></figure><hr><p><a name="ch3"></a></p><h1 id="Chapter-3-GETTING-HELP-IN-RED-HAT-ENTERPRISE-LINUX"><a href="#Chapter-3-GETTING-HELP-IN-RED-HAT-ENTERPRISE-LINUX" class="headerlink" title="Chapter 3. GETTING HELP IN RED HAT ENTERPRISE LINUX"></a>Chapter 3. GETTING HELP IN RED HAT ENTERPRISE LINUX</h1><h2 id="3-1-Reading-Documentation-Using-man-Command"><a href="#3-1-Reading-Documentation-Using-man-Command" class="headerlink" title="3.1 Reading Documentation Using man Command"></a>3.1 Reading Documentation Using man Command</h2><h3 id="3-1-1-Introducing-the-man-command"><a href="#3-1-1-Introducing-the-man-command" class="headerlink" title="3.1.1 Introducing the man command"></a>3.1.1 Introducing the man command</h3><p>Linux manual 包含多個 section：</p><table><thead><tr><th>Section</th><th>Content Type</th></tr></thead><tbody><tr><td><strong><font color="red">1</font></strong></td><td>一般使用者命令(包含可執行程式 &amp; shell script)</td></tr><tr><td><code>2</code></td><td>System calls(kernal routines invoked from user space)</td></tr><tr><td><code>3</code></td><td>Library functions (程式函式庫提供)</td></tr><tr><td><code>4</code></td><td>特殊檔案(例如：設備檔 /dev 目錄中的檔案)</td></tr><tr><td><strong><font color="red">5</font></strong></td><td><font color="blue">檔案格式(設定檔 &amp; 內容結構說明)</font></td></tr><tr><td><code>6</code></td><td>Games</td></tr><tr><td><strong><font color="red">7</font></strong></td><td>慣例、標準、其他…等等(協定、檔案系統)</td></tr><tr><td><strong><font color="red">8</font></strong></td><td><font color="blue">系統管理員以及特殊指令(用於維護工作)</font></td></tr><tr><td><code>9</code></td><td>Linux kernal API (internal kernel calls)</td></tr></tbody></table><p><code>man 1 passwd</code> or <code>man passwd</code>(未指定 section 則預設帶 1) 可以知道使用指令的方式 &amp; 相關參數</p><p><code>man 5 passwd</code> 則是說明 <strong>/etc/passwd</strong> 的檔案結構，組成內容….等資訊</p><blockquote><p>以上資訊要安裝 <strong><font color="red">man-pages</font></strong> 套件才會有</p></blockquote><h3 id="3-1-3-Searching-for-man-pages-by-keywords"><a href="#3-1-3-Searching-for-man-pages-by-keywords" class="headerlink" title="3.1.3 Searching for man pages by keywords"></a>3.1.3 Searching for man pages by keywords</h3><p>小寫 k 僅針對 title &amp; description 搜尋關鍵字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@server ~]$ man -k passwd</span><br><span class="line">grub2-mkpasswd-pbkdf2 (1) - Generate a PBKDF2 password <span class="built_in">hash</span>.</span><br><span class="line">sslpasswd (1ssl)     - compute password hashes</span><br></pre></td></tr></table></figure><blockquote><p>大寫 K 會進行全文搜尋…..內容很多…</p></blockquote><p>透過 <code>mandb</code> 指令可以立即強制 man page 資料庫更新，但系統其實已經將更新資料庫的工作放在 <strong>/etc/cron.daily/man-db.cron</strong> 中。</p><h2 id="3-2-Reading-Documentation-Using-pinfo-Command"><a href="#3-2-Reading-Documentation-Using-pinfo-Command" class="headerlink" title="3.2 Reading Documentation Using pinfo Command"></a>3.2 Reading Documentation Using pinfo Command</h2><p>info 文件是以類似超連結網頁的方式進行編排，透過 pinfo 指令來啟動 <strong>lynx</strong> 文字網頁瀏覽器來瀏覽。</p><p><code>--</code> 在指令中代表 command option 的結束，表示後面接的是 command argument，例如：<code>touch -- -r</code> 會產生名稱為 <strong>-r</strong> 的檔案。</p>]]></content>
      
      <categories>
          
          <category> RHCE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RHCE </tag>
            
            <tag> RH124 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[VMware] 免費的 vSphere ESXi VM 備份方案 - XSIBACKUP</title>
      <link href="/blog/2014/11/14/VMware/free-vsphere-esxi-vm-backup-solution-xsibackup/"/>
      <url>/blog/2014/11/14/VMware/free-vsphere-esxi-vm-backup-solution-xsibackup/</url>
      <content type="html"><![CDATA[<p>最近公司在找給 VMware vSphere ESXi 用的 shared storage，想當然爾也會考慮到備份的問題</p><p>後來學長提供了 <a href="http://sourceforge.net/projects/xsibackup/" target="_blank" rel="noopener">xsibackup</a> 這個 opensource 的免費軟體，雖然是免費，可是備份功能也不差呢。</p><h2 id="環境設定"><a href="#環境設定" class="headerlink" title="環境設定"></a>環境設定</h2><ul><li>vSphere ESXi <strong>5.5 Update 2</strong></li><li>esxibackup <strong>4.1.6</strong></li></ul><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>1、 首先必須先開啟 ESXi Host 的 SSH servive，並透過 ssh client 登入到 esxi 中</p><p>2、 下載 xsibackup 程式並解壓縮，將 xsibackup 程式設定為可執行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要將檔案放到 ESXi 重開機後不會回復初始設定的路徑(可以是任何 DataStore 的目錄下，只要是 persistent folder 即可)</span></span><br><span class="line"><span class="comment"># 切換到 datastore1 folder，避免 ESXi 重開機之後將檔案刪除</span></span><br><span class="line">$ <span class="built_in">cd</span> /vmfs/volumes/datastore1</span><br><span class="line">$ wget http://sourceforge.net/projects/xsibackup/files/xsibackup_4.1.6.zip/download -O xsibackup.zip</span><br><span class="line">$ unzip xsibackup.zip</span><br><span class="line">$ chmod 0700 xsibackup*</span><br></pre></td></tr></table></figure><p>3、執行備份工作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 備份檔存放路徑：/vmfs/volumes/backup</span></span><br><span class="line"><span class="comment"># 備份類型：目前運行中的 VM (running)</span></span><br><span class="line"><span class="comment"># mail &amp; smpt 的相關設定都是與寄信相關</span></span><br><span class="line">$ ./xsibackup --backup-point=/vmfs/volumes/backup --backup-type=running </span><br><span class="line">--mail-from=email.sender@yourdomain.com --mail-to=email.recipient@anotherdomain.com </span><br><span class="line">--smtp-srv=smtp.yourdomain.com --smtp-port=25 --smtp-usr=username </span><br><span class="line">--smtp-pwd=password</span><br></pre></td></tr></table></figure><p><code>/vmfs/volumes/backup 目錄也可以是 remote host 所提供的 NFS share folder</code></p><p>其中 <code>--backup-type</code> 有以下三種：</p><ul><li><strong>all</strong> (所有 vm)</li><li><strong>running</strong> (執行中的 vm)</li><li><strong>custom</strong> (指定 vm，需搭配 –backup-vms 參數指令要備份的 vm，多個 vm 可用逗號隔開)</li></ul><p>custom 應用如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定備份 WINDOWSVM1 &amp; LINUXVM2 兩台 vm</span></span><br><span class="line">$ ./xsibackup --backup-point=/vmfs/volumes/backup --backup-type=custom --backup-vms=WINDOWSVM1,LINUXVM2</span><br></pre></td></tr></table></figure><h2 id="其他參數"><a href="#其他參數" class="headerlink" title="其他參數"></a>其他參數</h2><ul><li><code>--test-mode=true</code> (測試模式，不實際進行備份；但若有設定 EMail 相關參數則會發信)</li><li><code>--backup-how (hot | cold)</code> (hot 會在 vm 開機情況下備份，cold 則會將 vm 關機後再備份)`</li></ul><h2 id="寄送-Mail-的問題"><a href="#寄送-Mail-的問題" class="headerlink" title="寄送 Mail 的問題"></a>寄送 Mail 的問題</h2><p>設定了 EMail 發送相關參數後，實際執行會發現竟然不行，排除方法如下：</p><p>xsibackup 程式會在 <strong>/etc/vmware/firewall/service.xml</strong> 這個檔案補上這一段內容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">id</span>=<span class="string">'9999'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>SMTPout<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rule</span> <span class="attr">id</span>=<span class="string">'0000'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">direction</span>&gt;</span>outbound<span class="tag">&lt;/<span class="name">direction</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">protocol</span>&gt;</span>tcp<span class="tag">&lt;/<span class="name">protocol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">porttype</span>&gt;</span>dst<span class="tag">&lt;/<span class="name">porttype</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">port</span>&gt;</span><span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">required</span>&gt;</span>false<span class="tag">&lt;/<span class="name">required</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但其實這是錯誤的，要把 <code>&lt;port&gt;&lt;/port&gt;</code>這個部分改成 <code>&lt;port&gt;25&lt;/port&gt;</code>，並執行以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ esxcli network firewall refresh</span><br></pre></td></tr></table></figure><p>如此一來 EMail 的功能就會正常啟動了!</p><h2 id="排程備份"><a href="#排程備份" class="headerlink" title="排程備份"></a>排程備份</h2><p>xsibackup 也支援排程喔! 設定方式如下：</p><ol><li>在 ESXi 主機上執行 <code>xsibackup --install-cron</code> 指令，此時會在 <strong>/vmfs/volumes/datastore1</strong> 目錄中產生 <code>xsibackup-cron</code>這個檔案，可以直接進入編輯：(若是星期一、五晚上 20:00 要備份)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加入 --time 參數，格式為 --time="Day HH:mm"(注意這邊要用 UTC 時間)</span></span><br><span class="line"><span class="comment"># 星期一 20:00 備份</span></span><br><span class="line">/vmfs/volumes/datastore1/xsibackup --time=<span class="string">"Mon 12:00"</span> --backup-point=/vmfs/volumes/backup --backup-type=running --mail-from=email.sender@yourdomain.com --mail-to=email.recipient@anotherdomain.com --smtp-srv=smtp.yourdomain.com --smtp-port=25 --smtp-usr=username --smtp-pwd=password</span><br><span class="line"><span class="comment"># 星期五 20:00 備份</span></span><br><span class="line">/vmfs/volumes/datastore1/xsibackup --time=<span class="string">"Fri 12:00"</span> --backup-point=/vmfs/volumes/backup --backup-type=running --mail-from=email.sender@yourdomain.com --mail-to=email.recipient@anotherdomain.com --smtp-srv=smtp.yourdomain.com --smtp-port=25 --smtp-usr=username --smtp-pwd=password</span><br></pre></td></tr></table></figure><ol start="2"><li>重新啟動 ESXi Host 讓 cron 的功能啟用</li></ol><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>因此總結一下，優缺點大致如下：</p><h3 id="優點"><a href="#優點" class="headerlink" title="優點"></a>優點</h3><ol><li><p>免費、開放</p></li><li><p>可進行完整備份，非特殊格式，不需要透過其他軟體還原</p></li><li><p>在單純的環境下使用簡單</p></li></ol><h3 id="缺點"><a href="#缺點" class="headerlink" title="缺點"></a>缺點</h3><ol><li><p>無法執行差異備份，自然也就沒有 dedupication 的功能。</p></li><li><p>目前沒有 exclude 的參數，若是有不想備份的 VM(例如：VDP)，只能透過 custom or running(搭配將 vm 關機)的方式來完成 (也可以透過改 source code 的方式來做….)</p></li><li><p>若是 vSphere 授權版本有 DRS(Dynamic Resource Scheduler) 的話，VM 可能會隨著資源耗損不同而跑來跑去，備份工作就很難透過 custom 方式來達成。</p></li></ol><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><p><a href="http://sourceforge.net/projects/xsibackup/" target="_blank" rel="noopener">Free Backup Software for VMware ESXi VMs | SourceForge.net</a></p></li><li><p><a href="http://blog.depicus.com/add-outbound-port-25-for-smtp-in-vmware-esxi-v5/" target="_blank" rel="noopener">Add outbound port 25 for SMTP in VMware ESXi v5 – depicus</a></p></li><li><p><a href="http://kb.vmware.com/selfservice/microsites/search.do?language=en_US&amp;cmd=displayKC&amp;externalId=2008226" target="_blank" rel="noopener">VMware KB: Creating custom firewall rules in VMware ESXi 5.x</a></p></li></ul>]]></content>
      
      <categories>
          
          <category> VMware </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VMware </tag>
            
            <tag> Backup </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
